# 1 "../../../server-code/src/map/clif.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "../../../server-code/src/map/clif.c"
# 23 "../../../server-code/src/map/clif.c"
# 1 "../../../server-code/src/config/core.h" 1
# 90 "../../../server-code/src/config/core.h"
# 1 "../../../server-code/src/config/./renewal.h" 1
# 91 "../../../server-code/src/config/core.h" 2
# 1 "../../../server-code/src/config/./secure.h" 1
# 92 "../../../server-code/src/config/core.h" 2
# 1 "../../../server-code/src/config/./classes/general.h" 1
# 93 "../../../server-code/src/config/core.h" 2




# 1 "../../../server-code/src/config/./const.h" 1
# 62 "../../../server-code/src/config/./const.h"
 typedef short defType;
# 98 "../../../server-code/src/config/core.h" 2
# 24 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/map/clif.h" 1
# 24 "../../../server-code/src/map/clif.h"
# 1 "../../../server-code/src/map/map.h" 1
# 24 "../../../server-code/src/map/map.h"
# 1 "../../../server-code/src/map/atcommand.h" 1
# 24 "../../../server-code/src/map/atcommand.h"
# 1 "../../../server-code/src/map/pc_groups.h" 1
# 24 "../../../server-code/src/map/pc_groups.h"
# 1 "../../../server-code/src/common/hercules.h" 1
# 24 "../../../server-code/src/common/hercules.h"
# 1 "../../../server-code/src/common/cbasetypes.h" 1
# 116 "../../../server-code/src/common/cbasetypes.h"
# 1 "/usr/include/inttypes.h" 1 3 4
# 25 "/usr/include/inttypes.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 361 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 410 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 411 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 362 "/usr/include/features.h" 2 3 4
# 385 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 386 "/usr/include/features.h" 2 3 4
# 26 "/usr/include/inttypes.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/stdint.h" 2 3 4
# 36 "/usr/include/stdint.h" 3 4

# 36 "/usr/include/stdint.h" 3 4
typedef signed char int8_t;
typedef short int int16_t;
typedef int int32_t;

typedef long int int64_t;







typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;



typedef unsigned long int uint64_t;
# 65 "/usr/include/stdint.h" 3 4
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 90 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 103 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 119 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 134 "/usr/include/stdint.h" 3 4
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stdint.h" 2 3 4
# 28 "/usr/include/inttypes.h" 2 3 4






typedef int __gwchar_t;
# 266 "/usr/include/inttypes.h" 3 4





typedef struct
  {
    long int quot;
    long int rem;
  } imaxdiv_t;
# 290 "/usr/include/inttypes.h" 3 4
extern intmax_t imaxabs (intmax_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern intmax_t strtoimax (const char *__restrict __nptr,
      char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t strtoumax (const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern intmax_t wcstoimax (const __gwchar_t *__restrict __nptr,
      __gwchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t wcstoumax (const __gwchar_t *__restrict __nptr,
       __gwchar_t ** __restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));
# 432 "/usr/include/inttypes.h" 3 4

# 117 "../../../server-code/src/common/cbasetypes.h" 2

# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 1 3 4
# 168 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 143 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 160 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 144 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 148 "/usr/include/limits.h" 2 3 4
# 169 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 2 3 4
# 119 "../../../server-code/src/common/cbasetypes.h" 2
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4








# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 38 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 42 "/usr/include/time.h" 2 3 4
# 55 "/usr/include/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 121 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 122 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 56 "/usr/include/time.h" 2 3 4



typedef __clock_t clock_t;



# 73 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 91 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };








struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;





typedef __pid_t pid_t;
# 186 "/usr/include/time.h" 3 4



extern clock_t clock (void) __attribute__ ((__nothrow__ , __leaf__));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));

# 221 "/usr/include/time.h" 3 4
# 1 "/usr/include/xlocale.h" 1 3 4
# 27 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 222 "/usr/include/time.h" 2 3 4

extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));
# 236 "/usr/include/time.h" 3 4



extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));





extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__ , __leaf__));



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) __attribute__ ((__nothrow__ , __leaf__));
# 319 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int dysize (int __year) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 334 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ , __leaf__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ , __leaf__));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));





extern int timespec_get (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 430 "/usr/include/time.h" 3 4

# 120 "../../../server-code/src/common/cbasetypes.h" 2
# 140 "../../../server-code/src/common/cbasetypes.h"

# 140 "../../../server-code/src/common/cbasetypes.h"
typedef int8_t int8;
typedef int16_t int16;
typedef int32_t int32;
typedef int64_t int64;

typedef int8_t sint8;
typedef int16_t sint16;
typedef int32_t sint32;
typedef int64_t sint64;

typedef uint8_t uint8;
typedef uint16_t uint16;
typedef uint32_t uint32;
typedef uint64_t uint64;
# 196 "../../../server-code/src/common/cbasetypes.h"
typedef long int ppint;
typedef long int ppint8;
typedef long int ppint16;
typedef long int ppint32;

typedef unsigned long int ppuint;
typedef unsigned long int ppuint8;
typedef unsigned long int ppuint16;
typedef unsigned long int ppuint32;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 149 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3 4

# 149 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 328 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3 4
typedef int wchar_t;
# 426 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 211 "../../../server-code/src/common/cbasetypes.h" 2
# 227 "../../../server-code/src/common/cbasetypes.h"

# 227 "../../../server-code/src/common/cbasetypes.h"
typedef intptr_t intptr;
typedef uintptr_t uintptr;







  typedef int64 sysint;
  typedef uint64 usysint;
# 305 "../../../server-code/src/common/cbasetypes.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stdbool.h" 1 3 4
# 306 "../../../server-code/src/common/cbasetypes.h" 2
# 395 "../../../server-code/src/common/cbasetypes.h"
# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4

# 39 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4

# 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 40 "/usr/include/ctype.h" 2 3 4






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 104 "/usr/include/ctype.h" 3 4






extern int isalnum (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha (int) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit (int) __attribute__ ((__nothrow__ , __leaf__));
extern int islower (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint (int) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit (int) __attribute__ ((__nothrow__ , __leaf__));



extern int tolower (int __c) __attribute__ ((__nothrow__ , __leaf__));


extern int toupper (int __c) __attribute__ ((__nothrow__ , __leaf__));








extern int isblank (int) __attribute__ ((__nothrow__ , __leaf__));


# 150 "/usr/include/ctype.h" 3 4
extern int isascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int toascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int _toupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int _tolower (int) __attribute__ ((__nothrow__ , __leaf__));
# 271 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int islower_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));

extern int isblank_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));



extern int __tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));


extern int __toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
# 347 "/usr/include/ctype.h" 3 4

# 396 "../../../server-code/src/common/cbasetypes.h" 2
# 417 "../../../server-code/src/common/cbasetypes.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 98 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 418 "../../../server-code/src/common/cbasetypes.h" 2
# 25 "../../../server-code/src/common/hercules.h" 2
# 25 "../../../server-code/src/map/pc_groups.h" 2



# 27 "../../../server-code/src/map/pc_groups.h"
struct DBMap;
struct config_setting_t;


enum e_pc_permission {
 PC_PERM_NONE = 0,
 PC_PERM_TRADE = 0x000001,
 PC_PERM_PARTY = 0x000002,
 PC_PERM_ALL_SKILL = 0x000004,
 PC_PERM_USE_ALL_EQUIPMENT = 0x000008,
 PC_PERM_SKILL_UNCONDITIONAL = 0x000010,
 PC_PERM_JOIN_ALL_CHAT = 0x000020,
 PC_PERM_NO_CHAT_KICK = 0x000040,
 PC_PERM_HIDE_SESSION = 0x000080,
 PC_PERM_WHO_DISPLAY_AID = 0x000100,
 PC_PERM_RECEIVE_HACK_INFO = 0x000200,
 PC_PERM_WARP_ANYWHERE = 0x000400,
 PC_PERM_VIEW_HPMETER = 0x000800,
 PC_PERM_VIEW_EQUIPMENT = 0x001000,
 PC_PERM_USE_CHECK = 0x002000,
 PC_PERM_USE_CHANGEMAPTYPE = 0x004000,
 PC_PERM_USE_ALL_COMMANDS = 0x008000,
 PC_PERM_RECEIVE_REQUESTS = 0x010000,
 PC_PERM_SHOW_BOSS = 0x020000,
 PC_PERM_DISABLE_PVM = 0x040000,
 PC_PERM_DISABLE_PVP = 0x080000,
 PC_PERM_DISABLE_CMD_DEAD = 0x100000,
 PC_PERM_HCHSYS_ADMIN = 0x200000,
 PC_PERM_TRADE_BOUND = 0x400000,
 PC_PERM_DISABLE_PICK_UP = 0x800000,
 PC_PERM_DISABLE_STORE = 0x1000000,
 PC_PERM_DISABLE_EXP = 0x2000000,
 PC_PERM_DISABLE_SKILL_USAGE = 0x4000000,
};


struct GroupSettings {
 unsigned int id;
 int level;
 char *name;
 unsigned int e_permissions;
 
# 68 "../../../server-code/src/map/pc_groups.h" 3 4
_Bool 
# 68 "../../../server-code/src/map/pc_groups.h"
     log_commands;
 int index;

 struct config_setting_t *commands;
 struct config_setting_t *permissions;
 struct config_setting_t *inherit;
 
# 74 "../../../server-code/src/map/pc_groups.h" 3 4
_Bool 
# 74 "../../../server-code/src/map/pc_groups.h"
     inheritance_done;
 struct config_setting_t *root;
};

typedef struct GroupSettings GroupSettings;

struct pc_groups_permission_table {
 char *name;
 unsigned int permission;
};


struct pc_groups_new_permission {
 unsigned int pID;
 char *name;
 unsigned int *mask;
};

struct pc_groups_interface {

 struct DBMap *db;
 struct DBMap *name_db;

 struct pc_groups_permission_table *permissions;
 unsigned char permission_count;

 struct pc_groups_new_permission *HPMpermissions;
 unsigned char HPMpermissions_count;

 void (*init) (void);
 void (*final) (void);
 void (*reload) (void);

 GroupSettings* (*get_dummy_group) (void);
 
# 108 "../../../server-code/src/map/pc_groups.h" 3 4
_Bool 
# 108 "../../../server-code/src/map/pc_groups.h"
     (*exists) (int group_id);
 GroupSettings* (*id2group) (int group_id);
 
# 110 "../../../server-code/src/map/pc_groups.h" 3 4
_Bool 
# 110 "../../../server-code/src/map/pc_groups.h"
     (*has_permission) (GroupSettings *group, unsigned int permission);
 
# 111 "../../../server-code/src/map/pc_groups.h" 3 4
_Bool 
# 111 "../../../server-code/src/map/pc_groups.h"
     (*should_log_commands) (GroupSettings *group);
 const char* (*get_name) (GroupSettings *group);
 int (*get_level) (GroupSettings *group);
 int (*get_idx) (GroupSettings *group);
};


void pc_groups_defaults(void);


extern struct pc_groups_interface *pcg;
# 25 "../../../server-code/src/map/atcommand.h" 2

# 1 "../../../server-code/src/common/db.h" 1
# 90 "../../../server-code/src/common/db.h"
enum DBReleaseOption {
 DB_RELEASE_NOTHING = 0x0,
 DB_RELEASE_KEY = 0x1,
 DB_RELEASE_DATA = 0x2,
 DB_RELEASE_BOTH = DB_RELEASE_KEY|DB_RELEASE_DATA,
};
# 117 "../../../server-code/src/common/db.h"
enum DBType {
 DB_INT,
 DB_UINT,
 DB_STRING,
 DB_ISTRING,
 DB_INT64,
 DB_UINT64,
};
# 148 "../../../server-code/src/common/db.h"
enum DBOptions {
 DB_OPT_BASE = 0x00,
 DB_OPT_DUP_KEY = 0x01,
 DB_OPT_RELEASE_KEY = 0x02,
 DB_OPT_RELEASE_DATA = 0x04,
 DB_OPT_RELEASE_BOTH = DB_OPT_RELEASE_KEY|DB_OPT_RELEASE_DATA,
 DB_OPT_ALLOW_NULL_KEY = 0x08,
 DB_OPT_ALLOW_NULL_DATA = 0x10,
};
# 169 "../../../server-code/src/common/db.h"
union DBKey {
 int i;
 unsigned int ui;
 const char *str;
 char *mutstr;
 int64 i64;
 uint64 ui64;
};
# 186 "../../../server-code/src/common/db.h"
enum DBDataType {
 DB_DATA_INT,
 DB_DATA_UINT,
 DB_DATA_PTR,
};
# 201 "../../../server-code/src/common/db.h"
struct DBData {
 enum DBDataType type;
 union {
  int i;
  unsigned int ui;
  void *ptr;
 } u;
};
# 220 "../../../server-code/src/common/db.h"
typedef struct DBData (*DBCreateData)(union DBKey key, va_list args);
# 237 "../../../server-code/src/common/db.h"
typedef int (*DBApply)(union DBKey key, struct DBData *data, va_list args);
# 250 "../../../server-code/src/common/db.h"
typedef int (*DBMatcher)(union DBKey key, struct DBData data, va_list args);
# 264 "../../../server-code/src/common/db.h"
typedef int (*DBComparator)(union DBKey key1, union DBKey key2, unsigned short maxlen);
# 276 "../../../server-code/src/common/db.h"
typedef uint64 (*DBHasher)(union DBKey key, unsigned short maxlen);
# 290 "../../../server-code/src/common/db.h"
typedef void (*DBReleaser)(union DBKey key, struct DBData data, enum DBReleaseOption which);
# 304 "../../../server-code/src/common/db.h"
struct DBIterator {
# 314 "../../../server-code/src/common/db.h"
 struct DBData *(*first)(struct DBIterator *self, union DBKey *out_key);
# 325 "../../../server-code/src/common/db.h"
 struct DBData *(*last)(struct DBIterator *self, union DBKey *out_key);
# 336 "../../../server-code/src/common/db.h"
 struct DBData *(*next)(struct DBIterator *self, union DBKey *out_key);
# 347 "../../../server-code/src/common/db.h"
 struct DBData *(*prev)(struct DBIterator *self, union DBKey *out_key);
# 357 "../../../server-code/src/common/db.h"
 
# 357 "../../../server-code/src/common/db.h" 3 4
_Bool 
# 357 "../../../server-code/src/common/db.h"
     (*exists)(struct DBIterator *self);
# 372 "../../../server-code/src/common/db.h"
 int (*remove)(struct DBIterator *self, struct DBData *out_data);






 void (*destroy)(struct DBIterator *self);

};







struct DBMap {
# 400 "../../../server-code/src/common/db.h"
 struct DBIterator *(*iterator)(struct DBMap *self);
# 409 "../../../server-code/src/common/db.h"
 
# 409 "../../../server-code/src/common/db.h" 3 4
_Bool 
# 409 "../../../server-code/src/common/db.h"
     (*exists)(struct DBMap *self, union DBKey key);
# 418 "../../../server-code/src/common/db.h"
 struct DBData *(*get)(struct DBMap *self, union DBKey key);
# 438 "../../../server-code/src/common/db.h"
 unsigned int (*getall)(struct DBMap *self, struct DBData **buf, unsigned int max, DBMatcher match, ...);
# 456 "../../../server-code/src/common/db.h"
 unsigned int (*vgetall)(struct DBMap *self, struct DBData **buf, unsigned int max, DBMatcher match, va_list args);
# 472 "../../../server-code/src/common/db.h"
 struct DBData *(*ensure)(struct DBMap *self, union DBKey key, DBCreateData create, ...);
# 486 "../../../server-code/src/common/db.h"
 struct DBData *(*vensure)(struct DBMap *self, union DBKey key, DBCreateData create, va_list args);
# 499 "../../../server-code/src/common/db.h"
 int (*put)(struct DBMap *self, union DBKey key, struct DBData data, struct DBData *out_data);
# 511 "../../../server-code/src/common/db.h"
 int (*remove)(struct DBMap *self, union DBKey key, struct DBData *out_data);
# 525 "../../../server-code/src/common/db.h"
 int (*foreach)(struct DBMap *self, DBApply func, ...);
# 537 "../../../server-code/src/common/db.h"
 int (*vforeach)(struct DBMap *self, DBApply func, va_list args);
# 553 "../../../server-code/src/common/db.h"
 int (*clear)(struct DBMap *self, DBApply func, ...);
# 567 "../../../server-code/src/common/db.h"
 int (*vclear)(struct DBMap *self, DBApply func, va_list args);
# 584 "../../../server-code/src/common/db.h"
 int (*destroy)(struct DBMap *self, DBApply func, ...);
# 599 "../../../server-code/src/common/db.h"
 int (*vdestroy)(struct DBMap *self, DBApply func, va_list args);







 unsigned int (*size)(struct DBMap *self);







 enum DBType (*type)(struct DBMap *self);







 enum DBOptions (*options)(struct DBMap *self);

};
# 745 "../../../server-code/src/common/db.h"
struct db_interface {
# 758 "../../../server-code/src/common/db.h"
enum DBOptions (*fix_options) (enum DBType type, enum DBOptions options);
# 768 "../../../server-code/src/common/db.h"
DBComparator (*default_cmp) (enum DBType type);
# 778 "../../../server-code/src/common/db.h"
DBHasher (*default_hash) (enum DBType type);
# 797 "../../../server-code/src/common/db.h"
DBReleaser (*default_release) (enum DBType type, enum DBOptions options);
# 808 "../../../server-code/src/common/db.h"
DBReleaser (*custom_release) (enum DBReleaseOption which);
# 834 "../../../server-code/src/common/db.h"
struct DBMap *(*alloc) (const char *file, const char *func, int line, enum DBType type, enum DBOptions options, unsigned short maxlen);







union DBKey (*i2key) (int key);







union DBKey (*ui2key) (unsigned int key);







union DBKey (*str2key) (const char *key);







union DBKey (*i642key) (int64 key);







union DBKey (*ui642key) (uint64 key);







struct DBData (*i2data) (int data);







struct DBData (*ui2data) (unsigned int data);







struct DBData (*ptr2data) (void *data);
# 907 "../../../server-code/src/common/db.h"
int (*data2i) (struct DBData *data);
# 916 "../../../server-code/src/common/db.h"
unsigned int (*data2ui) (struct DBData *data);
# 925 "../../../server-code/src/common/db.h"
void* (*data2ptr) (struct DBData *data);






void (*init) (void);







void (*final) (void);
};


struct linkdb_node {
 struct linkdb_node *next;
 struct linkdb_node *prev;
 void *key;
 void *data;
};

typedef void (*LinkDBFunc)(void* key, void* data, va_list args);


void linkdb_insert (struct linkdb_node** head, void *key, void* data);
void linkdb_replace (struct linkdb_node** head, void *key, void* data);
void* linkdb_search (struct linkdb_node** head, void *key);
void* linkdb_erase (struct linkdb_node** head, void *key);
void linkdb_final (struct linkdb_node** head);
void linkdb_vforeach(struct linkdb_node** head, LinkDBFunc func, va_list ap);
void linkdb_foreach (struct linkdb_node** head, LinkDBFunc func, ...);

void db_defaults(void);


extern struct db_interface *DB;
# 27 "../../../server-code/src/map/atcommand.h" 2






struct map_session_data;
struct AtCommandInfo;
struct block_list;
struct config_setting_t;
# 50 "../../../server-code/src/map/atcommand.h"
typedef enum {
 COMMAND_ATCOMMAND = 1,
 COMMAND_CHARCOMMAND = 2,
} AtCommandType;




typedef 
# 58 "../../../server-code/src/map/atcommand.h" 3 4
       _Bool 
# 58 "../../../server-code/src/map/atcommand.h"
            (*AtCommandFunc)(const int fd, struct map_session_data* sd, const char* command, const char* message,struct AtCommandInfo *info);
typedef struct AtCommandInfo AtCommandInfo;
typedef struct AliasInfo AliasInfo;




struct AliasInfo {
 AtCommandInfo *command;
 char alias[50];
};

struct AtCommandInfo {
 char command[50];
 AtCommandFunc func;
 char *at_groups;
 char *char_groups;
 char *help;
 
# 76 "../../../server-code/src/map/atcommand.h" 3 4
_Bool 
# 76 "../../../server-code/src/map/atcommand.h"
     log;
};

struct atcmd_binding_data {
 char command[50];
 char npc_event[50];
 int group_lv;
 int group_lv_char;
 
# 84 "../../../server-code/src/map/atcommand.h" 3 4
_Bool 
# 84 "../../../server-code/src/map/atcommand.h"
     log;
};




struct atcommand_interface {
 unsigned char at_symbol;
 unsigned char char_symbol;

 struct atcmd_binding_data** binding;
 int binding_count;

 struct DBMap *db;
 struct DBMap *alias_db;




 char*** msg_table;
 uint8 max_message_table;

 void (*init) (
# 106 "../../../server-code/src/map/atcommand.h" 3 4
              _Bool 
# 106 "../../../server-code/src/map/atcommand.h"
                   minimal);
 void (*final) (void);

 
# 109 "../../../server-code/src/map/atcommand.h" 3 4
_Bool 
# 109 "../../../server-code/src/map/atcommand.h"
     (*exec) (const int fd, struct map_session_data *sd, const char *message, 
# 109 "../../../server-code/src/map/atcommand.h" 3 4
                                                                              _Bool 
# 109 "../../../server-code/src/map/atcommand.h"
                                                                                   player_invoked);
 
# 110 "../../../server-code/src/map/atcommand.h" 3 4
_Bool 
# 110 "../../../server-code/src/map/atcommand.h"
     (*create) (char *name, AtCommandFunc func);
 
# 111 "../../../server-code/src/map/atcommand.h" 3 4
_Bool 
# 111 "../../../server-code/src/map/atcommand.h"
     (*can_use) (struct map_session_data *sd, const char *command);
 
# 112 "../../../server-code/src/map/atcommand.h" 3 4
_Bool 
# 112 "../../../server-code/src/map/atcommand.h"
     (*can_use2) (struct map_session_data *sd, const char *command, AtCommandType type);
 void (*load_groups) (GroupSettings **groups, struct config_setting_t **commands_, size_t sz);
 AtCommandInfo* (*exists) (const char* name);
 
# 115 "../../../server-code/src/map/atcommand.h" 3 4
_Bool 
# 115 "../../../server-code/src/map/atcommand.h"
     (*msg_read) (const char *cfg_name, 
# 115 "../../../server-code/src/map/atcommand.h" 3 4
                                        _Bool 
# 115 "../../../server-code/src/map/atcommand.h"
                                             allow_override);
 void (*final_msg) (void);

 struct atcmd_binding_data* (*get_bind_byname) (const char* name);

 AtCommandInfo* (*get_info_byname) (const char *name);
 const char* (*check_alias) (const char *aliasname);
 void (*get_suggestions) (struct map_session_data* sd, const char *name, 
# 122 "../../../server-code/src/map/atcommand.h" 3 4
                                                                        _Bool 
# 122 "../../../server-code/src/map/atcommand.h"
                                                                             is_atcmd_cmd);
 void (*config_read) (const char* config_filename);

 int (*stopattack) (struct block_list *bl,va_list ap);
 int (*pvpoff_sub) (struct block_list *bl,va_list ap);
 int (*pvpon_sub) (struct block_list *bl,va_list ap);
 int (*atkillmonster_sub) (struct block_list *bl, va_list ap);
 void (*raise_sub) (struct map_session_data* sd);
 void (*get_jail_time) (int jailtime, int* year, int* month, int* day, int* hour, int* minute);
 int (*cleanfloor_sub) (struct block_list *bl, va_list ap);
 int (*mutearea_sub) (struct block_list *bl,va_list ap);
 void (*getring) (struct map_session_data* sd);
 void (*channel_help) (int fd, const char *command, 
# 134 "../../../server-code/src/map/atcommand.h" 3 4
                                                   _Bool 
# 134 "../../../server-code/src/map/atcommand.h"
                                                        can_create);

 void (*commands_sub) (struct map_session_data* sd, const int fd, AtCommandType type);
 void (*cmd_db_clear) (void);
 int (*cmd_db_clear_sub) (union DBKey key, struct DBData *data, va_list args);
 void (*doload) (void);
 void (*base_commands) (void);
 
# 141 "../../../server-code/src/map/atcommand.h" 3 4
_Bool 
# 141 "../../../server-code/src/map/atcommand.h"
     (*add) (char *name, AtCommandFunc func, 
# 141 "../../../server-code/src/map/atcommand.h" 3 4
                                             _Bool 
# 141 "../../../server-code/src/map/atcommand.h"
                                                  replace);
 const char* (*msg) (int msg_number);
 void (*expand_message_table) (void);
 const char* (*msgfd) (int fd, int msg_number);
 const char* (*msgsd) (struct map_session_data *sd, int msg_number);
};


void atcommand_defaults(void);


extern struct atcommand_interface *atcommand;
# 25 "../../../server-code/src/map/map.h" 2

# 1 "../../../server-code/src/common/core.h" 1
# 34 "../../../server-code/src/common/core.h"
enum server_types {
 SERVER_TYPE_UNKNOWN = 0x0,
 SERVER_TYPE_LOGIN = 0x1,
 SERVER_TYPE_CHAR = 0x2,
 SERVER_TYPE_MAP = 0x4,
};


enum E_CORE_ST {
 CORE_ST_STOP = 0,
 CORE_ST_RUN,
 CORE_ST_LAST
};


enum cmdline_options {
 CMDLINE_OPT_NORMAL = 0x0,
 CMDLINE_OPT_PARAM = 0x1,
 CMDLINE_OPT_SILENT = 0x2,
 CMDLINE_OPT_PREINIT = 0x4,
};
typedef 
# 55 "../../../server-code/src/common/core.h" 3 4
       _Bool 
# 55 "../../../server-code/src/common/core.h"
            (*CmdlineExecFunc)(const char *name, const char *params);
struct CmdlineArgData {
 unsigned int pluginID;
 unsigned int options;
 char *name;
 char shortname;
 CmdlineExecFunc func;
 char *help;
};

struct cmdline_interface {
 struct { int _max_; int _len_; struct CmdlineArgData *_data_; } args_data;

 void (*init) (void);
 void (*final) (void);
 
# 70 "../../../server-code/src/common/core.h" 3 4
_Bool 
# 70 "../../../server-code/src/common/core.h"
     (*arg_add) (unsigned int pluginID, const char *name, char shortname, CmdlineExecFunc func, const char *help, unsigned int options);
 int (*exec) (int argc, char **argv, unsigned int options);
 
# 72 "../../../server-code/src/common/core.h" 3 4
_Bool 
# 72 "../../../server-code/src/common/core.h"
     (*arg_next_value) (const char *name, int current_arg, int argc);
 const char *(*arg_source) (struct CmdlineArgData *arg);
};

struct core_interface {
 int arg_c;
 char **arg_v;

 int runflag;
 char *server_name;
 enum server_types server_type;



 void (*shutdown_callback)(void);
};






extern void cmdline_args_init_local(void);
extern int do_init(int,char**);
extern void set_server_type(void);
extern void do_abort(void);
extern int do_final(void);







void cmdline_defaults(void);


extern struct core_interface *core;
extern struct cmdline_interface *cmdline;
# 27 "../../../server-code/src/map/map.h" 2

# 1 "../../../server-code/src/common/mapindex.h" 1
# 25 "../../../server-code/src/common/mapindex.h"
# 1 "../../../server-code/src/common/mmo.h" 1
# 225 "../../../server-code/src/common/mmo.h"
struct hplugin_data_store;

enum item_types {
 IT_HEALING = 0,
 IT_UNKNOWN,
 IT_USABLE,
 IT_ETC,
 IT_WEAPON,
 IT_ARMOR,
 IT_CARD,
 IT_PETEGG,
 IT_PETARMOR,
 IT_UNKNOWN2,
 IT_AMMO,
 IT_DELAYCONSUME,
 IT_CASH = 18,
 IT_MAX
};




enum quest_state {
 Q_INACTIVE,
 Q_ACTIVE,
 Q_COMPLETE,
};


struct quest {
 int quest_id;
 unsigned int time;
 int count[3];
 enum quest_state state;
};

struct item {
 int id;
 short nameid;
 short amount;
 unsigned int equip;
 char identify;
 char refine;
 char attribute;
 short card[4];
 unsigned int expire_time;
 char favorite;
 unsigned char bound;
 uint64 unique_id;
};


enum equip_pos {
 EQP_NONE = 0x000000,
 EQP_HEAD_LOW = 0x000001,
 EQP_HEAD_MID = 0x000200,
 EQP_HEAD_TOP = 0x000100,
 EQP_HAND_R = 0x000002,
 EQP_HAND_L = 0x000020,
 EQP_ARMOR = 0x000010,
 EQP_SHOES = 0x000040,
 EQP_GARMENT = 0x000004,
 EQP_ACC_L = 0x000008,
 EQP_ACC_R = 0x000080,
 EQP_COSTUME_HEAD_TOP = 0x000400,
 EQP_COSTUME_HEAD_MID = 0x000800,
 EQP_COSTUME_HEAD_LOW = 0x001000,
 EQP_COSTUME_GARMENT = 0x002000,

 EQP_AMMO = 0x008000,
 EQP_SHADOW_ARMOR = 0x010000,
 EQP_SHADOW_WEAPON = 0x020000,
 EQP_SHADOW_SHIELD = 0x040000,
 EQP_SHADOW_SHOES = 0x080000,
 EQP_SHADOW_ACC_R = 0x100000,
 EQP_SHADOW_ACC_L = 0x200000,
};

struct point {
 unsigned short map;
 short x,y;
};

enum e_skill_flag
{
 SKILL_FLAG_PERMANENT,
 SKILL_FLAG_TEMPORARY,
 SKILL_FLAG_PLAGIARIZED,
 SKILL_FLAG_UNUSED,
 SKILL_FLAG_PERM_GRANTED,


 SKILL_FLAG_REPLACED_LV_0,
};

enum e_mmo_charstatus_opt {
 OPT_NONE = 0x0,
 OPT_SHOW_EQUIP = 0x1,
 OPT_ALLOW_PARTY = 0x2,
};

enum e_item_bound_type {
 IBT_NONE = 0x0,
 IBT_MIN = 0x1,
 IBT_ACCOUNT = 0x1,
 IBT_GUILD = 0x2,
 IBT_PARTY = 0x3,
 IBT_CHARACTER = 0x4,
 IBT_MAX = 0x4,
};

enum {
 OPTION_NOTHING = 0x00000000,
 OPTION_SIGHT = 0x00000001,
 OPTION_HIDE = 0x00000002,
 OPTION_CLOAK = 0x00000004,
 OPTION_FALCON = 0x00000010,
 OPTION_RIDING = 0x00000020,
 OPTION_INVISIBLE = 0x00000040,
 OPTION_ORCISH = 0x00000800,
 OPTION_WEDDING = 0x00001000,
 OPTION_RUWACH = 0x00002000,
 OPTION_CHASEWALK = 0x00004000,
 OPTION_FLYING = 0x00008000,
 OPTION_XMAS = 0x00010000,
 OPTION_TRANSFORM = 0x00020000,
 OPTION_SUMMER = 0x00040000,
 OPTION_DRAGON1 = 0x00080000,
 OPTION_WUG = 0x00100000,
 OPTION_WUGRIDER = 0x00200000,
 OPTION_MADOGEAR = 0x00400000,
 OPTION_DRAGON2 = 0x00800000,
 OPTION_DRAGON3 = 0x01000000,
 OPTION_DRAGON4 = 0x02000000,
 OPTION_DRAGON5 = 0x04000000,
 OPTION_HANBOK = 0x08000000,
 OPTION_OKTOBERFEST = 0x10000000,
# 372 "../../../server-code/src/common/mmo.h"
 OPTION_DRAGON = OPTION_DRAGON1|OPTION_DRAGON2|OPTION_DRAGON3|OPTION_DRAGON4|OPTION_DRAGON5,
 OPTION_COSTUME = OPTION_WEDDING|OPTION_XMAS|OPTION_SUMMER|OPTION_HANBOK|OPTION_OKTOBERFEST,
};

struct s_skill {
 unsigned short id;
 unsigned char lv;
 unsigned char flag;
};

struct script_reg_state {
 unsigned int type : 1;
 unsigned int update : 1;
};

struct script_reg_num {
 struct script_reg_state flag;
 int value;
};

struct script_reg_str {
 struct script_reg_state flag;
 char *value;
};


struct status_change_data {
 unsigned short type;
 int val1, val2, val3, val4;
 int tick;
};

struct storage_data {
 int storage_amount;
 struct item items[600];
};

struct guild_storage {
 int dirty;
 int guild_id;
 short storage_status;
 short storage_amount;
 struct item items[600];
 unsigned short lock;
};

struct s_pet {
 int account_id;
 int char_id;
 int pet_id;
 short class_;
 short level;
 short egg_id;
 short equip;
 short intimate;
 short hungry;
 char name[(23 + 1)];
 char rename_flag;
 char incubate;
};

struct s_homunculus {
 char name[(23 + 1)];
 int hom_id;
 int char_id;
 short class_;
 short prev_class;
 int hp,max_hp,sp,max_sp;
 unsigned int intimacy;
 short hunger;
 struct s_skill hskill[43];
 short skillpts;
 short level;
 unsigned int exp;
 short rename_flag;
 short vaporize;
 int str;
 int agi;
 int vit;
 int int_;
 int dex;
 int luk;

 int str_value;
 int agi_value;
 int vit_value;
 int int_value;
 int dex_value;
 int luk_value;

 int8 spiritball;
};

struct s_mercenary {
 int mercenary_id;
 int char_id;
 short class_;
 int hp, sp;
 unsigned int kill_count;
 unsigned int life_time;
};

struct s_elemental {
 int elemental_id;
 int char_id;
 short class_;
 uint32 mode;
 int hp, sp, max_hp, max_sp, matk, atk, atk2;
 short hit, flee, amotion, def, mdef;
 int life_time;
};

struct s_friend {
 int account_id;
 int char_id;
 char name[(23 + 1)];
};

struct hotkey {

 unsigned int id;
 unsigned short lv;
 unsigned char type;



};

struct mmo_charstatus {
 int char_id;
 int account_id;
 int partner_id;
 int father;
 int mother;
 int child;

 unsigned int base_exp,job_exp;
 int zeny;
 int bank_vault;

 short class_;
 unsigned int status_point,skill_point;
 int hp,max_hp,sp,max_sp;
 unsigned int option;
 short manner;
 unsigned char karma;
 short hair,hair_color,clothes_color,body;
 int party_id,guild_id,pet_id,hom_id,mer_id,ele_id;
 int fame;


 int arch_faith, arch_calls;
 int spear_faith, spear_calls;
 int sword_faith, sword_calls;

 short weapon;
 short shield;
 short head_top,head_mid,head_bottom;
 short robe;

 char name[(23 + 1)];
 unsigned int base_level,job_level;
 short str,agi,vit,int_,dex,luk;
 unsigned char slot,sex;

 uint32 mapip;
 uint16 mapport;

 struct point last_point,save_point,memo_point[3];
 struct item inventory[100],cart[100];
 struct storage_data storage;
 struct s_skill skill[1478];

 struct s_friend friends[40];

 struct hotkey hotkeys[38];

 
# 549 "../../../server-code/src/common/mmo.h" 3 4
_Bool 
# 549 "../../../server-code/src/common/mmo.h"
     show_equip, allow_party;
 unsigned short rename;
 unsigned short slotchange;

 time_t delete_date;


 unsigned short mod_exp,mod_drop,mod_death;

 unsigned char font;

 uint32 uniqueitem_counter;

 unsigned char hotkey_rowshift;
};

typedef enum mail_status {
 MAIL_NEW,
 MAIL_UNREAD,
 MAIL_READ,
} mail_status;

struct mail_message {
 int id;
 int send_id;
 char send_name[(23 + 1)];
 int dest_id;
 char dest_name[(23 + 1)];
 char title[40];
 char body[200];

 mail_status status;
 time_t timestamp;

 int zeny;
 struct item item;
};

struct mail_data {
 short amount;
 
# 589 "../../../server-code/src/common/mmo.h" 3 4
_Bool 
# 589 "../../../server-code/src/common/mmo.h"
     full;
 short unchecked, unread;
 struct mail_message msg[30];
};

struct auction_data {
 unsigned int auction_id;
 int seller_id;
 char seller_name[(23 + 1)];
 int buyer_id;
 char buyer_name[(23 + 1)];

 struct item item;

 char item_name[50];
 short type;

 unsigned short hours;
 int price, buynow;
 time_t timestamp;
 int auction_end_timer;
};

struct party_member {
 int account_id;
 int char_id;
 char name[(23 + 1)];
 unsigned short class_;
 unsigned short map;
 unsigned short lv;
 unsigned leader : 1,
          online : 1;
};

struct party {
 int party_id;
 char name[(23 + 1)];
 unsigned char count;
 unsigned exp : 1,
    item : 2;
 struct party_member member[12];
};

struct map_session_data;
struct guild_member {
 int account_id, char_id;
 short hair,hair_color,gender,class_,lv;
 uint64 exp;
 int exp_payper;
 short online,position;
 char name[(23 + 1)];
 struct map_session_data *sd;
 unsigned char modified;
};

struct guild_position {
 char name[(23 + 1)];
 int mode;
 int exp_mode;
 unsigned char modified;
};

struct guild_alliance {
 int opposition;
 int guild_id;
 char name[(23 + 1)];
};

struct guild_expulsion {
 char name[(23 + 1)];
 char mes[40];
 int account_id;
};

struct guild_skill {
 int id,lv;
};

struct channel_data;
struct guild {
 int guild_id;
 short guild_lv, connect_member, max_member, average_lv;
 uint64 exp;
 unsigned int next_exp;
 int skill_point;
 char name[(23 + 1)],master[(23 + 1)];
 struct guild_member member[(16 +10*6)];
 struct guild_position position[20];
 char mes1[60],mes2[120];
 int emblem_len,emblem_id;
 char emblem_data[2048];
 struct guild_alliance alliance[16];
 struct guild_expulsion expulsion[32];
 struct guild_skill skill[15];


 unsigned short save_flag;

 short *instance;
 unsigned short instances;

 struct channel_data *channel;
 struct hplugin_data_store *hdata;
};

struct guild_castle {
 int castle_id;
 int mapindex;
 char castle_name[(23 + 1)];
 char castle_event[(23 + 1)];
 int guild_id;
 int economy;
 int defense;
 int triggerE;
 int triggerD;
 int nextTime;
 int payTime;
 int createTime;
 int visibleC;
 struct {
  unsigned visible : 1;
  int id;
 } guardian[8];
 int* temp_guardians;
 int temp_guardians_max;
};

struct fame_list {
 int id;
 int fame;
 char name[(23 + 1)];
};

enum fame_list_type {
 RANKTYPE_BLACKSMITH = 0,
 RANKTYPE_ALCHEMIST = 1,
 RANKTYPE_TAEKWON = 2,
 RANKTYPE_PK = 3,
};






enum guild_basic_info {
 GBI_EXP = 1,
 GBI_GUILDLV,
 GBI_SKILLPOINT,





 GBI_SKILLLV,
};

enum {
 GMI_POSITION = 0,
 GMI_EXP,
 GMI_HAIR,
 GMI_HAIR_COLOR,
 GMI_GENDER,
 GMI_CLASS,
 GMI_LEVEL,
};

enum guild_permission {
 GPERM_INVITE = 0x01,
 GPERM_EXPEL = 0x10,
 GPERM_ALL = GPERM_INVITE|GPERM_EXPEL,
 GPERM_MASK = GPERM_ALL,
};

enum {
 GD_SKILLBASE=10000,
 GD_APPROVAL=10000,
 GD_KAFRACONTRACT=10001,
 GD_GUARDRESEARCH=10002,
 GD_GUARDUP=10003,
 GD_EXTENSION=10004,
 GD_GLORYGUILD=10005,
 GD_LEADERSHIP=10006,
 GD_GLORYWOUNDS=10007,
 GD_SOULCOLD=10008,
 GD_HAWKEYES=10009,
 GD_BATTLEORDER=10010,
 GD_REGENERATION=10011,
 GD_RESTORE=10012,
 GD_EMERGENCYCALL=10013,
 GD_DEVELOPMENT=10014,
 GD_MAX,
};


enum {
 JOB_NOVICE,
 JOB_SWORDMAN,
 JOB_MAGE,
 JOB_ARCHER,
 JOB_ACOLYTE,
 JOB_MERCHANT,
 JOB_THIEF,
 JOB_KNIGHT,
 JOB_PRIEST,
 JOB_WIZARD,
 JOB_BLACKSMITH,
 JOB_HUNTER,
 JOB_ASSASSIN,
 JOB_KNIGHT2,
 JOB_CRUSADER,
 JOB_MONK,
 JOB_SAGE,
 JOB_ROGUE,
 JOB_ALCHEMIST,
 JOB_BARD,
 JOB_DANCER,
 JOB_CRUSADER2,
 JOB_WEDDING,
 JOB_SUPER_NOVICE,
 JOB_GUNSLINGER,
 JOB_NINJA,
 JOB_XMAS,
 JOB_SUMMER,
 JOB_MAX_BASIC,

 JOB_NOVICE_HIGH = 4001,
 JOB_SWORDMAN_HIGH,
 JOB_MAGE_HIGH,
 JOB_ARCHER_HIGH,
 JOB_ACOLYTE_HIGH,
 JOB_MERCHANT_HIGH,
 JOB_THIEF_HIGH,
 JOB_LORD_KNIGHT,
 JOB_HIGH_PRIEST,
 JOB_HIGH_WIZARD,
 JOB_WHITESMITH,
 JOB_SNIPER,
 JOB_ASSASSIN_CROSS,
 JOB_LORD_KNIGHT2,
 JOB_PALADIN,
 JOB_CHAMPION,
 JOB_PROFESSOR,
 JOB_STALKER,
 JOB_CREATOR,
 JOB_CLOWN,
 JOB_GYPSY,
 JOB_PALADIN2,

 JOB_BABY,
 JOB_BABY_SWORDMAN,
 JOB_BABY_MAGE,
 JOB_BABY_ARCHER,
 JOB_BABY_ACOLYTE,
 JOB_BABY_MERCHANT,
 JOB_BABY_THIEF,
 JOB_BABY_KNIGHT,
 JOB_BABY_PRIEST,
 JOB_BABY_WIZARD,
 JOB_BABY_BLACKSMITH,
 JOB_BABY_HUNTER,
 JOB_BABY_ASSASSIN,
 JOB_BABY_KNIGHT2,
 JOB_BABY_CRUSADER,
 JOB_BABY_MONK,
 JOB_BABY_SAGE,
 JOB_BABY_ROGUE,
 JOB_BABY_ALCHEMIST,
 JOB_BABY_BARD,
 JOB_BABY_DANCER,
 JOB_BABY_CRUSADER2,
 JOB_SUPER_BABY,

 JOB_TAEKWON,
 JOB_STAR_GLADIATOR,
 JOB_STAR_GLADIATOR2,
 JOB_SOUL_LINKER,

 JOB_GANGSI,
 JOB_DEATH_KNIGHT,
 JOB_DARK_COLLECTOR,

 JOB_RUNE_KNIGHT = 4054,
 JOB_WARLOCK,
 JOB_RANGER,
 JOB_ARCH_BISHOP,
 JOB_MECHANIC,
 JOB_GUILLOTINE_CROSS,

 JOB_RUNE_KNIGHT_T,
 JOB_WARLOCK_T,
 JOB_RANGER_T,
 JOB_ARCH_BISHOP_T,
 JOB_MECHANIC_T,
 JOB_GUILLOTINE_CROSS_T,

 JOB_ROYAL_GUARD,
 JOB_SORCERER,
 JOB_MINSTREL,
 JOB_WANDERER,
 JOB_SURA,
 JOB_GENETIC,
 JOB_SHADOW_CHASER,

 JOB_ROYAL_GUARD_T,
 JOB_SORCERER_T,
 JOB_MINSTREL_T,
 JOB_WANDERER_T,
 JOB_SURA_T,
 JOB_GENETIC_T,
 JOB_SHADOW_CHASER_T,

 JOB_RUNE_KNIGHT2,
 JOB_RUNE_KNIGHT_T2,
 JOB_ROYAL_GUARD2,
 JOB_ROYAL_GUARD_T2,
 JOB_RANGER2,
 JOB_RANGER_T2,
 JOB_MECHANIC2,
 JOB_MECHANIC_T2,

 JOB_BABY_RUNE = 4096,
 JOB_BABY_WARLOCK,
 JOB_BABY_RANGER,
 JOB_BABY_BISHOP,
 JOB_BABY_MECHANIC,
 JOB_BABY_CROSS,

 JOB_BABY_GUARD,
 JOB_BABY_SORCERER,
 JOB_BABY_MINSTREL,
 JOB_BABY_WANDERER,
 JOB_BABY_SURA,
 JOB_BABY_GENETIC,
 JOB_BABY_CHASER,

 JOB_BABY_RUNE2,
 JOB_BABY_GUARD2,
 JOB_BABY_RANGER2,
 JOB_BABY_MECHANIC2,

 JOB_SUPER_NOVICE_E = 4190,
 JOB_SUPER_BABY_E,

 JOB_KAGEROU = 4211,
 JOB_OBORO,
 JOB_REBELLION = 4215,

 JOB_MAX,
};




enum {
 SEX_FEMALE = 0,
 SEX_MALE,
 SEX_SERVER
};

enum weapon_type {
 W_FIST,
 W_DAGGER,
 W_1HSWORD,
 W_2HSWORD,
 W_1HSPEAR,
 W_2HSPEAR,
 W_1HAXE,
 W_2HAXE,
 W_MACE,
 W_2HMACE,
 W_STAFF,
 W_BOW,
 W_KNUCKLE,
 W_MUSICAL,
 W_WHIP,
 W_BOOK,
 W_KATAR,
 W_REVOLVER,
 W_RIFLE,
 W_GATLING,
 W_SHOTGUN,
 W_GRENADE,
 W_HUUMA,
 W_2HSTAFF,
 MAX_SINGLE_WEAPON_TYPE,

 W_DOUBLE_DD,
 W_DOUBLE_SS,
 W_DOUBLE_AA,
 W_DOUBLE_DS,
 W_DOUBLE_DA,
 W_DOUBLE_SA,
 MAX_WEAPON_TYPE,
};

enum ammo_type {
 A_ARROW = 1,
 A_DAGGER,
 A_BULLET,
 A_SHELL,
 A_GRENADE,
 A_SHURIKEN,
 A_KUNAI,
 A_CANNONBALL,
 A_THROWWEAPON,
};

enum e_char_server_type {
 CST_NORMAL = 0,
 CST_MAINTENANCE = 1,
 CST_OVER18 = 2,
 CST_PAYING = 3,
 CST_F2P = 4,
};

enum e_pc_reg_loading {
 PRL_NONE = 0x0,
 PRL_CHAR = 0x1,
 PRL_ACCL = 0x2,
 PRL_ACCG = 0x4,
 PRL_ALL = 0xFF,
};




enum zh_char_ask_name_type {
 CHAR_ASK_NAME_BLOCK = 1,
 CHAR_ASK_NAME_BAN = 2,
 CHAR_ASK_NAME_UNBLOCK = 3,
 CHAR_ASK_NAME_UNBAN = 4,
 CHAR_ASK_NAME_CHANGESEX = 5,
 CHAR_ASK_NAME_CHARBAN = 6,
 CHAR_ASK_NAME_CHARUNBAN = 7,
 CHAR_ASK_NAME_CHANGECHARSEX = 8,
};




enum hz_char_ask_name_answer {
 CHAR_ASK_NAME_ANS_DONE = 0,
 CHAR_ASK_NAME_ANS_NOTFOUND = 1,
 CHAR_ASK_NAME_ANS_GMLOW = 2,
 CHAR_ASK_NAME_ANS_OFFLINE = 3,
};
# 26 "../../../server-code/src/common/mapindex.h" 2


struct DBMap;
# 84 "../../../server-code/src/common/mapindex.h"
struct mapindex_interface {
 char config_file[80];

 struct DBMap *db;

 int num;

 char *default_map;

 int default_x;

 int default_y;

 struct {
  char name[(11 + 1)];
 } list[2000];

 int (*init) (void);
 void (*final) (void);

 int (*addmap) (int index, const char* name);
 void (*removemap) (int index);
 const char* (*getmapname) (const char* string, char* output);


 const char* (*getmapname_ext) (const char* string, char* output);

 unsigned short (*name2id) (const char*);
 const char * (*id2name) (uint16 id, const char *file, int line, const char *func);
 
# 113 "../../../server-code/src/common/mapindex.h" 3 4
_Bool 
# 113 "../../../server-code/src/common/mapindex.h"
     (*check_default) (void);
};


void mapindex_defaults(void);


extern struct mapindex_interface *mapindex;
# 29 "../../../server-code/src/map/map.h" 2


# 1 "/usr/include/stdio.h" 1 3 4
# 29 "/usr/include/stdio.h" 3 4




# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4
# 44 "/usr/include/stdio.h" 3 4

# 44 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 64 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 31 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 82 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 32 "/usr/include/libio.h" 2 3 4
# 144 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;





typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 173 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 241 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 289 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 298 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 334 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);
# 386 "/usr/include/libio.h" 3 4
extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 430 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 460 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 75 "/usr/include/stdio.h" 2 3 4
# 90 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;
# 102 "/usr/include/stdio.h" 3 4
typedef __ssize_t ssize_t;







typedef _G_fpos_t fpos_t;




# 164 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 165 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));








extern FILE *tmpfile (void) ;
# 209 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 227 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 252 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 266 "/usr/include/stdio.h" 3 4






extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 295 "/usr/include/stdio.h" 3 4

# 306 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;
# 319 "/usr/include/stdio.h" 3 4
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));








extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));

# 412 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 443 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 463 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 494 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 522 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 550 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 561 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 594 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 640 "/usr/include/stdio.h" 3 4

# 665 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 737 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 773 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 792 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 815 "/usr/include/stdio.h" 3 4

# 824 "/usr/include/stdio.h" 3 4


extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;








extern void perror (const char *__s);






# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];
# 854 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 872 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));
# 912 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 942 "/usr/include/stdio.h" 3 4

# 32 "../../../server-code/src/map/map.h" 2




# 35 "../../../server-code/src/map/map.h"
struct Sql;
struct mob_data;
struct npc_data;
struct channel_data;
struct hplugin_data_store;

enum E_MAPSERVER_ST {
 MAPSERVER_ST_RUNNING = CORE_ST_LAST,
 MAPSERVER_ST_SHUTDOWN,
 MAPSERVER_ST_LAST
};
# 74 "../../../server-code/src/map/map.h"
enum {

 MAPID_NOVICE = 0x0,
 MAPID_SWORDMAN,
 MAPID_MAGE,
 MAPID_ARCHER,
 MAPID_ACOLYTE,
 MAPID_MERCHANT,
 MAPID_THIEF,
 MAPID_TAEKWON,
 MAPID_WEDDING,
 MAPID_GUNSLINGER,
 MAPID_NINJA,
 MAPID_XMAS,
 MAPID_SUMMER,
 MAPID_GANGSI,

 MAPID_SUPER_NOVICE = 0x100|0x0,
 MAPID_KNIGHT,
 MAPID_WIZARD,
 MAPID_HUNTER,
 MAPID_PRIEST,
 MAPID_BLACKSMITH,
 MAPID_ASSASSIN,
 MAPID_STAR_GLADIATOR,
 MAPID_REBELLION = 0x100|0x09,
 MAPID_KAGEROUOBORO = 0x100|0x0A,
 MAPID_DEATH_KNIGHT = 0x100|0x0E,

 MAPID_CRUSADER = 0x200|0x1,
 MAPID_SAGE,
 MAPID_BARDDANCER,
 MAPID_MONK,
 MAPID_ALCHEMIST,
 MAPID_ROGUE,
 MAPID_SOUL_LINKER,
 MAPID_DARK_COLLECTOR = 0x200|0x0E,

 MAPID_NOVICE_HIGH = 0x1000|0x0,
 MAPID_SWORDMAN_HIGH,
 MAPID_MAGE_HIGH,
 MAPID_ARCHER_HIGH,
 MAPID_ACOLYTE_HIGH,
 MAPID_MERCHANT_HIGH,
 MAPID_THIEF_HIGH,

 MAPID_LORD_KNIGHT = 0x1000|0x100|0x1,
 MAPID_HIGH_WIZARD,
 MAPID_SNIPER,
 MAPID_HIGH_PRIEST,
 MAPID_WHITESMITH,
 MAPID_ASSASSIN_CROSS,

 MAPID_PALADIN = 0x1000|0x200|0x1,
 MAPID_PROFESSOR,
 MAPID_CLOWNGYPSY,
 MAPID_CHAMPION,
 MAPID_CREATOR,
 MAPID_STALKER,

 MAPID_BABY = 0x2000|0x0,
 MAPID_BABY_SWORDMAN,
 MAPID_BABY_MAGE,
 MAPID_BABY_ARCHER,
 MAPID_BABY_ACOLYTE,
 MAPID_BABY_MERCHANT,
 MAPID_BABY_THIEF,

 MAPID_SUPER_BABY = 0x2000|0x100|0x0,
 MAPID_BABY_KNIGHT,
 MAPID_BABY_WIZARD,
 MAPID_BABY_HUNTER,
 MAPID_BABY_PRIEST,
 MAPID_BABY_BLACKSMITH,
 MAPID_BABY_ASSASSIN,

 MAPID_BABY_CRUSADER = 0x2000|0x200|0x1,
 MAPID_BABY_SAGE,
 MAPID_BABY_BARDDANCER,
 MAPID_BABY_MONK,
 MAPID_BABY_ALCHEMIST,
 MAPID_BABY_ROGUE,

 MAPID_SUPER_NOVICE_E = 0x4000|0x100|0x0,
 MAPID_RUNE_KNIGHT,
 MAPID_WARLOCK,
 MAPID_RANGER,
 MAPID_ARCH_BISHOP,
 MAPID_MECHANIC,
 MAPID_GUILLOTINE_CROSS,

 MAPID_ROYAL_GUARD = 0x4000|0x200|0x1,
 MAPID_SORCERER,
 MAPID_MINSTRELWANDERER,
 MAPID_SURA,
 MAPID_GENETIC,
 MAPID_SHADOW_CHASER,

 MAPID_RUNE_KNIGHT_T = 0x4000|0x1000|0x100|0x1,
 MAPID_WARLOCK_T,
 MAPID_RANGER_T,
 MAPID_ARCH_BISHOP_T,
 MAPID_MECHANIC_T,
 MAPID_GUILLOTINE_CROSS_T,

 MAPID_ROYAL_GUARD_T = 0x4000|0x1000|0x200|0x1,
 MAPID_SORCERER_T,
 MAPID_MINSTRELWANDERER_T,
 MAPID_SURA_T,
 MAPID_GENETIC_T,
 MAPID_SHADOW_CHASER_T,

 MAPID_SUPER_BABY_E = 0x4000|0x2000|0x100|0x0,
 MAPID_BABY_RUNE,
 MAPID_BABY_WARLOCK,
 MAPID_BABY_RANGER,
 MAPID_BABY_BISHOP,
 MAPID_BABY_MECHANIC,
 MAPID_BABY_CROSS,

 MAPID_BABY_GUARD = 0x4000|0x2000|0x200|0x1,
 MAPID_BABY_SORCERER,
 MAPID_BABY_MINSTRELWANDERER,
 MAPID_BABY_SURA,
 MAPID_BABY_GENETIC,
 MAPID_BABY_CHASER,
};
# 233 "../../../server-code/src/map/map.h"
enum bl_type {
 BL_NUL = 0x000,
 BL_PC = 0x001,
 BL_MOB = 0x002,
 BL_PET = 0x004,
 BL_HOM = 0x008,
 BL_MER = 0x010,
 BL_ITEM = 0x020,
 BL_SKILL = 0x040,
 BL_NPC = 0x080,
 BL_CHAT = 0x100,
 BL_ELEM = 0x200,

 BL_ALL = 0xFFF,
};




enum npc_subtype { WARP, SHOP, SCRIPT, CASHSHOP, TOMB };






enum Race {

 RC_FORMLESS = 0,
 RC_UNDEAD,
 RC_BRUTE,
 RC_PLANT,
 RC_INSECT,
 RC_FISH,
 RC_DEMON,
 RC_DEMIHUMAN,
 RC_ANGEL,
 RC_DRAGON,
 RC_PLAYER,

 RC_BOSS,
 RC_NONBOSS,

 RC_MAX,


 RC_NONDEMIHUMAN,
 RC_NONPLAYER,
 RC_DEMIPLAYER,
 RC_NONDEMIPLAYER,
 RC_ALL = 0xFF,
};






enum RaceMask {
 RCMASK_NONE = 0,
 RCMASK_FORMLESS = 1<<RC_FORMLESS,
 RCMASK_UNDEAD = 1<<RC_UNDEAD,
 RCMASK_BRUTE = 1<<RC_BRUTE,
 RCMASK_PLANT = 1<<RC_PLANT,
 RCMASK_INSECT = 1<<RC_INSECT,
 RCMASK_FISH = 1<<RC_FISH,
 RCMASK_DEMON = 1<<RC_DEMON,
 RCMASK_DEMIHUMAN = 1<<RC_DEMIHUMAN,
 RCMASK_ANGEL = 1<<RC_ANGEL,
 RCMASK_DRAGON = 1<<RC_DRAGON,
 RCMASK_PLAYER = 1<<RC_PLAYER,
 RCMASK_BOSS = 1<<RC_BOSS,
 RCMASK_NONBOSS = 1<<RC_NONBOSS,
 RCMASK_NONDEMIPLAYER = RCMASK_FORMLESS | RCMASK_UNDEAD | RCMASK_BRUTE | RCMASK_PLANT | RCMASK_INSECT | RCMASK_FISH | RCMASK_DEMON | RCMASK_ANGEL | RCMASK_DRAGON,
 RCMASK_NONDEMIHUMAN = RCMASK_NONDEMIPLAYER | RCMASK_PLAYER,
 RCMASK_NONPLAYER = RCMASK_NONDEMIPLAYER | RCMASK_DEMIHUMAN,
 RCMASK_DEMIPLAYER = RCMASK_DEMIHUMAN | RCMASK_PLAYER,
 RCMASK_ALL = RCMASK_BOSS | RCMASK_NONBOSS,
 RCMASK_ANY = RCMASK_NONPLAYER | RCMASK_PLAYER,
};

enum {
 RC2_NONE = 0,
 RC2_GOBLIN,
 RC2_KOBOLD,
 RC2_ORC,
 RC2_GOLEM,
 RC2_GUARDIAN,
 RC2_NINJA,
 RC2_SCARABA,
 RC2_TURTLE,
 RC2_MAX
};

enum elements {
 ELE_NEUTRAL=0,
 ELE_WATER,
 ELE_EARTH,
 ELE_FIRE,
 ELE_WIND,
 ELE_POISON,
 ELE_HOLY,
 ELE_DARK,
 ELE_GHOST,
 ELE_UNDEAD,
 ELE_MAX,
 ELE_ALL = 0xFF
};






enum spirit_charm_types {
 CHARM_TYPE_NONE = 0,
 CHARM_TYPE_WATER,
 CHARM_TYPE_LAND,
 CHARM_TYPE_FIRE,
 CHARM_TYPE_WIND
};

enum auto_trigger_flag {
 ATF_SELF=0x01,
 ATF_TARGET=0x02,
 ATF_SHORT=0x04,
 ATF_LONG=0x08,
 ATF_WEAPON=0x10,
 ATF_MAGIC=0x20,
 ATF_MISC=0x40,
};

struct block_list {
 struct block_list *next,*prev;
 int id;
 int16 m,x,y;
 enum bl_type type;
};



struct spawn_data {
 short class_;
 unsigned short m, x, y;
 signed short xs, ys;
 unsigned short num;
 unsigned short active;
 unsigned int delay1, delay2;
 unsigned int level;
 struct {
  unsigned int size : 2;
  unsigned int ai : 4;


  unsigned int dynamic : 1;
  unsigned int boss : 1;
 } state;
 char name[(23 + 1)], eventname[( (23 + 1) * 2 + 3 )];
};

struct flooritem_data {
 struct block_list bl;
 unsigned char subx,suby;
 int cleartimer;
 int first_get_charid,second_get_charid,third_get_charid;
 int64 first_get_tick,second_get_tick,third_get_tick;
 struct item item_data;
};

enum status_point_types {
 SP_SPEED,SP_BASEEXP,SP_JOBEXP,SP_KARMA,SP_MANNER,SP_HP,SP_MAXHP,SP_SP,
 SP_MAXSP,SP_STATUSPOINT,SP_0a,SP_BASELEVEL,SP_SKILLPOINT,SP_STR,SP_AGI,SP_VIT,
 SP_INT,SP_DEX,SP_LUK,SP_CLASS,SP_ZENY,SP_SEX,SP_NEXTBASEEXP,SP_NEXTJOBEXP,
 SP_WEIGHT,SP_MAXWEIGHT,SP_1a,SP_1b,SP_1c,SP_1d,SP_1e,SP_1f,
 SP_USTR,SP_UAGI,SP_UVIT,SP_UINT,SP_UDEX,SP_ULUK,SP_26,SP_27,
 SP_28,SP_ATK1,SP_ATK2,SP_MATK1,SP_MATK2,SP_DEF1,SP_DEF2,SP_MDEF1,
 SP_MDEF2,SP_HIT,SP_FLEE1,SP_FLEE2,SP_CRITICAL,SP_ASPD,SP_36,SP_JOBLEVEL,
 SP_UPPER,SP_PARTNER,SP_CART,SP_FAME,SP_UNBREAKABLE,
 SP_CARTINFO=99,

 SP_BASEJOB=119,
 SP_BASECLASS=120,
 SP_KILLERRID=121,
 SP_KILLEDRID=122,
 SP_SLOTCHANGE=123,
 SP_CHARRENAME=124,
 SP_MOD_EXP=125,
 SP_MOD_DROP=126,
 SP_MOD_DEATH=127,


 SP_MERCFLEE=165, SP_MERCKILLS=189, SP_MERCFAITH=190,


 SP_ATTACKRANGE=1000, SP_ATKELE,SP_DEFELE,
 SP_CASTRATE, SP_MAXHPRATE, SP_MAXSPRATE, SP_SPRATE,
 SP_ADDELE, SP_ADDRACE, SP_ADDSIZE, SP_SUBELE, SP_SUBRACE,
 SP_ADDEFF, SP_RESEFF,
 SP_BASE_ATK,SP_ASPD_RATE,SP_HP_RECOV_RATE,SP_SP_RECOV_RATE,SP_SPEED_RATE,
 SP_CRITICAL_DEF,SP_NEAR_ATK_DEF,SP_LONG_ATK_DEF,
 SP_DOUBLE_RATE, SP_DOUBLE_ADD_RATE, SP_SKILL_HEAL, SP_MATK_RATE,
 SP_IGNORE_DEF_ELE,SP_IGNORE_DEF_RACE,
 SP_ATK_RATE,SP_SPEED_ADDRATE,SP_SP_REGEN_RATE,
 SP_MAGIC_ATK_DEF,SP_MISC_ATK_DEF,
 SP_IGNORE_MDEF_ELE,SP_IGNORE_MDEF_RACE,
 SP_MAGIC_ADDELE,SP_MAGIC_ADDRACE,SP_MAGIC_ADDSIZE,
 SP_PERFECT_HIT_RATE,SP_PERFECT_HIT_ADD_RATE,SP_CRITICAL_RATE,SP_GET_ZENY_NUM,SP_ADD_GET_ZENY_NUM,
 SP_ADD_DAMAGE_CLASS,SP_ADD_MAGIC_DAMAGE_CLASS,SP_ADD_DEF_CLASS,SP_ADD_MDEF_CLASS,
 SP_ADD_MONSTER_DROP_ITEM,SP_DEF_RATIO_ATK_ELE,SP_DEF_RATIO_ATK_RACE,SP_UNBREAKABLE_GARMENT,
 SP_HIT_RATE,SP_FLEE_RATE,SP_FLEE2_RATE,SP_DEF_RATE,SP_DEF2_RATE,SP_MDEF_RATE,SP_MDEF2_RATE,
 SP_SPLASH_RANGE,SP_SPLASH_ADD_RANGE,SP_AUTOSPELL,SP_HP_DRAIN_RATE,SP_SP_DRAIN_RATE,
 SP_SHORT_WEAPON_DAMAGE_RETURN,SP_LONG_WEAPON_DAMAGE_RETURN,SP_WEAPON_COMA_ELE,SP_WEAPON_COMA_RACE,
 SP_ADDEFF2,SP_BREAK_WEAPON_RATE,SP_BREAK_ARMOR_RATE,SP_ADD_STEAL_RATE,
 SP_MAGIC_DAMAGE_RETURN,SP_ALL_STATS=1073,SP_AGI_VIT,SP_AGI_DEX_STR,SP_PERFECT_HIDE,
 SP_NO_KNOCKBACK,SP_CLASSCHANGE,
 SP_HP_DRAIN_VALUE,SP_SP_DRAIN_VALUE,
 SP_WEAPON_ATK,SP_WEAPON_ATK_RATE,
 SP_DELAYRATE,SP_HP_DRAIN_RATE_RACE,SP_SP_DRAIN_RATE_RACE,
 SP_IGNORE_MDEF_RATE,SP_IGNORE_DEF_RATE,SP_SKILL_HEAL2,SP_ADDEFF_ONSKILL,
 SP_ADD_HEAL_RATE, SP_ADD_HEAL2_RATE, SP_HP_VANISH_RATE,

 SP_RESTART_FULL_RECOVER=2000,SP_NO_CASTCANCEL,SP_NO_SIZEFIX,SP_NO_MAGIC_DAMAGE,SP_NO_WEAPON_DAMAGE,SP_NO_GEMSTONE,
 SP_NO_CASTCANCEL2,SP_NO_MISC_DAMAGE,SP_UNBREAKABLE_WEAPON,SP_UNBREAKABLE_ARMOR, SP_UNBREAKABLE_HELM,
 SP_UNBREAKABLE_SHIELD, SP_LONG_ATK_RATE,

 SP_CRIT_ATK_RATE, SP_CRITICAL_ADDRACE, SP_NO_REGEN, SP_ADDEFF_WHENHIT, SP_AUTOSPELL_WHENHIT,
 SP_SKILL_ATK, SP_UNSTRIPABLE, SP_AUTOSPELL_ONSKILL,
 SP_SP_GAIN_VALUE, SP_HP_REGEN_RATE, SP_HP_LOSS_RATE, SP_ADDRACE2, SP_HP_GAIN_VALUE,
 SP_SUBSIZE, SP_HP_DRAIN_VALUE_RACE, SP_ADD_ITEM_HEAL_RATE, SP_SP_DRAIN_VALUE_RACE, SP_EXP_ADDRACE,
 SP_SP_GAIN_RACE, SP_SUBRACE2, SP_UNBREAKABLE_SHOES,
 SP_UNSTRIPABLE_WEAPON,SP_UNSTRIPABLE_ARMOR,SP_UNSTRIPABLE_HELM,SP_UNSTRIPABLE_SHIELD,
 SP_INTRAVISION, SP_ADD_MONSTER_DROP_CHAINITEM, SP_SP_LOSS_RATE,
 SP_ADD_SKILL_BLOW, SP_SP_VANISH_RATE, SP_MAGIC_SP_GAIN_VALUE, SP_MAGIC_HP_GAIN_VALUE, SP_ADD_CLASS_DROP_ITEM,
 SP_EMATK, SP_SP_GAIN_RACE_ATTACK, SP_HP_GAIN_RACE_ATTACK, SP_SKILL_USE_SP_RATE,
 SP_SKILL_COOLDOWN,SP_SKILL_FIXEDCAST, SP_SKILL_VARIABLECAST, SP_FIXCASTRATE, SP_VARCASTRATE,
 SP_SKILL_USE_SP,SP_MAGIC_ATK_ELE, SP_ADD_FIXEDCAST, SP_ADD_VARIABLECAST,
 SP_SET_DEF_RACE,SP_SET_MDEF_RACE,
 SP_RACE_TOLERANCE,SP_ADDMAXWEIGHT,


 SP_LAST_KNOWN,
};

enum look {
 LOOK_BASE,
 LOOK_HAIR,
 LOOK_WEAPON,
 LOOK_HEAD_BOTTOM,
 LOOK_HEAD_TOP,
 LOOK_HEAD_MID,
 LOOK_HAIR_COLOR,
 LOOK_CLOTHES_COLOR,
 LOOK_SHIELD,
 LOOK_SHOES,
 LOOK_BODY,
 LOOK_FLOOR,
 LOOK_ROBE,
 LOOK_BODY2,
};


typedef enum {
 CELL_WALKABLE,
 CELL_SHOOTABLE,
 CELL_WATER,

 CELL_NPC,
 CELL_BASILICA,
 CELL_LANDPROTECTOR,
 CELL_NOVENDING,
 CELL_NOCHAT,
 CELL_ICEWALL,
 CELL_NOICEWALL,

} cell_t;


typedef enum {
 CELL_GETTYPE,

 CELL_CHKWALL,
 CELL_CHKWATER,
 CELL_CHKCLIFF,

 CELL_CHKPASS,
 CELL_CHKREACH,
 CELL_CHKNOPASS,
 CELL_CHKNOREACH,
 CELL_CHKSTACK,

 CELL_CHKNPC,
 CELL_CHKBASILICA,
 CELL_CHKLANDPROTECTOR,
 CELL_CHKNOVENDING,
 CELL_CHKNOCHAT,
 CELL_CHKICEWALL,
 CELL_CHKNOICEWALL,

} cell_chk;

struct mapcell {

 unsigned char
  walkable : 1,
  shootable : 1,
  water : 1;


 unsigned char
  npc : 1,
  basilica : 1,
  landprotector : 1,
  novending : 1,
  nochat : 1,
  icewall : 1,
  noicewall : 1;




};

struct iwall_data {
 char wall_name[50];
 short m, x, y, size;
 int8 dir;
 
# 559 "../../../server-code/src/map/map.h" 3 4
_Bool 
# 559 "../../../server-code/src/map/map.h"
     shootable;
};

struct mapflag_skill_adjust {
 unsigned short skill_id;
 unsigned short modifier;
};

enum map_zone_skill_subtype {
 MZS_NONE = 0x0,
 MZS_CLONE = 0x01,
 MZS_BOSS = 0x02,

 MZS_ALL = 0xFFF
};

struct map_zone_disabled_skill_entry {
 unsigned short nameid;
 enum bl_type type;
 enum map_zone_skill_subtype subtype;
};
struct map_zone_disabled_command_entry {
 AtCommandFunc cmd;
 int group_lv;
};

struct map_zone_skill_damage_cap_entry {
 unsigned short nameid;
 unsigned int cap;
 enum bl_type type;
 enum map_zone_skill_subtype subtype;
};

enum map_zone_merge_type {
 MZMT_NORMAL = 0,
 MZMT_MERGEABLE,
 MZMT_NEVERMERGE,
};
# 607 "../../../server-code/src/map/map.h"
struct map_zone_data {
 char name[60];
 enum map_zone_merge_type merge_type;
 struct map_zone_disabled_skill_entry **disabled_skills;
 int disabled_skills_count;
 int *disabled_items;
 int disabled_items_count;
 int *cant_disable_items;
 int cant_disable_items_count;
 char **mapflags;
 int mapflags_count;
 struct map_zone_disabled_command_entry **disabled_commands;
 int disabled_commands_count;
 struct map_zone_skill_damage_cap_entry **capped_skills;
 int capped_skills_count;
 struct {
  unsigned int merged : 1;
 } info;
};

struct map_drop_list {
 int drop_id;
 int drop_type;
 int drop_per;
};


struct questinfo {
 struct npc_data *nd;
 unsigned short icon;
 unsigned char color;
 int quest_id;
 
# 639 "../../../server-code/src/map/map.h" 3 4
_Bool 
# 639 "../../../server-code/src/map/map.h"
     hasJob;
 unsigned short job;
};


struct map_data {
 char name[(11 + 1)];
 uint16 index;
 struct mapcell* cell;
# 658 "../../../server-code/src/map/map.h"
 struct block_list **block;
 struct block_list **block_mob;

 int16 m;
 int16 xs,ys;
 int16 bxs,bys;
 int16 bgscore_lion, bgscore_eagle;
 int npc_num;
 int users;
 int users_pvp;
 int iwall_num;
 struct map_flag {
  unsigned town : 1;
  unsigned autotrade : 1;
  unsigned allowks : 1;
  unsigned nomemo : 1;
  unsigned noteleport : 1;
  unsigned noreturn : 1;
  unsigned monster_noteleport : 1;
  unsigned nosave : 1;
  unsigned nobranch : 1;
  unsigned noexppenalty : 1;
  unsigned pvp : 1;
  unsigned pvp_noparty : 1;
  unsigned pvp_noguild : 1;
  unsigned pvp_nightmaredrop :1;
  unsigned pvp_nocalcrank : 1;
  unsigned gvg_castle : 1;
  unsigned gvg : 1;
  unsigned gvg_dungeon : 1;
  unsigned gvg_noparty : 1;
  unsigned battleground : 2;
  unsigned nozenypenalty : 1;
  unsigned notrade : 1;
  unsigned noskill : 1;
  unsigned nowarp : 1;
  unsigned nowarpto : 1;
  unsigned noicewall : 1;
  unsigned snow : 1;
  unsigned clouds : 1;
  unsigned clouds2 : 1;
  unsigned fog : 1;
  unsigned fireworks : 1;
  unsigned sakura : 1;
  unsigned leaves : 1;
  unsigned nobaseexp : 1;
  unsigned nojobexp : 1;
  unsigned nomobloot : 1;
  unsigned nomvploot : 1;
  unsigned nightenabled :1;
  unsigned nodrop : 1;
  unsigned novending : 1;
  unsigned loadevent : 1;
  unsigned nochat :1;
  unsigned partylock :1;
  unsigned guildlock :1;
  unsigned src4instance : 1;
  unsigned reset :1;
  unsigned chsysnolocalaj : 1;
  unsigned noknockback : 1;
  unsigned notomb : 1;
  unsigned nocashshop : 1;
  uint32 noviewid;
 } flag;
 struct point save;
 struct npc_data *npc[512];
 struct map_drop_list *drop_list;
 unsigned short drop_list_count;

 struct spawn_data *moblist[100];
 int mob_delete_timer;
 int jexp;
 int bexp;
 int nocommand;


 int instance_id;
 int instance_src_map;


 struct mapflag_skill_adjust **units;
 unsigned short unit_count;

 struct mapflag_skill_adjust **skills;
 unsigned short skill_count;


 struct map_zone_data *zone;
 char **zone_mf;
 unsigned short zone_mf_count;
 struct map_zone_data *prev_zone;


 struct channel_data *channel;


 unsigned int invincible_time_inc;


 unsigned short weapon_damage_rate;

 unsigned short magic_damage_rate;

 unsigned short misc_damage_rate;

 unsigned short short_damage_rate;

 unsigned short long_damage_rate;

 
# 767 "../../../server-code/src/map/map.h" 3 4
_Bool 
# 767 "../../../server-code/src/map/map.h"
     custom_name;


 int (*getcellp)(struct map_data* m, const struct block_list *bl, int16 x, int16 y, cell_chk cellchk);
 void (*setcell) (int16 m, int16 x, int16 y, cell_t cell, 
# 771 "../../../server-code/src/map/map.h" 3 4
                                                         _Bool 
# 771 "../../../server-code/src/map/map.h"
                                                              flag);
 char *cellPos;


 struct questinfo *qi_data;
 unsigned short qi_count;


 unsigned short hpmeter_visible;
 struct hplugin_data_store *hdata;
};



struct map_data_other_server {
 char name[(11 + 1)];
 unsigned short index;
 struct mapcell* cell;
 uint32 ip;
 uint16 port;
};




enum e_mapitflags {
 MAPIT_NORMAL = 0,

};

struct s_mapiterator;


struct mapit_interface {
 struct s_mapiterator* (*alloc) (enum e_mapitflags flags, enum bl_type types);
 void (*free) (struct s_mapiterator* iter);
 struct block_list* (*first) (struct s_mapiterator* iter);
 struct block_list* (*last) (struct s_mapiterator* iter);
 struct block_list* (*next) (struct s_mapiterator* iter);
 struct block_list* (*prev) (struct s_mapiterator* iter);
 
# 811 "../../../server-code/src/map/map.h" 3 4
_Bool 
# 811 "../../../server-code/src/map/map.h"
                        (*exists) (struct s_mapiterator* iter);
};
# 821 "../../../server-code/src/map/map.h"
typedef struct map_session_data TBL_PC;
typedef struct npc_data TBL_NPC;
typedef struct mob_data TBL_MOB;
typedef struct flooritem_data TBL_ITEM;
typedef struct chat_data TBL_CHAT;
typedef struct skill_unit TBL_SKILL;
typedef struct pet_data TBL_PET;
typedef struct homun_data TBL_HOM;
typedef struct mercenary_data TBL_MER;
typedef struct elemental_data TBL_ELEM;
# 870 "../../../server-code/src/map/map.h"
static inline struct block_list *BL_UCAST_(struct block_list *bl) __attribute__((unused));
static inline struct block_list *BL_UCAST_(struct block_list *bl)
{
 return bl;
}
# 899 "../../../server-code/src/map/map.h"
static inline const struct block_list *BL_UCCAST_(const struct block_list *bl) __attribute__((unused));
static inline const struct block_list *BL_UCCAST_(const struct block_list *bl)
{
 return bl;
}
# 918 "../../../server-code/src/map/map.h"
struct charid_request {
 struct charid_request* next;
 int charid;
};
struct charid2nick {
 char nick[(23 + 1)];
 struct charid_request* requests;
};


struct map_cache_main_header {
 uint32 file_size;
 uint16 map_count;
};


struct map_cache_map_info {
 char name[(11 + 1)];
 int16 xs;
 int16 ys;
 int32 len;
};







struct map_interface {


 
# 950 "../../../server-code/src/map/map.h" 3 4
_Bool 
# 950 "../../../server-code/src/map/map.h"
     minimal;
 
# 951 "../../../server-code/src/map/map.h" 3 4
_Bool 
# 951 "../../../server-code/src/map/map.h"
     scriptcheck;


 char **extra_scripts;
 int extra_scripts_count;

 int retval;
 int count;

 int autosave_interval;
 int minsave_interval;
 int save_settings;
 int agit_flag;
 int agit2_flag;
 int night_flag;
 int enable_spy;
 char db_path[256];

 char help_txt[256];
 char help2_txt[256];
 char charhelp_txt[256];

 char wisp_server_name[(23 + 1)];

 char *INTER_CONF_NAME;
 char *LOG_CONF_NAME;
 char *MAP_CONF_NAME;
 char *BATTLE_CONF_FILENAME;
 char *ATCOMMAND_CONF_FILENAME;
 char *SCRIPT_CONF_NAME;
 char *MSG_CONF_NAME;
 char *GRF_PATH_FILENAME;

 char autotrade_merchants_db[32];
 char autotrade_data_db[32];
 char npc_market_data_db[32];

 char default_codepage[32];
 char default_lang_str[64];
 uint8 default_lang_id;

 int server_port;
 char server_ip[32];
 char server_id[32];
 char server_pw[100];
 char server_db[32];
 struct Sql *mysql_handle;

 int port;
 int users;
 int enable_grf;
 
# 1002 "../../../server-code/src/map/map.h" 3 4
_Bool 
# 1002 "../../../server-code/src/map/map.h"
     ip_set;
 
# 1003 "../../../server-code/src/map/map.h" 3 4
_Bool 
# 1003 "../../../server-code/src/map/map.h"
     char_ip_set;

 int16 index2mapid[2000];

 struct DBMap *id_db;
 struct DBMap *pc_db;
 struct DBMap *mobid_db;
 struct DBMap *bossid_db;
 struct DBMap *map_db;
 struct DBMap *nick_db;
 struct DBMap *charid_db;
 struct DBMap *regen_db;
 struct DBMap *zone_db;
 struct DBMap *iwall_db;
 struct block_list **block_free;
 int block_free_count, block_free_lock, block_free_list_size;
 struct block_list **bl_list;
 int bl_list_count, bl_list_size;
int8 HERC__zeroed_block_BEGIN;
 struct block_list bl_head;
 struct map_zone_data zone_all;
 struct map_zone_data zone_pk;
int8 HERC__zeroed_block_END;

 struct map_session_data *cpsd;
 struct map_data *list;

 struct eri *iterator_ers;
 char *cache_buffer;

 struct eri *flooritem_ers;

 int bonus_id;

 
# 1037 "../../../server-code/src/map/map.h" 3 4
_Bool 
# 1037 "../../../server-code/src/map/map.h"
     cpsd_active;

 void (*zone_init) (void);
 void (*zone_remove) (int m);
 void (*zone_apply) (int m, struct map_zone_data *zone, const char* start, const char* buffer, const char* filepath);
 void (*zone_change) (int m, struct map_zone_data *zone, const char* start, const char* buffer, const char* filepath);
 void (*zone_change2) (int m, struct map_zone_data *zone);

 int (*getcell) (int16 m, const struct block_list *bl, int16 x, int16 y, cell_chk cellchk);
 void (*setgatcell) (int16 m, int16 x, int16 y, int gat);

 void (*cellfromcache) (struct map_data *m);

 void (*setusers) (int);
 int (*getusers) (void);
 int (*usercount) (void);

 int (*freeblock) (struct block_list *bl);
 int (*freeblock_lock) (void);
 int (*freeblock_unlock) (void);

 int (*addblock) (struct block_list* bl);
 int (*delblock) (struct block_list* bl);
 int (*moveblock) (struct block_list *bl, int x1, int y1, int64 tick);

 int (*count_oncell) (int16 m,int16 x,int16 y,int type,int flag);
 struct skill_unit * (*find_skill_unit_oncell) (struct block_list* target,int16 x,int16 y,uint16 skill_id,struct skill_unit* out_unit, int flag);

 int (*get_new_object_id) (void);
 int (*search_freecell) (struct block_list *src, int16 m, int16 *x, int16 *y, int16 rx, int16 ry, int flag);
 
# 1067 "../../../server-code/src/map/map.h" 3 4
_Bool 
# 1067 "../../../server-code/src/map/map.h"
     (*closest_freecell) (int16 m, const struct block_list *bl, int16 *x, int16 *y, int type, int flag);

 int (*quit) (struct map_session_data *sd);

 
# 1071 "../../../server-code/src/map/map.h" 3 4
_Bool 
# 1071 "../../../server-code/src/map/map.h"
     (*addnpc) (int16 m,struct npc_data *nd);

 int (*clearflooritem_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*removemobs_timer) (int tid, int64 tick, int id, intptr_t data);
 void (*clearflooritem) (struct block_list* bl);
 int (*addflooritem) (const struct block_list *bl, struct item *item_data, int amount, int16 m, int16 x, int16 y, int first_charid, int second_charid, int third_charid, int flags);

 void (*addnickdb) (int charid, const char* nick);
 void (*delnickdb) (int charid, const char* nick);
 void (*reqnickdb) (struct map_session_data* sd,int charid);
 const char* (*charid2nick) (int charid);
 struct map_session_data* (*charid2sd) (int charid);

 void (*vforeachpc) (int (*func)(struct map_session_data* sd, va_list args), va_list args);
 void (*foreachpc) (int (*func)(struct map_session_data* sd, va_list args), ...);
 void (*vforeachmob) (int (*func)(struct mob_data* md, va_list args), va_list args);
 void (*foreachmob) (int (*func)(struct mob_data* md, va_list args), ...);
 void (*vforeachnpc) (int (*func)(struct npc_data* nd, va_list args), va_list args);
 void (*foreachnpc) (int (*func)(struct npc_data* nd, va_list args), ...);
 void (*vforeachregen) (int (*func)(struct block_list* bl, va_list args), va_list args);
 void (*foreachregen) (int (*func)(struct block_list* bl, va_list args), ...);
 void (*vforeachiddb) (int (*func)(struct block_list* bl, va_list args), va_list args);
 void (*foreachiddb) (int (*func)(struct block_list* bl, va_list args), ...);

 int (*vforeachinrange) (int (*func)(struct block_list*,va_list), struct block_list* center, int16 range, int type, va_list ap);
 int (*foreachinrange) (int (*func)(struct block_list*,va_list), struct block_list* center, int16 range, int type, ...);
 int (*vforeachinshootrange) (int (*func)(struct block_list*,va_list), struct block_list* center, int16 range, int type, va_list ap);
 int (*foreachinshootrange) (int (*func)(struct block_list*,va_list), struct block_list* center, int16 range, int type, ...);
 int (*vforeachinarea) (int (*func)(struct block_list*,va_list), int16 m, int16 x0, int16 y0, int16 x1, int16 y1, int type, va_list ap);
 int (*foreachinarea) (int (*func)(struct block_list*,va_list), int16 m, int16 x0, int16 y0, int16 x1, int16 y1, int type, ...);
 int (*vforcountinrange) (int (*func)(struct block_list*,va_list), struct block_list* center, int16 range, int count, int type, va_list ap);
 int (*forcountinrange) (int (*func)(struct block_list*,va_list), struct block_list* center, int16 range, int count, int type, ...);
 int (*vforcountinarea) (int (*func)(struct block_list*,va_list), int16 m, int16 x0, int16 y0, int16 x1, int16 y1, int count, int type, va_list ap);
 int (*forcountinarea) (int (*func)(struct block_list*,va_list), int16 m, int16 x0, int16 y0, int16 x1, int16 y1, int count, int type, ...);
 int (*vforeachinmovearea) (int (*func)(struct block_list*,va_list), struct block_list* center, int16 range, int16 dx, int16 dy, int type, va_list ap);
 int (*foreachinmovearea) (int (*func)(struct block_list*,va_list), struct block_list* center, int16 range, int16 dx, int16 dy, int type, ...);
 int (*vforeachincell) (int (*func)(struct block_list*,va_list), int16 m, int16 x, int16 y, int type, va_list ap);
 int (*foreachincell) (int (*func)(struct block_list*,va_list), int16 m, int16 x, int16 y, int type, ...);
 int (*vforeachinpath) (int (*func)(struct block_list*,va_list), int16 m, int16 x0, int16 y0, int16 x1, int16 y1, int16 range, int length, int type, va_list ap);
 int (*foreachinpath) (int (*func)(struct block_list*,va_list), int16 m, int16 x0, int16 y0, int16 x1, int16 y1, int16 range, int length, int type, ...);
 int (*vforeachinmap) (int (*func)(struct block_list*,va_list), int16 m, int type, va_list args);
 int (*foreachinmap) (int (*func)(struct block_list*,va_list), int16 m, int type, ...);
 int (*vforeachininstance)(int (*func)(struct block_list*,va_list), int16 instance_id, int type, va_list ap);
 int (*foreachininstance)(int (*func)(struct block_list*,va_list), int16 instance_id, int type,...);

 struct map_session_data *(*id2sd) (int id);
 struct npc_data *(*id2nd) (int id);
 struct mob_data *(*id2md) (int id);
 struct flooritem_data *(*id2fi) (int id);
 struct chat_data *(*id2cd) (int id);
 struct skill_unit *(*id2su) (int id);
 struct pet_data *(*id2pd) (int id);
 struct homun_data *(*id2hd) (int id);
 struct mercenary_data *(*id2mc) (int id);
 struct elemental_data *(*id2ed) (int id);
 struct block_list *(*id2bl) (int id);
 
# 1127 "../../../server-code/src/map/map.h" 3 4
_Bool 
# 1127 "../../../server-code/src/map/map.h"
     (*blid_exists) (int id);
 int16 (*mapindex2mapid) (unsigned short map_index);
 int16 (*mapname2mapid) (const char* name);
 int (*mapname2ipport) (unsigned short name, uint32* ip, uint16* port);
 int (*setipport) (unsigned short map_index, uint32 ip, uint16 port);
 int (*eraseipport) (unsigned short map_index, uint32 ip, uint16 port);
 int (*eraseallipport) (void);
 void (*addiddb) (struct block_list *bl);
 void (*deliddb) (struct block_list *bl);

 struct map_session_data * (*nick2sd) (const char *nick);
 struct mob_data * (*getmob_boss) (int16 m);
 struct mob_data * (*id2boss) (int id);
 uint32 (*race_id2mask) (int race);

 void (*reloadnpc) (
# 1142 "../../../server-code/src/map/map.h" 3 4
                   _Bool 
# 1142 "../../../server-code/src/map/map.h"
                        clear);

 int (*check_dir) (int s_dir,int t_dir);
 uint8 (*calc_dir) (struct block_list *src,int16 x,int16 y);
 int (*random_dir) (struct block_list *bl, short *x, short *y);

 int (*cleanup_sub) (struct block_list *bl, va_list ap);

 int (*delmap) (char* mapname);
 void (*flags_init) (void);

 
# 1153 "../../../server-code/src/map/map.h" 3 4
_Bool 
# 1153 "../../../server-code/src/map/map.h"
     (*iwall_set) (int16 m, int16 x, int16 y, int size, int8 dir, 
# 1153 "../../../server-code/src/map/map.h" 3 4
                                                                  _Bool 
# 1153 "../../../server-code/src/map/map.h"
                                                                       shootable, const char* wall_name);
 void (*iwall_get) (struct map_session_data *sd);
 void (*iwall_remove) (const char *wall_name);

 int (*addmobtolist) (unsigned short m, struct spawn_data *spawn);
 void (*spawnmobs) (int16 m);
 void (*removemobs) (int16 m);

 void (*addmap2db) (struct map_data *m);
 void (*removemapdb) (struct map_data *m);
 void (*clean) (int i);

 void (*do_shutdown) (void);

 int (*freeblock_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*searchrandfreecell) (int16 m, const struct block_list *bl, int16 *x, int16 *y, int stack);
 int (*count_sub) (struct block_list *bl, va_list ap);
 struct DBData (*create_charid2nick) (union DBKey key, va_list args);
 int (*removemobs_sub) (struct block_list *bl, va_list ap);
 struct mapcell (*gat2cell) (int gat);
 int (*cell2gat) (struct mapcell cell);
 int (*getcellp) (struct map_data *m, const struct block_list *bl, int16 x, int16 y, cell_chk cellchk);
 void (*setcell) (int16 m, int16 x, int16 y, cell_t cell, 
# 1175 "../../../server-code/src/map/map.h" 3 4
                                                         _Bool 
# 1175 "../../../server-code/src/map/map.h"
                                                              flag);
 int (*sub_getcellp) (struct map_data *m, const struct block_list *bl, int16 x, int16 y, cell_chk cellchk);
 void (*sub_setcell) (int16 m, int16 x, int16 y, cell_t cell, 
# 1177 "../../../server-code/src/map/map.h" 3 4
                                                             _Bool 
# 1177 "../../../server-code/src/map/map.h"
                                                                  flag);
 void (*iwall_nextxy) (int16 x, int16 y, int8 dir, int pos, int16 *x1, int16 *y1);
 struct DBData (*create_map_data_other_server) (union DBKey key, va_list args);
 int (*eraseallipport_sub) (union DBKey key, struct DBData *data, va_list va);
 char* (*init_mapcache) (FILE *fp);
 int (*readfromcache) (struct map_data *m, char *buffer);
 int (*addmap) (const char *mapname);
 void (*delmapid) (int id);
 void (*zone_db_clear) (void);
 void (*list_final) (void);
 int (*waterheight) (char *mapname);
 int (*readgat) (struct map_data *m);
 int (*readallmaps) (void);
 int (*config_read) (char *cfgName);
 int (*config_read_sub) (char *cfgName);
 void (*reloadnpc_sub) (char *cfgName);
 int (*inter_config_read) (char *cfgName);
 int (*sql_init) (void);
 int (*sql_close) (void);
 
# 1196 "../../../server-code/src/map/map.h" 3 4
_Bool 
# 1196 "../../../server-code/src/map/map.h"
     (*zone_mf_cache) (int m, char *flag, char *params);
 unsigned short (*zone_str2itemid) (const char *name);
 unsigned short (*zone_str2skillid) (const char *name);
 enum bl_type (*zone_bl_type) (const char *entry, enum map_zone_skill_subtype *subtype);
 void (*read_zone_db) (void);
 int (*db_final) (union DBKey key, struct DBData *data, va_list ap);
 int (*nick_db_final) (union DBKey key, struct DBData *data, va_list args);
 int (*cleanup_db_sub) (union DBKey key, struct DBData *data, va_list va);
 int (*abort_sub) (struct map_session_data *sd, va_list ap);
 void (*update_cell_bl) (struct block_list *bl, 
# 1205 "../../../server-code/src/map/map.h" 3 4
                                               _Bool 
# 1205 "../../../server-code/src/map/map.h"
                                                    increase);
 int (*get_new_bonus_id) (void);
 void (*add_questinfo) (int m, struct questinfo *qi);
 
# 1208 "../../../server-code/src/map/map.h" 3 4
_Bool 
# 1208 "../../../server-code/src/map/map.h"
     (*remove_questinfo) (int m, struct npc_data *nd);
 struct map_zone_data *(*merge_zone) (struct map_zone_data *main, struct map_zone_data *other);
 void (*zone_clear_single) (struct map_zone_data *zone);
};


void map_defaults(void);


extern struct mapit_interface *mapit;
extern struct map_interface *map;
# 25 "../../../server-code/src/map/clif.h" 2
# 1 "../../../server-code/src/map/packets_struct.h" 1
# 32 "../../../server-code/src/map/packets_struct.h"
enum packet_headers {
 banking_withdraw_ackType = 0x9aa,
 banking_deposit_ackType = 0x9a8,
 banking_checkType = 0x9a6,
 cart_additem_ackType = 0x12c,
 sc_notickType = 0x196,

 hotkeyType = 0xa00,
# 48 "../../../server-code/src/map/packets_struct.h"
 cartaddType = 0x1c5,






 storageaddType = 0x1c4,






 tradeaddType = 0x80f,
# 73 "../../../server-code/src/map/packets_struct.h"
 additemType = 0x990,
# 92 "../../../server-code/src/map/packets_struct.h"
 idle_unitType = 0x9dd,




 status_changeType = 0x983,





 status_change2Type = 0x43f,
 status_change_endType = 0x196,
# 114 "../../../server-code/src/map/packets_struct.h"
 damageType = 0x8c8,
# 131 "../../../server-code/src/map/packets_struct.h"
 spawn_unitType = 0x9dc,
# 140 "../../../server-code/src/map/packets_struct.h"
 authokType = 0xa18,

 script_clearType = 0x8d6,
 package_item_announceType = 0x7fd,
 item_drop_announceType = 0x7fd,
# 160 "../../../server-code/src/map/packets_struct.h"
 unit_walkingType = 0x9db,



 bgqueue_ackType = 0x8d8,
 bgqueue_notice_deleteType = 0x8db,
 bgqueue_registerType = 0x8d7,
 bgqueue_updateinfoType = 0x8d9,
 bgqueue_checkstateType = 0x90a,
 bgqueue_revokereqType = 0x8da,
 bgqueue_battlebeginackType = 0x8e0,
 bgqueue_notify_entryType = 0x8d9,
 bgqueue_battlebeginsType = 0x8df,
 notify_bounditemType = 0x2d3,







 skill_entryType = 0x9ca,

 graffiti_entryType = 0x1c9,

 dropflooritemType = 0x84b,




 inventorylistnormalType = 0x991,
# 201 "../../../server-code/src/map/packets_struct.h"
 inventorylistequipType = 0x992,
# 210 "../../../server-code/src/map/packets_struct.h"
 storagelistnormalType = 0x995,
# 221 "../../../server-code/src/map/packets_struct.h"
 storagelistequipType = 0x996,
# 230 "../../../server-code/src/map/packets_struct.h"
 cartlistnormalType = 0x993,
# 241 "../../../server-code/src/map/packets_struct.h"
 cartlistequipType = 0x994,
# 252 "../../../server-code/src/map/packets_struct.h"
 vendinglistType = 0x800,

 openvendingType = 0x136,

 equipitemType = 0x998,




 equipitemackType = 0x999,




 unequipitemackType = 0x99a,






 viewequipackType = 0x997,





 notifybindonequip = 0x2d3,
 monsterhpType = 0x977,
 maptypeproperty2Type = 0x99b,
 npcmarketresultackType = 0x9d7,
 npcmarketopenType = 0x9d5,

 wisendType = 0x9df,



 partyleaderchangedType = 0x7fc,
 rouletteinfoackType = 0xa1c,
 roulettgenerateackType = 0xa20,
 roulettercvitemackType = 0xa22,



 questListType = 0x97a,



};


#pragma pack(push, 1)





struct EQUIPSLOTINFO {
 unsigned short card[4];
} __attribute__((packed));

struct NORMALITEM_INFO {
 short index;
 unsigned short ITID;
 unsigned char type;



 short count;

 unsigned int WearState;




 struct EQUIPSLOTINFO slot;


 int HireExpireDate;


 struct {
  unsigned char IsIdentified : 1;
  unsigned char PlaceETCTab : 1;
  unsigned char SpareBits : 6;
 } Flag;

} __attribute__((packed));

struct RndOptions {
 short index;
 short value;
 unsigned char param;
} __attribute__((packed));

struct EQUIPITEM_INFO {
 short index;
 unsigned short ITID;
 unsigned char type;




 unsigned int location;
 unsigned int WearState;







 unsigned char RefiningLevel;
 struct EQUIPSLOTINFO slot;

 int HireExpireDate;


 unsigned short bindOnEquipType;


 unsigned short wItemSpriteNumber;






 struct {
  unsigned char IsIdentified : 1;
  unsigned char IsDamaged : 1;
  unsigned char PlaceETCTab : 1;
  unsigned char SpareBits : 5;
 } Flag;

} __attribute__((packed));

struct packet_authok {
 short PacketType;
 unsigned int startTime;
 unsigned char PosDir[3];
 unsigned char xSize;
 unsigned char ySize;

 short font;


 unsigned char sex;

} __attribute__((packed));

struct packet_monster_hp {
 short PacketType;
 unsigned int GID;
 int HP;
 int MaxHP;
} __attribute__((packed));

struct packet_sc_notick {
 short PacketType;
 short index;
 unsigned int AID;
 unsigned char state;
} __attribute__((packed));

struct packet_additem {
 short PacketType;
 unsigned short Index;
 unsigned short count;
 unsigned short nameid;
 uint8 IsIdentified;
 uint8 IsDamaged;
 unsigned char refiningLevel;
 struct EQUIPSLOTINFO slot;

 unsigned int location;



 unsigned char type;
 unsigned char result;

 int HireExpireDate;


 unsigned short bindOnEquipType;




} __attribute__((packed));

struct packet_dropflooritem {
 short PacketType;
 unsigned int ITAID;
 unsigned short ITID;

 unsigned short type;

 uint8 IsIdentified;
 short xPos;
 short yPos;
 unsigned char subX;
 unsigned char subY;
 short count;
} __attribute__((packed));
struct packet_idle_unit2 {
# 491 "../../../server-code/src/map/packets_struct.h"
 int8 HERC__unavailable_struct;

} __attribute__((packed));

struct packet_spawn_unit2 {
# 522 "../../../server-code/src/map/packets_struct.h"
 int8 HERC__unavailable_struct;

} __attribute__((packed));

struct packet_spawn_unit {
 short PacketType;

 short PacketLength;
 unsigned char objecttype;


 unsigned int AID;

 unsigned int GID;
 short speed;
 short bodyState;
 short healthState;



 int effectState;

 short job;
 short head;



 int weapon;

 short accessory;



 short accessory2;
 short accessory3;
 short headpalette;
 short bodypalette;
 short headDir;

 short robe;

 unsigned int GUID;
 short GEmblemVer;
 short honor;

 int virtue;



 uint8 isPKModeON;
 unsigned char sex;
 unsigned char PosDir[3];
 unsigned char xSize;
 unsigned char ySize;
 short clevel;

 short font;


 int maxHP;
 int HP;
 unsigned char isBoss;





} __attribute__((packed));

struct packet_unit_walking {
 short PacketType;

 short PacketLength;


 unsigned char objecttype;


 unsigned int AID;

 unsigned int GID;
 short speed;
 short bodyState;
 short healthState;



 int effectState;

 short job;
 short head;



 int weapon;

 short accessory;
 unsigned int moveStartTime;



 short accessory2;
 short accessory3;
 short headpalette;
 short bodypalette;
 short headDir;

 short robe;

 unsigned int GUID;
 short GEmblemVer;
 short honor;

 int virtue;



 uint8 isPKModeON;
 unsigned char sex;
 unsigned char MoveData[6];
 unsigned char xSize;
 unsigned char ySize;
 short clevel;

 short font;


 int maxHP;
 int HP;
 unsigned char isBoss;





} __attribute__((packed));

struct packet_idle_unit {
 short PacketType;

 short PacketLength;
 unsigned char objecttype;


 unsigned int AID;

 unsigned int GID;
 short speed;
 short bodyState;
 short healthState;



 int effectState;

 short job;
 short head;



 int weapon;

 short accessory;



 short accessory2;
 short accessory3;
 short headpalette;
 short bodypalette;
 short headDir;

 short robe;

 unsigned int GUID;
 short GEmblemVer;
 short honor;

 int virtue;



 uint8 isPKModeON;
 unsigned char sex;
 unsigned char PosDir[3];
 unsigned char xSize;
 unsigned char ySize;
 unsigned char state;
 short clevel;

 short font;


 int maxHP;
 int HP;
 unsigned char isBoss;





} __attribute__((packed));

struct packet_status_change {
 short PacketType;
 short index;
 unsigned int AID;
 unsigned char state;

 unsigned int Total;


 unsigned int Left;
 int val1;
 int val2;
 int val3;

} __attribute__((packed));

struct packet_status_change_end {
 short PacketType;
 short index;
 unsigned int AID;
 unsigned char state;
} __attribute__((packed));

struct packet_status_change2 {
 short PacketType;
 short index;
 unsigned int AID;
 unsigned char state;
 unsigned int Left;
 int val1;
 int val2;
 int val3;
} __attribute__((packed));

struct packet_maptypeproperty2 {
 short PacketType;
 short type;
 struct {
  unsigned int party : 1;
  unsigned int guild : 1;
  unsigned int siege : 1;
  unsigned int mineffect : 1;
  unsigned int nolockon : 1;
  unsigned int countpk : 1;
  unsigned int nopartyformation : 1;
  unsigned int bg : 1;
  unsigned int nocostume : 1;
  unsigned int usecart : 1;
  unsigned int summonstarmiracle : 1;
  unsigned int SpareBits : 15;
 } flag;
} __attribute__((packed));

struct packet_bgqueue_ack {
 short PacketType;
 unsigned char type;
 char bg_name[(23 + 1)];
} __attribute__((packed));

struct packet_bgqueue_notice_delete {
 short PacketType;
 unsigned char type;
 char bg_name[(23 + 1)];
} __attribute__((packed));

struct packet_bgqueue_register {
 short PacketType;
 short type;
 char bg_name[(23 + 1)];
} __attribute__((packed));

struct packet_bgqueue_update_info {
 short PacketType;
 char bg_name[(23 + 1)];
 int position;
} __attribute__((packed));

struct packet_bgqueue_checkstate {
 short PacketType;
 char bg_name[(23 + 1)];
} __attribute__((packed));

struct packet_bgqueue_revoke_req {
 short PacketType;
 char bg_name[(23 + 1)];
} __attribute__((packed));

struct packet_bgqueue_battlebegin_ack {
 short PacketType;
 unsigned char result;
 char bg_name[(23 + 1)];
 char game_name[(23 + 1)];
} __attribute__((packed));

struct packet_bgqueue_notify_entry {
 short PacketType;
 char name[(23 + 1)];
 int position;
} __attribute__((packed));

struct packet_bgqueue_battlebegins {
 short PacketType;
 char bg_name[(23 + 1)];
 char game_name[(23 + 1)];
} __attribute__((packed));

struct packet_script_clear {
 short PacketType;
 unsigned int NpcID;
} __attribute__((packed));


struct packet_package_item_announce {
 short PacketType;
 short PacketLength;
 unsigned char type;
 unsigned short ItemID;
 char len;
 char Name[(23 + 1)];
 char unknown;
 unsigned short BoxItemID;
} __attribute__((packed));


struct packet_item_drop_announce {
 short PacketType;
 short PacketLength;
 unsigned char type;
 unsigned short ItemID;
 char len;
 char Name[(23 + 1)];
 char monsterNameLen;
 char monsterName[(23 + 1)];
} __attribute__((packed));

struct packet_cart_additem_ack {
 short PacketType;
 char result;
} __attribute__((packed));

struct packet_banking_check {
 short PacketType;
 int64 Money;
 short Reason;
} __attribute__((packed));

struct packet_banking_deposit_req {
 short PacketType;
 unsigned int AID;
 int Money;
} __attribute__((packed));

struct packet_banking_withdraw_req {
 short PacketType;
 unsigned int AID;
 int Money;
} __attribute__((packed));

struct packet_banking_deposit_ack {
 short PacketType;
 short Reason;
 int64 Money;
 int Balance;
} __attribute__((packed));

struct packet_banking_withdraw_ack {
 short PacketType;
 short Reason;
 int64 Money;
 int Balance;
} __attribute__((packed));


struct packet_roulette_open_ack {
 short PacketType;
 char Result;
 int Serial;
 char Step;
 char Idx;
 short AdditionItemID;
 int GoldPoint;
 int SilverPoint;
 int BronzePoint;
} __attribute__((packed));

struct packet_roulette_info_ack {
 short PacketType;
 short PacketLength;
 unsigned int RouletteSerial;
 struct {
  unsigned short Row;
  unsigned short Position;
  unsigned short ItemId;
  unsigned short Count;
 } ItemInfo[42];
} __attribute__((packed));

struct packet_roulette_close_ack {
 short PacketType;
 unsigned char Result;
} __attribute__((packed));

struct packet_roulette_generate_ack {
 short PacketType;
 unsigned char Result;
 unsigned short Step;
 unsigned short Idx;
 unsigned short AdditionItemID;
 int RemainGold;
 int RemainSilver;
 int RemainBronze;
} __attribute__((packed));

struct packet_roulette_itemrecv_req {
 short PacketType;
 unsigned char Condition;
} __attribute__((packed));

struct packet_roulette_itemrecv_ack {
 short PacketType;
 unsigned char Result;
 unsigned short AdditionItemID;
} __attribute__((packed));

struct packet_itemlist_normal {
 short PacketType;
 short PacketLength;
 struct NORMALITEM_INFO list[600];
} __attribute__((packed));

struct packet_itemlist_equip {
 short PacketType;
 short PacketLength;
 struct EQUIPITEM_INFO list[600];
} __attribute__((packed));

struct packet_storelist_normal {
 short PacketType;
 short PacketLength;

 char name[(23 + 1)];

 struct NORMALITEM_INFO list[600];
} __attribute__((packed));

struct packet_storelist_equip {
 short PacketType;
 short PacketLength;

 char name[(23 + 1)];

 struct EQUIPITEM_INFO list[600];
} __attribute__((packed));

struct packet_equip_item {
 short PacketType;
 unsigned short index;

 unsigned int wearLocation;



} __attribute__((packed));

struct packet_equipitem_ack {
 short PacketType;
 unsigned short index;

 unsigned int wearLocation;




 unsigned short wItemSpriteNumber;

 unsigned char result;
} __attribute__((packed));

struct packet_unequipitem_ack {
 short PacketType;
 unsigned short index;

 unsigned int wearLocation;



 unsigned char result;
} __attribute__((packed));

struct packet_viewequip_ack {
 short PacketType;
 short PacketLength;
 char characterName[(23 + 1)];
 short job;
 short head;
 short accessory;
 short accessory2;
 short accessory3;

 short robe;

 short headpalette;
 short bodypalette;
 unsigned char sex;
 struct EQUIPITEM_INFO list[100];
} __attribute__((packed));

struct packet_notify_bounditem {
 short PacketType;
 unsigned short index;
} __attribute__((packed));

struct packet_skill_entry {
 short PacketType;

 short PacketLength;

 unsigned int AID;
 unsigned int creatorAID;
 short xPos;
 short yPos;

 int job;




 char RadiusRange;

 unsigned char isVisible;

 unsigned char level;

} __attribute__((packed));

struct packet_graffiti_entry {
 short PacketType;
 unsigned int AID;
 unsigned int creatorAID;
 short xPos;
 short yPos;
 unsigned char job;
 unsigned char isVisible;
 unsigned char isContens;
 char msg[80];
} __attribute__((packed));

struct packet_damage {
 short PacketType;
 unsigned int GID;
 unsigned int targetGID;
 unsigned int startTime;
 int attackMT;
 int attackedMT;



 int damage;


 unsigned char is_sp_damaged;

 short count;
 unsigned char action;



 int leftDamage;

} __attribute__((packed));

struct packet_gm_monster_item {
 short PacketType;

 char str[100];



} __attribute__((packed));

struct packet_npc_market_purchase {
 short PacketType;
 short PacketLength;
 struct {
  unsigned short ITID;
  int qty;
 } list[];
} __attribute__((packed));

struct packet_npc_market_result_ack {
 short PacketType;
 short PacketLength;
 unsigned char result;
 struct {
  unsigned short ITID;
  unsigned short qty;
  unsigned int price;
 } list[100];
} __attribute__((packed));

struct packet_npc_market_open {
 short PacketType;
 short PacketLength;

 struct {
  unsigned short nameid;
  unsigned char type;
  unsigned int price;
  unsigned int qty;
  unsigned short view;



 } list[1000];
} __attribute__((packed));

struct packet_wis_end {
 short PacketType;
 char result;

 unsigned int unknown;

} __attribute__((packed));


struct packet_party_leader_changed {
 short PacketType;
 unsigned int prev_leader_aid;
 unsigned int new_leader_aid;
} __attribute__((packed));

struct packet_hotkey {

 short PacketType;

 char Rotate;

 struct {
  char isSkill;
  unsigned int ID;
  short count;
 } hotkey[38];



} __attribute__((packed));




struct packet_mission_info_sub {
 int32 mob_id;
 int16 huntCount;
 int16 maxCount;
 char mobName[(23 + 1)];
} __attribute__((packed));





struct packet_quest_list_info {
 int32 questID;
 int8 active;

 int32 quest_svrTime;
 int32 quest_endTime;
 int16 hunting_count;
 struct packet_mission_info_sub objectives[];

} __attribute__((packed));
# 1206 "../../../server-code/src/map/packets_struct.h"
struct packet_quest_list_header {
 uint16 PacketType;
 uint16 PacketLength;
 int32 questCount;

} __attribute__((packed));


#pragma pack(pop)
# 26 "../../../server-code/src/map/clif.h" 2
# 34 "../../../server-code/src/map/clif.h"
struct battleground_data;
struct channel_data;
struct chat_data;
struct eri;
struct flooritem_data;
struct guild;
struct homun_data;
struct item;
struct item_data;
struct itemlist;
struct map_session_data;
struct mercenary_data;
struct mob_data;
struct npc_data;
struct party_booking_ad_info;
struct party_data;
struct pet_data;
struct quest;
struct s_vending;
struct skill_cd;
struct skill_unit;
struct unit_data;
struct view_data;
# 76 "../../../server-code/src/map/clif.h"
typedef enum send_target {
 ALL_CLIENT,
 ALL_SAMEMAP,
 AREA,
 AREA_WOS,
 AREA_WOC,
 AREA_WOSC,
 AREA_CHAT_WOC,
 CHAT,
 CHAT_WOS,
 PARTY,
 PARTY_WOS,
 PARTY_SAMEMAP,
 PARTY_SAMEMAP_WOS,
 PARTY_AREA,
 PARTY_AREA_WOS,
 GUILD,
 GUILD_WOS,
 GUILD_SAMEMAP,
 GUILD_SAMEMAP_WOS,
 GUILD_AREA,
 GUILD_AREA_WOS,
 GUILD_NOBG,
 DUEL,
 DUEL_WOS,
 SELF,

 BG,
 BG_WOS,
 BG_SAMEMAP,
 BG_SAMEMAP_WOS,
 BG_AREA,
 BG_AREA_WOS,

 BG_QUEUE,
} send_target;

typedef enum broadcast_flags {
 BC_ALL = 0,
 BC_MAP = 1,
 BC_AREA = 2,
 BC_SELF = 3,
 BC_TARGET_MASK = 0x07,

 BC_PC = 0x00,
 BC_NPC = 0x08,
 BC_SOURCE_MASK = 0x08,

 BC_YELLOW = 0x00,
 BC_BLUE = 0x10,
 BC_WOE = 0x20,
 BC_COLOR_MASK = 0x30,

 BC_DEFAULT = BC_ALL|BC_PC|BC_YELLOW
} broadcast_flags;

typedef enum emotion_type {
 E_GASP = 0,
 E_WHAT,
 E_HO,
 E_LV,
 E_SWT,
 E_IC,
 E_AN,
 E_AG,
 E_CASH,
 E_DOTS,
 E_SCISSORS,
 E_ROCK,
 E_PAPER,
 E_KOREA,
 E_LV2,
 E_THX,
 E_WAH,
 E_SRY,
 E_HEH,
 E_SWT2,
 E_HMM,
 E_NO1,
 E_NO,
 E_OMG,
 E_OH,
 E_X,
 E_HLP,
 E_GO,
 E_SOB,
 E_GG,
 E_KIS,
 E_KIS2,
 E_PIF,
 E_OK,
 E_MUTE,
 E_INDONESIA,
 E_BZZ,
 E_RICE,
 E_AWSM,
 E_MEH,
 E_SHY,
 E_PAT,
 E_MP,
 E_SLUR,
 E_COM,
 E_YAWN,
 E_GRAT,
 E_HP,
 E_PHILIPPINES,
 E_MALAYSIA,
 E_SINGAPORE,
 E_BRAZIL,
 E_FLASH,
 E_SPIN,
 E_SIGH,
 E_DUM,
 E_LOUD,
 E_OTL,
 E_DICE1,
 E_DICE2,
 E_DICE3,
 E_DICE4,
 E_DICE5,
 E_DICE6,
 E_INDIA,
 E_LUV,
 E_RUSSIA,
 E_VIRGIN,
 E_MOBILE,
 E_MAIL,
 E_CHINESE,
 E_ANTENNA1,
 E_ANTENNA2,
 E_ANTENNA3,
 E_HUM,
 E_ABS,
 E_OOPS,
 E_SPIT,
 E_ENE,
 E_PANIC,
 E_WHISP,
 E_YUT1,
 E_YUT2,
 E_YUT3,
 E_YUT4,
 E_YUT5,
 E_YUT6,
 E_YUT7,

 E_MAX
} emotion_type;

typedef enum clr_type {
 CLR_OUTSIGHT = 0,
 CLR_DEAD,
 CLR_RESPAWN,
 CLR_TELEPORT,
 CLR_TRICKDEAD,
} clr_type;

enum map_property {
 MAPPROPERTY_NOTHING = 0,
 MAPPROPERTY_FREEPVPZONE = 1,
 MAPPROPERTY_EVENTPVPZONE = 2,
 MAPPROPERTY_AGITZONE = 3,
 MAPPROPERTY_PKSERVERZONE = 4,
 MAPPROPERTY_PVPSERVERZONE = 5,
 MAPPROPERTY_DENYSKILLZONE = 6,
};

enum map_type {
 MAPTYPE_VILLAGE = 0,
 MAPTYPE_VILLAGE_IN = 1,
 MAPTYPE_FIELD = 2,
 MAPTYPE_DUNGEON = 3,
 MAPTYPE_ARENA = 4,
 MAPTYPE_PENALTY_FREEPKZONE = 5,
 MAPTYPE_NOPENALTY_FREEPKZONE = 6,
 MAPTYPE_EVENT_GUILDWAR = 7,
 MAPTYPE_AGIT = 8,
 MAPTYPE_DUNGEON2 = 9,
 MAPTYPE_DUNGEON3 = 10,
 MAPTYPE_PKSERVER = 11,
 MAPTYPE_PVPSERVER = 12,
 MAPTYPE_DENYSKILL = 13,
 MAPTYPE_TURBOTRACK = 14,
 MAPTYPE_JAIL = 15,
 MAPTYPE_MONSTERTRACK = 16,
 MAPTYPE_PORINGBATTLE = 17,
 MAPTYPE_AGIT_SIEGEV15 = 18,
 MAPTYPE_BATTLEFIELD = 19,
 MAPTYPE_PVP_TOURNAMENT = 20,

 MAPTYPE_SIEGE_LOWLEVEL = 25,

 MAPTYPE_UNUSED = 29,
};

typedef enum useskill_fail_cause {
 USESKILL_FAIL_LEVEL = 0,
 USESKILL_FAIL_SP_INSUFFICIENT = 1,
 USESKILL_FAIL_HP_INSUFFICIENT = 2,
 USESKILL_FAIL_STUFF_INSUFFICIENT = 3,
 USESKILL_FAIL_SKILLINTERVAL = 4,
 USESKILL_FAIL_MONEY = 5,
 USESKILL_FAIL_THIS_WEAPON = 6,
 USESKILL_FAIL_REDJAMSTONE = 7,
 USESKILL_FAIL_BLUEJAMSTONE = 8,
 USESKILL_FAIL_WEIGHTOVER = 9,
 USESKILL_FAIL = 10,
 USESKILL_FAIL_TOTARGET = 11,
 USESKILL_FAIL_ANCILLA_NUMOVER = 12,
 USESKILL_FAIL_HOLYWATER = 13,
 USESKILL_FAIL_ANCILLA = 14,
 USESKILL_FAIL_DUPLICATE_RANGEIN = 15,
 USESKILL_FAIL_NEED_OTHER_SKILL = 16,
 USESKILL_FAIL_NEED_HELPER = 17,
 USESKILL_FAIL_INVALID_DIR = 18,
 USESKILL_FAIL_SUMMON = 19,
 USESKILL_FAIL_SUMMON_NONE = 20,
 USESKILL_FAIL_IMITATION_SKILL_NONE = 21,
 USESKILL_FAIL_DUPLICATE = 22,
 USESKILL_FAIL_CONDITION = 23,
 USESKILL_FAIL_PAINTBRUSH = 24,
 USESKILL_FAIL_DRAGON = 25,
 USESKILL_FAIL_POS = 26,
 USESKILL_FAIL_HELPER_SP_INSUFFICIENT = 27,
 USESKILL_FAIL_NEER_WALL = 28,
 USESKILL_FAIL_NEED_EXP_1PERCENT = 29,
 USESKILL_FAIL_CHORUS_SP_INSUFFICIENT = 30,
 USESKILL_FAIL_GC_WEAPONBLOCKING = 31,
 USESKILL_FAIL_GC_POISONINGWEAPON = 32,
 USESKILL_FAIL_MADOGEAR = 33,
 USESKILL_FAIL_NEED_EQUIPMENT_KUNAI = 34,
 USESKILL_FAIL_TOTARGET_PLAYER = 35,
 USESKILL_FAIL_SIZE = 36,
 USESKILL_FAIL_CANONBALL = 37,





 USESKILL_FAIL_GUILLONTINE_POISON = 43,






 USESKILL_FAIL_MADOGEAR_RIDE = 50,
 USESKILL_FAIL_SPELLBOOK = 51,
 USESKILL_FAIL_SPELLBOOK_DIFFICULT_SLEEP = 52,
 USESKILL_FAIL_SPELLBOOK_PRESERVATION_POINT = 53,
 USESKILL_FAIL_SPELLBOOK_READING = 54,


 USESKILL_FAIL_CART = 57,


 USESKILL_FAIL_NO_MORE_SPELL = 60,
# 342 "../../../server-code/src/map/clif.h"
 USESKILL_FAIL_MANUAL_NOTIFY = 70,
 USESKILL_FAIL_NEED_ITEM = 71,
 USESKILL_FAIL_NEED_EQUIPMENT = 72,
 USESKILL_FAIL_COMBOSKILL = 73,
 USESKILL_FAIL_SPIRITS = 74,
 USESKILL_FAIL_EXPLOSIONSPIRITS = 75,
 USESKILL_FAIL_HP_TOOMANY = 76,
 USESKILL_FAIL_NEED_ROYAL_GUARD_BANDING = 77,
 USESKILL_FAIL_NEED_EQUIPPED_WEAPON_CLASS = 78,
 USESKILL_FAIL_EL_SUMMON = 79,
 USESKILL_FAIL_RELATIONGRADE = 80,
 USESKILL_FAIL_STYLE_CHANGE_FIGHTER = 81,
 USESKILL_FAIL_STYLE_CHANGE_GRAPPLER = 82,
 USESKILL_FAIL_THERE_ARE_NPC_AROUND = 83,
 USESKILL_FAIL_NEED_MORE_BULLET = 84,
}useskill_fail_cause;

enum clif_messages {
 MSG_ITEM_CANT_OBTAIN_WEIGHT = 0x034,
 MSG_ITEM_NEED_STANDING = 0x297,
 MSG_MERCENARY_EXPIRED = 0x4f2,
 MSG_MERCENARY_DIED = 0x4f3,
 MSG_MERCENARY_RELEASED = 0x4f4,
 MSG_MERCENARY_ESCAPED = 0x4f5,
 MSG_SKILL_CANT_USE_AREA = 0x536,
 MSG_ITEM_CANT_USE_AREA = 0x537,
 MSG_EQUIP_NOT_PUBLIC = 0x54d,
 MSG_ITEM_NEED_MADO = 0x59b,
 MSG_ITEM_NEED_CART = 0x5ef,
 MSG_RUNE_STONE_MAX_AMOUNT = 0x61b,
 MSG_SKILL_POINTS_LEFT_JOB1 = 0x61e,
 MSG_SKILL_POINTS_LEFT_JOB2 = 0x61f,
 MSG_SKILL_ITEM_NOT_FOUND = 0x623,
 MSG_SKILL_SUCCESS = 0x627,
 MSG_SKILL_FAILURE = 0x628,
 MSG_SKILL_ITEM_NEED_IDENTIFY = 0x62d,
 MSG_ITEM_CANT_EQUIP_LVL = 0x6ed,
 MSG_ITEM_CANT_USE_LVL = 0x6ee,
 MSG_COOKING_LIST_FAIL = 0x625,
 MSG_SECONDS_UNTIL_USE = 0x746,
 MSG_NPC_WORK_IN_PROGRESS = 0x783,
 MSG_REINS_CANT_USE_MOUNTED = 0x78b,
};




enum cashshop_error {
 ERROR_TYPE_NONE = 0,
 ERROR_TYPE_NPC = 1,
 ERROR_TYPE_SYSTEM = 2,
 ERROR_TYPE_INVENTORY_WEIGHT = 3,
 ERROR_TYPE_EXCHANGE = 4,
 ERROR_TYPE_ITEM_ID = 5,
 ERROR_TYPE_MONEY = 6,

 ERROR_TYPE_QUANTITY = 7,
 ERROR_TYPE_NOT_ALL = 8,
};

enum CASH_SHOP_TABS {
 CASHSHOP_TAB_NEW = 0,
 CASHSHOP_TAB_POPULAR = 1,
 CASHSHOP_TAB_LIMITED = 2,
 CASHSHOP_TAB_RENTAL = 3,
 CASHSHOP_TAB_PERPETUITY = 4,
 CASHSHOP_TAB_BUFF = 5,
 CASHSHOP_TAB_RECOVERY = 6,
 CASHSHOP_TAB_ETC = 7,
 CASHSHOP_TAB_MAX,
};

enum CASH_SHOP_BUY_RESULT {
 CSBR_SUCCESS = 0x0,
 CSBR_SHORTTAGE_CASH = 0x2,
 CSBR_UNKONWN_ITEM = 0x3,
 CSBR_INVENTORY_WEIGHT = 0x4,
 CSBR_INVENTORY_ITEMCNT = 0x5,
 CSBR_RUNE_OVERCOUNT = 0x9,
 CSBR_EACHITEM_OVERCOUNT = 0xa,
 CSBR_UNKNOWN = 0xb,
};

enum BATTLEGROUNDS_QUEUE_ACK {
 BGQA_SUCCESS = 1,
 BGQA_FAIL_QUEUING_FINISHED,
 BGQA_FAIL_BGNAME_INVALID,
 BGQA_FAIL_TYPE_INVALID,
 BGQA_FAIL_PPL_OVERAMOUNT,
 BGQA_FAIL_LEVEL_INCORRECT,
 BGQA_DUPLICATE_REQUEST,
 BGQA_PLEASE_RELOGIN,
 BGQA_NOT_PARTY_GUILD_LEADER,
 BGQA_FAIL_CLASS_INVALID,

 BGQA_FAIL_DESERTER,
 BGQA_FAIL_COOLDOWN,
 BGQA_FAIL_TEAM_COUNT,
};

enum BATTLEGROUNDS_QUEUE_NOTICE_DELETED {
 BGQND_CLOSEWINDOW = 1,
 BGQND_FAIL_BGNAME_WRONG = 3,
 BGQND_FAIL_NOT_QUEUING = 11,
};

enum e_BANKING_DEPOSIT_ACK {
 BDA_SUCCESS = 0x0,
 BDA_ERROR = 0x1,
 BDA_NO_MONEY = 0x2,
 BDA_OVERFLOW = 0x3,
};
enum e_BANKING_WITHDRAW_ACK {
 BWA_SUCCESS = 0x0,
 BWA_NO_MONEY = 0x1,
 BWA_UNKNOWN_ERROR = 0x2,
};


enum e_EQUIP_ITEM_ACK {

 EIA_SUCCESS = 0x0,
 EIA_FAIL_LV = 0x1,
 EIA_FAIL = 0x2,





};


enum e_UNEQUIP_ITEM_ACK {

 UIA_SUCCESS = 0x0,
 UIA_FAIL = 0x1,




};

enum e_trade_item_ok {
 TIO_SUCCESS = 0x0,
 TIO_OVERWEIGHT = 0x1,
 TIO_CANCEL = 0x2,

 TIO_INDROCKS = 0x9,
};

enum RECV_ROULETTE_ITEM_REQ {
 RECV_ITEM_SUCCESS = 0x0,
 RECV_ITEM_FAILED = 0x1,
 RECV_ITEM_OVERCOUNT = 0x2,
 RECV_ITEM_OVERWEIGHT = 0x3,
};

enum RECV_ROULETTE_ITEM_ACK {
 RECV_ITEM_NORMAL = 0x0,
 RECV_ITEM_LOSING = 0x1,
};

enum GENERATE_ROULETTE_ACK {
 GENERATE_ROULETTE_SUCCESS = 0x0,
 GENERATE_ROULETTE_FAILED = 0x1,
 GENERATE_ROULETTE_NO_ENOUGH_POINT = 0x2,
 GENERATE_ROULETTE_LOSING = 0x3,
};

enum OPEN_ROULETTE_ACK{
 OPEN_ROULETTE_SUCCESS = 0x0,
 OPEN_ROULETTE_FAILED = 0x1,
};

enum CLOSE_ROULETTE_ACK {
 CLOSE_ROULETTE_SUCCESS = 0x0,
 CLOSE_ROULETTE_FAILED = 0x1,
};




enum delitem_reason {
 DELITEM_NORMAL = 0,
 DELITEM_SKILLUSE = 1,
 DELITEM_FAILREFINE = 2,
 DELITEM_MATERIALCHANGE = 3,
 DELITEM_TOSTORAGE = 4,
 DELITEM_TOCART = 5,
 DELITEM_SOLD = 6,
 DELITEM_ANALYSIS = 7,
};





enum mergeitem_reason {
 MERGEITEM_SUCCESS = 0x0,
 MERGEITEM_FAILD = 0x1,
 MERGEITEM_MAXCOUNTFAILD = 0x2,
};




typedef void (*pFunc)(int, struct map_session_data *);
struct s_packet_db {
 short len;
 pFunc func;
 short pos[20];
};

struct hCSData {
 unsigned short id;
 unsigned int price;
};

struct cdelayed_damage {
 struct packet_damage p;
 struct block_list bl;
};

struct merge_item {
    int16 position;
    int16 nameid;
};




struct clif_interface {

 uint32 map_ip;
 uint32 bind_ip;
 uint16 map_port;
 char map_ip_str[128];
 int map_fd;

 struct eri *delay_clearunit_ers;

 struct {
  struct hCSData **data[CASHSHOP_TAB_MAX];
  unsigned int item_count[CASHSHOP_TAB_MAX];
 } cs;

 struct {
  int *nameid[7];
  int *qty[7];
  int items[7];
 } rd;

 unsigned int cryptKey[3];

 
# 596 "../../../server-code/src/map/clif.h" 3 4
_Bool 
# 596 "../../../server-code/src/map/clif.h"
     ally_only;

 struct eri *delayed_damage_ers;

 int (*init) (
# 600 "../../../server-code/src/map/clif.h" 3 4
             _Bool 
# 600 "../../../server-code/src/map/clif.h"
                  minimal);
 void (*final) (void);
 
# 602 "../../../server-code/src/map/clif.h" 3 4
_Bool 
# 602 "../../../server-code/src/map/clif.h"
     (*setip) (const char* ip);
 
# 603 "../../../server-code/src/map/clif.h" 3 4
_Bool 
# 603 "../../../server-code/src/map/clif.h"
     (*setbindip) (const char* ip);
 void (*setport) (uint16 port);
 uint32 (*refresh_ip) (void);
 
# 606 "../../../server-code/src/map/clif.h" 3 4
_Bool 
# 606 "../../../server-code/src/map/clif.h"
     (*send) (const void* buf, int len, struct block_list* bl, enum send_target type);
 int (*send_sub) (struct block_list *bl, va_list ap);
 int (*send_actual) (int fd, void *buf, int len);
 int (*parse) (int fd);
 const struct s_packet_db *(*packet) (int packet_id);
 unsigned short (*parse_cmd) ( int fd, struct map_session_data *sd );
 unsigned short (*decrypt_cmd) ( int cmd, struct map_session_data *sd );

 void (*authok) (struct map_session_data *sd);
 void (*authrefuse) (int fd, uint8 error_code);
 void (*authfail_fd) (int fd, int type);
 void (*charselectok) (int id, uint8 ok);

 void (*dropflooritem) (struct flooritem_data* fitem);
 void (*clearflooritem) (struct flooritem_data *fitem, int fd);
 void (*additem) (struct map_session_data *sd, int n, int amount, int fail);
 void (*dropitem) (struct map_session_data *sd,int n,int amount);
 void (*delitem) (struct map_session_data *sd,int n,int amount, short reason);
 void (*takeitem) (struct block_list* src, struct block_list* dst);
 void (*item_equip) (short idx, struct EQUIPITEM_INFO *p, struct item *i, struct item_data *id, int eqp_pos);
 void (*item_normal) (short idx, struct NORMALITEM_INFO *p, struct item *i, struct item_data *id);
 void (*arrowequip) (struct map_session_data *sd,int val);
 void (*arrow_fail) (struct map_session_data *sd,int type);
 void (*use_card) (struct map_session_data *sd,int idx);
 void (*cart_additem) (struct map_session_data *sd,int n,int amount,int fail);
 void (*cart_delitem) (struct map_session_data *sd,int n,int amount);
 void (*equipitemack) (struct map_session_data *sd,int n,int pos,enum e_EQUIP_ITEM_ACK result);
 void (*unequipitemack) (struct map_session_data *sd,int n,int pos,enum e_UNEQUIP_ITEM_ACK result);
 void (*useitemack) (struct map_session_data *sd,int index,int amount,
# 634 "../../../server-code/src/map/clif.h" 3 4
                                                                     _Bool 
# 634 "../../../server-code/src/map/clif.h"
                                                                          ok);
 void (*addcards) (unsigned char* buf, struct item* item);
 void (*addcards2) (unsigned short *cards, struct item* item);
 void (*item_sub) (unsigned char *buf, int n, struct item *i, struct item_data *id, int equip);
 void (*getareachar_item) (struct map_session_data* sd,struct flooritem_data* fitem);
 void (*cart_additem_ack) (struct map_session_data *sd, int flag);
 void (*cashshop_load) (void);
 void (*package_announce) (struct map_session_data *sd, unsigned short nameid, unsigned short containerid);
 void (*item_drop_announce) (struct map_session_data *sd, unsigned short nameid, char *monsterName);

 void (*clearunit_single) (int id, clr_type type, int fd);
 void (*clearunit_area) (struct block_list* bl, clr_type type);
 void (*clearunit_delayed) (struct block_list* bl, clr_type type, int64 tick);
 void (*walkok) (struct map_session_data *sd);
 void (*move) (struct unit_data *ud);
 void (*move2) (struct block_list *bl, struct view_data *vd, struct unit_data *ud);
 void (*blown) (struct block_list *bl);
 void (*slide) (struct block_list *bl, int x, int y);
 void (*fixpos) (struct block_list *bl);
 void (*changelook) (struct block_list *bl,int type,int val);
 void (*changetraplook) (struct block_list *bl,int val);
 void (*refreshlook) (struct block_list *bl,int id,int type,int val,enum send_target target);
 void (*sendlook) (struct block_list *bl, int id, int type, int val, int val2, enum send_target target);
 void (*class_change) (struct block_list *bl,int class_,int type);
 void (*skill_delunit) (struct skill_unit *su);
 void (*skillunit_update) (struct block_list* bl);
 int (*clearunit_delayed_sub) (int tid, int64 tick, int id, intptr_t data);
 void (*set_unit_idle) (struct block_list* bl, struct map_session_data *tsd,enum send_target target);
 void (*spawn_unit) (struct block_list* bl, enum send_target target);
 void (*spawn_unit2) (struct block_list* bl, enum send_target target);
 void (*set_unit_idle2) (struct block_list* bl, struct map_session_data *tsd, enum send_target target);
 void (*set_unit_walking) (struct block_list* bl, struct map_session_data *tsd,struct unit_data* ud, enum send_target target);
 int (*calc_walkdelay) (struct block_list *bl,int delay, int type, int damage, int div_);
 void (*getareachar_skillunit) (struct block_list *bl, struct skill_unit *su, enum send_target target);
 void (*getareachar_unit) (struct map_session_data* sd,struct block_list *bl);
 void (*clearchar_skillunit) (struct skill_unit *su, int fd);
 int (*getareachar) (struct block_list* bl,va_list ap);
 void (*graffiti_entry) (struct block_list *bl, struct skill_unit *su, enum send_target target);

 
# 673 "../../../server-code/src/map/clif.h" 3 4
_Bool 
# 673 "../../../server-code/src/map/clif.h"
     (*spawn) (struct block_list *bl);

 void (*changemap) (struct map_session_data *sd, short m, int x, int y);
 void (*changemapcell) (int fd, int16 m, int x, int y, int type, enum send_target target);
 void (*map_property) (struct map_session_data* sd, enum map_property property);
 void (*pvpset) (struct map_session_data *sd, int pvprank, int pvpnum,int type);
 void (*map_property_mapall) (int mapid, enum map_property property);
 void (*bossmapinfo) (int fd, struct mob_data *md, short flag);
 void (*map_type) (struct map_session_data* sd, enum map_type type);
 void (*maptypeproperty2) (struct block_list *bl,enum send_target t);

 void (*changemapserver) (struct map_session_data* sd, unsigned short map_index, int x, int y, uint32 ip, uint16 port);

 void (*npcbuysell) (struct map_session_data* sd, int id);
 void (*buylist) (struct map_session_data *sd, struct npc_data *nd);
 void (*selllist) (struct map_session_data *sd);
 void (*cashshop_show) (struct map_session_data *sd, struct npc_data *nd);
 void (*npc_buy_result) (struct map_session_data* sd, unsigned char result);
 void (*npc_sell_result) (struct map_session_data* sd, unsigned char result);
 void (*cashshop_ack) (struct map_session_data* sd, int error);

 void (*scriptmes) (struct map_session_data *sd, int npcid, const char *mes);
 void (*scriptnext) (struct map_session_data *sd,int npcid);
 void (*scriptclose) (struct map_session_data *sd, int npcid);
 void (*scriptmenu) (struct map_session_data* sd, int npcid, const char* mes);
 void (*scriptinput) (struct map_session_data *sd, int npcid);
 void (*scriptinputstr) (struct map_session_data *sd, int npcid);
 void (*cutin) (struct map_session_data* sd, const char* image, int type);
 void (*sendfakenpc) (struct map_session_data *sd, int npcid);
 void (*scriptclear) (struct map_session_data *sd, int npcid);

 void (*viewpoint) (struct map_session_data *sd, int npc_id, int type, int x, int y, int id, int color);
 int (*damage) (struct block_list* src, struct block_list* dst, int sdelay, int ddelay, int64 damage, short div, unsigned char type, int64 damage2);
 void (*sitting) (struct block_list* bl);
 void (*standing) (struct block_list* bl);
 void (*arrow_create_list) (struct map_session_data *sd);
 void (*refresh_storagewindow) (struct map_session_data *sd);
 void (*refresh) (struct map_session_data *sd);
 void (*fame_blacksmith) (struct map_session_data *sd, int points);
 void (*fame_alchemist) (struct map_session_data *sd, int points);
 void (*fame_taekwon) (struct map_session_data *sd, int points);
 void (*ranklist) (struct map_session_data *sd, enum fame_list_type type);
 void (*update_rankingpoint) (struct map_session_data *sd, enum fame_list_type type, int points);
 void (*pRanklist) (int fd, struct map_session_data *sd);
 void (*hotkeys) (struct map_session_data *sd);
 int (*insight) (struct block_list *bl,va_list ap);
 int (*outsight) (struct block_list *bl,va_list ap);
 void (*skillcastcancel) (struct block_list* bl);
 void (*skill_fail) (struct map_session_data *sd,uint16 skill_id,enum useskill_fail_cause cause,int btype);
 void (*skill_cooldown) (struct map_session_data *sd, uint16 skill_id, unsigned int duration);
 void (*skill_memomessage) (struct map_session_data* sd, int type);
 void (*skill_mapinfomessage) (struct map_session_data *sd, int type);
 void (*skill_produce_mix_list) (struct map_session_data *sd, int skill_id, int trigger);
 void (*cooking_list) (struct map_session_data *sd, int trigger, uint16 skill_id, int qty, int list_type);
 void (*autospell) (struct map_session_data *sd,uint16 skill_lv);
 void (*combo_delay) (struct block_list *bl,int wait);
 void (*status_change) (struct block_list *bl,int type,int flag,int tick,int val1, int val2, int val3);
 void (*insert_card) (struct map_session_data *sd,int idx_equip,int idx_card,int flag);
 void (*inventorylist) (struct map_session_data *sd);
 void (*equiplist) (struct map_session_data *sd);
 void (*cartlist) (struct map_session_data *sd);
 void (*favorite_item) (struct map_session_data* sd, unsigned short index);
 void (*clearcart) (int fd);
 void (*item_identify_list) (struct map_session_data *sd);
 void (*item_identified) (struct map_session_data *sd,int idx,int flag);
 void (*item_repair_list) (struct map_session_data *sd, struct map_session_data *dstsd, int lv);
 void (*item_repaireffect) (struct map_session_data *sd, int idx, int flag);
 void (*item_damaged) (struct map_session_data* sd, unsigned short position);
 void (*item_refine_list) (struct map_session_data *sd);
 void (*item_skill) (struct map_session_data *sd,uint16 skill_id,uint16 skill_lv);
 void (*mvp_item) (struct map_session_data *sd,int nameid);
 void (*mvp_exp) (struct map_session_data *sd, unsigned int exp);
 void (*mvp_noitem) (struct map_session_data* sd);
 void (*changed_dir) (struct block_list *bl, enum send_target target);
 void (*charnameack) (int fd, struct block_list *bl);
 void (*monster_hp_bar) ( struct mob_data* md, struct map_session_data *sd );
 int (*hpmeter) (struct map_session_data *sd);
 void (*hpmeter_single) (int fd, int id, unsigned int hp, unsigned int maxhp);
 int (*hpmeter_sub) (struct block_list *bl, va_list ap);
 void (*upgrademessage) (int fd, int result, int item_id);
 void (*get_weapon_view) (struct map_session_data* sd, unsigned short *rhand, unsigned short *lhand);
 void (*gospel_info) (struct map_session_data *sd, int type);
 void (*feel_req) (int fd, struct map_session_data *sd, uint16 skill_lv);
 void (*starskill) (struct map_session_data* sd, const char* mapname, int monster_id, unsigned char star, unsigned char result);
 void (*feel_info) (struct map_session_data* sd, unsigned char feel_level, unsigned char type);
 void (*hate_info) (struct map_session_data *sd, unsigned char hate_level,int class_, unsigned char type);
 void (*mission_info) (struct map_session_data *sd, int mob_id, unsigned char progress);
 void (*feel_hate_reset) (struct map_session_data *sd);
 void (*partytickack) (struct map_session_data* sd, 
# 761 "../../../server-code/src/map/clif.h" 3 4
                                                   _Bool 
# 761 "../../../server-code/src/map/clif.h"
                                                        flag);
 void (*equiptickack) (struct map_session_data* sd, int flag);
 void (*viewequip_ack) (struct map_session_data* sd, struct map_session_data* tsd);
 void (*equpcheckbox) (struct map_session_data* sd);
 void (*displayexp) (struct map_session_data *sd, unsigned int exp, char type, 
# 765 "../../../server-code/src/map/clif.h" 3 4
                                                                              _Bool 
# 765 "../../../server-code/src/map/clif.h"
                                                                                   is_quest);
 void (*font) (struct map_session_data *sd);
 void (*progressbar) (struct map_session_data * sd, unsigned int color, unsigned int second);
 void (*progressbar_abort) (struct map_session_data * sd);
 void (*showdigit) (struct map_session_data* sd, unsigned char type, int value);
 int (*elementalconverter_list) (struct map_session_data *sd);
 int (*spellbook_list) (struct map_session_data *sd);
 int (*magicdecoy_list) (struct map_session_data *sd, uint16 skill_lv, short x, short y);
 int (*poison_list) (struct map_session_data *sd, uint16 skill_lv);
 int (*autoshadowspell_list) (struct map_session_data *sd);
 int (*skill_itemlistwindow) ( struct map_session_data *sd, uint16 skill_id, uint16 skill_lv );
 void (*sc_load) (struct block_list *bl, int tid, enum send_target target, int type, int val1, int val2, int val3);
 void (*sc_end) (struct block_list *bl, int tid, enum send_target target, int type);
 void (*initialstatus) (struct map_session_data *sd);
 void (*cooldown_list) (int fd, struct skill_cd* cd);

 void (*updatestatus) (struct map_session_data *sd,int type);
 void (*changestatus) (struct map_session_data* sd,int type,int val);
 void (*statusupack) (struct map_session_data *sd,int type,int ok,int val);
 void (*movetoattack) (struct map_session_data *sd,struct block_list *bl);
 void (*solved_charname) (int fd, int charid, const char* name);
 void (*charnameupdate) (struct map_session_data *ssd);
 int (*delayquit) (int tid, int64 tick, int id, intptr_t data);
 void (*getareachar_pc) (struct map_session_data* sd,struct map_session_data* dstsd);
 void (*disconnect_ack) (struct map_session_data* sd, short result);
 void (*PVPInfo) (struct map_session_data* sd);
 void (*blacksmith) (struct map_session_data* sd);
 void (*alchemist) (struct map_session_data* sd);
 void (*taekwon) (struct map_session_data* sd);
 void (*ranking_pk) (struct map_session_data* sd);
 void (*quitsave) (int fd,struct map_session_data *sd);

 void (*misceffect) (struct block_list* bl,int type);
 void (*changeoption) (struct block_list* bl);
 void (*changeoption2) (struct block_list* bl);
 void (*emotion) (struct block_list *bl,int type);
 void (*talkiebox) (struct block_list* bl, const char* talkie);
 void (*wedding_effect) (struct block_list *bl);
 void (*divorced) (struct map_session_data* sd, const char* name);
 void (*callpartner) (struct map_session_data *sd);
 int (*skill_damage) (struct block_list *src, struct block_list *dst, int64 tick, int sdelay, int ddelay, int64 damage, int div, uint16 skill_id, uint16 skill_lv, int type);
 int (*skill_nodamage) (struct block_list *src,struct block_list *dst,uint16 skill_id,int heal,int fail);
 void (*skill_poseffect) (struct block_list *src, uint16 skill_id, int val, int x, int y, int64 tick);
 void (*skill_estimation) (struct map_session_data *sd,struct block_list *dst);
 void (*skill_warppoint) (struct map_session_data* sd, uint16 skill_id, uint16 skill_lv, unsigned short map1, unsigned short map2, unsigned short map3, unsigned short map4);
 void (*skillcasting) (struct block_list* bl, int src_id, int dst_id, int dst_x, int dst_y, uint16 skill_id, int property, int casttime);
 void (*produce_effect) (struct map_session_data* sd,int flag,int nameid);
 void (*devotion) (struct block_list *src, struct map_session_data *tsd);
 void (*spiritball) (struct block_list *bl);
 void (*spiritball_single) (int fd, struct map_session_data *sd);
 void (*bladestop) (struct block_list *src, int dst_id, int active);
 void (*mvp_effect) (struct map_session_data *sd);
 void (*heal) (int fd,int type,int val);
 void (*resurrection) (struct block_list *bl,int type);
 void (*refine) (int fd, int fail, int index, int val);
 void (*weather) (int16 m);
 void (*specialeffect) (struct block_list* bl, int type, enum send_target target);
 void (*specialeffect_single) (struct block_list* bl, int type, int fd);
 void (*specialeffect_value) (struct block_list* bl, int effect_id, int num, send_target target);
 void (*millenniumshield) (struct block_list *bl, short shields );
 void (*spiritcharm) (struct map_session_data *sd);
 void (*charm_single) (int fd, struct map_session_data *sd);
 void (*snap) ( struct block_list *bl, short x, short y );
 void (*weather_check) (struct map_session_data *sd);

 void (*playBGM) (struct map_session_data* sd, const char* name);
 void (*soundeffect) (struct map_session_data* sd, struct block_list* bl, const char* name, int type);
 void (*soundeffectall) (struct block_list* bl, const char* name, int type, enum send_target coverage);

 void (*GlobalMessage) (struct block_list* bl, const char* message);
 void (*createchat) (struct map_session_data* sd, int flag);
 void (*dispchat) (struct chat_data* cd, int fd);
 void (*joinchatfail) (struct map_session_data *sd,int flag);
 void (*joinchatok) (struct map_session_data *sd,struct chat_data* cd);
 void (*addchat) (struct chat_data* cd,struct map_session_data *sd);
 void (*changechatowner) (struct chat_data* cd, struct map_session_data* sd);
 void (*clearchat) (struct chat_data *cd,int fd);
 void (*leavechat) (struct chat_data* cd, struct map_session_data* sd, 
# 842 "../../../server-code/src/map/clif.h" 3 4
                                                                      _Bool 
# 842 "../../../server-code/src/map/clif.h"
                                                                           flag);
 void (*changechatstatus) (struct chat_data* cd);
 void (*wis_message) (int fd, const char* nick, const char* mes, size_t mes_len);
 void (*wis_end) (int fd, int flag);
 void (*disp_message) (struct block_list* src, const char* mes, size_t len, enum send_target target);
 void (*broadcast) (struct block_list* bl, const char* mes, size_t len, int type, enum send_target target);
 void (*broadcast2) (struct block_list* bl, const char* mes, size_t len, unsigned int fontColor, short fontType, short fontSize, short fontAlign, short fontY, enum send_target target);
 void (*messagecolor_self) (int fd, uint32 color, const char *msg);
 void (*messagecolor) (struct block_list* bl, uint32 color, const char* msg);
 void (*disp_overhead) (struct block_list *bl, const char* mes);
 void (*msgtable) (struct map_session_data* sd, unsigned short msg_id);
 void (*msgtable_num) (struct map_session_data *sd, unsigned short msg_id, int value);
 void (*msgtable_skill) (struct map_session_data *sd, uint16 skill_id, int msg_id);
 void (*message) (const int fd, const char* mes);
 void (*messageln) (const int fd, const char* mes);

 void (*messages) (const int fd, const char *mes, ...) __attribute__((format(printf, 2, 3)));
 
# 859 "../../../server-code/src/map/clif.h" 3 4
_Bool 
# 859 "../../../server-code/src/map/clif.h"
     (*process_message) (struct map_session_data *sd, int format, const char **name_, size_t *namelen_, const char **message_, size_t *messagelen_);
 void (*wisexin) (struct map_session_data *sd,int type,int flag);
 void (*wisall) (struct map_session_data *sd,int type,int flag);
 void (*PMIgnoreList) (struct map_session_data* sd);
 void (*ShowScript) (struct block_list* bl, const char* message);

 void (*traderequest) (struct map_session_data* sd, const char* name);
 void (*tradestart) (struct map_session_data* sd, uint8 type);
 void (*tradeadditem) (struct map_session_data* sd, struct map_session_data* tsd, int index, int amount);
 void (*tradeitemok) (struct map_session_data* sd, int index, int fail);
 void (*tradedeal_lock) (struct map_session_data* sd, int fail);
 void (*tradecancelled) (struct map_session_data* sd);
 void (*tradecompleted) (struct map_session_data* sd, int fail);
 void (*tradeundo) (struct map_session_data* sd);

 void (*openvendingreq) (struct map_session_data* sd, int num);
 void (*showvendingboard) (struct block_list* bl, const char* message, int fd);
 void (*closevendingboard) (struct block_list* bl, int fd);
 void (*vendinglist) (struct map_session_data* sd, unsigned int id, struct s_vending* vending_list);
 void (*buyvending) (struct map_session_data* sd, int index, int amount, int fail);
 void (*openvending) (struct map_session_data* sd, int id, struct s_vending* vending_list);
 void (*vendingreport) (struct map_session_data* sd, int index, int amount);

 void (*storagelist) (struct map_session_data* sd, struct item* items, int items_length);
 void (*updatestorageamount) (struct map_session_data* sd, int amount, int max_amount);
 void (*storageitemadded) (struct map_session_data* sd, struct item* i, int index, int amount);
 void (*storageitemremoved) (struct map_session_data* sd, int index, int amount);
 void (*storageclose) (struct map_session_data* sd);

 void (*skillinfoblock) (struct map_session_data *sd);
 void (*skillup) (struct map_session_data *sd, uint16 skill_id, int skill_lv, int flag);
 void (*skillinfo) (struct map_session_data *sd,int skill_id, int inf);
 void (*addskill) (struct map_session_data *sd, int id);
 void (*deleteskill) (struct map_session_data *sd, int id);

 void (*party_created) (struct map_session_data *sd,int result);
 void (*party_member_info) (struct party_data *p, struct map_session_data *sd);
 void (*party_info) (struct party_data* p, struct map_session_data *sd);
 void (*party_invite) (struct map_session_data *sd,struct map_session_data *tsd);
 void (*party_inviteack) (struct map_session_data* sd, const char* nick, int result);
 void (*party_option) (struct party_data *p,struct map_session_data *sd,int flag);
 void (*party_withdraw) (struct party_data* p, struct map_session_data* sd, int account_id, const char* name, int flag);
 void (*party_message) (struct party_data* p, int account_id, const char* mes, int len);
 void (*party_xy) (struct map_session_data *sd);
 void (*party_xy_single) (int fd, struct map_session_data *sd);
 void (*party_hp) (struct map_session_data *sd);
 void (*party_xy_remove) (struct map_session_data *sd);
 void (*party_show_picker) (struct map_session_data * sd, struct item * item_data);
 void (*partyinvitationstate) (struct map_session_data* sd);
 void (*PartyLeaderChanged) (struct map_session_data *sd, int prev_leader_aid, int new_leader_aid);

 void (*guild_created) (struct map_session_data *sd,int flag);
 void (*guild_belonginfo) (struct map_session_data *sd, struct guild *g);
 void (*guild_masterormember) (struct map_session_data *sd);
 void (*guild_basicinfo) (struct map_session_data *sd);
 void (*guild_allianceinfo) (struct map_session_data *sd);
 void (*guild_memberlist) (struct map_session_data *sd);
 void (*guild_skillinfo) (struct map_session_data* sd);
 void (*guild_send_onlineinfo) (struct map_session_data *sd);
 void (*guild_memberlogin_notice) (struct guild *g,int idx,int flag);
 void (*guild_invite) (struct map_session_data *sd,struct guild *g);
 void (*guild_inviteack) (struct map_session_data *sd,int flag);
 void (*guild_leave) (struct map_session_data *sd,const char *name,const char *mes);
 void (*guild_expulsion) (struct map_session_data* sd, const char* name, const char* mes, int account_id);
 void (*guild_positionchanged) (struct guild *g,int idx);
 void (*guild_memberpositionchanged) (struct guild *g,int idx);
 void (*guild_emblem) (struct map_session_data *sd,struct guild *g);
 void (*guild_emblem_area) (struct block_list* bl);
 void (*guild_notice) (struct map_session_data* sd, struct guild* g);
 void (*guild_message) (struct guild *g,int account_id,const char *mes,int len);
 void (*guild_reqalliance) (struct map_session_data *sd,int account_id,const char *name);
 void (*guild_allianceack) (struct map_session_data *sd,int flag);
 void (*guild_delalliance) (struct map_session_data *sd,int guild_id,int flag);
 void (*guild_oppositionack) (struct map_session_data *sd,int flag);
 void (*guild_broken) (struct map_session_data *sd,int flag);
 void (*guild_xy) (struct map_session_data *sd);
 void (*guild_xy_single) (int fd, struct map_session_data *sd);
 void (*guild_xy_remove) (struct map_session_data *sd);
 void (*guild_positionnamelist) (struct map_session_data *sd);
 void (*guild_positioninfolist) (struct map_session_data *sd);
 void (*guild_expulsionlist) (struct map_session_data* sd);
 
# 940 "../../../server-code/src/map/clif.h" 3 4
_Bool 
# 940 "../../../server-code/src/map/clif.h"
     (*validate_emblem) (const uint8* emblem, unsigned long emblem_len);

 void (*bg_hp) (struct map_session_data *sd);
 void (*bg_xy) (struct map_session_data *sd);
 void (*bg_xy_remove) (struct map_session_data *sd);
 void (*bg_message) (struct battleground_data *bgd, int src_id, const char *name, const char *mes, size_t len);
 void (*bg_updatescore) (int16 m);
 void (*bg_updatescore_single) (struct map_session_data *sd);
 void (*sendbgemblem_area) (struct map_session_data *sd);
 void (*sendbgemblem_single) (int fd, struct map_session_data *sd);

 int (*instance) (int instance_id, int type, int flag);
 void (*instance_join) (int fd, int instance_id);
 void (*instance_leave) (int fd);

 void (*catch_process) (struct map_session_data *sd);
 void (*pet_roulette) (struct map_session_data *sd,int data);
 void (*sendegg) (struct map_session_data *sd);
 void (*send_petstatus) (struct map_session_data *sd);
 void (*send_petdata) (struct map_session_data* sd, struct pet_data* pd, int type, int param);
 void (*pet_emotion) (struct pet_data *pd,int param);
 void (*pet_food) (struct map_session_data *sd,int foodid,int fail);

 int (*friendslist_toggle_sub) (struct map_session_data *sd,va_list ap);
 void (*friendslist_send) (struct map_session_data *sd);
 void (*friendslist_reqack) (struct map_session_data *sd, struct map_session_data *f_sd, int type);
 void (*friendslist_toggle) (struct map_session_data *sd,int account_id, int char_id, int online);
 void (*friendlist_req) (struct map_session_data* sd, int account_id, int char_id, const char* name);

 void (*GM_kickack) (struct map_session_data *sd, int result);
 void (*GM_kick) (struct map_session_data *sd,struct map_session_data *tsd);
 void (*manner_message) (struct map_session_data* sd, uint32 type);
 void (*GM_silence) (struct map_session_data* sd, struct map_session_data* tsd, uint8 type);
 void (*account_name) (struct map_session_data* sd, int account_id, const char* accname);
 void (*check) (int fd, struct map_session_data* pl_sd);

 void (*hominfo) (struct map_session_data *sd, struct homun_data *hd, int flag);
 void (*homskillinfoblock) (struct map_session_data *sd);
 void (*homskillup) (struct map_session_data *sd, uint16 skill_id);
 void (*hom_food) (struct map_session_data *sd,int foodid,int fail);
 void (*send_homdata) (struct map_session_data *sd, int state, int param);

 void (*quest_send_list) (struct map_session_data *sd);
 void (*quest_send_mission) (struct map_session_data *sd);
 void (*quest_add) (struct map_session_data *sd, struct quest *qd);
 void (*quest_delete) (struct map_session_data *sd, int quest_id);
 void (*quest_update_status) (struct map_session_data *sd, int quest_id, 
# 986 "../../../server-code/src/map/clif.h" 3 4
                                                                        _Bool 
# 986 "../../../server-code/src/map/clif.h"
                                                                             active);
 void (*quest_update_objective) (struct map_session_data *sd, struct quest *qd);
 void (*quest_show_event) (struct map_session_data *sd, struct block_list *bl, short state, short color);

 void (*mail_window) (int fd, int flag);
 void (*mail_read) (struct map_session_data *sd, int mail_id);
 void (*mail_delete) (int fd, int mail_id, short fail);
 void (*mail_return) (int fd, int mail_id, short fail);
 void (*mail_send) (int fd, 
# 994 "../../../server-code/src/map/clif.h" 3 4
                           _Bool 
# 994 "../../../server-code/src/map/clif.h"
                                fail);
 void (*mail_new) (int fd, int mail_id, const char *sender, const char *title);
 void (*mail_refreshinbox) (struct map_session_data *sd);
 void (*mail_getattachment) (int fd, uint8 flag);
 void (*mail_setattachment) (int fd, int index, uint8 flag);

 void (*auction_openwindow) (struct map_session_data *sd);
 void (*auction_results) (struct map_session_data *sd, short count, short pages, const uint8 *buf);
 void (*auction_message) (int fd, unsigned char flag);
 void (*auction_close) (int fd, unsigned char flag);
 void (*auction_setitem) (int fd, int index, 
# 1004 "../../../server-code/src/map/clif.h" 3 4
                                            _Bool 
# 1004 "../../../server-code/src/map/clif.h"
                                                 fail);

 void (*mercenary_info) (struct map_session_data *sd);
 void (*mercenary_skillblock) (struct map_session_data *sd);
 void (*mercenary_message) (struct map_session_data* sd, int message);
 void (*mercenary_updatestatus) (struct map_session_data *sd, int type);

 void (*rental_time) (int fd, int nameid, int seconds);
 void (*rental_expired) (int fd, int index, int nameid);

 void (*PartyBookingRegisterAck) (struct map_session_data *sd, int flag);
 void (*PartyBookingDeleteAck) (struct map_session_data* sd, int flag);
 void (*PartyBookingSearchAck) (int fd, struct party_booking_ad_info** results, int count, 
# 1016 "../../../server-code/src/map/clif.h" 3 4
                                                                                          _Bool 
# 1016 "../../../server-code/src/map/clif.h"
                                                                                               more_result);
 void (*PartyBookingUpdateNotify) (struct map_session_data* sd, struct party_booking_ad_info* pb_ad);
 void (*PartyBookingDeleteNotify) (struct map_session_data* sd, int index);
 void (*PartyBookingInsertNotify) (struct map_session_data* sd, struct party_booking_ad_info* pb_ad);
 void (*PartyRecruitRegisterAck) (struct map_session_data *sd, int flag);
 void (*PartyRecruitDeleteAck) (struct map_session_data* sd, int flag);
 void (*PartyRecruitSearchAck) (int fd, struct party_booking_ad_info** results, int count, 
# 1022 "../../../server-code/src/map/clif.h" 3 4
                                                                                          _Bool 
# 1022 "../../../server-code/src/map/clif.h"
                                                                                               more_result);
 void (*PartyRecruitUpdateNotify) (struct map_session_data* sd, struct party_booking_ad_info* pb_ad);
 void (*PartyRecruitDeleteNotify) (struct map_session_data* sd, int index);
 void (*PartyRecruitInsertNotify) (struct map_session_data* sd, struct party_booking_ad_info* pb_ad);

 void (*PartyBookingVolunteerInfo) (int index, struct map_session_data *sd);
 void (*PartyBookingRefuseVolunteer) (unsigned int aid, struct map_session_data *sd);
 void (*PartyBookingCancelVolunteer) (int index, struct map_session_data *sd);
 void (*PartyBookingAddFilteringList) (int index, struct map_session_data *sd);
 void (*PartyBookingSubFilteringList) (int gid, struct map_session_data *sd);

 void (*buyingstore_open) (struct map_session_data* sd);
 void (*buyingstore_open_failed) (struct map_session_data* sd, unsigned short result, unsigned int weight);
 void (*buyingstore_myitemlist) (struct map_session_data* sd);
 void (*buyingstore_entry) (struct map_session_data* sd);
 void (*buyingstore_entry_single) (struct map_session_data* sd, struct map_session_data* pl_sd);
 void (*buyingstore_disappear_entry) (struct map_session_data* sd);
 void (*buyingstore_disappear_entry_single) (struct map_session_data* sd, struct map_session_data* pl_sd);
 void (*buyingstore_itemlist) (struct map_session_data* sd, struct map_session_data* pl_sd);
 void (*buyingstore_trade_failed_buyer) (struct map_session_data* sd, short result);
 void (*buyingstore_update_item) (struct map_session_data* sd, unsigned short nameid, unsigned short amount);
 void (*buyingstore_delete_item) (struct map_session_data* sd, short index, unsigned short amount, int price);
 void (*buyingstore_trade_failed_seller) (struct map_session_data* sd, short result, unsigned short nameid);

 void (*search_store_info_ack) (struct map_session_data* sd);
 void (*search_store_info_failed) (struct map_session_data* sd, unsigned char reason);
 void (*open_search_store_info) (struct map_session_data* sd);
 void (*search_store_info_click_ack) (struct map_session_data* sd, short x, short y);

 void (*elemental_info) (struct map_session_data *sd);
 void (*elemental_updatestatus) (struct map_session_data *sd, int type);

 void (*bgqueue_ack) (struct map_session_data *sd, enum BATTLEGROUNDS_QUEUE_ACK response, unsigned char arena_id);
 void (*bgqueue_notice_delete) (struct map_session_data *sd, enum BATTLEGROUNDS_QUEUE_NOTICE_DELETED response, const char *name);
 void (*bgqueue_update_info) (struct map_session_data *sd, unsigned char arena_id, int position);
 void (*bgqueue_joined) (struct map_session_data *sd, int pos);
 void (*bgqueue_pcleft) (struct map_session_data *sd);
 void (*bgqueue_battlebegins) (struct map_session_data *sd, unsigned char arena_id, enum send_target target);

 void (*adopt_reply) (struct map_session_data *sd, int type);
 void (*adopt_request) (struct map_session_data *sd, struct map_session_data *src, int p_id);
 void (*readbook) (int fd, int book_id, int page);
 void (*notify_time) (struct map_session_data* sd, int64 time);
 void (*user_count) (struct map_session_data* sd, int count);
 void (*noask_sub) (struct map_session_data *src, struct map_session_data *target, int type);
 void (*bc_ready) (void);

 void (*channel_msg) (struct channel_data *chan, struct map_session_data *sd, char *msg);
 void (*channel_msg2) (struct channel_data *chan, char *msg);
 int (*undisguise_timer) (int tid, int64 tick, int id, intptr_t data);

 void (*bank_deposit) (struct map_session_data *sd, enum e_BANKING_DEPOSIT_ACK reason);
 void (*bank_withdraw) (struct map_session_data *sd,enum e_BANKING_WITHDRAW_ACK reason);

 void (*show_modifiers) (struct map_session_data *sd);

 void (*notify_bounditem) (struct map_session_data *sd, unsigned short index);

 int (*delay_damage) (int64 tick, struct block_list *src, struct block_list *dst, int sdelay, int ddelay, int64 in_damage, short div, unsigned char type);
 int (*delay_damage_sub) (int tid, int64 tick, int id, intptr_t data);

 void (*npc_market_open) (struct map_session_data *sd, struct npc_data *nd);
 void (*npc_market_purchase_ack) (struct map_session_data *sd, const struct itemlist *item_list, unsigned char response);

 
# 1086 "../../../server-code/src/map/clif.h" 3 4
_Bool 
# 1086 "../../../server-code/src/map/clif.h"
     (*parse_roulette_db) (void);
 void (*roulette_generate_ack) (struct map_session_data *sd, unsigned char result, short stage, short prizeIdx, short bonusItemID);

 void (*openmergeitem) (int fd, struct map_session_data *sd);
 void (*cancelmergeitem) (int fd, struct map_session_data *sd);
 int (*comparemergeitem) (const void *a, const void *b);
 void (*ackmergeitems) (int fd, struct map_session_data *sd);




 void (*pWantToConnection) (int fd, struct map_session_data *sd);
 void (*pLoadEndAck) (int fd,struct map_session_data *sd);
 void (*pTickSend) (int fd, struct map_session_data *sd);
 void (*pHotkey) (int fd, struct map_session_data *sd);
 void (*pProgressbar) (int fd, struct map_session_data * sd);
 void (*pWalkToXY) (int fd, struct map_session_data *sd);
 void (*pQuitGame) (int fd, struct map_session_data *sd);
 void (*pGetCharNameRequest) (int fd, struct map_session_data *sd);
 void (*pGlobalMessage) (int fd, struct map_session_data* sd);
 void (*pMapMove) (int fd, struct map_session_data *sd);
 void (*pChangeDir) (int fd, struct map_session_data *sd);
 void (*pEmotion) (int fd, struct map_session_data *sd);
 void (*pHowManyConnections) (int fd, struct map_session_data *sd);
 void (*pActionRequest) (int fd, struct map_session_data *sd);
 void (*pActionRequest_sub) (struct map_session_data *sd, int action_type, int target_id, int64 tick);
 void (*pRestart) (int fd, struct map_session_data *sd);
 void (*pWisMessage) (int fd, struct map_session_data* sd);
 void (*pBroadcast) (int fd, struct map_session_data* sd);
 void (*pTakeItem) (int fd, struct map_session_data *sd);
 void (*pDropItem) (int fd, struct map_session_data *sd);
 void (*pUseItem) (int fd, struct map_session_data *sd);
 void (*pEquipItem) (int fd,struct map_session_data *sd);
 void (*pUnequipItem) (int fd,struct map_session_data *sd);
 void (*pNpcClicked) (int fd,struct map_session_data *sd);
 void (*pNpcBuySellSelected) (int fd,struct map_session_data *sd);
 void (*pNpcBuyListSend) (int fd, struct map_session_data* sd);
 void (*pNpcSellListSend) (int fd,struct map_session_data *sd);
 void (*pCreateChatRoom) (int fd, struct map_session_data* sd);
 void (*pChatAddMember) (int fd, struct map_session_data* sd);
 void (*pChatRoomStatusChange) (int fd, struct map_session_data* sd);
 void (*pChangeChatOwner) (int fd, struct map_session_data* sd);
 void (*pKickFromChat) (int fd,struct map_session_data *sd);
 void (*pChatLeave) (int fd, struct map_session_data* sd);
 void (*pTradeRequest) (int fd,struct map_session_data *sd);
 void (*pTradeAck) (int fd,struct map_session_data *sd);
 void (*pTradeAddItem) (int fd,struct map_session_data *sd);
 void (*pTradeOk) (int fd,struct map_session_data *sd);
 void (*pTradeCancel) (int fd,struct map_session_data *sd);
 void (*pTradeCommit) (int fd,struct map_session_data *sd);
 void (*pStopAttack) (int fd,struct map_session_data *sd);
 void (*pPutItemToCart) (int fd,struct map_session_data *sd);
 void (*pGetItemFromCart) (int fd,struct map_session_data *sd);
 void (*pRemoveOption) (int fd,struct map_session_data *sd);
 void (*pChangeCart) (int fd,struct map_session_data *sd);
 void (*pStatusUp) (int fd,struct map_session_data *sd);
 void (*pSkillUp) (int fd,struct map_session_data *sd);
 void (*pUseSkillToId) (int fd, struct map_session_data *sd);
 void (*pUseSkillToId_homun) (struct homun_data *hd, struct map_session_data *sd, int64 tick, uint16 skill_id, uint16 skill_lv, int target_id);
 void (*pUseSkillToId_mercenary) (struct mercenary_data *md, struct map_session_data *sd, int64 tick, uint16 skill_id, uint16 skill_lv, int target_id);
 void (*pUseSkillToPos) (int fd, struct map_session_data *sd);
 void (*pUseSkillToPosSub) (int fd, struct map_session_data *sd, uint16 skill_lv, uint16 skill_id, short x, short y, int skillmoreinfo);
 void (*pUseSkillToPos_homun) (struct homun_data *hd, struct map_session_data *sd, int64 tick, uint16 skill_id, uint16 skill_lv, short x, short y, int skillmoreinfo);
 void (*pUseSkillToPos_mercenary) (struct mercenary_data *md, struct map_session_data *sd, int64 tick, uint16 skill_id, uint16 skill_lv, short x, short y, int skillmoreinfo);
 void (*pUseSkillToPosMoreInfo) (int fd, struct map_session_data *sd);
 void (*pUseSkillMap) (int fd, struct map_session_data* sd);
 void (*pRequestMemo) (int fd,struct map_session_data *sd);
 void (*pProduceMix) (int fd,struct map_session_data *sd);
 void (*pCooking) (int fd,struct map_session_data *sd);
 void (*pRepairItem) (int fd, struct map_session_data *sd);
 void (*pWeaponRefine) (int fd, struct map_session_data *sd);
 void (*pNpcSelectMenu) (int fd,struct map_session_data *sd);
 void (*pNpcNextClicked) (int fd,struct map_session_data *sd);
 void (*pNpcAmountInput) (int fd,struct map_session_data *sd);
 void (*pNpcStringInput) (int fd, struct map_session_data* sd);
 void (*pNpcCloseClicked) (int fd,struct map_session_data *sd);
 void (*pItemIdentify) (int fd,struct map_session_data *sd);
 void (*pSelectArrow) (int fd,struct map_session_data *sd);
 void (*pAutoSpell) (int fd,struct map_session_data *sd);
 void (*pUseCard) (int fd,struct map_session_data *sd);
 void (*pInsertCard) (int fd,struct map_session_data *sd);
 void (*pSolveCharName) (int fd, struct map_session_data *sd);
 void (*pResetChar) (int fd, struct map_session_data *sd);
 void (*pLocalBroadcast) (int fd, struct map_session_data* sd);
 void (*pMoveToKafra) (int fd, struct map_session_data *sd);
 void (*pMoveFromKafra) (int fd,struct map_session_data *sd);
 void (*pMoveToKafraFromCart) (int fd, struct map_session_data *sd);
 void (*pMoveFromKafraToCart) (int fd, struct map_session_data *sd);
 void (*pCloseKafra) (int fd, struct map_session_data *sd);
 void (*pStoragePassword) (int fd, struct map_session_data *sd);
 void (*pCreateParty) (int fd, struct map_session_data *sd);
 void (*pCreateParty2) (int fd, struct map_session_data *sd);
 void (*pPartyInvite) (int fd, struct map_session_data *sd);
 void (*pPartyInvite2) (int fd, struct map_session_data *sd);
 void (*pReplyPartyInvite) (int fd,struct map_session_data *sd);
 void (*pReplyPartyInvite2) (int fd,struct map_session_data *sd);
 void (*pLeaveParty) (int fd, struct map_session_data *sd);
 void (*pRemovePartyMember) (int fd, struct map_session_data *sd);
 void (*pPartyChangeOption) (int fd, struct map_session_data *sd);
 void (*pPartyMessage) (int fd, struct map_session_data* sd);
 void (*pPartyChangeLeader) (int fd, struct map_session_data* sd);
 void (*pPartyBookingRegisterReq) (int fd, struct map_session_data* sd);
 void (*pPartyBookingSearchReq) (int fd, struct map_session_data* sd);
 void (*pPartyBookingDeleteReq) (int fd, struct map_session_data* sd);
 void (*pPartyBookingUpdateReq) (int fd, struct map_session_data* sd);
 void (*pPartyRecruitRegisterReq) (int fd, struct map_session_data* sd);
 void (*pPartyRecruitSearchReq) (int fd, struct map_session_data* sd);
 void (*pPartyRecruitDeleteReq) (int fd, struct map_session_data* sd);
 void (*pPartyRecruitUpdateReq) (int fd, struct map_session_data* sd);
 void (*pCloseVending) (int fd, struct map_session_data* sd);
 void (*pVendingListReq) (int fd, struct map_session_data* sd);
 void (*pPurchaseReq) (int fd, struct map_session_data* sd);
 void (*pPurchaseReq2) (int fd, struct map_session_data* sd);
 void (*pOpenVending) (int fd, struct map_session_data* sd);
 void (*pCreateGuild) (int fd,struct map_session_data *sd);
 void (*pGuildCheckMaster) (int fd, struct map_session_data *sd);
 void (*pGuildRequestInfo) (int fd, struct map_session_data *sd);
 void (*pGuildChangePositionInfo) (int fd, struct map_session_data *sd);
 void (*pGuildChangeMemberPosition) (int fd, struct map_session_data *sd);
 void (*pGuildRequestEmblem) (int fd,struct map_session_data *sd);
 void (*pGuildChangeEmblem) (int fd,struct map_session_data *sd);
 void (*pGuildChangeNotice) (int fd, struct map_session_data* sd);
 void (*pGuildInvite) (int fd,struct map_session_data *sd);
 void (*pGuildReplyInvite) (int fd,struct map_session_data *sd);
 void (*pGuildLeave) (int fd,struct map_session_data *sd);
 void (*pGuildExpulsion) (int fd,struct map_session_data *sd);
 void (*pGuildMessage) (int fd, struct map_session_data* sd);
 void (*pGuildRequestAlliance) (int fd, struct map_session_data *sd);
 void (*pGuildReplyAlliance) (int fd, struct map_session_data *sd);
 void (*pGuildDelAlliance) (int fd, struct map_session_data *sd);
 void (*pGuildOpposition) (int fd, struct map_session_data *sd);
 void (*pGuildBreak) (int fd, struct map_session_data *sd);
 void (*pPetMenu) (int fd, struct map_session_data *sd);
 void (*pCatchPet) (int fd, struct map_session_data *sd);
 void (*pSelectEgg) (int fd, struct map_session_data *sd);
 void (*pSendEmotion) (int fd, struct map_session_data *sd);
 void (*pChangePetName) (int fd, struct map_session_data *sd);
 void (*pGMKick) (int fd, struct map_session_data *sd);
 void (*pGMKickAll) (int fd, struct map_session_data* sd);
 void (*pGMShift) (int fd, struct map_session_data *sd);
 void (*pGMRemove2) (int fd, struct map_session_data* sd);
 void (*pGMRecall) (int fd, struct map_session_data *sd);
 void (*pGMRecall2) (int fd, struct map_session_data* sd);
 void (*pGM_Monster_Item) (int fd, struct map_session_data *sd);
 void (*pGMHide) (int fd, struct map_session_data *sd);
 void (*pGMReqNoChat) (int fd,struct map_session_data *sd);
 void (*pGMRc) (int fd, struct map_session_data* sd);
 void (*pGMReqAccountName) (int fd, struct map_session_data *sd);
 void (*pGMChangeMapType) (int fd, struct map_session_data *sd);
 void (*pGMFullStrip) (int fd, struct map_session_data *sd);
 void (*pPMIgnore) (int fd, struct map_session_data* sd);
 void (*pPMIgnoreAll) (int fd, struct map_session_data *sd);
 void (*pPMIgnoreList) (int fd,struct map_session_data *sd);
 void (*pNoviceDoriDori) (int fd, struct map_session_data *sd);
 void (*pNoviceExplosionSpirits) (int fd, struct map_session_data *sd);
 void (*pFriendsListAdd) (int fd, struct map_session_data *sd);
 void (*pFriendsListReply) (int fd, struct map_session_data *sd);
 void (*pFriendsListRemove) (int fd, struct map_session_data *sd);
 void (*pPVPInfo) (int fd,struct map_session_data *sd);
 void (*pBlacksmith) (int fd,struct map_session_data *sd);
 void (*pAlchemist) (int fd,struct map_session_data *sd);
 void (*pTaekwon) (int fd,struct map_session_data *sd);
 void (*pRankingPk) (int fd,struct map_session_data *sd);
 void (*pFeelSaveOk) (int fd,struct map_session_data *sd);
 void (*pChangeHomunculusName) (int fd, struct map_session_data *sd);
 void (*pHomMoveToMaster) (int fd, struct map_session_data *sd);
 void (*pHomMoveTo) (int fd, struct map_session_data *sd);
 void (*pHomAttack) (int fd,struct map_session_data *sd);
 void (*pHomMenu) (int fd, struct map_session_data *sd);
 void (*pAutoRevive) (int fd, struct map_session_data *sd);
 void (*pCheck) (int fd, struct map_session_data *sd);
 void (*pMail_refreshinbox) (int fd, struct map_session_data *sd);
 void (*pMail_read) (int fd, struct map_session_data *sd);
 void (*pMail_getattach) (int fd, struct map_session_data *sd);
 void (*pMail_delete) (int fd, struct map_session_data *sd);
 void (*pMail_return) (int fd, struct map_session_data *sd);
 void (*pMail_setattach) (int fd, struct map_session_data *sd);
 void (*pMail_winopen) (int fd, struct map_session_data *sd);
 void (*pMail_send) (int fd, struct map_session_data *sd);
 void (*pAuction_cancelreg) (int fd, struct map_session_data *sd);
 void (*pAuction_setitem) (int fd, struct map_session_data *sd);
 void (*pAuction_register) (int fd, struct map_session_data *sd);
 void (*pAuction_cancel) (int fd, struct map_session_data *sd);
 void (*pAuction_close) (int fd, struct map_session_data *sd);
 void (*pAuction_bid) (int fd, struct map_session_data *sd);
 void (*pAuction_search) (int fd, struct map_session_data* sd);
 void (*pAuction_buysell) (int fd, struct map_session_data* sd);
 void (*pcashshop_buy) (int fd, struct map_session_data *sd);
 void (*pAdopt_request) (int fd, struct map_session_data *sd);
 void (*pAdopt_reply) (int fd, struct map_session_data *sd);
 void (*pViewPlayerEquip) (int fd, struct map_session_data* sd);
 void (*pEquipTick) (int fd, struct map_session_data* sd);
 void (*pquestStateAck) (int fd, struct map_session_data * sd);
 void (*pmercenary_action) (int fd, struct map_session_data* sd);
 void (*pBattleChat) (int fd, struct map_session_data* sd);
 void (*pLessEffect) (int fd, struct map_session_data* sd);
 void (*pItemListWindowSelected) (int fd, struct map_session_data* sd);
 void (*pReqOpenBuyingStore) (int fd, struct map_session_data* sd);
 void (*pReqCloseBuyingStore) (int fd, struct map_session_data* sd);
 void (*pReqClickBuyingStore) (int fd, struct map_session_data* sd);
 void (*pReqTradeBuyingStore) (int fd, struct map_session_data* sd);
 void (*pSearchStoreInfo) (int fd, struct map_session_data* sd);
 void (*pSearchStoreInfoNextPage) (int fd, struct map_session_data* sd);
 void (*pCloseSearchStoreInfo) (int fd, struct map_session_data* sd);
 void (*pSearchStoreInfoListItemClick) (int fd, struct map_session_data* sd);
 void (*pDebug) (int fd,struct map_session_data *sd);
 void (*pSkillSelectMenu) (int fd, struct map_session_data *sd);
 void (*pMoveItem) (int fd, struct map_session_data *sd);
 void (*pDull) (int fd, struct map_session_data *sd);

 void (*pBGQueueRegister) (int fd, struct map_session_data *sd);
 void (*pBGQueueCheckState) (int fd, struct map_session_data *sd);
 void (*pBGQueueRevokeReq) (int fd, struct map_session_data *sd);
 void (*pBGQueueBattleBeginAck) (int fd, struct map_session_data *sd);

 void (*pCashShopOpen) (int fd, struct map_session_data *sd);
 void (*pCashShopClose) (int fd, struct map_session_data *sd);
 void (*pCashShopReqTab) (int fd, struct map_session_data *sd);
 void (*pCashShopSchedule) (int fd, struct map_session_data *sd);
 void (*pCashShopBuy) (int fd, struct map_session_data *sd);
 void (*pPartyTick) (int fd, struct map_session_data *sd);
 void (*pGuildInvite2) (int fd, struct map_session_data *sd);

 void (*pPartyBookingAddFilter) (int fd, struct map_session_data *sd);
 void (*pPartyBookingSubFilter) (int fd, struct map_session_data *sd);
 void (*pPartyBookingReqVolunteer) (int fd, struct map_session_data *sd);
 void (*pPartyBookingRefuseVolunteer) (int fd, struct map_session_data *sd);
 void (*pPartyBookingCancelVolunteer) (int fd, struct map_session_data *sd);

 void (*pBankDeposit) (int fd, struct map_session_data *sd);
 void (*pBankWithdraw) (int fd, struct map_session_data *sd);
 void (*pBankCheck) (int fd, struct map_session_data *sd);
 void (*pBankOpen) (int fd, struct map_session_data *sd);
 void (*pBankClose) (int fd, struct map_session_data *sd);

 void (*pRouletteOpen) (int fd, struct map_session_data *sd);
 void (*pRouletteInfo) (int fd, struct map_session_data *sd);
 void (*pRouletteClose) (int fd, struct map_session_data *sd);
 void (*pRouletteGenerate) (int fd, struct map_session_data *sd);
 void (*pRouletteRecvItem) (int fd, struct map_session_data *sd);

 void (*pNPCShopClosed) (int fd, struct map_session_data *sd);

 void (*pNPCMarketClosed) (int fd, struct map_session_data *sd);
 void (*pNPCMarketPurchase) (int fd, struct map_session_data *sd);

 void (*add_random_options) (unsigned char* buf, struct item* item);
 void (*pHotkeyRowShift) (int fd, struct map_session_data *sd);
 void (*dressroom_open) (struct map_session_data *sd, int view);
 void (*pOneClick_ItemIdentify) (int fd,struct map_session_data *sd);

 void (*selectcart) (struct map_session_data *sd);
 void (*pSelectCart) (int fd, struct map_session_data *sd);

 const char *(*get_bl_name) (const struct block_list *bl);
};


void clif_defaults(void);


extern struct clif_interface *clif;
# 25 "../../../server-code/src/map/clif.c" 2


# 1 "../../../server-code/src/map/battle.h" 1
# 30 "../../../server-code/src/map/battle.h"
struct map_session_data;
struct mob_data;
struct block_list;
struct weapon_atk;
struct status_change;
struct status_data;
# 55 "../../../server-code/src/map/battle.h"
enum {

 BF_WEAPON = 0x0001,
 BF_MAGIC = 0x0002,
 BF_MISC = 0x0004,
 BF_SHORT = 0x0010,
 BF_LONG = 0x0040,
 BF_SKILL = 0x0100,
 BF_NORMAL = 0x0200,
 BF_WEAPONMASK = 0x000f,
 BF_RANGEMASK = 0x00f0,
 BF_SKILLMASK = 0x0f00,
};


typedef enum damage_lv {
 ATK_NONE,
 ATK_LUCKY,
 ATK_FLEE,
 ATK_MISS,
 ATK_BLOCK,
 ATK_DEF
} damage_lv;

enum e_battle_check_target {
 BCT_NOONE = 0x000000,
 BCT_SELF = 0x010000,
 BCT_ENEMY = 0x020000,
 BCT_PARTY = 0x040000,
 BCT_GUILDALLY = 0x080000,
 BCT_NEUTRAL = 0x100000,
 BCT_SAMEGUILD = 0x200000,

 BCT_GUILD = 0x280000,

 BCT_NOGUILD = 0x170000,
 BCT_NOPARTY = 0x3b0000,
 BCT_NOENEMY = 0x3d0000,

 BCT_ALL = 0x3f0000,
};






enum battle_dmg_type {
 BDT_NORMAL = 0,



 BDT_ENDURE = 4,
 BDT_SPLASH = 5,
 BDT_SKILL = 6,

 BDT_MULTIHIT = 8,
 BDT_MULTIENDURE = 9,
 BDT_CRIT = 10,
 BDT_PDODGE = 11,

};






struct Damage {
 int64 damage,damage2;
 int type,div_;
 int amotion,dmotion;
 int blewcount;
 int flag;
 enum damage_lv dmg_lv;
};

struct Battle_Config {
 int warp_point_debug;
 int enable_critical;
 int mob_critical_rate;
 int critical_rate;
 int enable_baseatk;
 int enable_perfect_flee;
 int cast_rate, delay_rate;
 int delay_dependon_dex, delay_dependon_agi;
 int sdelay_attack_enable;
 int left_cardfix_to_right;
 int skill_add_range;
 int skill_out_range_consume;
 int skill_amotion_leniency;
 int skillrange_by_distance;
 int use_weapon_skill_range;
 int pc_damage_delay_rate;
 int defnotenemy;
 int vs_traps_bctall;
 int traps_setting;
 int summon_flora;
 int clear_unit_ondeath;
 int clear_unit_onwarp;
 int random_monster_checklv;
 int attr_recover;
 int item_auto_get;
 int flooritem_lifetime;
 int item_first_get_time;
 int item_second_get_time;
 int item_third_get_time;
 int mvp_item_first_get_time;
 int mvp_item_second_get_time;
 int mvp_item_third_get_time;
 int base_exp_rate,job_exp_rate;
 int drop_rate0item;
 int death_penalty_type;
 int death_penalty_base,death_penalty_job;
 int pvp_exp;
 int gtb_sc_immunity;
 int zeny_penalty;
 int restart_hp_rate;
 int restart_sp_rate;
 int mvp_exp_rate;
 int mvp_hp_rate;
 int monster_hp_rate;
 int monster_max_aspd;
 int view_range_rate;
 int chase_range_rate;
 int atc_spawn_quantity_limit;
 int atc_slave_clone_limit;
 int partial_name_scan;
 int skillfree;
 int skillup_limit;
 int wp_rate;
 int pp_rate;
 int monster_active_enable;
 int monster_damage_delay_rate;
 int monster_loot_type;
 int mob_skill_rate;
 int mob_skill_delay;
 int mob_count_rate;
 int no_spawn_on_player;
 int force_random_spawn;
 int mob_spawn_delay, plant_spawn_delay, boss_spawn_delay;
 int slaves_inherit_mode;
 int slaves_inherit_speed;
 int summons_trigger_autospells;
 int pc_walk_delay_rate;
 int walk_delay_rate;
 int multihit_delay;
 int quest_skill_learn;
 int quest_skill_reset;
 int basic_skill_check;
 int guild_emperium_check;
 int guild_exp_limit;
 int guild_max_castles;
 int guild_skill_relog_delay;
 int emergency_call;
 int guild_aura;
 int pc_invincible_time;

 int pet_catch_rate;
 int pet_rename;
 int pet_friendly_rate;
 int pet_hungry_delay_rate;
 int pet_hungry_friendly_decrease;
 int pet_status_support;
 int pet_attack_support;
 int pet_damage_support;
 int pet_support_min_friendly;
 int pet_equip_min_friendly;
 int pet_support_rate;
 int pet_attack_exp_to_master;
 int pet_attack_exp_rate;
 int pet_lv_rate;
 int pet_max_stats;
 int pet_max_atk1;
 int pet_max_atk2;
 int pet_no_gvg;
 int pet_equip_required;

 int skill_min_damage;
 int finger_offensive_type;
 int heal_exp;
 int max_heal_lv;
 int max_heal;
 int resurrection_exp;
 int shop_exp;
 int combo_delay_rate;
 int item_check;
 int item_use_interval;
 int cashfood_use_interval;
 int wedding_modifydisplay;
 int wedding_ignorepalette;
 int xmas_ignorepalette;
 int summer_ignorepalette;
 int hanbok_ignorepalette;
 int natural_healhp_interval;
 int natural_healsp_interval;
 int natural_heal_skill_interval;
 int natural_heal_weight_rate;
 int arrow_decrement;
 int max_aspd;
 int max_walk_speed;
 int max_hp;
 int max_sp;
 int max_lv, aura_lv;
 int max_parameter, max_baby_parameter;
 int max_cart_weight;
 int skill_log;
 int battle_log;
 int etc_log;
 int save_clothcolor;
 int undead_detect_type;
 int auto_counter_type;
 int min_hitrate;
 int max_hitrate;
 int agi_penalty_target;
 int agi_penalty_type;
 int agi_penalty_count;
 int agi_penalty_num;
 int vit_penalty_target;
 int vit_penalty_type;
 int vit_penalty_count;
 int vit_penalty_num;
 int weapon_defense_type;
 int magic_defense_type;
 int skill_reiteration;
 int skill_nofootset;
 int pc_cloak_check_type;
 int monster_cloak_check_type;
 int estimation_type;
 int gvg_flee_penalty;
 int mob_changetarget_byskill;
 int attack_direction_change;
 int land_skill_limit;
 int monster_class_change_recover;
 int produce_item_name_input;
 int display_skill_fail;
 int chat_warpportal;
 int mob_warp;
 int dead_branch_active;
 int vending_max_value;
 int vending_over_max;
 int vending_tax;
 int show_steal_in_same_party;
 int party_share_type;
 int party_hp_mode;
 int party_show_share_picker;
 int show_picker_item_type;
 int attack_attr_none;
 int item_rate_mvp, item_rate_common, item_rate_common_boss, item_rate_card, item_rate_card_boss,
 item_rate_equip, item_rate_equip_boss, item_rate_heal, item_rate_heal_boss, item_rate_use,
 item_rate_use_boss, item_rate_treasure, item_rate_adddrop;

 int logarithmic_drops;
 int item_drop_common_min,item_drop_common_max;
 int item_drop_card_min,item_drop_card_max;
 int item_drop_equip_min,item_drop_equip_max;
 int item_drop_mvp_min,item_drop_mvp_max;
 int item_drop_heal_min,item_drop_heal_max;
 int item_drop_use_min,item_drop_use_max;
 int item_drop_treasure_min,item_drop_treasure_max;
 int item_drop_adddrop_min,item_drop_adddrop_max;

 int prevent_logout;

 int alchemist_summon_reward;
 int drops_by_luk;
 int drops_by_luk2;
 int equip_natural_break_rate;
 int equip_self_break_rate;
 int equip_skill_break_rate;
 int multi_level_up;
 int max_exp_gain_rate;
 int pk_mode;
 int pk_level_range;

 int manner_system;
 int show_mob_info;

 int gx_allhit;
 int gx_disptype;
 int devotion_level_difference;
 int player_skill_partner_check;
 int invite_request_check;
 int skill_removetrap_type;
 int disp_experience;
 int disp_zeny;
 int castle_defense_rate;
 int backstab_bow_penalty;
 int hp_rate;
 int sp_rate;
 int bone_drop;
 int buyer_name;
 int dancing_weaponswitch_fix;


 int night_at_start;
 int day_duration;
 int night_duration;
 int ban_hack_trade;

 int min_hair_style;
 int max_hair_style;
 int min_hair_color;
 int max_hair_color;
 int min_cloth_color;
 int max_cloth_color;
 int pet_hair_style;

 int castrate_dex_scale;
 int area_size;

 int max_def, over_def_bonus;

 int zeny_from_mobs;
 int mobs_level_up;
 int mobs_level_up_exp_rate;
 int pk_min_level;
 int skill_steal_max_tries;
 int exp_calc_type;
 int exp_bonus_attacker;
 int exp_bonus_max_attacker;
 int min_skill_delay_limit;
 int default_walk_delay;
 int no_skill_delay;
 int attack_walk_delay;
 int require_glory_guild;
 int idle_no_share;
 int party_update_interval;
 int party_even_share_bonus;
 int delay_battle_damage;
 int hide_woe_damage;
 int display_version;

 int display_hallucination;
 int use_statpoint_table;

 int ignore_items_gender;

 int copyskill_restrict;
 int berserk_cancels_buffs;
 int mob_ai;
 int hom_setting;
 int dynamic_mobs;
 int mob_remove_damaged;
 int mob_remove_delay;
 int mob_active_time;
 int boss_active_time;

 int show_hp_sp_drain, show_hp_sp_gain;
 int show_katar_crit_bonus;

 int mob_npc_event_type;

 int character_size;
 int rare_drop_announce;

 int retaliate_to_master;

 int duel_allow_pvp;
 int duel_allow_gvg;
 int duel_allow_teleport;
 int duel_autoleave_when_die;
 int duel_time_interval;
 int duel_only_on_same_map;

 int skip_teleport_lv1_menu;
 int mob_max_skilllvl;
 int allow_skill_without_day;
 int allow_es_magic_pc;
 int skill_wall_check;
 int official_cell_stack_limit;
 int custom_cell_stack_limit;
 int check_occupied_cells;
 int skill_caster_check;
 int sc_castcancel;
 int pc_sc_def_rate;
 int mob_sc_def_rate;
 int pc_max_sc_def;
 int mob_max_sc_def;

 int sg_angel_skill_ratio;
 int sg_miracle_skill_ratio;
 int sg_miracle_skill_duration;
 int autospell_stacking;
 int override_mob_names;
 int min_chat_delay;
 int friend_auto_add;
 int hvan_explosion_intimate;
 int hom_rename;
 int homunculus_show_growth;
 int homunculus_friendly_rate;
 int quest_exp_rate;
 int autotrade_mapflag;
 int at_timeout;
 int homunculus_autoloot;
 int idle_no_autoloot;
 int max_guild_alliance;
 int ksprotection;
 int auction_feeperhour;
 int auction_maximumprice;
 int homunculus_auto_vapor;
 int display_status_timers;
 int skill_add_heal_rate;
 int eq_single_target_reflectable;
 int invincible_nodamage;
 int mob_slave_keep_target;
 int autospell_check_range;
 int knockback_left;
 int client_reshuffle_dice;
 int client_sort_storage;
 int feature_buying_store;
 int feature_search_stores;
 int searchstore_querydelay;
 int searchstore_maxresults;
 int display_party_name;
 int cashshop_show_points;
 int mail_show_status;
 int client_limit_unit_lv;
 int client_emblem_max_blank_percent;
 int hom_max_level;
 int hom_S_max_level;


 int bg_update_interval;
 int bg_flee_penalty;


 int max_third_parameter;
 int max_baby_third_parameter;
 int max_extended_parameter;
 int atcommand_max_stat_bypass;
 int max_third_aspd;
 int vcast_stat_scale;

 int mvp_tomb_enabled;

 int atcommand_suggestions_enabled;
 int min_npc_vendchat_distance;
 int vendchat_near_hiddennpc;
 int atcommand_mobinfo_type;

 int mob_size_influence;
 int bowling_bash_area;
 int mob_chase_refresh;
 int mob_icewall_walk_block;
 int boss_icewall_walk_block;


 int skill_trap_type;
 int item_restricted_consumption_type;
 int unequip_restricted_equipment;
 int max_walk_path;
 int item_enabled_npc;
 int packet_obfuscation;
 int idletime_criteria;
 int gm_ignore_warpable_area;

 int client_accept_chatdori;
 int snovice_call_type;
 int guild_notice_changemap;

 int feature_banking;
 int feature_auction;

 int mon_trans_disable_in_gvg;

 int case_sensitive_aegisnames;
 int guild_castle_invite;
 int guild_castle_expulsion;

 int song_timer_reset;
 int snap_dodge;
 int stormgust_knockback;

 int feature_roulette;

 int show_monster_hp_bar;

 int fix_warp_hit_delay_abuse;


 int costume_refine_def, shadow_refine_def;
 int shadow_refine_atk;


 int min_body_style, max_body_style;
 int save_body_style;
};


enum e_battle_config_idletime {
 BCIDLE_WALK = 0x001,
 BCIDLE_USESKILLTOID = 0x002,
 BCIDLE_USESKILLTOPOS = 0x004,
 BCIDLE_USEITEM = 0x008,
 BCIDLE_ATTACK = 0x010,
 BCIDLE_CHAT = 0x020,
 BCIDLE_SIT = 0x040,
 BCIDLE_EMOTION = 0x080,
 BCIDLE_DROPITEM = 0x100,
 BCIDLE_ATCOMMAND = 0x200,
};


struct delay_damage {
 int src_id;
 int target_id;
 int64 damage;
 int delay;
 unsigned short distance;
 uint16 skill_lv;
 uint16 skill_id;
 enum damage_lv dmg_lv;
 unsigned short attack_type;
 
# 569 "../../../server-code/src/map/battle.h" 3 4
_Bool 
# 569 "../../../server-code/src/map/battle.h"
     additional_effects;
 enum bl_type src_type;
};




struct battle_interface {

 struct Battle_Config *bc;

 int attr_fix_table[4][ELE_MAX][ELE_MAX];
 struct eri *delay_damage_ers;

 void (*init) (
# 583 "../../../server-code/src/map/battle.h" 3 4
              _Bool 
# 583 "../../../server-code/src/map/battle.h"
                   minimal);

 void (*final) (void);

 struct Damage (*calc_attack) (int attack_type, struct block_list *bl, struct block_list *target, uint16 skill_id, uint16 skill_lv, int count);

 int64 (*calc_damage) (struct block_list *src, struct block_list *bl, struct Damage *d, int64 damage, uint16 skill_id, uint16 skill_lv);

 int64 (*calc_gvg_damage) (struct block_list *src, struct block_list *bl, int64 damage, int div_, uint16 skill_id, uint16 skill_lv, int flag);

 int64 (*calc_bg_damage) (struct block_list *src, struct block_list *bl, int64 damage, int div_, uint16 skill_id, uint16 skill_lv, int flag);

 enum damage_lv (*weapon_attack) (struct block_list *bl, struct block_list *target, int64 tick, int flag);

 struct Damage (*calc_weapon_attack) (struct block_list *src,struct block_list *target,uint16 skill_id,uint16 skill_lv,int wflag);

 int (*delay_damage) (int64 tick, int amotion, struct block_list *src, struct block_list *target, int attack_type, uint16 skill_id, uint16 skill_lv, int64 damage, enum damage_lv dmg_lv, int ddelay, 
# 599 "../../../server-code/src/map/battle.h" 3 4
                                                                                                                                                                                                     _Bool 
# 599 "../../../server-code/src/map/battle.h"
                                                                                                                                                                                                          additional_effects);

 void (*drain) (struct map_session_data *sd, struct block_list *tbl, int64 rdamage, int64 ldamage, int race, int boss);

 void (*reflect_damage) (struct block_list *target, struct block_list *src, struct Damage *wd,uint16 skill_id);

 int (*attr_ratio) (int atk_elem, int def_type, int def_lv);

 int64 (*attr_fix) (struct block_list *src, struct block_list *target, int64 damage, int atk_elem, int def_type, int def_lv);

 int64 (*calc_cardfix) (int attack_type, struct block_list *src, struct block_list *target, int nk, int s_ele, int s_ele_, int64 damage, int left, int flag);
 int64 (*calc_cardfix2) (struct block_list *src, struct block_list *bl, int64 damage, int s_ele, int nk, int flag);

 int64 (*calc_elefix) (struct block_list *src, struct block_list *target, uint16 skill_id, uint16 skill_lv, int64 damage, int nk, int n_ele, int s_ele, int s_ele_, 
# 612 "../../../server-code/src/map/battle.h" 3 4
                                                                                                                                                                   _Bool 
# 612 "../../../server-code/src/map/battle.h"
                                                                                                                                                                        left, int flag);

 int64 (*calc_masteryfix) (struct block_list *src, struct block_list *target, uint16 skill_id, uint16 skill_lv, int64 damage, int div, 
# 614 "../../../server-code/src/map/battle.h" 3 4
                                                                                                                                      _Bool 
# 614 "../../../server-code/src/map/battle.h"
                                                                                                                                           left, 
# 614 "../../../server-code/src/map/battle.h" 3 4
                                                                                                                                                 _Bool 
# 614 "../../../server-code/src/map/battle.h"
                                                                                                                                                      weapon);

 int (*calc_chorusbonus) (struct map_session_data *sd);

 int (*calc_skillratio) (int attack_type, struct block_list *src, struct block_list *target, uint16 skill_id, uint16 skill_lv, int skillratio, int flag);

 int64 (*calc_sizefix) (struct map_session_data *sd, int64 damage, int type, int size, 
# 620 "../../../server-code/src/map/battle.h" 3 4
                                                                                       _Bool 
# 620 "../../../server-code/src/map/battle.h"
                                                                                            ignore);

 int64 (*calc_weapon_damage) (struct block_list *src, struct block_list *bl, uint16 skill_id, uint16 skill_lv, struct weapon_atk *watk, int nk, 
# 622 "../../../server-code/src/map/battle.h" 3 4
                                                                                                                                               _Bool 
# 622 "../../../server-code/src/map/battle.h"
                                                                                                                                                    n_ele, short s_ele, short s_ele_, int size, int type, int flag, int flag2);

 int64 (*calc_defense) (int attack_type, struct block_list *src, struct block_list *target, uint16 skill_id, uint16 skill_lv, int64 damage, int flag, int pdef);

 struct block_list *(*get_master) (struct block_list *src);

 struct block_list *(*get_targeted) (struct block_list *target);

 struct block_list *(*get_enemy) (struct block_list *target, int type, int range);

 int (*get_target) (struct block_list *bl);

 int (*get_current_skill) (struct block_list *bl);

 
# 636 "../../../server-code/src/map/battle.h" 3 4
_Bool 
# 636 "../../../server-code/src/map/battle.h"
     (*check_undead) (int race,int element);

 int (*check_target) (struct block_list *src, struct block_list *target,int flag);

 
# 640 "../../../server-code/src/map/battle.h" 3 4
_Bool 
# 640 "../../../server-code/src/map/battle.h"
     (*check_range) (struct block_list *src,struct block_list *bl,int range);

 void (*consume_ammo) (struct map_session_data* sd, int skill_id, int lv);
 int (*get_targeted_sub) (struct block_list *bl, va_list ap);
 int (*get_enemy_sub) (struct block_list *bl, va_list ap);
 int (*get_enemy_area_sub) (struct block_list *bl, va_list ap);
 int (*delay_damage_sub) (int tid, int64 tick, int id, intptr_t data);
 int (*blewcount_bonus) (struct map_session_data *sd, uint16 skill_id);

 int (*range_type) (struct block_list *src, struct block_list *target, uint16 skill_id, uint16 skill_lv);
 int64 (*calc_base_damage) (struct block_list *src, struct block_list *bl, uint16 skill_id, uint16 skill_lv, int nk, 
# 650 "../../../server-code/src/map/battle.h" 3 4
                                                                                                                    _Bool 
# 650 "../../../server-code/src/map/battle.h"
                                                                                                                         n_ele, short s_ele, short s_ele_, int type, int flag, int flag2);
 int64 (*calc_base_damage2) (struct status_data *st, struct weapon_atk *wa, struct status_change *sc, unsigned short t_size, struct map_session_data *sd, int flag);
 struct Damage (*calc_misc_attack) (struct block_list *src,struct block_list *target,uint16 skill_id,uint16 skill_lv,int mflag);
 struct Damage (*calc_magic_attack) (struct block_list *src,struct block_list *target,uint16 skill_id,uint16 skill_lv,int mflag);
 int (*adjust_skill_damage) (int m, unsigned short skill_id);
 int64 (*add_mastery) (struct map_session_data *sd,struct block_list *target,int64 dmg,int type);
 int (*calc_drain) (int64 damage, int rate, int per);

 int (*config_read) (const char *cfgName);
 void (*config_set_defaults) (void);
 int (*config_set_value) (const char *w1, const char *w2);
 
# 661 "../../../server-code/src/map/battle.h" 3 4
_Bool 
# 661 "../../../server-code/src/map/battle.h"
     (*config_get_value) (const char *w1, int *value);
 void (*config_adjust) (void);


 struct block_list* (*get_enemy_area) (struct block_list *src, int x, int y, int range, int type, int ignore_id);

 int (*damage_area) (struct block_list *bl, va_list ap);
 void (*calc_masteryfix_unknown) (struct block_list *src, struct block_list *target, uint16 *skill_id, uint16 *skill_lv, int64 *damage, int *div, 
# 668 "../../../server-code/src/map/battle.h" 3 4
                                                                                                                                                 _Bool 
# 668 "../../../server-code/src/map/battle.h"
                                                                                                                                                      *left, 
# 668 "../../../server-code/src/map/battle.h" 3 4
                                                                                                                                                             _Bool 
# 668 "../../../server-code/src/map/battle.h"
                                                                                                                                                                  *weapon);
 void (*calc_skillratio_magic_unknown) (int *attack_type, struct block_list *src, struct block_list *target, uint16 *skill_id, uint16 *skill_lv, int *skillratio, int *flag);
 void (*calc_skillratio_weapon_unknown) (int *attack_type, struct block_list *src, struct block_list *target, uint16 *skill_id, uint16 *skill_lv, int *skillratio, int *flag);
 void (*calc_misc_attack_unknown) (struct block_list *src, struct block_list *target, uint16 *skill_id, uint16 *skill_lv, int *mflag, struct Damage *md);
};


extern struct Battle_Config battle_config;

void battle_defaults(void);


extern struct battle_interface *battle;
# 28 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/map/battleground.h" 1
# 29 "../../../server-code/src/map/battleground.h"
struct hplugin_data_store;
struct block_list;
struct map_session_data;
# 42 "../../../server-code/src/map/battleground.h"
enum bg_queue_types {
 BGQT_INVALID = 0x0,
 BGQT_INDIVIDUAL = 0x1,
 BGQT_PARTY = 0x2,

 BGQT_GUILD = 0x4,
};

enum bg_team_leave_type {
 BGTL_LEFT = 0x0,
 BGTL_QUIT = 0x1,
 BGTL_AFK = 0x2,
};

struct battleground_member_data {
 unsigned short x, y;
 struct map_session_data *sd;
 unsigned afk : 1;
 struct point source;
};

struct battleground_data {
 unsigned int bg_id;
 unsigned char count;
 struct battleground_member_data members[30];

 unsigned short mapindex, x, y;

 char logout_event[( (23 + 1) * 2 + 3 )];
 char die_event[( (23 + 1) * 2 + 3 )];
 struct hplugin_data_store *hdata;
};

struct bg_arena {
 char name[(23 + 1)];
 unsigned char id;
 char npc_event[( (23 + 1) * 2 + 3 )];
 short min_level, max_level;
 short prize_win, prize_loss, prize_draw;
 short min_players;
 short max_players;
 short min_team_players;
 char delay_var[(23 + 1)];
 unsigned short maxDuration;
 int queue_id;
 int begin_timer;
 int fillup_timer;
 int game_timer;
 unsigned short fillup_duration;
 unsigned short pregame_duration;
 
# 92 "../../../server-code/src/map/battleground.h" 3 4
_Bool 
# 92 "../../../server-code/src/map/battleground.h"
     ongoing;
 enum bg_queue_types allowed_types;
};

struct battleground_interface {
 
# 97 "../../../server-code/src/map/battleground.h" 3 4
_Bool 
# 97 "../../../server-code/src/map/battleground.h"
     queue_on;

 int mafksec, afk_timer_id;
 char gdelay_var[30];

 struct bg_arena **arena;
 unsigned char arenas;

 struct DBMap *team_db;
 unsigned int team_counter;

 void (*init) (
# 108 "../../../server-code/src/map/battleground.h" 3 4
              _Bool 
# 108 "../../../server-code/src/map/battleground.h"
                   minimal);
 void (*final) (void);

 struct bg_arena *(*name2arena) (const char *name);
 void (*queue_add) (struct map_session_data *sd, struct bg_arena *arena, enum bg_queue_types type);
 enum BATTLEGROUNDS_QUEUE_ACK (*can_queue) (struct map_session_data *sd, struct bg_arena *arena, enum bg_queue_types type);
 int (*id2pos) (int queue_id, int account_id);
 void (*queue_pc_cleanup) (struct map_session_data *sd);
 void (*begin) (struct bg_arena *arena);
 int (*begin_timer) (int tid, int64 tick, int id, intptr_t data);
 void (*queue_pregame) (struct bg_arena *arena);
 int (*fillup_timer) (int tid, int64 tick, int id, intptr_t data);
 void (*queue_ready_ack) (struct bg_arena *arena, struct map_session_data *sd, 
# 120 "../../../server-code/src/map/battleground.h" 3 4
                                                                              _Bool 
# 120 "../../../server-code/src/map/battleground.h"
                                                                                   response);
 void (*match_over) (struct bg_arena *arena, 
# 121 "../../../server-code/src/map/battleground.h" 3 4
                                            _Bool 
# 121 "../../../server-code/src/map/battleground.h"
                                                 canceled);
 void (*queue_check) (struct bg_arena *arena);
 struct battleground_data* (*team_search) (int bg_id);
 struct map_session_data* (*getavailablesd) (struct battleground_data *bgd);
 
# 125 "../../../server-code/src/map/battleground.h" 3 4
_Bool 
# 125 "../../../server-code/src/map/battleground.h"
     (*team_delete) (int bg_id);
 
# 126 "../../../server-code/src/map/battleground.h" 3 4
_Bool 
# 126 "../../../server-code/src/map/battleground.h"
     (*team_warp) (int bg_id, unsigned short map_index, short x, short y);
 void (*send_dot_remove) (struct map_session_data *sd);
 
# 128 "../../../server-code/src/map/battleground.h" 3 4
_Bool 
# 128 "../../../server-code/src/map/battleground.h"
     (*team_join) (int bg_id, struct map_session_data *sd);
 int (*team_leave) (struct map_session_data *sd, enum bg_team_leave_type flag);
 
# 130 "../../../server-code/src/map/battleground.h" 3 4
_Bool 
# 130 "../../../server-code/src/map/battleground.h"
     (*member_respawn) (struct map_session_data *sd);
 int (*create) (unsigned short map_index, short rx, short ry, const char *ev, const char *dev);
 int (*team_get_id) (struct block_list *bl);
 
# 133 "../../../server-code/src/map/battleground.h" 3 4
_Bool 
# 133 "../../../server-code/src/map/battleground.h"
     (*send_message) (struct map_session_data *sd, const char *mes, int len);
 int (*send_xy_timer_sub) (union DBKey key, struct DBData *data, va_list ap);
 int (*send_xy_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*afk_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*team_db_final) (union DBKey key, struct DBData *data, va_list ap);

 enum bg_queue_types (*str2teamtype) (const char *str);

 void (*config_read) (void);
};


void battleground_defaults(void);


extern struct battleground_interface *bg;
# 29 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/map/channel.h" 1
# 29 "../../../server-code/src/map/channel.h"
struct DBMap;
struct map_session_data;
struct guild;






enum channel_options {
 HCS_OPT_BASE = 0x0,
 HCS_OPT_ANNOUNCE_JOIN = 0x1,
 HCS_OPT_MSG_DELAY = 0x2,
};

enum channel_types {
 HCS_TYPE_PUBLIC = 0,
 HCS_TYPE_PRIVATE = 1,
 HCS_TYPE_MAP = 2,
 HCS_TYPE_ALLY = 3,
 HCS_TYPE_IRC = 4,
};

enum channel_operation_status {
 HCS_STATUS_OK = 0,
 HCS_STATUS_FAIL,
 HCS_STATUS_ALREADY,
 HCS_STATUS_NOPERM,
 HCS_STATUS_BANNED,
};




struct Channel_Config {
 unsigned int *colors;
 char **colors_name;
 unsigned char colors_count;
 
# 67 "../../../server-code/src/map/channel.h" 3 4
_Bool 
# 67 "../../../server-code/src/map/channel.h"
     local, ally, irc;
 
# 68 "../../../server-code/src/map/channel.h" 3 4
_Bool 
# 68 "../../../server-code/src/map/channel.h"
     local_autojoin, ally_autojoin, irc_autojoin;
 char local_name[20], ally_name[20], irc_name[20];
 unsigned char local_color, ally_color, irc_color;
 
# 71 "../../../server-code/src/map/channel.h" 3 4
_Bool 
# 71 "../../../server-code/src/map/channel.h"
     closing;
 
# 72 "../../../server-code/src/map/channel.h" 3 4
_Bool 
# 72 "../../../server-code/src/map/channel.h"
     allow_user_channel_creation;
 char irc_server[40], irc_channel[50], irc_nick[40], irc_nick_pw[30];
 unsigned short irc_server_port;
 
# 75 "../../../server-code/src/map/channel.h" 3 4
_Bool 
# 75 "../../../server-code/src/map/channel.h"
     irc_use_ghost;
};

struct channel_ban_entry {
 char name[(23 + 1)];
};

struct channel_data {
 char name[20];
 char password[20];
 unsigned char color;
 struct DBMap *users;
 struct DBMap *banned;
 unsigned int options;
 unsigned int owner;
 enum channel_types type;
 uint16 m;
 unsigned char msg_delay;
};

struct channel_interface {

 struct DBMap *db;
 struct Channel_Config *config;

 int (*init) (
# 100 "../../../server-code/src/map/channel.h" 3 4
             _Bool 
# 100 "../../../server-code/src/map/channel.h"
                  minimal);
 void (*final) (void);

 struct channel_data *(*search) (const char *name, struct map_session_data *sd);
 struct channel_data *(*create) (enum channel_types type, const char *name, unsigned char color);
 void (*delete) (struct channel_data *chan);

 void (*set_password) (struct channel_data *chan, const char *password);
 enum channel_operation_status (*ban) (struct channel_data *chan, const struct map_session_data *ssd, struct map_session_data *tsd);
 enum channel_operation_status (*unban) (struct channel_data *chan, const struct map_session_data *ssd, struct map_session_data *tsd);
 void (*set_options) (struct channel_data *chan, unsigned int options);

 void (*send) (struct channel_data *chan, struct map_session_data *sd, const char *msg);
 void (*join_sub) (struct channel_data *chan, struct map_session_data *sd, 
# 113 "../../../server-code/src/map/channel.h" 3 4
                                                                          _Bool 
# 113 "../../../server-code/src/map/channel.h"
                                                                               stealth);
 enum channel_operation_status (*join) (struct channel_data *chan, struct map_session_data *sd, const char *password, 
# 114 "../../../server-code/src/map/channel.h" 3 4
                                                                                                                     _Bool 
# 114 "../../../server-code/src/map/channel.h"
                                                                                                                          silent);
 void (*leave) (struct channel_data *chan, struct map_session_data *sd);
 void (*leave_sub) (struct channel_data *chan, struct map_session_data *sd);
 void (*quit) (struct map_session_data *sd);

 void (*map_join) (struct map_session_data *sd);
 void (*guild_join_alliance) (const struct guild *g_source, const struct guild *g_ally);
 void (*guild_leave_alliance) (const struct guild *g_source, const struct guild *g_ally);
 void (*quit_guild) (struct map_session_data *sd);
 void (*irc_join) (struct map_session_data *sd);

 void (*config_read) (void);
};


void channel_defaults(void);


extern struct channel_interface *channel;
# 30 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/map/chat.h" 1
# 28 "../../../server-code/src/map/chat.h"
struct DBMap;
struct chat_data;
struct map_session_data;
struct npc_data;



struct chat_data {
 struct block_list bl;
 char title[(36 + 1)];
 char pass[(8 + 1)];
 
# 39 "../../../server-code/src/map/chat.h" 3 4
_Bool 
# 39 "../../../server-code/src/map/chat.h"
     pub;
 uint8 users;
 uint8 limit;
 uint8 trigger;
 uint32 zeny;
 uint32 minLvl;
 uint32 maxLvl;
 struct map_session_data* usersd[20];
 struct block_list* owner;
 char npc_event[( (23 + 1) * 2 + 3 )];

 struct DBMap *kick_list;
};






struct chat_interface {

 
# 60 "../../../server-code/src/map/chat.h" 3 4
_Bool 
# 60 "../../../server-code/src/map/chat.h"
     (*create_pc_chat) (struct map_session_data* sd, const char* title, const char* pass, int limit, 
# 60 "../../../server-code/src/map/chat.h" 3 4
                                                                                                     _Bool 
# 60 "../../../server-code/src/map/chat.h"
                                                                                                          pub);
 
# 61 "../../../server-code/src/map/chat.h" 3 4
_Bool 
# 61 "../../../server-code/src/map/chat.h"
     (*join) (struct map_session_data* sd, int chatid, const char* pass);
 int (*leave) (struct map_session_data* sd, 
# 62 "../../../server-code/src/map/chat.h" 3 4
                                           _Bool 
# 62 "../../../server-code/src/map/chat.h"
                                                kicked);
 
# 63 "../../../server-code/src/map/chat.h" 3 4
_Bool 
# 63 "../../../server-code/src/map/chat.h"
     (*change_owner) (struct map_session_data* sd, const char* nextownername);
 
# 64 "../../../server-code/src/map/chat.h" 3 4
_Bool 
# 64 "../../../server-code/src/map/chat.h"
     (*change_status) (struct map_session_data* sd, const char* title, const char* pass, int limit, 
# 64 "../../../server-code/src/map/chat.h" 3 4
                                                                                                    _Bool 
# 64 "../../../server-code/src/map/chat.h"
                                                                                                         pub);
 
# 65 "../../../server-code/src/map/chat.h" 3 4
_Bool 
# 65 "../../../server-code/src/map/chat.h"
     (*kick) (struct map_session_data* sd, const char* kickusername);
 
# 66 "../../../server-code/src/map/chat.h" 3 4
_Bool 
# 66 "../../../server-code/src/map/chat.h"
     (*create_npc_chat) (struct npc_data* nd, const char* title, int limit, 
# 66 "../../../server-code/src/map/chat.h" 3 4
                                                                            _Bool 
# 66 "../../../server-code/src/map/chat.h"
                                                                                 pub, int trigger, const char* ev, int zeny, int minLvl, int maxLvl);
 
# 67 "../../../server-code/src/map/chat.h" 3 4
_Bool 
# 67 "../../../server-code/src/map/chat.h"
     (*delete_npc_chat) (struct npc_data* nd);
 
# 68 "../../../server-code/src/map/chat.h" 3 4
_Bool 
# 68 "../../../server-code/src/map/chat.h"
     (*enable_event) (struct chat_data* cd);
 
# 69 "../../../server-code/src/map/chat.h" 3 4
_Bool 
# 69 "../../../server-code/src/map/chat.h"
     (*disable_event) (struct chat_data* cd);
 
# 70 "../../../server-code/src/map/chat.h" 3 4
_Bool 
# 70 "../../../server-code/src/map/chat.h"
     (*npc_kick_all) (struct chat_data* cd);
 
# 71 "../../../server-code/src/map/chat.h" 3 4
_Bool 
# 71 "../../../server-code/src/map/chat.h"
     (*trigger_event) (struct chat_data *cd);
 struct chat_data* (*create) (struct block_list* bl, const char* title, const char* pass, int limit, 
# 72 "../../../server-code/src/map/chat.h" 3 4
                                                                                                    _Bool 
# 72 "../../../server-code/src/map/chat.h"
                                                                                                         pub, int trigger, const char* ev, int zeny, int minLvl, int maxLvl);
};


void chat_defaults(void);


extern struct chat_interface *chat;
# 31 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/map/chrif.h" 1
# 28 "../../../server-code/src/map/chrif.h"
struct eri;
struct map_session_data;
struct status_change_entry;
# 45 "../../../server-code/src/map/chrif.h"
enum sd_state { ST_LOGIN, ST_LOGOUT, ST_MAPCHANGE };




struct auth_node {
 int account_id, char_id;
 int login_id1, login_id2, sex, fd;
 time_t expiration_time;
 struct map_session_data *sd;
 int64 node_created;
 enum sd_state state;
};
# 66 "../../../server-code/src/map/chrif.h"
struct chrif_interface {



 int connected;
 int other_mapserver_count;


 struct eri *auth_db_ers;
 struct DBMap *auth_db;

 int packet_len_table[0x3d];
 int fd;
 int srvinfo;
 char ip_str[128];
 uint32 ip;
 uint16 port;
 char userid[(23 + 1)], passwd[(23 + 1)];
 int state;

 void (*init) (
# 86 "../../../server-code/src/map/chrif.h" 3 4
              _Bool 
# 86 "../../../server-code/src/map/chrif.h"
                   minimal);
 void (*final) (void);

 void (*setuserid) (char* id);
 void (*setpasswd) (char* pwd);
 void (*checkdefaultlogin) (void);
 
# 92 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 92 "../../../server-code/src/map/chrif.h"
     (*setip) (const char* ip);
 void (*setport) (uint16 port);

 int (*isconnected) (void);
 void (*check_shutdown) (void);

 struct auth_node* (*search) (int account_id);
 struct auth_node* (*auth_check) (int account_id, int char_id, enum sd_state state);
 
# 100 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 100 "../../../server-code/src/map/chrif.h"
     (*auth_delete) (int account_id, int char_id, enum sd_state state);
 
# 101 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 101 "../../../server-code/src/map/chrif.h"
     (*auth_finished) (struct map_session_data* sd);

 void (*authreq) (struct map_session_data* sd, 
# 103 "../../../server-code/src/map/chrif.h" 3 4
                                              _Bool 
# 103 "../../../server-code/src/map/chrif.h"
                                                   hstandalone);
 void (*authok) (int fd);
 
# 105 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 105 "../../../server-code/src/map/chrif.h"
     (*scdata_request) (int account_id, int char_id);
 
# 106 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 106 "../../../server-code/src/map/chrif.h"
     (*save) (struct map_session_data* sd, int flag);
 
# 107 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 107 "../../../server-code/src/map/chrif.h"
     (*charselectreq) (struct map_session_data* sd, uint32 s_ip);
 
# 108 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 108 "../../../server-code/src/map/chrif.h"
     (*changemapserver) (struct map_session_data* sd, uint32 ip, uint16 port);

 
# 110 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 110 "../../../server-code/src/map/chrif.h"
     (*searchcharid) (int char_id);
 
# 111 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 111 "../../../server-code/src/map/chrif.h"
     (*changeemail) (int id, const char *actual_email, const char *new_email);
 
# 112 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 112 "../../../server-code/src/map/chrif.h"
     (*char_ask_name) (int acc, const char* character_name, unsigned short operation_type, int year, int month, int day, int hour, int minute, int second);
 int (*updatefamelist) (struct map_session_data *sd);
 
# 114 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 114 "../../../server-code/src/map/chrif.h"
     (*buildfamelist) (void);
 
# 115 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 115 "../../../server-code/src/map/chrif.h"
     (*save_scdata) (struct map_session_data *sd);
 
# 116 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 116 "../../../server-code/src/map/chrif.h"
     (*ragsrvinfo) (int base_rate,int job_rate, int drop_rate);

 
# 118 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 118 "../../../server-code/src/map/chrif.h"
     (*char_offline_nsd) (int account_id, int char_id);
 
# 119 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 119 "../../../server-code/src/map/chrif.h"
     (*char_reset_offline) (void);
 
# 120 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 120 "../../../server-code/src/map/chrif.h"
     (*send_users_tochar) (void);
 
# 121 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 121 "../../../server-code/src/map/chrif.h"
     (*char_online) (struct map_session_data *sd);
 
# 122 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 122 "../../../server-code/src/map/chrif.h"
     (*changesex) (struct map_session_data *sd, 
# 122 "../../../server-code/src/map/chrif.h" 3 4
                                                _Bool 
# 122 "../../../server-code/src/map/chrif.h"
                                                     change_account);

 
# 124 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 124 "../../../server-code/src/map/chrif.h"
     (*divorce) (int partner_id1, int partner_id2);

 
# 126 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 126 "../../../server-code/src/map/chrif.h"
     (*removefriend) (int char_id, int friend_id);
 void (*send_report) (char* buf, int len);

 
# 129 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 129 "../../../server-code/src/map/chrif.h"
     (*flush) (void);
 void (*skillid2idx) (int fd);

 
# 132 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 132 "../../../server-code/src/map/chrif.h"
     (*sd_to_auth) (struct map_session_data *sd, enum sd_state state);
 int (*check_connect_char_server) (int tid, int64 tick, int id, intptr_t data);
 
# 134 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 134 "../../../server-code/src/map/chrif.h"
     (*auth_logout) (struct map_session_data *sd, enum sd_state state);
 void (*save_ack) (int fd);
 int (*reconnect) (union DBKey key, struct DBData *data, va_list ap);
 int (*auth_db_cleanup_sub) (union DBKey key, struct DBData *data, va_list ap);
 
# 138 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 138 "../../../server-code/src/map/chrif.h"
     (*char_ask_name_answer) (int acc, const char* player_name, uint16 type, uint16 answer);
 int (*auth_db_final) (union DBKey key, struct DBData *data, va_list ap);
 int (*send_usercount_tochar) (int tid, int64 tick, int id, intptr_t data);
 int (*auth_db_cleanup) (int tid, int64 tick, int id, intptr_t data);

 void (*connect) (int fd);
 void (*connectack) (int fd);
 void (*sendmap) (int fd);
 void (*sendmapack) (int fd);
 void (*recvmap) (int fd);
 
# 148 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 148 "../../../server-code/src/map/chrif.h"
     (*changemapserverack) (int account_id, int login_id1, int login_id2, int char_id, short map_index, short x, short y, uint32 ip, uint16 port);
 void (*changedsex) (int fd);
 
# 150 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 150 "../../../server-code/src/map/chrif.h"
     (*divorceack) (int char_id, int partner_id);
 void (*idbanned) (int fd);
 void (*recvfamelist) (int fd);
 
# 153 "../../../server-code/src/map/chrif.h" 3 4
_Bool 
# 153 "../../../server-code/src/map/chrif.h"
     (*load_scdata) (int fd);
 void (*update_ip) (int fd);
 int (*disconnectplayer) (int fd);
 void (*removemap) (int fd);
 int (*updatefamelist_ack) (int fd);
 void (*keepalive)(int fd);
 void (*keepalive_ack) (int fd);
 void (*deadopt) (int father_id, int mother_id, int child_id);
 void (*authfail) (int fd);
 void (*on_ready) (void);
 void (*on_disconnect) (void);
 int (*parse) (int fd);
 void (*save_scdata_single) (int account_id, int char_id, short type, struct status_change_entry *sce);
 void (*del_scdata_single) (int account_id, int char_id, short type);
};


void chrif_defaults(void);


extern struct chrif_interface *chrif;
# 32 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/map/elemental.h" 1
# 24 "../../../server-code/src/map/elemental.h"
# 1 "../../../server-code/src/map/status.h" 1
# 27 "../../../server-code/src/map/status.h"
struct block_list;
struct config_setting_t;
struct elemental_data;
struct homun_data;
struct mercenary_data;
struct mob_data;
struct npc_data;
struct pet_data;
# 61 "../../../server-code/src/map/status.h"
enum refine_type {
 REFINE_TYPE_ARMOR = 0,
 REFINE_TYPE_WEAPON1 = 1,
 REFINE_TYPE_WEAPON2 = 2,
 REFINE_TYPE_WEAPON3 = 3,
 REFINE_TYPE_WEAPON4 = 4,
 REFINE_TYPE_MAX = 5
};





typedef enum sc_conf_type {
 SC_NO_REM_DEATH = 0x01,
 SC_NO_SAVE = 0x02,
 SC_NO_DISPELL = 0x04,
 SC_NO_CLEARANCE = 0x08,
 SC_BUFF = 0x10,
 SC_DEBUFF = 0x20,
 SC_MADO_NO_RESET = 0x40,
 SC_NO_CLEAR = 0x80,
} sc_conf_type;




enum scstart_flag {

 SCFLAG_NONE = 0x00,
 SCFLAG_NOAVOID = 0x01,
 SCFLAG_FIXEDTICK = 0x02,
 SCFLAG_LOADED = 0x04,
 SCFLAG_FIXEDRATE = 0x08,
 SCFLAG_NOICON = 0x10,
 SCFLAG_ALL = SCFLAG_NONE|SCFLAG_NOAVOID|SCFLAG_FIXEDTICK|SCFLAG_LOADED|SCFLAG_FIXEDRATE|SCFLAG_NOICON
};


typedef enum sc_type {
 SC_NONE = -1,

 SC_STONE = 0,
 SC_COMMON_MIN = 0,
 SC_FREEZE,
 SC_STUN,
 SC_SLEEP,
 SC_POISON,
 SC_CURSE,
 SC_SILENCE,
 SC_CONFUSION,
 SC_BLIND,
 SC_BLOODING,
 SC_DPOISON,
 SC_FEAR,
 SC_COLD,
 SC_BURNING,
 SC_DEEP_SLEEP,
 SC_COMMON_MAX = 14,


 SC_PROVOKE = 20,
 SC_ENDURE,
 SC_TWOHANDQUICKEN,
 SC_CONCENTRATION,
 SC_HIDING,
 SC_CLOAKING,
 SC_ENCHANTPOISON,
 SC_POISONREACT,
 SC_QUAGMIRE,
 SC_ANGELUS,
 SC_BLESSING,
 SC_CRUCIS,
 SC_INC_AGI,
 SC_DEC_AGI,
 SC_SLOWPOISON,
 SC_IMPOSITIO ,
 SC_SUFFRAGIUM,
 SC_ASPERSIO,
 SC_BENEDICTIO,
 SC_KYRIE,
 SC_MAGNIFICAT,
 SC_GLORIA,
 SC_LEXAETERNA,
 SC_ADRENALINE,
 SC_WEAPONPERFECT,
 SC_OVERTHRUST,
 SC_MAXIMIZEPOWER,
 SC_TRICKDEAD,
 SC_SHOUT,
 SC_ENERGYCOAT,
 SC_BROKENARMOR,
 SC_BROKENWEAPON,
 SC_ILLUSION,
 SC_WEIGHTOVER50,
 SC_WEIGHTOVER90,
 SC_ATTHASTE_POTION1,
 SC_ATTHASTE_POTION2,
 SC_ATTHASTE_POTION3,
 SC_ATTHASTE_INFINITY,
 SC_MOVHASTE_HORSE,
 SC_MOVHASTE_INFINITY,
 SC_PLUSATTACKPOWER,
 SC_PLUSMAGICPOWER,
 SC_WEDDING,
 SC_SLOWDOWN,
 SC_ANKLESNARE,
 SC_KEEPING,
 SC_BARRIER,
 SC_NOEQUIPWEAPON,
 SC_NOEQUIPSHIELD,
 SC_NOEQUIPARMOR,
 SC_NOEQUIPHELM,
 SC_PROTECTWEAPON,
 SC_PROTECTSHIELD,
 SC_PROTECTARMOR,
 SC_PROTECTHELM,
 SC_AUTOGUARD,
 SC_REFLECTSHIELD,
 SC_SPLASHER,
 SC_PROVIDENCE,
 SC_DEFENDER,
 SC_MAGICROD,
 SC_SPELLBREAKER,
 SC_AUTOSPELL,
 SC_SIGHTTRASHER,
 SC_AUTOBERSERK,
 SC_SPEARQUICKEN,
 SC_AUTOCOUNTER,
 SC_SIGHT,
 SC_SAFETYWALL,
 SC_RUWACH,
 SC_EXTREMITYFIST,
 SC_EXPLOSIONSPIRITS,
 SC_COMBOATTACK,
 SC_BLADESTOP_WAIT,
 SC_BLADESTOP,
 SC_PROPERTYFIRE,
 SC_PROPERTYWATER,
 SC_PROPERTYWIND,
 SC_PROPERTYGROUND,
 SC_VOLCANO,
 SC_DELUGE,
 SC_VIOLENTGALE,
 SC_SUB_WEAPONPROPERTY,
 SC_ARMOR,
 SC_ARMORPROPERTY,
 SC_NOCHAT,
 SC_BABY,
 SC_AURABLADE,
 SC_PARRYING,
 SC_LKCONCENTRATION,
 SC_TENSIONRELAX,
 SC_BERSERK,
 SC_FURY,
 SC_GOSPEL,
 SC_ASSUMPTIO,
 SC_BASILICA,
 SC_GUILDAURA,
 SC_MAGICPOWER,
 SC_EDP,
 SC_TRUESIGHT,
 SC_WINDWALK,
 SC_MELTDOWN,
 SC_CARTBOOST,
 SC_CHASEWALK,
 SC_SWORDREJECT,
 SC_MARIONETTE_MASTER,
 SC_MARIONETTE,
 SC_PROPERTYUNDEAD,
 SC_JOINTBEAT,
 SC_MINDBREAKER,
 SC_MEMORIZE,
 SC_FOGWALL,
 SC_SPIDERWEB,
 SC_DEVOTION,
 SC_SACRIFICE,
 SC_STEELBODY,
 SC_ORCISH,
 SC_STORMKICK_READY,
 SC_DOWNKICK_READY,
 SC_TURNKICK_READY,
 SC_COUNTERKICK_READY,
 SC_DODGE_READY,
 SC_RUN,
 SC_PROPERTYDARK,
 SC_ADRENALINE2,
 SC_PROPERTYTELEKINESIS,
 SC_KAIZEL,
 SC_KAAHI,
 SC_KAUPE,
 SC_ONEHANDQUICKEN,
 SC_PRESERVE,
 SC_GDSKILL_BATTLEORDER,
 SC_GDSKILL_REGENERATION,
 SC_DOUBLECASTING,
 SC_GRAVITATION,
 SC_OVERTHRUSTMAX,
 SC_LONGING,
 SC_HERMODE,
 SC_TAROTCARD,
 SC_CR_SHRINK,
 SC_WZ_SIGHTBLASTER,
 SC_DC_WINKCHARM,
 SC_RG_CCONFINE_M,
 SC_RG_CCONFINE_S,
 SC_DANCING,
 SC_ARMOR_PROPERTY,
 SC_RICHMANKIM,
 SC_ETERNALCHAOS,
 SC_DRUMBATTLE,
 SC_NIBELUNGEN,
 SC_ROKISWEIL,
 SC_INTOABYSS,
 SC_SIEGFRIED,
 SC_WHISTLE,
 SC_ASSNCROS,
 SC_POEMBRAGI,
 SC_APPLEIDUN,
 SC_MODECHANGE,
 SC_HUMMING,
 SC_DONTFORGETME,
 SC_FORTUNE,
 SC_SERVICEFORYOU,
 SC_STOP,
 SC_STRUP,
 SC_SOULLINK,
 SC_COMA,
 SC_CLAIRVOYANCE,
 SC_INCALLSTATUS,
 SC_CHASEWALK2,
 SC_INCAGI,
 SC_INCVIT,
 SC_INCINT,
 SC_INCDEX,
 SC_INCLUK,
 SC_INCHIT,
 SC_INCHITRATE,
 SC_INCFLEE,
 SC_INCFLEERATE,
 SC_INCMHPRATE,
 SC_INCMSPRATE,
 SC_INCATKRATE,
 SC_INCMATKRATE,
 SC_INCDEFRATE,
 SC_FOOD_STR,
 SC_FOOD_AGI,
 SC_FOOD_VIT,
 SC_FOOD_INT,
 SC_FOOD_DEX,
 SC_FOOD_LUK,
 SC_FOOD_BASICHIT,
 SC_FOOD_BASICAVOIDANCE,
 SC_BATKFOOD,
 SC_WATKFOOD,
 SC_MATKFOOD,
 SC_SCRESIST,
 SC_XMAS,
 SC_WARM,
 SC_SUN_COMFORT,
 SC_MOON_COMFORT,
 SC_STAR_COMFORT,
 SC_FUSION,
 SC_SKILLRATE_UP,
 SC_SKE,
 SC_KAITE,
 SC_SWOO,
 SC_SKA,
 SC_EARTHSCROLL,
 SC_MIRACLE,
 SC_GS_MADNESSCANCEL,
 SC_GS_ADJUSTMENT,
 SC_GS_ACCURACY,
 SC_GS_GATLINGFEVER,
 SC_NJ_TATAMIGAESHI,
 SC_NJ_UTSUSEMI,
 SC_NJ_BUNSINJYUTSU,
 SC_NJ_KAENSIN,
 SC_NJ_SUITON,
 SC_NJ_NEN,
 SC_KNOWLEDGE,
 SC_SMA_READY,
 SC_FLING,
 SC_HLIF_AVOID,
 SC_HLIF_CHANGE,
 SC_HAMI_BLOODLUST,
 SC_HLIF_FLEET,
 SC_HLIF_SPEED,
 SC_HAMI_DEFENCE,
 SC_INCASPDRATE,
 SC_PLUSAVOIDVALUE,
 SC_JAILED,
 SC_ENCHANTARMS,
 SC_MAGICALATTACK,
 SC_STONESKIN,
 SC_CRITICALWOUND,
 SC_MAGICMIRROR,
 SC_SLOWCAST,
 SC_SUMMER,
 SC_CASH_PLUSEXP,
 SC_CASH_RECEIVEITEM,
 SC_CASH_BOSS_ALARM,
 SC_CASH_DEATHPENALTY,
 SC_CRITICALPERCENT,



 SC_PROTECT_MDEF = 266,

 SC_HEALPLUS = 268,
 SC_PNEUMA,
 SC_AUTOTRADE,
 SC_KSPROTECTED,
 SC_ARMOR_RESIST,
 SC_ATKER_BLOOD,
 SC_TARGET_BLOOD,
 SC_TK_SEVENWIND,
 SC_PROTECT_DEF,

 SC_WALKSPEED = 278,

 SC_MER_FLEE,
 SC_MER_ATK,
 SC_MER_HP,
 SC_MER_SP,
 SC_MER_HIT,
 SC_MER_QUICKEN,
 SC_REBIRTH,





 SC_S_LIFEPOTION = 291,
 SC_L_LIFEPOTION,
 SC_CASH_PLUSONLYJOBEXP,

 SC_HELLPOWER = 295,
 SC_INVINCIBLE,
 SC_INVINCIBLEOFF,
 SC_MANU_ATK,
 SC_MANU_DEF,
 SC_SPL_ATK,
 SC_SPL_DEF,
 SC_MANU_MATK,
 SC_SPL_MATK,
 SC_FOOD_STR_CASH,
 SC_FOOD_AGI_CASH,
 SC_FOOD_VIT_CASH,
 SC_FOOD_DEX_CASH,
 SC_FOOD_INT_CASH,
 SC_FOOD_LUK_CASH,




 SC_FROSTMISTY = 311,



 SC_ENCHANTBLADE,
 SC_DEATHBOUND,
 SC_MILLENNIUMSHIELD,
 SC_CRUSHSTRIKE,
 SC_REFRESH,
 SC_REUSE_REFRESH,
 SC_GIANTGROWTH,
 SC_STONEHARDSKIN,
 SC_VITALITYACTIVATION,
 SC_STORMBLAST,
 SC_FIGHTINGSPIRIT,
 SC_ABUNDANCE,



 SC_ADORAMUS,
 SC_EPICLESIS,
 SC_ORATIO,
 SC_LAUDAAGNUS,
 SC_LAUDARAMUS,
 SC_RENOVATIO,
 SC_EXPIATIO,
 SC_DUPLELIGHT,
 SC_SECRAMENT,



 SC_WHITEIMPRISON,
 SC_MARSHOFABYSS,
 SC_RECOGNIZEDSPELL,
 SC_STASIS,
 SC_SUMMON1,
 SC_SUMMON2,
 SC_SUMMON3,
 SC_SUMMON4,
 SC_SUMMON5,
 SC_READING_SB,
 SC_FREEZINGSP,



 SC_FEARBREEZE,
 SC_ELECTRICSHOCKER,
 SC_WUGDASH,
 SC_WUGBITE,
 SC_CAMOUFLAGE,



 SC_ACCELERATION,
 SC_HOVERING,
 SC_SHAPESHIFT,
 SC_INFRAREDSCAN,
 SC_ANALYZE,
 SC_MAGNETICFIELD,
 SC_NEUTRALBARRIER,
 SC_NEUTRALBARRIER_MASTER,
 SC_STEALTHFIELD,
 SC_STEALTHFIELD_MASTER,
 SC_OVERHEAT,
 SC_OVERHEAT_LIMITPOINT,



 SC_VENOMIMPRESS,
 SC_POISONINGWEAPON,
 SC_WEAPONBLOCKING,
 SC_CLOAKINGEXCEED,
 SC_HALLUCINATIONWALK,
 SC_HALLUCINATIONWALK_POSTDELAY,
 SC_ROLLINGCUTTER,
 SC_TOXIN,
 SC_PARALYSE,
 SC_VENOMBLEED,
 SC_MAGICMUSHROOM,
 SC_DEATHHURT,
 SC_PYREXIA,
 SC_OBLIVIONCURSE,
 SC_LEECHESEND,



 SC_LG_REFLECTDAMAGE,
 SC_FORCEOFVANGUARD,
 SC_SHIELDSPELL_DEF,
 SC_SHIELDSPELL_MDEF,
 SC_SHIELDSPELL_REF,
 SC_EXEEDBREAK,
 SC_PRESTIGE,
 SC_BANDING,
 SC_BANDING_DEFENCE,
 SC_EARTHDRIVE,
 SC_INSPIRATION,



 SC_SPELLFIST,

 SC_STRIKING = 389,
 SC_WARMER,
 SC_VACUUM_EXTREME,
 SC_PROPERTYWALK,



 SC_SWING,
 SC_SYMPHONY_LOVE,
 SC_MOONLIT_SERENADE,
 SC_RUSH_WINDMILL,
 SC_ECHOSONG,
 SC_HARMONIZE,
 SC_SIREN,

 SC_SIRCLEOFNATURE = 401,
 SC_GLOOMYDAY,

 SC_SONG_OF_MANA = 404,
 SC_DANCE_WITH_WUG,
 SC_SATURDAY_NIGHT_FEVER,
 SC_LERADS_DEW,
 SC_MELODYOFSINK,
 SC_BEYOND_OF_WARCRY,
 SC_UNLIMITED_HUMMING_VOICE,
 SC_SITDOWN_FORCE,
 SC_NETHERWORLD,



 SC_CRESCENTELBOW = 413,
 SC_CURSEDCIRCLE_ATKER,
 SC_CURSEDCIRCLE_TARGET,
 SC_LIGHTNINGWALK,
 SC_RAISINGDRAGON,
 SC_GENTLETOUCH_ENERGYGAIN,
 SC_GENTLETOUCH_CHANGE,
 SC_GENTLETOUCH_REVITALIZE,



 SC_GN_CARTBOOST,
 SC_THORNS_TRAP,
 SC_BLOOD_SUCKER,
 SC_FIRE_EXPANSION_SMOKE_POWDER,
 SC_FIRE_EXPANSION_TEAR_GAS,
 SC_MANDRAGORA,
 SC_STOMACHACHE,
 SC_MYSTERIOUS_POWDER,
 SC_MELON_BOMB,
 SC_BANANA_BOMB,
 SC_BANANA_BOMB_SITDOWN_POSTDELAY,
 SC_SAVAGE_STEAK,
 SC_COCKTAIL_WARG_BLOOD,
 SC_MINOR_BBQ,
 SC_SIROMA_ICE_TEA,
 SC_DROCERA_HERB_STEAMED,
 SC_PUTTI_TAILS_NOODLES,
 SC_BOOST500,
 SC_FULL_SWING_K,
 SC_MANA_PLUS,
 SC_MUSTLE_M,
 SC_LIFE_FORCE_F,
 SC_EXTRACT_WHITE_POTION_Z,
 SC_VITATA_500,
 SC_EXTRACT_SALAMINE_JUICE,



 SC__REPRODUCE,
 SC__AUTOSHADOWSPELL,
 SC__SHADOWFORM,
 SC__BODYPAINT,
 SC__INVISIBILITY,
 SC__DEADLYINFECT,
 SC__ENERVATION,
 SC__GROOMY,
 SC__IGNORANCE,
 SC__LAZINESS,
 SC__UNLUCKY,
 SC__WEAKNESS,
 SC__STRIPACCESSARY,
 SC__MANHOLE,
 SC__BLOODYLUST,



 SC_CIRCLE_OF_FIRE,
 SC_CIRCLE_OF_FIRE_OPTION,
 SC_FIRE_CLOAK,
 SC_FIRE_CLOAK_OPTION,
 SC_WATER_SCREEN,
 SC_WATER_SCREEN_OPTION,
 SC_WATER_DROP,
 SC_WATER_DROP_OPTION,
 SC_WATER_BARRIER,
 SC_WIND_STEP,
 SC_WIND_STEP_OPTION,
 SC_WIND_CURTAIN,
 SC_WIND_CURTAIN_OPTION,
 SC_ZEPHYR,
 SC_SOLID_SKIN,
 SC_SOLID_SKIN_OPTION,
 SC_STONE_SHIELD,
 SC_STONE_SHIELD_OPTION,
 SC_POWER_OF_GAIA,
 SC_PYROTECHNIC,
 SC_PYROTECHNIC_OPTION,
 SC_HEATER,
 SC_HEATER_OPTION,
 SC_TROPIC,
 SC_TROPIC_OPTION,
 SC_AQUAPLAY,
 SC_AQUAPLAY_OPTION,
 SC_COOLER,
 SC_COOLER_OPTION,
 SC_CHILLY_AIR,
 SC_CHILLY_AIR_OPTION,
 SC_GUST,
 SC_GUST_OPTION,
 SC_BLAST,
 SC_BLAST_OPTION,
 SC_WILD_STORM,
 SC_WILD_STORM_OPTION,
 SC_PETROLOGY,
 SC_PETROLOGY_OPTION,
 SC_CURSED_SOIL,
 SC_CURSED_SOIL_OPTION,
 SC_UPHEAVAL,
 SC_UPHEAVAL_OPTION,
 SC_TIDAL_WEAPON,
 SC_TIDAL_WEAPON_OPTION,
 SC_ROCK_CRUSHER,
 SC_ROCK_CRUSHER_ATK,

 SC_LEADERSHIP,
 SC_GLORYWOUNDS,
 SC_SOULCOLD,
 SC_HAWKEYES,

 SC_ODINS_POWER,

 SC_FIRE_INSIGNIA,
 SC_WATER_INSIGNIA,
 SC_WIND_INSIGNIA,
 SC_EARTH_INSIGNIA,

 SC_PUSH_CART,

 SC_SPELLBOOK1,
 SC_SPELLBOOK2,
 SC_SPELLBOOK3,
 SC_SPELLBOOK4,
 SC_SPELLBOOK5,
 SC_SPELLBOOK6,




 SC_SPELLBOOK7,

 SC_INCMHP,
 SC_INCMSP,
 SC_PARTYFLEE,



 SC_MEIKYOUSISUI,
 SC_KO_JYUMONJIKIRI,
 SC_KYOUGAKU,
 SC_IZAYOI,
 SC_ZENKAI,
 SC_KG_KAGEHUMI,
 SC_KYOMU,
 SC_KAGEMUSYA,
 SC_ZANGETSU,
 SC_GENSOU,
 SC_AKAITSUKI,


 SC_STYLE_CHANGE,
 SC_GOLDENE_FERSE,
 SC_ANGRIFFS_MODUS,
 SC_ERASER_CUTTER,
 SC_OVERED_BOOST,
 SC_LIGHT_OF_REGENE,
 SC_VOLCANIC_ASH,
 SC_GRANITIC_ARMOR,
 SC_MAGMA_FLOW,
 SC_PYROCLASTIC,
 SC_NEEDLE_OF_PARALYZE,
 SC_PAIN_KILLER,

 SC_EXTREMITYFIST2,
 SC_RAID,

 SC_DARKCROW = 553,
 SC_FULL_THROTTLE,
 SC_REBOUND,
 SC_UNLIMIT,
 SC_KINGS_GRACE,
 SC_TELEKINESIS_INTENSE,
 SC_OFFERTORIUM,
 SC_FRIGG_SONG,

 SC_ALL_RIDING,
 SC_HANBOK,
 SC_MONSTER_TRANSFORM,
 SC_ANGEL_PROTECT,
 SC_ILLUSIONDOPING,

 SC_MTF_ASPD,
 SC_MTF_RANGEATK,
 SC_MTF_MATK,
 SC_MTF_MLEATKED,
 SC_MTF_CRIDAMAGE,

 SC_MOONSTAR,
 SC_SUPER_STAR,

 SC_OKTOBERFEST,
 SC_STRANGELIGHTS,
 SC_DECORATION_OF_MUSIC,

 SC__MAELSTROM,
 SC__CHAOS,

 SC__FEINTBOMB_MASTER,
 SC_FALLENEMPIRE,
 SC_FLASHCOMBO,


 SC_DEFSET,
 SC_MDEFSET,

 SC_NO_SWITCH_EQUIP,


 SC_MTF_MHP,
 SC_MTF_MSP,
 SC_MTF_PUMPKIN,
 SC_MTF_HITFLEE,

 SC_LJOSALFAR,
 SC_MERMAID_LONGING,

 SC_ACARAJE,
 SC_TARGET_ASPD,


 SC_SKELSCROLL,
 SC_DISTRUCTIONSCROLL,
 SC_ROYALSCROLL,
 SC_IMMUNITYSCROLL,
 SC_MYSTICSCROLL,
 SC_BATTLESCROLL,
 SC_ARMORSCROLL,
 SC_FREYJASCROLL,
 SC_SOULSCROLL,


 SC_QUEST_BUFF1,
 SC_QUEST_BUFF2,
 SC_QUEST_BUFF3,


 SC_GEFFEN_MAGIC1,
 SC_GEFFEN_MAGIC2,
 SC_GEFFEN_MAGIC3,
 SC_FENRIR_CARD,

 SC_ATKER_ASPD,
 SC_ATKER_MOVESPEED,
 SC_FOOD_CRITICALSUCCESSVALUE,
 SC_CUP_OF_BOZA,
 SC_OVERLAPEXPUP,
 SC_MORA_BUFF,


 SC_MVPCARD_TAOGUNKA,
 SC_MVPCARD_MISTRESS,
 SC_MVPCARD_ORCHERO,
 SC_MVPCARD_ORCLORD,

 SC_HAT_EFFECT,
 SC_FLOWERSMOKE,
 SC_FSTONE,
 SC_HAPPINESS_STAR,
 SC_MAPLE_FALLS,
 SC_TIME_ACCESSORY,
 SC_MAGICAL_FEATHER,
 SC_BLOSSOM_FLUTTERING,

 SC_GM_BATTLE,
 SC_GM_BATTLE2,
 SC_2011RWC,
 SC_STR_SCROLL,
 SC_INT_SCROLL,
 SC_STEAMPACK,
 SC_MOVHASTE_POTION,
 SC_MOVESLOW_POTION,
 SC_BUCHEDENOEL,
 SC_PHI_DEMON,
 SC_PROMOTE_HEALTH_RESERCH,
 SC_ENERGY_DRINK_RESERCH,
 SC_MAGIC_CANDY,
 SC_M_LIFEPOTION,
 SC_G_LIFEPOTION,
 SC_MYSTICPOWDER,

 SC_MAX,
} sc_type;


enum si_type {
 SI_BLANK = -1,

 SI_PROVOKE = 0,
 SI_ENDURE = 1,
 SI_TWOHANDQUICKEN = 2,
 SI_CONCENTRATION = 3,
 SI_HIDING = 4,
 SI_CLOAKING = 5,
 SI_ENCHANTPOISON = 6,
 SI_POISONREACT = 7,
 SI_QUAGMIRE = 8,
 SI_ANGELUS = 9,
 SI_BLESSING = 10,
 SI_CRUCIS = 11,
 SI_INC_AGI = 12,
 SI_DEC_AGI = 13,
 SI_SLOWPOISON = 14,
 SI_IMPOSITIO = 15,
 SI_SUFFRAGIUM = 16,
 SI_ASPERSIO = 17,
 SI_BENEDICTIO = 18,
 SI_KYRIE = 19,
 SI_MAGNIFICAT = 20,
 SI_GLORIA = 21,
 SI_LEXAETERNA = 22,
 SI_ADRENALINE = 23,
 SI_WEAPONPERFECT = 24,
 SI_OVERTHRUST = 25,
 SI_MAXIMIZE = 26,
 SI_RIDING = 27,
 SI_FALCON = 28,
 SI_TRICKDEAD = 29,
 SI_SHOUT = 30,
 SI_ENERGYCOAT = 31,
 SI_BROKENARMOR = 32,
 SI_BROKENWEAPON = 33,
 SI_ILLUSION = 34,
 SI_WEIGHTOVER50 = 35,
 SI_WEIGHTOVER90 = 36,
 SI_ATTHASTE_POTION1 = 37,
 SI_ATTHASTE_POTION2 = 38,
 SI_ATTHASTE_POTION3 = 39,
 SI_ATTHASTE_INFINITY = 40,
 SI_MOVHASTE_POTION = 41,
 SI_MOVHASTE_INFINITY = 42,


 SI_ANKLESNARE = 45,
 SI_POSTDELAY = 46,




 SI_NOEQUIPWEAPON = 50,
 SI_NOEQUIPSHIELD = 51,
 SI_NOEQUIPARMOR = 52,
 SI_NOEQUIPHELM = 53,
 SI_PROTECTWEAPON = 54,
 SI_PROTECTSHIELD = 55,
 SI_PROTECTARMOR = 56,
 SI_PROTECTHELM = 57,
 SI_AUTOGUARD = 58,
 SI_REFLECTSHIELD = 59,

 SI_PROVIDENCE = 61,
 SI_DEFENDER = 62,


 SI_AUTOSPELL = 65,


 SI_SPEARQUICKEN = 68,
# 923 "../../../server-code/src/map/status.h"
 SI_EXPLOSIONSPIRITS = 86,
 SI_STEELBODY = 87,
 SI_EXTREMITYFIST = 88,

 SI_PROPERTYFIRE = 90,
 SI_PROPERTYWATER = 91,
 SI_PROPERTYWIND = 92,
 SI_PROPERTYGROUND = 93,

 SI_STOP = 95,

 SI_PROPERTYUNDEAD = 97,






 SI_AURABLADE = 103,
 SI_PARRYING = 104,
 SI_LKCONCENTRATION = 105,
 SI_TENSIONRELAX = 106,
 SI_BERSERK = 107,


 SI_ASSUMPTIO = 110,

 SI_GROUNDMAGIC = 112,
 SI_MAGICPOWER = 113,
 SI_EDP = 114,
 SI_TRUESIGHT = 115,
 SI_WINDWALK = 116,
 SI_MELTDOWN = 117,
 SI_CARTBOOST = 118,

 SI_SWORDREJECT = 120,
 SI_MARIONETTE_MASTER = 121,
 SI_MARIONETTE = 122,
 SI_MOON = 123,
 SI_BLOODING = 124,
 SI_JOINTBEAT = 125,




 SI_PROTECTEXP = 130,

 SI_AUTOBERSERK = 132,
 SI_RUN = 133,
 SI_TING = 134,
 SI_STORMKICK_ON = 135,
 SI_STORMKICK_READY = 136,
 SI_DOWNKICK_ON = 137,
 SI_DOWNKICK_READY = 138,
 SI_TURNKICK_ON = 139,
 SI_TURNKICK_READY = 140,
 SI_COUNTER_ON = 141,
 SI_COUNTER_READY = 142,
 SI_DODGE_ON = 143,
 SI_DODGE_READY = 144,
 SI_STRUP = 145,
 SI_PROPERTYDARK = 146,
 SI_ADRENALINE2 = 147,
 SI_PROPERTYTELEKINESIS = 148,
 SI_SOULLINK = 149,

 SI_PLUSATTACKPOWER = 150,
 SI_PLUSMAGICPOWER = 151,
 SI_DEVIL1 = 152,
 SI_KAITE = 153,


 SI_KAIZEL = 156,
 SI_KAAHI = 157,
 SI_KAUPE = 158,
 SI_SMA_READY = 159,
 SI_SKE = 160,
 SI_ONEHANDQUICKEN = 161,



 SI_SG_SUN_WARM = 165,



 SI_SUN_COMFORT = 169,
 SI_MOON_COMFORT = 170,
 SI_STAR_COMFORT = 171,
# 1020 "../../../server-code/src/map/status.h"
 SI_PRESERVE = 181,
 SI_INCSTR = 182,

 SI_CLAIRVOYANCE = 184,
 SI_MOVESLOW_POTION = 185,
 SI_DOUBLECASTING = 186,

 SI_OVERTHRUSTMAX = 188,


 SI_TAROTCARD = 191,





 SI_CR_SHRINK = 197,
 SI_WZ_SIGHTBLASTER = 198,
 SI_DC_WINKCHARM = 199,

 SI_RG_CCONFINE_M = 200,
 SI_RG_CCONFINE_S = 201,

 SI_GS_MADNESSCANCEL = 203,
 SI_GS_GATLINGFEVER = 204,
 SI_EARTHSCROLL = 205,
 SI_NJ_UTSUSEMI = 206,
 SI_NJ_BUNSINJYUTSU = 207,
 SI_NJ_NEN = 208,
 SI_GS_ADJUSTMENT = 209,
 SI_GS_ACCURACY = 210,
 SI_NJ_SUITON = 211,
# 1081 "../../../server-code/src/map/status.h"
 SI_FOOD_STR = 241,
 SI_FOOD_AGI = 242,
 SI_FOOD_VIT = 243,
 SI_FOOD_DEX = 244,
 SI_FOOD_INT = 245,
 SI_FOOD_LUK = 246,
 SI_FOOD_BASICAVOIDANCE = 247,
 SI_FOOD_BASICHIT = 248,
 SI_FOOD_CRITICALSUCCESSVALUE = 249,

 SI_CASH_PLUSEXP = 250,
 SI_CASH_DEATHPENALTY = 251,
 SI_CASH_RECEIVEITEM = 252,
 SI_CASH_BOSS_ALARM = 253,
# 1112 "../../../server-code/src/map/status.h"
 SI_FOOD_STR_CASH = 271,
 SI_FOOD_AGI_CASH = 272,
 SI_FOOD_VIT_CASH = 273,
 SI_FOOD_DEX_CASH = 274,
 SI_FOOD_INT_CASH = 275,
 SI_FOOD_LUK_CASH = 276,
 SI_MER_FLEE = 277,
 SI_MER_ATK = 278,
 SI_MER_HP = 279,
 SI_MER_SP = 280,
 SI_MER_HIT = 281,
 SI_SLOWCAST = 282,



 SI_CRITICALWOUND = 286,


 SI_MOVHASTE_HORSE = 289,
 SI_PROTECT_DEF = 290,
 SI_PROTECT_MDEF = 291,
 SI_HEALPLUS = 292,
 SI_S_LIFEPOTION = 293,
 SI_L_LIFEPOTION = 294,
 SI_CRITICALPERCENT = 295,
 SI_PLUSAVOIDVALUE = 296,
 SI_ATKER_ASPD = 297,
 SI_TARGET_ASPD = 298,
 SI_ATKER_MOVESPEED = 299,

 SI_ATKER_BLOOD = 300,
 SI_TARGET_BLOOD = 301,
 SI_ARMOR_PROPERTY = 302,

 SI_HELLPOWER = 304,
 SI_STEAMPACK = 305,





 SI_INVINCIBLE = 311,
 SI_CASH_PLUSONLYJOBEXP = 312,
 SI_PARTYFLEE = 313,
 SI_ANGEL_PROTECT = 314,

 SI_ENCHANTBLADE = 316,
 SI_DEATHBOUND = 317,
 SI_REFRESH = 318,
 SI_GIANTGROWTH = 319,
 SI_STONEHARDSKIN = 320,
 SI_VITALITYACTIVATION = 321,
 SI_FIGHTINGSPIRIT = 322,
 SI_ABUNDANCE = 323,
 SI_REUSE_MILLENNIUMSHIELD = 324,
 SI_REUSE_CRUSHSTRIKE = 325,
 SI_REUSE_REFRESH = 326,
 SI_REUSE_STORMBLAST = 327,
 SI_VENOMIMPRESS = 328,
 SI_EPICLESIS = 329,
 SI_ORATIO = 330,
 SI_LAUDAAGNUS = 331,
 SI_LAUDARAMUS = 332,
 SI_CLOAKINGEXCEED = 333,
 SI_HALLUCINATIONWALK = 334,
 SI_HALLUCINATIONWALK_POSTDELAY = 335,
 SI_RENOVATIO = 336,
 SI_WEAPONBLOCKING = 337,
 SI_WEAPONBLOCKING_POSTDELAY = 338,
 SI_ROLLINGCUTTER = 339,
 SI_EXPIATIO = 340,
 SI_POISONINGWEAPON = 341,
 SI_TOXIN = 342,
 SI_PARALYSE = 343,
 SI_VENOMBLEED = 344,
 SI_MAGICMUSHROOM = 345,
 SI_DEATHHURT = 346,
 SI_PYREXIA = 347,
 SI_OBLIVIONCURSE = 348,
 SI_LEECHESEND = 349,

 SI_DUPLELIGHT = 350,
 SI_FROSTMISTY = 351,
 SI_FEARBREEZE = 352,
 SI_ELECTRICSHOCKER = 353,
 SI_MARSHOFABYSS = 354,
 SI_RECOGNIZEDSPELL = 355,
 SI_STASIS = 356,
 SI_WUGRIDER = 357,
 SI_WUGDASH = 358,
 SI_WUGBITE = 359,
 SI_CAMOUFLAGE = 360,
 SI_ACCELERATION = 361,
 SI_HOVERING = 362,
 SI_SPHERE_1 = 363,
 SI_SPHERE_2 = 364,
 SI_SPHERE_3 = 365,
 SI_SPHERE_4 = 366,
 SI_SPHERE_5 = 367,
 SI_MVPCARD_TAOGUNKA = 368,
 SI_MVPCARD_MISTRESS = 369,
 SI_MVPCARD_ORCHERO = 370,
 SI_MVPCARD_ORCLORD = 371,
 SI_OVERHEAT_LIMITPOINT = 372,
 SI_OVERHEAT = 373,
 SI_SHAPESHIFT = 374,
 SI_INFRAREDSCAN = 375,
 SI_MAGNETICFIELD = 376,
 SI_NEUTRALBARRIER = 377,
 SI_NEUTRALBARRIER_MASTER = 378,
 SI_STEALTHFIELD = 379,
 SI_STEALTHFIELD_MASTER = 380,
 SI_MANU_ATK = 381,
 SI_MANU_DEF = 382,
 SI_SPL_ATK = 383,
 SI_SPL_DEF = 384,
 SI_REPRODUCE = 385,
 SI_MANU_MATK = 386,
 SI_SPL_MATK = 387,
 SI_STR_SCROLL = 388,
 SI_INT_SCROLL = 389,
 SI_LG_REFLECTDAMAGE = 390,
 SI_FORCEOFVANGUARD = 391,
 SI_BUCHEDENOEL = 392,
 SI_AUTOSHADOWSPELL = 393,
 SI_SHADOWFORM = 394,
 SI_RAID = 395,
 SI_SHIELDSPELL_DEF = 396,
 SI_SHIELDSPELL_MDEF = 397,
 SI_SHIELDSPELL_REF = 398,
 SI_BODYPAINT = 399,

 SI_EXEEDBREAK = 400,
 SI_ADORAMUS = 401,
 SI_PRESTIGE = 402,
 SI_INVISIBILITY = 403,
 SI_DEADLYINFECT = 404,
 SI_BANDING = 405,
 SI_EARTHDRIVE = 406,
 SI_INSPIRATION = 407,
 SI_ENERVATION = 408,
 SI_GROOMY = 409,
 SI_RAISINGDRAGON = 410,
 SI_IGNORANCE = 411,
 SI_LAZINESS = 412,
 SI_LIGHTNINGWALK = 413,
 SI_ACARAJE = 414,
 SI_UNLUCKY = 415,
 SI_CURSEDCIRCLE_ATKER = 416,
 SI_CURSEDCIRCLE_TARGET = 417,
 SI_WEAKNESS = 418,
 SI_CRESCENTELBOW = 419,
 SI_NOEQUIPACCESSARY = 420,
 SI_STRIPACCESSARY = 421,
 SI_MANHOLE = 422,
 SI_POPECOOKIE = 423,
 SI_FALLENEMPIRE = 424,
 SI_GENTLETOUCH_ENERGYGAIN = 425,
 SI_GENTLETOUCH_CHANGE = 426,
 SI_GENTLETOUCH_REVITALIZE = 427,
 SI_BLOODYLUST = 428,
 SI_SWINGDANCE = 429,
 SI_SYMPHONYOFLOVERS = 430,
 SI_PROPERTYWALK = 431,
 SI_SPELLFIST = 432,
 SI_NETHERWORLD = 433,
 SI_SIREN = 434,
 SI_DEEPSLEEP = 435,
 SI_SIRCLEOFNATURE = 436,
 SI_COLD = 437,
 SI_GLOOMYDAY = 438,
 SI_SONG_OF_MANA = 439,
 SI_CLOUDKILL = 440,
 SI_DANCEWITHWUG = 441,
 SI_RUSHWINDMILL = 442,
 SI_ECHOSONG = 443,
 SI_HARMONIZE = 444,
 SI_STRIKING = 445,

 SI_MOONLITSERENADE = 447,
 SI_SATURDAYNIGHTFEVER = 448,
 SI_SITDOWN_FORCE = 449,

 SI_ANALYZE = 450,
 SI_LERADSDEW = 451,
 SI_MELODYOFSINK = 452,
 SI_WARCRYOFBEYOND = 453,
 SI_UNLIMITEDHUMMINGVOICE = 454,
 SI_SPELLBOOK1 = 455,
 SI_SPELLBOOK2 = 456,
 SI_SPELLBOOK3 = 457,
 SI_FREEZE_SP = 458,
 SI_GN_TRAINING_SWORD = 459,
 SI_GN_REMODELING_CART = 460,
 SI_CARTSBOOST = 461,
 SI_FIXEDCASTINGTM_REDUCE = 462,
 SI_THORNTRAP = 463,
 SI_BLOODSUCKER = 464,
 SI_SPORE_EXPLOSION = 465,
 SI_DEMONIC_FIRE = 466,
 SI_FIRE_EXPANSION_SMOKE_POWDER = 467,
 SI_FIRE_EXPANSION_TEAR_GAS = 468,
 SI_BLOCKING_PLAY = 469,
 SI_MANDRAGORA = 470,
 SI_ACTIVATE = 471,
 SI_SECRAMENT = 472,
 SI_ASSUMPTIO2 = 473,
 SI_TK_SEVENWIND = 474,
 SI_LIMIT_ODINS_RECALL = 475,
 SI_STOMACHACHE = 476,
 SI_MYSTERIOUS_POWDER = 477,
 SI_MELON_BOMB = 478,
 SI_BANANA_BOMB_SITDOWN_POSTDELAY = 479,
 SI_PROMOTE_HEALTH_RESERCH = 480,
 SI_ENERGY_DRINK_RESERCH = 481,
 SI_EXTRACT_WHITE_POTION_Z = 482,
 SI_VITATA_500 = 483,
 SI_EXTRACT_SALAMINE_JUICE = 484,
 SI_BOOST500 = 485,
 SI_FULL_SWING_K = 486,
 SI_MANA_PLUS = 487,
 SI_MUSTLE_M = 488,
 SI_LIFE_FORCE_F = 489,
 SI_VACUUM_EXTREME = 490,
 SI_SAVAGE_STEAK = 491,
 SI_COCKTAIL_WARG_BLOOD = 492,
 SI_MINOR_BBQ = 493,
 SI_SIROMA_ICE_TEA = 494,
 SI_DROCERA_HERB_STEAMED = 495,
 SI_PUTTI_TAILS_NOODLES = 496,
 SI_BANANA_BOMB = 497,
 SI_SUMMON_AGNI = 498,
 SI_SPELLBOOK4 = 499,

 SI_SPELLBOOK5 = 500,
 SI_SPELLBOOK6 = 501,
 SI_SPELLBOOK7 = 502,
 SI_ELEMENTAL_AGGRESSIVE = 503,
 SI_RETURN_TO_ELDICASTES = 504,
 SI_BANDING_DEFENCE = 505,
 SI_SKELSCROLL = 506,
 SI_DISTRUCTIONSCROLL = 507,
 SI_ROYALSCROLL = 508,
 SI_IMMUNITYSCROLL = 509,
 SI_MYSTICSCROLL = 510,
 SI_BATTLESCROLL = 511,
 SI_ARMORSCROLL = 512,
 SI_FREYJASCROLL = 513,
 SI_SOULSCROLL = 514,
 SI_CIRCLE_OF_FIRE = 515,
 SI_CIRCLE_OF_FIRE_OPTION = 516,
 SI_FIRE_CLOAK = 517,
 SI_FIRE_CLOAK_OPTION = 518,
 SI_WATER_SCREEN = 519,
 SI_WATER_SCREEN_OPTION = 520,
 SI_WATER_DROP = 521,
 SI_WATER_DROP_OPTION = 522,
 SI_WIND_STEP = 523,
 SI_WIND_STEP_OPTION = 524,
 SI_WIND_CURTAIN = 525,
 SI_WIND_CURTAIN_OPTION = 526,
 SI_WATER_BARRIER = 527,
 SI_ZEPHYR = 528,
 SI_SOLID_SKIN = 529,
 SI_SOLID_SKIN_OPTION = 530,
 SI_STONE_SHIELD = 531,
 SI_STONE_SHIELD_OPTION = 532,
 SI_POWER_OF_GAIA = 533,





 SI_PYROTECHNIC = 539,
 SI_PYROTECHNIC_OPTION = 540,
 SI_HEATER = 541,
 SI_HEATER_OPTION = 542,
 SI_TROPIC = 543,
 SI_TROPIC_OPTION = 544,
 SI_AQUAPLAY = 545,
 SI_AQUAPLAY_OPTION = 546,
 SI_COOLER = 547,
 SI_COOLER_OPTION = 548,
 SI_CHILLY_AIR = 549,

 SI_CHILLY_AIR_OPTION = 550,
 SI_GUST = 551,
 SI_GUST_OPTION = 552,
 SI_BLAST = 553,
 SI_BLAST_OPTION = 554,
 SI_WILD_STORM = 555,
 SI_WILD_STORM_OPTION = 556,
 SI_PETROLOGY = 557,
 SI_PETROLOGY_OPTION = 558,
 SI_CURSED_SOIL = 559,
 SI_CURSED_SOIL_OPTION = 560,
 SI_UPHEAVAL = 561,
 SI_UPHEAVAL_OPTION = 562,
 SI_TIDAL_WEAPON = 563,
 SI_TIDAL_WEAPON_OPTION = 564,
 SI_ROCK_CRUSHER = 565,
 SI_ROCK_CRUSHER_ATK = 566,
 SI_FIRE_INSIGNIA = 567,
 SI_WATER_INSIGNIA = 568,
 SI_WIND_INSIGNIA = 569,
 SI_EARTH_INSIGNIA = 570,
 SI_EQUIPED_FLOOR = 571,
 SI_GUARDIAN_RECALL = 572,
 SI_MORA_BUFF = 573,
 SI_REUSE_LIMIT_G = 574,
 SI_REUSE_LIMIT_H = 575,
 SI_NEEDLE_OF_PARALYZE = 576,
 SI_PAIN_KILLER = 577,
 SI_G_LIFEPOTION = 578,
 SI_VITALIZE_POTION = 579,
 SI_LIGHT_OF_REGENE = 580,
 SI_OVERED_BOOST = 581,
 SI_SILENT_BREEZE = 582,
 SI_ODINS_POWER = 583,
 SI_STYLE_CHANGE = 584,
 SI_SONIC_CLAW_POSTDELAY = 585,
# 1443 "../../../server-code/src/map/status.h"
 SI_SILVERVEIN_RUSH_POSTDELAY = 596,
 SI_MIDNIGHT_FRENZY_POSTDELAY = 597,
 SI_GOLDENE_FERSE = 598,
 SI_ANGRIFFS_MODUS = 599,

 SI_TINDER_BREAKER = 600,
 SI_TINDER_BREAKER_POSTDELAY = 601,
 SI_CBC = 602,
 SI_CBC_POSTDELAY = 603,
 SI_EQC = 604,
 SI_MAGMA_FLOW = 605,
 SI_GRANITIC_ARMOR = 606,
 SI_PYROCLASTIC = 607,
 SI_VOLCANIC_ASH = 608,
 SI_SPIRITS_SAVEINFO1 = 609,
 SI_SPIRITS_SAVEINFO2 = 610,
 SI_MAGIC_CANDY = 611,
 SI_SEARCH_STORE_INFO = 612,
 SI_ALL_RIDING = 613,
 SI_ALL_RIDING_REUSE_LIMIT = 614,
 SI_MACRO = 615,
 SI_MACRO_POSTDELAY = 616,
 SI_BEER_BOTTLE_CAP = 617,
 SI_OVERLAPEXPUP = 618,
 SI_PC_IZ_DUN05 = 619,
 SI_CRUSHSTRIKE = 620,
 SI_MONSTER_TRANSFORM = 621,
 SI_SIT = 622,
 SI_ONAIR = 623,
 SI_MTF_ASPD = 624,
 SI_MTF_RANGEATK = 625,
 SI_MTF_MATK = 626,
 SI_MTF_MLEATKED = 627,
 SI_MTF_CRIDAMAGE = 628,
 SI_REUSE_LIMIT_MTF = 629,
 SI_MACRO_PERMIT = 630,
 SI_MACRO_PLAY = 631,
 SI_SKF_CAST = 632,
 SI_SKF_ASPD = 633,
 SI_SKF_ATK = 634,
 SI_SKF_MATK = 635,
 SI_REWARD_PLUSONLYJOBEXP = 636,
 SI_HANDICAPSTATE_NORECOVER = 637,
 SI_SET_NUM_DEF = 638,
 SI_SET_NUM_MDEF = 639,
 SI_SET_PER_DEF = 640,
 SI_SET_PER_MDEF = 641,
 SI_PARTYBOOKING_SEARCH_DEALY = 642,
 SI_PARTYBOOKING_REGISTER_DEALY = 643,
 SI_PERIOD_TIME_CHECK_DETECT_SKILL = 644,
 SI_KO_JYUMONJIKIRI = 645,
 SI_MEIKYOUSISUI = 646,
 SI_ATTHASTE_CASH = 647,
 SI_EQUIPPED_DIVINE_ARMOR = 648,
 SI_EQUIPPED_HOLY_ARMOR = 649,

 SI_2011RWC = 650,
 SI_KYOUGAKU = 651,
 SI_IZAYOI = 652,
 SI_ZENKAI = 653,
 SI_KG_KAGEHUMI = 654,
 SI_KYOMU = 655,
 SI_KAGEMUSYA = 656,
 SI_ZANGETSU = 657,
 SI_PHI_DEMON = 658,
 SI_GENSOU = 659,
 SI_AKAITSUKI = 660,
 SI_TETANY = 661,
 SI_GM_BATTLE = 662,
 SI_GM_BATTLE2 = 663,
 SI_2011RWC_SCROLL = 664,
 SI_ACTIVE_MONSTER_TRANSFORM = 665,
 SI_MYSTICPOWDER = 666,
 SI_ECLAGE_RECALL = 667,
 SI_ENTRY_QUEUE_APPLY_DELAY = 668,
 SI_REUSE_LIMIT_ECL = 669,
 SI_M_LIFEPOTION = 670,
 SI_ENTRY_QUEUE_NOTIFY_ADMISSION_TIME_OUT = 671,
 SI_UNKNOWN_NAME = 672,
 SI_ON_PUSH_CART = 673,
 SI_HAT_EFFECT = 674,
 SI_FLOWER_LEAF = 675,
 SI_RAY_OF_PROTECTION = 676,
 SI_GLASTHEIM_ATK = 677,
 SI_GLASTHEIM_DEF = 678,
 SI_GLASTHEIM_HEAL = 679,
 SI_GLASTHEIM_HIDDEN = 680,
 SI_GLASTHEIM_STATE = 681,
 SI_GLASTHEIM_ITEMDEF = 682,
 SI_GLASTHEIM_HPSP = 683,
 SI_HOMUN_SKILL_POSTDELAY = 684,
 SI_ALMIGHTY = 685,
 SI_GVG_GIANT = 686,
 SI_GVG_GOLEM = 687,
 SI_GVG_STUN = 688,
 SI_GVG_STONE = 689,
 SI_GVG_FREEZ = 690,
 SI_GVG_SLEEP = 691,
 SI_GVG_CURSE = 692,
 SI_GVG_SILENCE = 693,
 SI_GVG_BLIND = 694,
 SI_CLIENT_ONLY_EQUIP_ARROW = 695,
 SI_CLAN_INFO = 696,
 SI_JP_EVENT01 = 697,
 SI_JP_EVENT02 = 698,
 SI_JP_EVENT03 = 699,

 SI_JP_EVENT04 = 700,
 SI_TELEPORT_FIXEDCASTINGDELAY = 701,
 SI_GEFFEN_MAGIC1 = 702,
 SI_GEFFEN_MAGIC2 = 703,
 SI_GEFFEN_MAGIC3 = 704,
 SI_QUEST_BUFF1 = 705,
 SI_QUEST_BUFF2 = 706,
 SI_QUEST_BUFF3 = 707,
 SI_REUSE_LIMIT_RECALL = 708,
 SI_SAVEPOSITION = 709,
 SI_HANDICAPSTATE_ICEEXPLO = 710,
 SI_FENRIR_CARD = 711,
 SI_REUSE_LIMIT_ASPD_POTION = 712,
 SI_MAXPAIN = 713,
 SI_PC_STOP = 714,
 SI_FRIGG_SONG = 715,
 SI_OFFERTORIUM = 716,
 SI_TELEKINESIS_INTENSE = 717,
 SI_MOONSTAR = 718,
 SI_STRANGELIGHTS = 719,
 SI_FULL_THROTTLE = 720,
 SI_REBOUND = 721,
 SI_UNLIMIT = 722,
 SI_KINGS_GRACE = 723,
 SI_ITEM_ATKMAX = 724,
 SI_ITEM_ATKMIN = 725,
 SI_ITEM_MATKMAX = 726,
 SI_ITEM_MATKMIN = 727,
 SI_SUPER_STAR = 728,
 SI_HIGH_RANKER = 729,
 SI_DARKCROW = 730,
 SI_2013_VALENTINE1 = 731,
 SI_2013_VALENTINE2 = 732,
 SI_2013_VALENTINE3 = 733,
 SI_ILLUSIONDOPING = 734,

 SI_CHILL = 736,
 SI_BURNT = 737,


 SI_FLASHCOMBO = 740,
# 1602 "../../../server-code/src/map/status.h"
 SI_CUP_OF_BOZA = 751,
 SI_B_TRAP = 752,
 SI_E_CHAIN = 753,
 SI_E_QD_SHOT_READY = 754,
 SI_C_MARKER = 755,
 SI_H_MINE = 756,
 SI_H_MINE_SPLASH = 757,
 SI_P_ALTER = 758,
 SI_HEAT_BARREL = 759,
 SI_ANTI_M_BLAST = 760,
 SI_SLUGSHOT = 761,
 SI_SWORDCLAN = 762,
 SI_ARCWANDCLAN = 763,
 SI_GOLDENMACECLAN = 764,
 SI_CROSSBOWCLAN = 765,
 SI_PACKING_ENVELOPE1 = 766,
 SI_PACKING_ENVELOPE2 = 767,
 SI_PACKING_ENVELOPE3 = 768,
 SI_PACKING_ENVELOPE4 = 769,
 SI_PACKING_ENVELOPE5 = 770,
 SI_PACKING_ENVELOPE6 = 771,
 SI_PACKING_ENVELOPE7 = 772,
 SI_PACKING_ENVELOPE8 = 773,
 SI_PACKING_ENVELOPE9 = 774,
 SI_PACKING_ENVELOPE10 = 775,
 SI_GLASTHEIM_TRANS = 776,

 SI_HEAT_BARREL_AFTER = 778,
 SI_DECORATION_OF_MUSIC = 779,
# 1644 "../../../server-code/src/map/status.h"
 SI_MTF_MHP = 793,
 SI_MTF_MSP = 794,
 SI_MTF_PUMPKIN = 795,
 SI_MTF_HITFLEE = 796,
# 1674 "../../../server-code/src/map/status.h"
 SI_FLOWERSMOKE = 822,
 SI_FSTONE = 823,


 SI_LJOSALFAR = 826,
# 1701 "../../../server-code/src/map/status.h"
 SI_HAPPINESS_STAR = 849,
# 1710 "../../../server-code/src/map/status.h"
 SI_MAPLE_FALLS = 857,





 SI_MERMAID_LONGING = 863,
 SI_MAGICAL_FEATHER = 864,







 SI_TIME_ACCESSORY = 872,
# 1748 "../../../server-code/src/map/status.h"
 SI_BLOSSOM_FLUTTERING = 895,
# 1796 "../../../server-code/src/map/status.h"
 SI_MAX,
};


enum e_joint_break
{
 BREAK_ANKLE = 0x01,
 BREAK_WRIST = 0x02,
 BREAK_KNEE = 0x04,
 BREAK_SHOULDER = 0x08,
 BREAK_WAIST = 0x10,
 BREAK_NECK = 0x20,
 BREAK_FLAGS = BREAK_ANKLE | BREAK_WRIST | BREAK_KNEE | BREAK_SHOULDER | BREAK_WAIST | BREAK_NECK,
};






enum e_mode
{
 MD_NONE = 0x00000000,
 MD_CANMOVE = 0x00000001,
 MD_LOOTER = 0x00000002,
 MD_AGGRESSIVE = 0x00000004,
 MD_ASSIST = 0x00000008,
 MD_CASTSENSOR_IDLE = 0x00000010,
 MD_BOSS = 0x00000020,
 MD_PLANT = 0x00000040,
 MD_CANATTACK = 0x00000080,
 MD_DETECTOR = 0x00000100,
 MD_CASTSENSOR_CHASE = 0x00000200,
 MD_CHANGECHASE = 0x00000400,
 MD_ANGRY = 0x00000800,
 MD_CHANGETARGET_MELEE = 0x00001000,
 MD_CHANGETARGET_CHASE = 0x00002000,
 MD_TARGETWEAK = 0x00004000,
 MD_NOKNOCKBACK = 0x00008000,


 MD_MASK = 0x7FFFFFFF,
};





enum {
 OPT1_STONE = 1,
 OPT1_FREEZE,
 OPT1_STUN,
 OPT1_SLEEP,

 OPT1_STONEWAIT=6,
 OPT1_BURNING,
 OPT1_IMPRISON,
 OPT1_CRYSTALIZE,
};


enum {
 OPT2_POISON = 0x0001,
 OPT2_CURSE = 0x0002,
 OPT2_SILENCE = 0x0004,
 OPT2_SIGNUMCRUCIS = 0x0008,
 OPT2_BLIND = 0x0010,
 OPT2_ANGELUS = 0x0020,
 OPT2_BLEEDING = 0x0040,
 OPT2_DPOISON = 0x0080,
 OPT2_FEAR = 0x0100,
};


enum {
 OPT3_NORMAL = 0x00000000,
 OPT3_QUICKEN = 0x00000001,
 OPT3_OVERTHRUST = 0x00000002,
 OPT3_ENERGYCOAT = 0x00000004,
 OPT3_EXPLOSIONSPIRITS = 0x00000008,
 OPT3_STEELBODY = 0x00000010,
 OPT3_BLADESTOP = 0x00000020,
 OPT3_AURABLADE = 0x00000040,
 OPT3_BERSERK = 0x00000080,
 OPT3_LIGHTBLADE = 0x00000100,
 OPT3_MOONLIT = 0x00000200,
 OPT3_MARIONETTE = 0x00000400,
 OPT3_ASSUMPTIO = 0x00000800,
 OPT3_WARM = 0x00001000,
 OPT3_KAITE = 0x00002000,
 OPT3_BUNSIN = 0x00004000,
 OPT3_SOULLINK = 0x00008000,
 OPT3_UNDEAD = 0x00010000,
 OPT3_CONTRACT = 0x00020000,
};


enum manner_flags
{
 MANNER_NOCHAT = 0x01,
 MANNER_NOSKILL = 0x02,
 MANNER_NOCOMMAND = 0x04,
 MANNER_NOITEM = 0x08,
 MANNER_NOROOM = 0x10,
};


enum scb_flag
{
 SCB_NONE = 0x00000000,
 SCB_BASE = 0x00000001,
 SCB_MAXHP = 0x00000002,
 SCB_MAXSP = 0x00000004,
 SCB_STR = 0x00000008,
 SCB_AGI = 0x00000010,
 SCB_VIT = 0x00000020,
 SCB_INT = 0x00000040,
 SCB_DEX = 0x00000080,
 SCB_LUK = 0x00000100,
 SCB_BATK = 0x00000200,
 SCB_WATK = 0x00000400,
 SCB_MATK = 0x00000800,
 SCB_HIT = 0x00001000,
 SCB_FLEE = 0x00002000,
 SCB_DEF = 0x00004000,
 SCB_DEF2 = 0x00008000,
 SCB_MDEF = 0x00010000,
 SCB_MDEF2 = 0x00020000,
 SCB_SPEED = 0x00040000,
 SCB_ASPD = 0x00080000,
 SCB_DSPD = 0x00100000,
 SCB_CRI = 0x00200000,
 SCB_FLEE2 = 0x00400000,
 SCB_ATK_ELE = 0x00800000,
 SCB_DEF_ELE = 0x01000000,
 SCB_MODE = 0x02000000,
 SCB_SIZE = 0x04000000,
 SCB_RACE = 0x08000000,
 SCB_RANGE = 0x10000000,
 SCB_REGEN = 0x20000000,
 SCB_DYE = 0x40000000,




 SCB_BATTLE = 0x3FFFFFFE,
 SCB_ALL = 0x3FFFFFFF
};


enum e_regen {
 RGN_HP = 0x01,
 RGN_SP = 0x02,
 RGN_SHP = 0x04,
 RGN_SSP = 0x08,
};

enum e_status_calc_opt {
 SCO_NONE = 0x0,
 SCO_FIRST = 0x1,
 SCO_FORCE = 0x2,
};
# 1969 "../../../server-code/src/map/status.h"
typedef struct weapon_atk {
 unsigned short atk, atk2;
 unsigned short range;
 unsigned char ele;

 unsigned short matk;
 unsigned char wlv;

} weapon_atk;


struct status_data {
 unsigned int
  hp, sp,
  max_hp, max_sp;
 unsigned short
  str, agi, vit, int_, dex, luk,
  batk,
  matk_min, matk_max,
  speed,
  amotion, adelay, dmotion;
 uint32 mode;
 short
  hit, flee, cri, flee2,
  def2, mdef2,

  aspd_rate2,

  aspd_rate;



 defType def,mdef;

 unsigned char
  def_ele, ele_lv,
  size, race;

 struct weapon_atk rhw, lhw;

 int equip_atk;

};


struct regen_data_sub {
 unsigned short
  hp,sp;


 struct {
  unsigned int hp,sp;
 } tick;


 struct {
  unsigned char hp,sp;
 } rate;
};

struct regen_data {

 unsigned short flag;
 unsigned short
  hp,sp,shp,ssp;


 struct {
  unsigned int hp,sp,shp,ssp;
 } tick;


 struct {
  unsigned char
  hp,sp,shp,ssp;
 } rate;

 struct {
  unsigned walk:1;
  unsigned gc:1;
  unsigned overweight :2;
  unsigned block :2;
 } state;


 struct regen_data_sub *sregen, *ssregen;
};

struct sc_display_entry {
 enum sc_type type;
 int val1,val2,val3;
};

struct status_change_entry {
 int timer;
 int val1,val2,val3,val4;
 
# 2065 "../../../server-code/src/map/status.h" 3 4
_Bool 
# 2065 "../../../server-code/src/map/status.h"
     infinite_duration;
};

struct status_change {
 unsigned int option;
 unsigned int opt3;
 unsigned short opt1;
 unsigned short opt2;
 unsigned char count;

 unsigned char jb_flag;

 short comet_x, comet_y;






 unsigned char bs_counter;
 unsigned char fv_counter;
 struct status_change_entry *data[SC_MAX];
};
# 2154 "../../../server-code/src/map/status.h"
struct s_refine_info {
 int chance[20];
 int bonus[20];
 int randombonus_max[20];
};

struct s_status_dbs {
int8 HERC__zeroed_block_BEGIN;
 int max_weight_base[(JOB_MAX - JOB_NOVICE_HIGH + JOB_MAX_BASIC)];
 int HP_table[(JOB_MAX - JOB_NOVICE_HIGH + JOB_MAX_BASIC)][175 + 1];
 int SP_table[(JOB_MAX - JOB_NOVICE_HIGH + JOB_MAX_BASIC)][175 + 1];
 int aspd_base[(JOB_MAX - JOB_NOVICE_HIGH + JOB_MAX_BASIC)][MAX_SINGLE_WEAPON_TYPE+1];
 sc_type Skill2SCTable[1478];
 int IconChangeTable[SC_MAX];
 unsigned int ChangeFlagTable[SC_MAX];
 int SkillChangeTable[SC_MAX];
 int RelevantBLTypes[SI_MAX];
 
# 2171 "../../../server-code/src/map/status.h" 3 4
_Bool 
# 2171 "../../../server-code/src/map/status.h"
     DisplayType[SC_MAX];

 struct s_refine_info refine_info[REFINE_TYPE_MAX];

 int atkmods[3][MAX_SINGLE_WEAPON_TYPE];
 char job_bonus[(JOB_MAX - JOB_NOVICE_HIGH + JOB_MAX_BASIC)][175];
 sc_conf_type sc_conf[SC_MAX];
int8 HERC__zeroed_block_END;
};






struct status_interface {


 int current_equip_item_index;
 int current_equip_card_id;

 struct s_status_dbs *dbs;

 struct eri *data_ers;
 struct status_data dummy;
 int64 natural_heal_prev_tick;
 unsigned int natural_heal_diff_tick;

 int (*init) (
# 2199 "../../../server-code/src/map/status.h" 3 4
             _Bool 
# 2199 "../../../server-code/src/map/status.h"
                  minimal);
 void (*final) (void);

 int (*get_refine_chance) (enum refine_type wlv, int refine);

 sc_type (*skill2sc) (int skill_id);
 int (*sc2skill) (sc_type sc);
 unsigned int (*sc2scb_flag) (sc_type sc);
 int (*type2relevant_bl_types) (int type);
 int (*get_sc_type) (sc_type idx);
 int (*damage) (struct block_list *src,struct block_list *target,int64 hp,int64 sp, int walkdelay, int flag);

 int (*charge) (struct block_list* bl, int64 hp, int64 sp);
 int (*percent_change) (struct block_list *src,struct block_list *target,signed char hp_rate, signed char sp_rate, int flag);

 int (*set_hp) (struct block_list *bl, unsigned int hp, int flag);
 int (*set_sp) (struct block_list *bl, unsigned int sp, int flag);
 int (*heal) (struct block_list *bl,int64 hp,int64 sp, int flag);
 int (*revive) (struct block_list *bl, unsigned char per_hp, unsigned char per_sp);
 int (*fixed_revive) (struct block_list *bl, unsigned int per_hp, unsigned int per_sp);
 struct regen_data * (*get_regen_data) (struct block_list *bl);
 struct status_data * (*get_status_data) (struct block_list *bl);
 struct status_data * (*get_base_status) (struct block_list *bl);
 const char *(*get_name) (const struct block_list *bl);
 int (*get_class) (const struct block_list *bl);
 int (*get_lv) (const struct block_list *bl);
 defType (*get_def) (struct block_list *bl);
 unsigned short (*get_speed) (struct block_list *bl);
 unsigned char (*calc_attack_element) (struct block_list *bl, struct status_change *sc, int element);
 int (*get_party_id) (const struct block_list *bl);
 int (*get_guild_id) (const struct block_list *bl);
 int (*get_emblem_id) (const struct block_list *bl);
 int (*get_mexp) (const struct block_list *bl);
 int (*get_race2) (const struct block_list *bl);
 struct view_data * (*get_viewdata) (struct block_list *bl);
 void (*set_viewdata) (struct block_list *bl, int class_);
 void (*change_init) (struct block_list *bl);
 struct status_change * (*get_sc) (struct block_list *bl);
 int (*isdead) (struct block_list *bl);
 int (*isimmune) (struct block_list *bl);
 int (*get_sc_def) (struct block_list *src, struct block_list *bl, enum sc_type type, int rate, int tick, int flag);
 int (*change_start) (struct block_list *src, struct block_list *bl, enum sc_type type, int rate, int val1, int val2, int val3, int val4, int tick, int flag);
 int (*change_end_) (struct block_list* bl, enum sc_type type, int tid, const char* file, int line);
 int (*kaahi_heal_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*change_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*change_timer_sub) (struct block_list* bl, va_list ap);
 int (*change_clear) (struct block_list* bl, int type);
 int (*change_clear_buffs) (struct block_list* bl, int type);
 void (*calc_bl_) (struct block_list *bl, enum scb_flag flag, enum e_status_calc_opt opt);
 int (*calc_mob_) (struct mob_data* md, enum e_status_calc_opt opt);
 int (*calc_pet_) (struct pet_data* pd, enum e_status_calc_opt opt);
 int (*calc_pc_) (struct map_session_data* sd, enum e_status_calc_opt opt);
 void (*calc_pc_additional) (struct map_session_data* sd, enum e_status_calc_opt opt);
 int (*calc_homunculus_) (struct homun_data *hd, enum e_status_calc_opt opt);
 int (*calc_mercenary_) (struct mercenary_data *md, enum e_status_calc_opt opt);
 int (*calc_elemental_) (struct elemental_data *ed, enum e_status_calc_opt opt);
 void (*calc_misc) (struct block_list *bl, struct status_data *st, int level);
 void (*calc_regen) (struct block_list *bl, struct status_data *st, struct regen_data *regen);
 void (*calc_regen_rate) (struct block_list *bl, struct regen_data *regen, struct status_change *sc);
 int (*check_skilluse) (struct block_list *src, struct block_list *target, uint16 skill_id, int flag);
 int (*check_visibility) (struct block_list *src, struct block_list *target);
 int (*change_spread) (struct block_list *src, struct block_list *bl);
 defType (*calc_def) (struct block_list *bl, struct status_change *sc, int def, 
# 2261 "../../../server-code/src/map/status.h" 3 4
                                                                               _Bool 
# 2261 "../../../server-code/src/map/status.h"
                                                                                    viewable);
 short (*calc_def2) (struct block_list *bl, struct status_change *sc, int def2, 
# 2262 "../../../server-code/src/map/status.h" 3 4
                                                                               _Bool 
# 2262 "../../../server-code/src/map/status.h"
                                                                                    viewable);
 defType (*calc_mdef) (struct block_list *bl, struct status_change *sc, int mdef, 
# 2263 "../../../server-code/src/map/status.h" 3 4
                                                                                 _Bool 
# 2263 "../../../server-code/src/map/status.h"
                                                                                      viewable);
 short (*calc_mdef2) (struct block_list *bl, struct status_change *sc, int mdef2, 
# 2264 "../../../server-code/src/map/status.h" 3 4
                                                                                 _Bool 
# 2264 "../../../server-code/src/map/status.h"
                                                                                      viewable);
 unsigned short (*calc_batk)(struct block_list *bl, struct status_change *sc, int batk, 
# 2265 "../../../server-code/src/map/status.h" 3 4
                                                                                       _Bool 
# 2265 "../../../server-code/src/map/status.h"
                                                                                            viewable);
 unsigned short(*base_matk) (struct block_list *bl, const struct status_data *st, int level);
 int (*get_weapon_atk) (struct block_list *src, struct weapon_atk *watk, int flag);
 int (*get_total_mdef) (struct block_list *src);
 int (*get_total_def) (struct block_list *src);
 int (*get_matk) (struct block_list *src, int flag);
 void (*update_matk) ( struct block_list *bl );
 int (*readdb) (void);

 void (*initChangeTables) (void);
 void (*initDummyData) (void);
 int (*base_amotion_pc) (struct map_session_data *sd, struct status_data *st);
 unsigned short (*base_atk) (const struct block_list *bl, const struct status_data *st);
 unsigned int (*get_base_maxhp) (const struct map_session_data *sd, const struct status_data *st);
 unsigned int (*get_base_maxsp) (const struct map_session_data *sd, const struct status_data *st);
 int (*calc_npc_) (struct npc_data *nd, enum e_status_calc_opt opt);
 unsigned short (*calc_str) (struct block_list *bl, struct status_change *sc, int str);
 unsigned short (*calc_agi) (struct block_list *bl, struct status_change *sc, int agi);
 unsigned short (*calc_vit) (struct block_list *bl, struct status_change *sc, int vit);
 unsigned short (*calc_int) (struct block_list *bl, struct status_change *sc, int int_);
 unsigned short (*calc_dex) (struct block_list *bl, struct status_change *sc, int dex);
 unsigned short (*calc_luk) (struct block_list *bl, struct status_change *sc, int luk);
 unsigned short (*calc_watk) (struct block_list *bl, struct status_change *sc, int watk, 
# 2287 "../../../server-code/src/map/status.h" 3 4
                                                                                        _Bool 
# 2287 "../../../server-code/src/map/status.h"
                                                                                             viewable);
 unsigned short (*calc_matk) (struct block_list *bl, struct status_change *sc, int matk, 
# 2288 "../../../server-code/src/map/status.h" 3 4
                                                                                        _Bool 
# 2288 "../../../server-code/src/map/status.h"
                                                                                             viewable);
 signed short (*calc_hit) (struct block_list *bl, struct status_change *sc, int hit, 
# 2289 "../../../server-code/src/map/status.h" 3 4
                                                                                    _Bool 
# 2289 "../../../server-code/src/map/status.h"
                                                                                         viewable);
 signed short (*calc_critical) (struct block_list *bl, struct status_change *sc, int critical, 
# 2290 "../../../server-code/src/map/status.h" 3 4
                                                                                              _Bool 
# 2290 "../../../server-code/src/map/status.h"
                                                                                                   viewable);
 signed short (*calc_flee) (struct block_list *bl, struct status_change *sc, int flee, 
# 2291 "../../../server-code/src/map/status.h" 3 4
                                                                                      _Bool 
# 2291 "../../../server-code/src/map/status.h"
                                                                                           viewable);
 signed short (*calc_flee2) (struct block_list *bl, struct status_change *sc, int flee2, 
# 2292 "../../../server-code/src/map/status.h" 3 4
                                                                                        _Bool 
# 2292 "../../../server-code/src/map/status.h"
                                                                                             viewable);
 unsigned short (*calc_speed) (struct block_list *bl, struct status_change *sc, int speed);
 short (*calc_aspd_rate) (struct block_list *bl, struct status_change *sc, int aspd_rate);
 unsigned short (*calc_dmotion) (struct block_list *bl, struct status_change *sc, int dmotion);
 short (*calc_aspd) (struct block_list *bl, struct status_change *sc, short flag);
 short (*calc_fix_aspd) (struct block_list *bl, struct status_change *sc, int aspd);
 unsigned int (*calc_maxhp) (struct block_list *bl, struct status_change *sc, uint64 maxhp);
 unsigned int (*calc_maxsp) (struct block_list *bl, struct status_change *sc, unsigned int maxsp);
 unsigned char (*calc_element) (struct block_list *bl, struct status_change *sc, int element);
 unsigned char (*calc_element_lv) (struct block_list *bl, struct status_change *sc, int lv);
 uint32 (*calc_mode) (const struct block_list *bl, const struct status_change *sc, uint32 mode);
 unsigned short (*calc_ematk) (struct block_list *bl, struct status_change *sc, int matk);
 void (*calc_bl_main) (struct block_list *bl, int flag);
 void (*display_add) (struct map_session_data *sd, enum sc_type type, int dval1, int dval2, int dval3);
 void (*display_remove) (struct map_session_data *sd, enum sc_type type);
 int (*natural_heal) (struct block_list *bl, va_list args);
 int (*natural_heal_timer) (int tid, int64 tick, int id, intptr_t data);
 
# 2309 "../../../server-code/src/map/status.h" 3 4
_Bool 
# 2309 "../../../server-code/src/map/status.h"
     (*readdb_job2) (char *fields[], int columns, int current);
 
# 2310 "../../../server-code/src/map/status.h" 3 4
_Bool 
# 2310 "../../../server-code/src/map/status.h"
     (*readdb_sizefix) (char *fields[], int columns, int current);
 int (*readdb_refine_libconfig) (const char *filename);
 int (*readdb_refine_libconfig_sub) (struct config_setting_t *r, const char *name, const char *source);
 
# 2313 "../../../server-code/src/map/status.h" 3 4
_Bool 
# 2313 "../../../server-code/src/map/status.h"
     (*readdb_scconfig) (char *fields[], int columns, int current);
 void (*read_job_db) (void);
 void (*read_job_db_sub) (int idx, const char *name, struct config_setting_t *jdb);
};


void status_defaults(void);


extern struct status_interface *status;
# 25 "../../../server-code/src/map/elemental.h" 2
# 1 "../../../server-code/src/map/unit.h" 1
# 24 "../../../server-code/src/map/unit.h"
# 1 "../../../server-code/src/map/clif.h" 1
# 25 "../../../server-code/src/map/unit.h" 2
# 1 "../../../server-code/src/map/path.h" 1
# 32 "../../../server-code/src/map/path.h"
struct walkpath_data {
 unsigned char path_len,path_pos;
 unsigned char path[32];
};

struct shootpath_data {
 int rx,ry,len;
 int x[32];
 int y[32];
};
# 59 "../../../server-code/src/map/path.h"
struct path_interface {

 int (*blownpos) (struct block_list *bl, int16 m, int16 x0, int16 y0, int16 dx, int16 dy, int count);

 
# 63 "../../../server-code/src/map/path.h" 3 4
_Bool 
# 63 "../../../server-code/src/map/path.h"
     (*search) (struct walkpath_data *wpd, struct block_list *bl, int16 m, int16 x0, int16 y0, int16 x1, int16 y1, int flag, cell_chk cell);

 
# 65 "../../../server-code/src/map/path.h" 3 4
_Bool 
# 65 "../../../server-code/src/map/path.h"
     (*search_long) (struct shootpath_data *spd, struct block_list *bl, int16 m, int16 x0, int16 y0, int16 x1, int16 y1, cell_chk cell);
 
# 66 "../../../server-code/src/map/path.h" 3 4
_Bool 
# 66 "../../../server-code/src/map/path.h"
     (*check_distance) (int dx, int dy, int distance);
 unsigned int (*distance) (int dx, int dy);
 
# 68 "../../../server-code/src/map/path.h" 3 4
_Bool 
# 68 "../../../server-code/src/map/path.h"
     (*check_distance_client) (int dx, int dy, int distance);
 int (*distance_client) (int dx, int dy);
};


void path_defaults(void);


extern struct path_interface *path;
# 26 "../../../server-code/src/map/unit.h" 2
# 1 "../../../server-code/src/map/skill.h" 1
# 33 "../../../server-code/src/map/skill.h"
struct Damage;
struct homun_data;
struct itemlist;
struct map_session_data;
struct mercenary_data;
struct unit_data;
struct skill_unit;
struct square;
struct status_change_entry;
# 79 "../../../server-code/src/map/skill.h"
enum e_skill_inf {
 INF_ATTACK_SKILL = 0x01,
 INF_GROUND_SKILL = 0x02,
 INF_SELF_SKILL = 0x04,

 INF_SUPPORT_SKILL = 0x10,
 INF_TARGET_TRAP = 0x20,
};




enum e_skill_nk {
 NK_NO_DAMAGE = 0x01,
 NK_SPLASH = 0x02|0x04,
 NK_SPLASHSPLIT = 0x04,
 NK_NO_CARDFIX_ATK = 0x08,
 NK_NO_ELEFIX = 0x10,
 NK_IGNORE_DEF = 0x20,
 NK_IGNORE_FLEE = 0x40,
 NK_NO_CARDFIX_DEF = 0x80,
};



enum e_skill_inf2 {
 INF2_QUEST_SKILL = 0x0001,
 INF2_NPC_SKILL = 0x0002,
 INF2_WEDDING_SKILL = 0x0004,
 INF2_SPIRIT_SKILL = 0x0008,
 INF2_GUILD_SKILL = 0x0010,
 INF2_SONG_DANCE = 0x0020,
 INF2_ENSEMBLE_SKILL = 0x0040,
 INF2_TRAP = 0x0080,
 INF2_TARGET_SELF = 0x0100,
 INF2_NO_TARGET_SELF = 0x0200,
 INF2_PARTY_ONLY = 0x0400,
 INF2_GUILD_ONLY = 0x0800,
 INF2_NO_ENEMY = 0x1000,
 INF2_NOLP = 0x2000,
 INF2_CHORUS_SKILL = 0x4000,
};



enum e_skill_display {
 SD_LEVEL = 0x1000,
 SD_ANIMATION = 0x2000,
 SD_SPLASH = 0x4000,
 SD_PREAMBLE = 0x8000,
};

enum {
 UF_DEFNOTENEMY = 0x0001,
 UF_NOREITERATION = 0x0002,
 UF_NOFOOTSET = 0x0004,
 UF_NOOVERLAP = 0x0008,
 UF_PATHCHECK = 0x0010,
 UF_NOPC = 0x0020,
 UF_NOMOB = 0x0040,
 UF_SKILL = 0x0080,
 UF_DANCE = 0x0100,
 UF_ENSEMBLE = 0x0200,
 UF_SONG = 0x0400,
 UF_DUALMODE = 0x0800,
 UF_RANGEDSINGLEUNIT = 0x2000,
};


enum { CAST_GROUND, CAST_DAMAGE, CAST_NODAMAGE };

enum wl_spheres {
 WLS_FIRE = 0x44,
 WLS_WIND,
 WLS_WATER,
 WLS_STONE,
};

enum {
 ST_NONE,
 ST_HIDING,
 ST_CLOAKING,
 ST_HIDDEN,
 ST_RIDING,
 ST_FALCON,
 ST_CART,
 ST_SHIELD,
 ST_SIGHT,
 ST_EXPLOSIONSPIRITS,
 ST_CARTBOOST,
 ST_RECOV_WEIGHT_RATE,
 ST_MOVE_ENABLE,
 ST_WATER,
 ST_RIDINGDRAGON,
 ST_WUG,
 ST_RIDINGWUG,
 ST_MADO,
 ST_ELEMENTALSPIRIT,
 ST_POISONINGWEAPON,
 ST_ROLLINGCUTTER,
 ST_MH_FIGHTING,
 ST_MH_GRAPPLING,
 ST_PECO,
};

enum e_skill {
 NV_BASIC = 1,

 SM_SWORD,
 SM_TWOHAND,
 SM_RECOVERY,
 SM_BASH,
 SM_PROVOKE,
 SM_MAGNUM,
 SM_ENDURE,

 MG_SRECOVERY,
 MG_SIGHT,
 MG_NAPALMBEAT,
 MG_SAFETYWALL,
 MG_SOULSTRIKE,
 MG_COLDBOLT,
 MG_FROSTDIVER,
 MG_STONECURSE,
 MG_FIREBALL,
 MG_FIREWALL,
 MG_FIREBOLT,
 MG_LIGHTNINGBOLT,
 MG_THUNDERSTORM,

 AL_DP,
 AL_DEMONBANE,
 AL_RUWACH,
 AL_PNEUMA,
 AL_TELEPORT,
 AL_WARP,
 AL_HEAL,
 AL_INCAGI,
 AL_DECAGI,
 AL_HOLYWATER,
 AL_CRUCIS,
 AL_ANGELUS,
 AL_BLESSING,
 AL_CURE,

 MC_INCCARRY,
 MC_DISCOUNT,
 MC_OVERCHARGE,
 MC_PUSHCART,
 MC_IDENTIFY,
 MC_VENDING,
 MC_MAMMONITE,

 AC_OWL,
 AC_VULTURE,
 AC_CONCENTRATION,
 AC_DOUBLE,
 AC_SHOWER,

 TF_DOUBLE,
 TF_MISS,
 TF_STEAL,
 TF_HIDING,
 TF_POISON,
 TF_DETOXIFY,

 ALL_RESURRECTION,

 KN_SPEARMASTERY,
 KN_PIERCE,
 KN_BRANDISHSPEAR,
 KN_SPEARSTAB,
 KN_SPEARBOOMERANG,
 KN_TWOHANDQUICKEN,
 KN_AUTOCOUNTER,
 KN_BOWLINGBASH,
 KN_RIDING,
 KN_CAVALIERMASTERY,

 PR_MACEMASTERY,
 PR_IMPOSITIO,
 PR_SUFFRAGIUM,
 PR_ASPERSIO,
 PR_BENEDICTIO,
 PR_SANCTUARY,
 PR_SLOWPOISON,
 PR_STRECOVERY,
 PR_KYRIE,
 PR_MAGNIFICAT,
 PR_GLORIA,
 PR_LEXDIVINA,
 PR_TURNUNDEAD,
 PR_LEXAETERNA,
 PR_MAGNUS,

 WZ_FIREPILLAR,
 WZ_SIGHTRASHER,
 WZ_FIREIVY,
 WZ_METEOR,
 WZ_JUPITEL,
 WZ_VERMILION,
 WZ_WATERBALL,
 WZ_ICEWALL,
 WZ_FROSTNOVA,
 WZ_STORMGUST,
 WZ_EARTHSPIKE,
 WZ_HEAVENDRIVE,
 WZ_QUAGMIRE,
 WZ_ESTIMATION,

 BS_IRON,
 BS_STEEL,
 BS_ENCHANTEDSTONE,
 BS_ORIDEOCON,
 BS_DAGGER,
 BS_SWORD,
 BS_TWOHANDSWORD,
 BS_AXE,
 BS_MACE,
 BS_KNUCKLE,
 BS_SPEAR,
 BS_HILTBINDING,
 BS_FINDINGORE,
 BS_WEAPONRESEARCH,
 BS_REPAIRWEAPON,
 BS_SKINTEMPER,
 BS_HAMMERFALL,
 BS_ADRENALINE,
 BS_WEAPONPERFECT,
 BS_OVERTHRUST,
 BS_MAXIMIZE,

 HT_SKIDTRAP,
 HT_LANDMINE,
 HT_ANKLESNARE,
 HT_SHOCKWAVE,
 HT_SANDMAN,
 HT_FLASHER,
 HT_FREEZINGTRAP,
 HT_BLASTMINE,
 HT_CLAYMORETRAP,
 HT_REMOVETRAP,
 HT_TALKIEBOX,
 HT_BEASTBANE,
 HT_FALCON,
 HT_STEELCROW,
 HT_BLITZBEAT,
 HT_DETECTING,
 HT_SPRINGTRAP,

 AS_RIGHT,
 AS_LEFT,
 AS_KATAR,
 AS_CLOAKING,
 AS_SONICBLOW,
 AS_GRIMTOOTH,
 AS_ENCHANTPOISON,
 AS_POISONREACT,
 AS_VENOMDUST,
 AS_SPLASHER,

 NV_FIRSTAID,
 NV_TRICKDEAD,
 SM_MOVINGRECOVERY,
 SM_FATALBLOW,
 SM_AUTOBERSERK,
 AC_MAKINGARROW,
 AC_CHARGEARROW,
 TF_SPRINKLESAND,
 TF_BACKSLIDING,
 TF_PICKSTONE,
 TF_THROWSTONE,
 MC_CARTREVOLUTION,
 MC_CHANGECART,
 MC_LOUD,
 AL_HOLYLIGHT,
 MG_ENERGYCOAT,

 NPC_PIERCINGATT,
 NPC_MENTALBREAKER,
 NPC_RANGEATTACK,
 NPC_ATTRICHANGE,
 NPC_CHANGEWATER,
 NPC_CHANGEGROUND,
 NPC_CHANGEFIRE,
 NPC_CHANGEWIND,
 NPC_CHANGEPOISON,
 NPC_CHANGEHOLY,
 NPC_CHANGEDARKNESS,
 NPC_CHANGETELEKINESIS,
 NPC_CRITICALSLASH,
 NPC_COMBOATTACK,
 NPC_GUIDEDATTACK,
 NPC_SELFDESTRUCTION,
 NPC_SPLASHATTACK,
 NPC_SUICIDE,
 NPC_POISON,
 NPC_BLINDATTACK,
 NPC_SILENCEATTACK,
 NPC_STUNATTACK,
 NPC_PETRIFYATTACK,
 NPC_CURSEATTACK,
 NPC_SLEEPATTACK,
 NPC_RANDOMATTACK,
 NPC_WATERATTACK,
 NPC_GROUNDATTACK,
 NPC_FIREATTACK,
 NPC_WINDATTACK,
 NPC_POISONATTACK,
 NPC_HOLYATTACK,
 NPC_DARKNESSATTACK,
 NPC_TELEKINESISATTACK,
 NPC_MAGICALATTACK,
 NPC_METAMORPHOSIS,
 NPC_PROVOCATION,
 NPC_SMOKING,
 NPC_SUMMONSLAVE,
 NPC_EMOTION,
 NPC_TRANSFORMATION,
 NPC_BLOODDRAIN,
 NPC_ENERGYDRAIN,
 NPC_KEEPING,
 NPC_DARKBREATH,
 NPC_DARKBLESSING,
 NPC_BARRIER,
 NPC_DEFENDER,
 NPC_LICK,
 NPC_HALLUCINATION,
 NPC_REBIRTH,
 NPC_SUMMONMONSTER,

 RG_SNATCHER,
 RG_STEALCOIN,
 RG_BACKSTAP,
 RG_TUNNELDRIVE,
 RG_RAID,
 RG_STRIPWEAPON,
 RG_STRIPSHIELD,
 RG_STRIPARMOR,
 RG_STRIPHELM,
 RG_INTIMIDATE,
 RG_GRAFFITI,
 RG_FLAGGRAFFITI,
 RG_CLEANER,
 RG_GANGSTER,
 RG_COMPULSION,
 RG_PLAGIARISM,

 AM_AXEMASTERY,
 AM_LEARNINGPOTION,
 AM_PHARMACY,
 AM_DEMONSTRATION,
 AM_ACIDTERROR,
 AM_POTIONPITCHER,
 AM_CANNIBALIZE,
 AM_SPHEREMINE,
 AM_CP_WEAPON,
 AM_CP_SHIELD,
 AM_CP_ARMOR,
 AM_CP_HELM,
 AM_BIOETHICS,
 AM_BIOTECHNOLOGY,
 AM_CREATECREATURE,
 AM_CULTIVATION,
 AM_FLAMECONTROL,
 AM_CALLHOMUN,
 AM_REST,
 AM_DRILLMASTER,
 AM_HEALHOMUN,
 AM_RESURRECTHOMUN,

 CR_TRUST,
 CR_AUTOGUARD,
 CR_SHIELDCHARGE,
 CR_SHIELDBOOMERANG,
 CR_REFLECTSHIELD,
 CR_HOLYCROSS,
 CR_GRANDCROSS,
 CR_DEVOTION,
 CR_PROVIDENCE,
 CR_DEFENDER,
 CR_SPEARQUICKEN,

 MO_IRONHAND,
 MO_SPIRITSRECOVERY,
 MO_CALLSPIRITS,
 MO_ABSORBSPIRITS,
 MO_TRIPLEATTACK,
 MO_BODYRELOCATION,
 MO_DODGE,
 MO_INVESTIGATE,
 MO_FINGEROFFENSIVE,
 MO_STEELBODY,
 MO_BLADESTOP,
 MO_EXPLOSIONSPIRITS,
 MO_EXTREMITYFIST,
 MO_CHAINCOMBO,
 MO_COMBOFINISH,

 SA_ADVANCEDBOOK,
 SA_CASTCANCEL,
 SA_MAGICROD,
 SA_SPELLBREAKER,
 SA_FREECAST,
 SA_AUTOSPELL,
 SA_FLAMELAUNCHER,
 SA_FROSTWEAPON,
 SA_LIGHTNINGLOADER,
 SA_SEISMICWEAPON,
 SA_DRAGONOLOGY,
 SA_VOLCANO,
 SA_DELUGE,
 SA_VIOLENTGALE,
 SA_LANDPROTECTOR,
 SA_DISPELL,
 SA_ABRACADABRA,
 SA_MONOCELL,
 SA_CLASSCHANGE,
 SA_SUMMONMONSTER,
 SA_REVERSEORCISH,
 SA_DEATH,
 SA_FORTUNE,
 SA_TAMINGMONSTER,
 SA_QUESTION,
 SA_GRAVITY,
 SA_LEVELUP,
 SA_INSTANTDEATH,
 SA_FULLRECOVERY,
 SA_COMA,

 BD_ADAPTATION,
 BD_ENCORE,
 BD_LULLABY,
 BD_RICHMANKIM,
 BD_ETERNALCHAOS,
 BD_DRUMBATTLEFIELD,
 BD_RINGNIBELUNGEN,
 BD_ROKISWEIL,
 BD_INTOABYSS,
 BD_SIEGFRIED,
 BD_RAGNAROK,

 BA_MUSICALLESSON,
 BA_MUSICALSTRIKE,
 BA_DISSONANCE,
 BA_FROSTJOKER,
 BA_WHISTLE,
 BA_ASSASSINCROSS,
 BA_POEMBRAGI,
 BA_APPLEIDUN,

 DC_DANCINGLESSON,
 DC_THROWARROW,
 DC_UGLYDANCE,
 DC_SCREAM,
 DC_HUMMING,
 DC_DONTFORGETME,
 DC_FORTUNEKISS,
 DC_SERVICEFORYOU,

 NPC_RANDOMMOVE,
 NPC_SPEEDUP,
 NPC_REVENGE,

 WE_MALE,
 WE_FEMALE,
 WE_CALLPARTNER,

 ITM_TOMAHAWK,

 NPC_DARKCROSS,
 NPC_GRANDDARKNESS,
 NPC_DARKSTRIKE,
 NPC_DARKTHUNDER,
 NPC_STOP,
 NPC_WEAPONBRAKER,
 NPC_ARMORBRAKE,
 NPC_HELMBRAKE,
 NPC_SHIELDBRAKE,
 NPC_UNDEADATTACK,
 NPC_CHANGEUNDEAD,
 NPC_POWERUP,
 NPC_AGIUP,
 NPC_SIEGEMODE,
 NPC_CALLSLAVE,
 NPC_INVISIBLE,
 NPC_RUN,

 LK_AURABLADE,
 LK_PARRYING,
 LK_CONCENTRATION,
 LK_TENSIONRELAX,
 LK_BERSERK,
 LK_FURY,
 HP_ASSUMPTIO,
 HP_BASILICA,
 HP_MEDITATIO,
 HW_SOULDRAIN,
 HW_MAGICCRASHER,
 HW_MAGICPOWER,
 PA_PRESSURE,
 PA_SACRIFICE,
 PA_GOSPEL,
 CH_PALMSTRIKE,
 CH_TIGERFIST,
 CH_CHAINCRUSH,
 PF_HPCONVERSION,
 PF_SOULCHANGE,
 PF_SOULBURN,
 ASC_KATAR,
 ASC_HALLUCINATION,
 ASC_EDP,
 ASC_BREAKER,
 SN_SIGHT,
 SN_FALCONASSAULT,
 SN_SHARPSHOOTING,
 SN_WINDWALK,
 WS_MELTDOWN,
 WS_CREATECOIN,
 WS_CREATENUGGET,
 WS_CARTBOOST,
 WS_SYSTEMCREATE,
 ST_CHASEWALK,
 ST_REJECTSWORD,
 ST_STEALBACKPACK,
 CR_ALCHEMY,
 CR_SYNTHESISPOTION,
 CG_ARROWVULCAN,
 CG_MOONLIT,
 CG_MARIONETTE,
 LK_SPIRALPIERCE,
 LK_HEADCRUSH,
 LK_JOINTBEAT,
 HW_NAPALMVULCAN,
 CH_SOULCOLLECT,
 PF_MINDBREAKER,
 PF_MEMORIZE,
 PF_FOGWALL,
 PF_SPIDERWEB,
 ASC_METEORASSAULT,
 ASC_CDP,

 WE_BABY,
 WE_CALLPARENT,
 WE_CALLBABY,

 TK_RUN,
 TK_READYSTORM,
 TK_STORMKICK,
 TK_READYDOWN,
 TK_DOWNKICK,
 TK_READYTURN,
 TK_TURNKICK,
 TK_READYCOUNTER,
 TK_COUNTER,
 TK_DODGE,
 TK_JUMPKICK,
 TK_HPTIME,
 TK_SPTIME,
 TK_POWER,
 TK_SEVENWIND,
 TK_HIGHJUMP,

 SG_FEEL,
 SG_SUN_WARM,
 SG_MOON_WARM,
 SG_STAR_WARM,
 SG_SUN_COMFORT,
 SG_MOON_COMFORT,
 SG_STAR_COMFORT,
 SG_HATE,
 SG_SUN_ANGER,
 SG_MOON_ANGER,
 SG_STAR_ANGER,
 SG_SUN_BLESS,
 SG_MOON_BLESS,
 SG_STAR_BLESS,
 SG_DEVIL,
 SG_FRIEND,
 SG_KNOWLEDGE,
 SG_FUSION,

 SL_ALCHEMIST,
 AM_BERSERKPITCHER,
 SL_MONK,
 SL_STAR,
 SL_SAGE,
 SL_CRUSADER,
 SL_SUPERNOVICE,
 SL_KNIGHT,
 SL_WIZARD,
 SL_PRIEST,
 SL_BARDDANCER,
 SL_ROGUE,
 SL_ASSASIN,
 SL_BLACKSMITH,
 BS_ADRENALINE2,
 SL_HUNTER,
 SL_SOULLINKER,
 SL_KAIZEL,
 SL_KAAHI,
 SL_KAUPE,
 SL_KAITE,
 SL_KAINA,
 SL_STIN,
 SL_STUN,
 SL_SMA,
 SL_SWOO,
 SL_SKE,
 SL_SKA,

 SM_SELFPROVOKE,
 NPC_EMOTION_ON,
 ST_PRESERVE,
 ST_FULLSTRIP,
 WS_WEAPONREFINE,
 CR_SLIMPITCHER,
 CR_FULLPROTECTION,
 PA_SHIELDCHAIN,
 HP_MANARECHARGE,
 PF_DOUBLECASTING,
 HW_GANBANTEIN,
 HW_GRAVITATION,
 WS_CARTTERMINATION,
 WS_OVERTHRUSTMAX,
 CG_LONGINGFREEDOM,
 CG_HERMODE,
 CG_TAROTCARD,
 CR_ACIDDEMONSTRATION,
 CR_CULTIVATION,
 ITEM_ENCHANTARMS,
 TK_MISSION,
 SL_HIGH,
 KN_ONEHAND,
 AM_TWILIGHT1,
 AM_TWILIGHT2,
 AM_TWILIGHT3,
 HT_POWER,

 GS_GLITTERING,
 GS_FLING,
 GS_TRIPLEACTION,
 GS_BULLSEYE,
 GS_MADNESSCANCEL,
 GS_ADJUSTMENT,
 GS_INCREASING,
 GS_MAGICALBULLET,
 GS_CRACKER,
 GS_SINGLEACTION,
 GS_SNAKEEYE,
 GS_CHAINACTION,
 GS_TRACKING,
 GS_DISARM,
 GS_PIERCINGSHOT,
 GS_RAPIDSHOWER,
 GS_DESPERADO,
 GS_GATLINGFEVER,
 GS_DUST,
 GS_FULLBUSTER,
 GS_SPREADATTACK,
 GS_GROUNDDRIFT,

 NJ_TOBIDOUGU,
 NJ_SYURIKEN,
 NJ_KUNAI,
 NJ_HUUMA,
 NJ_ZENYNAGE,
 NJ_TATAMIGAESHI,
 NJ_KASUMIKIRI,
 NJ_SHADOWJUMP,
 NJ_KIRIKAGE,
 NJ_UTSUSEMI,
 NJ_BUNSINJYUTSU,
 NJ_NINPOU,
 NJ_KOUENKA,
 NJ_KAENSIN,
 NJ_BAKUENRYU,
 NJ_HYOUSENSOU,
 NJ_SUITON,
 NJ_HYOUSYOURAKU,
 NJ_HUUJIN,
 NJ_RAIGEKISAI,
 NJ_KAMAITACHI,
 NJ_NEN,
 NJ_ISSEN,

 MB_FIGHTING,
 MB_NEUTRAL,
 MB_TAIMING_PUTI,
 MB_WHITEPOTION,
 MB_MENTAL,
 MB_CARDPITCHER,
 MB_PETPITCHER,
 MB_BODYSTUDY,
 MB_BODYALTER,
 MB_PETMEMORY,
 MB_M_TELEPORT,
 MB_B_GAIN,
 MB_M_GAIN,
 MB_MISSION,
 MB_MUNAKKNOWLEDGE,
 MB_MUNAKBALL,
 MB_SCROLL,
 MB_B_GATHERING,
 MB_M_GATHERING,
 MB_B_EXCLUDE,
 MB_B_DRIFT,
 MB_B_WALLRUSH,
 MB_M_WALLRUSH,
 MB_B_WALLSHIFT,
 MB_M_WALLCRASH,
 MB_M_REINCARNATION,
 MB_B_EQUIP,

 SL_DEATHKNIGHT,
 SL_COLLECTOR,
 SL_NINJA,
 SL_GUNNER,
 AM_TWILIGHT4,
 DA_RESET,
 DE_BERSERKAIZER,
 DA_DARKPOWER,

 DE_PASSIVE,
 DE_PATTACK,
 DE_PSPEED,
 DE_PDEFENSE,
 DE_PCRITICAL,
 DE_PHP,
 DE_PSP,
 DE_RESET,
 DE_RANKING,
 DE_PTRIPLE,
 DE_ENERGY,
 DE_NIGHTMARE,
 DE_SLASH,
 DE_COIL,
 DE_WAVE,
 DE_REBIRTH,
 DE_AURA,
 DE_FREEZER,
 DE_CHANGEATTACK,
 DE_PUNISH,
 DE_POISON,
 DE_INSTANT,
 DE_WARNING,
 DE_RANKEDKNIFE,
 DE_RANKEDGRADIUS,
 DE_GAUGE,
 DE_GTIME,
 DE_GPAIN,
 DE_GSKILL,
 DE_GKILL,
 DE_ACCEL,
 DE_BLOCKDOUBLE,
 DE_BLOCKMELEE,
 DE_BLOCKFAR,
 DE_FRONTATTACK,
 DE_DANGERATTACK,
 DE_TWINATTACK,
 DE_WINDATTACK,
 DE_WATERATTACK,

 DA_ENERGY,
 DA_CLOUD,
 DA_FIRSTSLOT,
 DA_HEADDEF,
 DA_SPACE,
 DA_TRANSFORM,
 DA_EXPLOSION,
 DA_REWARD,
 DA_CRUSH,
 DA_ITEMREBUILD,
 DA_ILLUSION,
 DA_NUETRALIZE,
 DA_RUNNER,
 DA_TRANSFER,
 DA_WALL,
 DA_ZENY,
 DA_REVENGE,
 DA_EARPLUG,
 DA_CONTRACT,
 DA_BLACK,
 DA_DREAM,
 DA_MAGICCART,
 DA_COPY,
 DA_CRYSTAL,
 DA_EXP,
 DA_CARTSWING,
 DA_REBUILD,
 DA_JOBCHANGE,
 DA_EDARKNESS,
 DA_EGUARDIAN,
 DA_TIMEOUT,
 ALL_TIMEIN,
 DA_ZENYRANK,
 DA_ACCESSORYMIX,

 NPC_EARTHQUAKE,
 NPC_FIREBREATH,
 NPC_ICEBREATH,
 NPC_THUNDERBREATH,
 NPC_ACIDBREATH,
 NPC_DARKNESSBREATH,
 NPC_DRAGONFEAR,
 NPC_BLEEDING,
 NPC_PULSESTRIKE,
 NPC_HELLJUDGEMENT,
 NPC_WIDESILENCE,
 NPC_WIDEFREEZE,
 NPC_WIDEBLEEDING,
 NPC_WIDESTONE,
 NPC_WIDECONFUSE,
 NPC_WIDESLEEP,
 NPC_WIDESIGHT,
 NPC_EVILLAND,
 NPC_MAGICMIRROR,
 NPC_SLOWCAST,
 NPC_CRITICALWOUND,
 NPC_EXPULSION,
 NPC_STONESKIN,
 NPC_ANTIMAGIC,
 NPC_WIDECURSE,
 NPC_WIDESTUN,
 NPC_VAMPIRE_GIFT,
 NPC_WIDESOULDRAIN,
 ALL_INCCARRY,
 NPC_TALK,
 NPC_HELLPOWER,
 NPC_WIDEHELLDIGNITY,
 NPC_INVINCIBLE,
 NPC_INVINCIBLEOFF,
 NPC_ALLHEAL,
 GM_SANDMAN,
 CASH_BLESSING,
 CASH_INCAGI,
 CASH_ASSUMPTIO,
 ALL_CATCRY,
 ALL_PARTYFLEE,
 ALL_ANGEL_PROTECT,
 ALL_DREAM_SUMMERNIGHT,
 NPC_CHANGEUNDEAD2,
 ALL_REVERSEORCISH,
 ALL_WEWISH,
 ALL_SONKRAN,
 NPC_WIDEHEALTHFEAR,
 NPC_WIDEBODYBURNNING,
 NPC_WIDEFROSTMISTY,
 NPC_WIDECOLD,
 NPC_WIDE_DEEP_SLEEP,
 NPC_WIDESIREN,
 NPC_VENOMFOG,
 NPC_MILLENNIUMSHIELD,
 NPC_COMET,




 NPC_ICEMINE,
 NPC_ICEEXPLO,
 NPC_FLAMECROSS,
 NPC_PULSESTRIKE2,
 NPC_DANCINGBLADE,
 NPC_DANCINGBLADE_ATK,
 NPC_DARKPIERCING,
 NPC_MAXPAIN,
 NPC_MAXPAIN_ATK,
 NPC_DEATHSUMMON,
 NPC_HELLBURNING,
 NPC_JACKFROST,

 NPC_WIDEWEB,
 NPC_WIDESUCK,
 NPC_STORMGUST2,
 NPC_FIRESTORM,
 NPC_REVERBERATION,
 NPC_REVERBERATION_ATK,
 NPC_LEX_AETERNA,

 KN_CHARGEATK = 1001,
 CR_SHRINK,
 AS_SONICACCEL,
 AS_VENOMKNIFE,
 RG_CLOSECONFINE,
 WZ_SIGHTBLASTER,
 SA_CREATECON,
 SA_ELEMENTWATER,
 HT_PHANTASMIC,
 BA_PANGVOICE,
 DC_WINKCHARM,
 BS_UNFAIRLYTRICK,
 BS_GREED,
 PR_REDEMPTIO,
 MO_KITRANSLATION,
 MO_BALKYOUNG,
 SA_ELEMENTGROUND,
 SA_ELEMENTFIRE,
 SA_ELEMENTWIND,

 RK_ENCHANTBLADE = 2001,
 RK_SONICWAVE,
 RK_DEATHBOUND,
 RK_HUNDREDSPEAR,
 RK_WINDCUTTER,
 RK_IGNITIONBREAK,
 RK_DRAGONTRAINING,
 RK_DRAGONBREATH,
 RK_DRAGONHOWLING,
 RK_RUNEMASTERY,
 RK_MILLENNIUMSHIELD,
 RK_CRUSHSTRIKE,
 RK_REFRESH,
 RK_GIANTGROWTH,
 RK_STONEHARDSKIN,
 RK_VITALITYACTIVATION,
 RK_STORMBLAST,
 RK_FIGHTINGSPIRIT,
 RK_ABUNDANCE,
 RK_PHANTOMTHRUST,

 GC_VENOMIMPRESS,
 GC_CROSSIMPACT,
 GC_DARKILLUSION,
 GC_RESEARCHNEWPOISON,
 GC_CREATENEWPOISON,
 GC_ANTIDOTE,
 GC_POISONINGWEAPON,
 GC_WEAPONBLOCKING,
 GC_COUNTERSLASH,
 GC_WEAPONCRUSH,
 GC_VENOMPRESSURE,
 GC_POISONSMOKE,
 GC_CLOAKINGEXCEED,
 GC_PHANTOMMENACE,
 GC_HALLUCINATIONWALK,
 GC_ROLLINGCUTTER,
 GC_CROSSRIPPERSLASHER,

 AB_JUDEX,
 AB_ANCILLA,
 AB_ADORAMUS,
 AB_CLEMENTIA,
 AB_CANTO,
 AB_CHEAL,
 AB_EPICLESIS,
 AB_PRAEFATIO,
 AB_ORATIO,
 AB_LAUDAAGNUS,
 AB_LAUDARAMUS,
 AB_EUCHARISTICA,
 AB_RENOVATIO,
 AB_HIGHNESSHEAL,
 AB_CLEARANCE,
 AB_EXPIATIO,
 AB_DUPLELIGHT,
 AB_DUPLELIGHT_MELEE,
 AB_DUPLELIGHT_MAGIC,
 AB_SILENTIUM,

 WL_WHITEIMPRISON = 2201,
 WL_SOULEXPANSION,
 WL_FROSTMISTY,
 WL_JACKFROST,
 WL_MARSHOFABYSS,
 WL_RECOGNIZEDSPELL,
 WL_SIENNAEXECRATE,
 WL_RADIUS,
 WL_STASIS,
 WL_DRAINLIFE,
 WL_CRIMSONROCK,
 WL_HELLINFERNO,
 WL_COMET,
 WL_CHAINLIGHTNING,
 WL_CHAINLIGHTNING_ATK,
 WL_EARTHSTRAIN,
 WL_TETRAVORTEX,
 WL_TETRAVORTEX_FIRE,
 WL_TETRAVORTEX_WATER,
 WL_TETRAVORTEX_WIND,
 WL_TETRAVORTEX_GROUND,
 WL_SUMMONFB,
 WL_SUMMONBL,
 WL_SUMMONWB,
 WL_SUMMON_ATK_FIRE,
 WL_SUMMON_ATK_WIND,
 WL_SUMMON_ATK_WATER,
 WL_SUMMON_ATK_GROUND,
 WL_SUMMONSTONE,
 WL_RELEASE,
 WL_READING_SB,
 WL_FREEZE_SP,

 RA_ARROWSTORM,
 RA_FEARBREEZE,
 RA_RANGERMAIN,
 RA_AIMEDBOLT,
 RA_DETONATOR,
 RA_ELECTRICSHOCKER,
 RA_CLUSTERBOMB,
 RA_WUGMASTERY,
 RA_WUGRIDER,
 RA_WUGDASH,
 RA_WUGSTRIKE,
 RA_WUGBITE,
 RA_TOOTHOFWUG,
 RA_SENSITIVEKEEN,
 RA_CAMOUFLAGE,
 RA_RESEARCHTRAP,
 RA_MAGENTATRAP,
 RA_COBALTTRAP,
 RA_MAIZETRAP,
 RA_VERDURETRAP,
 RA_FIRINGTRAP,
 RA_ICEBOUNDTRAP,

 NC_MADOLICENCE,
 NC_BOOSTKNUCKLE,
 NC_PILEBUNKER,
 NC_VULCANARM,
 NC_FLAMELAUNCHER,
 NC_COLDSLOWER,
 NC_ARMSCANNON,
 NC_ACCELERATION,
 NC_HOVERING,
 NC_F_SIDESLIDE,
 NC_B_SIDESLIDE,
 NC_MAINFRAME,
 NC_SELFDESTRUCTION,
 NC_SHAPESHIFT,
 NC_EMERGENCYCOOL,
 NC_INFRAREDSCAN,
 NC_ANALYZE,
 NC_MAGNETICFIELD,
 NC_NEUTRALBARRIER,
 NC_STEALTHFIELD,
 NC_REPAIR,
 NC_TRAININGAXE,
 NC_RESEARCHFE,
 NC_AXEBOOMERANG,
 NC_POWERSWING,
 NC_AXETORNADO,
 NC_SILVERSNIPER,
 NC_MAGICDECOY,
 NC_DISJOINT,

 SC_FATALMENACE,
 SC_REPRODUCE,
 SC_AUTOSHADOWSPELL,
 SC_SHADOWFORM,
 SC_TRIANGLESHOT,
 SC_BODYPAINT,
 SC_INVISIBILITY,
 SC_DEADLYINFECT,
 SC_ENERVATION,
 SC_GROOMY,
 SC_IGNORANCE,
 SC_LAZINESS,
 SC_UNLUCKY,
 SC_WEAKNESS,
 SC_STRIPACCESSARY,
 SC_MANHOLE,
 SC_DIMENSIONDOOR,
 SC_CHAOSPANIC,
 SC_MAELSTROM,
 SC_BLOODYLUST,
 SC_FEINTBOMB,

 LG_CANNONSPEAR = 2307,
 LG_BANISHINGPOINT,
 LG_TRAMPLE,
 LG_SHIELDPRESS,
 LG_REFLECTDAMAGE,
 LG_PINPOINTATTACK,
 LG_FORCEOFVANGUARD,
 LG_RAGEBURST,
 LG_SHIELDSPELL,
 LG_EXEEDBREAK,
 LG_OVERBRAND,
 LG_PRESTIGE,
 LG_BANDING,
 LG_MOONSLASHER,
 LG_RAYOFGENESIS,
 LG_PIETY,
 LG_EARTHDRIVE,
 LG_HESPERUSLIT,
 LG_INSPIRATION,

 SR_DRAGONCOMBO,
 SR_SKYNETBLOW,
 SR_EARTHSHAKER,
 SR_FALLENEMPIRE,
 SR_TIGERCANNON,
 SR_HELLGATE,
 SR_RAMPAGEBLASTER,
 SR_CRESCENTELBOW,
 SR_CURSEDCIRCLE,
 SR_LIGHTNINGWALK,
 SR_KNUCKLEARROW,
 SR_WINDMILL,
 SR_RAISINGDRAGON,
 SR_GENTLETOUCH,
 SR_ASSIMILATEPOWER,
 SR_POWERVELOCITY,
 SR_CRESCENTELBOW_AUTOSPELL,
 SR_GATEOFHELL,
 SR_GENTLETOUCH_QUIET,
 SR_GENTLETOUCH_CURE,
 SR_GENTLETOUCH_ENERGYGAIN,
 SR_GENTLETOUCH_CHANGE,
 SR_GENTLETOUCH_REVITALIZE,

 WA_SWING_DANCE = 2350,
 WA_SYMPHONY_OF_LOVER,
 WA_MOONLIT_SERENADE,

 MI_RUSH_WINDMILL = 2381,
 MI_ECHOSONG,
 MI_HARMONIZE,

 WM_LESSON = 2412,
 WM_METALICSOUND,
 WM_REVERBERATION,
 WM_REVERBERATION_MELEE,
 WM_REVERBERATION_MAGIC,
 WM_DOMINION_IMPULSE,
 WM_SEVERE_RAINSTORM,
 WM_POEMOFNETHERWORLD,
 WM_VOICEOFSIREN,
 WM_DEADHILLHERE,
 WM_LULLABY_DEEPSLEEP,
 WM_SIRCLEOFNATURE,
 WM_RANDOMIZESPELL,
 WM_GLOOMYDAY,
 WM_GREAT_ECHO,
 WM_SONG_OF_MANA,
 WM_DANCE_WITH_WUG,
 WM_SOUND_OF_DESTRUCTION,
 WM_SATURDAY_NIGHT_FEVER,
 WM_LERADS_DEW,
 WM_MELODYOFSINK,
 WM_BEYOND_OF_WARCRY,
 WM_UNLIMITED_HUMMING_VOICE,

 SO_FIREWALK = 2443,
 SO_ELECTRICWALK,
 SO_SPELLFIST,
 SO_EARTHGRAVE,
 SO_DIAMONDDUST,
 SO_POISON_BUSTER,
 SO_PSYCHIC_WAVE,
 SO_CLOUD_KILL,
 SO_STRIKING,
 SO_WARMER,
 SO_VACUUM_EXTREME,
 SO_VARETYR_SPEAR,
 SO_ARRULLO,
 SO_EL_CONTROL,
 SO_SUMMON_AGNI,
 SO_SUMMON_AQUA,
 SO_SUMMON_VENTUS,
 SO_SUMMON_TERA,
 SO_EL_ACTION,
 SO_EL_ANALYSIS,
 SO_EL_SYMPATHY,
 SO_EL_CURE,
 SO_FIRE_INSIGNIA,
 SO_WATER_INSIGNIA,
 SO_WIND_INSIGNIA,
 SO_EARTH_INSIGNIA,

 GN_TRAINING_SWORD = 2474,
 GN_REMODELING_CART,
 GN_CART_TORNADO,
 GN_CARTCANNON,
 GN_CARTBOOST,
 GN_THORNS_TRAP,
 GN_BLOOD_SUCKER,
 GN_SPORE_EXPLOSION,
 GN_WALLOFTHORN,
 GN_CRAZYWEED,
 GN_CRAZYWEED_ATK,
 GN_DEMONIC_FIRE,
 GN_FIRE_EXPANSION,
 GN_FIRE_EXPANSION_SMOKE_POWDER,
 GN_FIRE_EXPANSION_TEAR_GAS,
 GN_FIRE_EXPANSION_ACID,
 GN_HELLS_PLANT,
 GN_HELLS_PLANT_ATK,
 GN_MANDRAGORA,
 GN_SLINGITEM,
 GN_CHANGEMATERIAL,
 GN_MIX_COOKING,
 GN_MAKEBOMB,
 GN_S_PHARMACY,
 GN_SLINGITEM_RANGEMELEEATK,

 AB_SECRAMENT = 2515,
 WM_SEVERE_RAINSTORM_MELEE,
 SR_HOWLINGOFLION,
 SR_RIDEINLIGHTNING,
 LG_OVERBRAND_BRANDISH,
 LG_OVERBRAND_PLUSATK,

 ALL_ODINS_RECALL = 2533,
 RETURN_TO_ELDICASTES,
 ALL_BUYING_STORE,
 ALL_GUARDIAN_RECALL,
 ALL_ODINS_POWER,
 BEER_BOTTLE_CAP,
 NPC_ASSASSINCROSS,
 NPC_DISSONANCE,
 NPC_UGLYDANCE,
 ALL_TETANY,
 ALL_RAY_OF_PROTECTION,
 MC_CARTDECORATE,
 GM_ITEM_ATKMAX,
 GM_ITEM_ATKMIN,
 GM_ITEM_MATKMAX,
 GM_ITEM_MATKMIN,
 ALL_LIGHTGUARD,

 RL_GLITTERING_GREED = 2551,
 RL_RICHS_COIN,
 RL_MASS_SPIRAL,
 RL_BANISHING_BUSTER,
 RL_B_TRAP,
 RL_FLICKER,
 RL_S_STORM,
 RL_E_CHAIN,
 RL_QD_SHOT,
 RL_C_MARKER,
 RL_FIREDANCE,
 RL_H_MINE,
 RL_P_ALTER,
 RL_FALLEN_ANGEL,
 RL_R_TRIP,
 RL_D_TAIL,
 RL_FIRE_RAIN,
 RL_HEAT_BARREL,
 RL_AM_BLAST,
 RL_SLUGSHOT,
 RL_HAMMER_OF_GOD,
 RL_R_TRIP_PLUSATK,
 RL_B_FLICKER_ATK,
 RL_GLITTERING_GREED_ATK,

 KO_YAMIKUMO = 3001,
 KO_RIGHT,
 KO_LEFT,
 KO_JYUMONJIKIRI,
 KO_SETSUDAN,
 KO_BAKURETSU,
 KO_HAPPOKUNAI,
 KO_MUCHANAGE,
 KO_HUUMARANKA,
 KO_MAKIBISHI,
 KO_MEIKYOUSISUI,
 KO_ZANZOU,
 KO_KYOUGAKU,
 KO_JYUSATSU,
 KO_KAHU_ENTEN,
 KO_HYOUHU_HUBUKI,
 KO_KAZEHU_SEIRAN,
 KO_DOHU_KOUKAI,
 KO_KAIHOU,
 KO_ZENKAI,
 KO_GENWAKU,
 KO_IZAYOI,
 KG_KAGEHUMI,
 KG_KYOMU,
 KG_KAGEMUSYA,
 OB_ZANGETSU,
 OB_OBOROGENSOU,
 OB_OBOROGENSOU_TRANSITION_ATK,
 OB_AKAITSUKI,

 ECL_SNOWFLIP = 3031,
 ECL_PEONYMAMY,
 ECL_SADAGUI,
 ECL_SEQUOIADUST,
 ECLAGE_RECALL,
 BA_POEMBRAGI2,
 DC_FORTUNEKISS2,
 ITEM_OPTION_SPLASH_ATTACK,
 GM_FORCE_TRANSFER,
 GM_WIDE_RESURRECTION,

 GC_DARKCROW = 5001,
 RA_UNLIMIT,
 GN_ILLUSIONDOPING,
 RK_DRAGONBREATH_WATER,
 RK_LUXANIMA,
 NC_MAGMA_ERUPTION,
 WM_FRIGG_SONG,
 SO_ELEMENTAL_SHIELD,
 SR_FLASHCOMBO,
 SC_ESCAPE,
 AB_OFFERTORIUM,
 WL_TELEKINESIS_INTENSE,
 LG_KINGS_GRACE,
 ALL_FULL_THROTTLE,
 NC_MAGMA_ERUPTION_DOTDAMAGE,

 HLIF_HEAL = 8001,
 HLIF_AVOID,
 HLIF_BRAIN,
 HLIF_CHANGE,
 HAMI_CASTLE,
 HAMI_DEFENCE,
 HAMI_SKIN,
 HAMI_BLOODLUST,
 HFLI_MOON,
 HFLI_FLEET,
 HFLI_SPEED,
 HFLI_SBR44,
 HVAN_CAPRICE,
 HVAN_CHAOTIC,
 HVAN_INSTRUCT,
 HVAN_EXPLOSION,
 MUTATION_BASEJOB,
 MH_SUMMON_LEGION,
 MH_NEEDLE_OF_PARALYZE,
 MH_POISON_MIST,
 MH_PAIN_KILLER,
 MH_LIGHT_OF_REGENE,
 MH_OVERED_BOOST,
 MH_ERASER_CUTTER,
 MH_XENO_SLASHER,
 MH_SILENT_BREEZE,
 MH_STYLE_CHANGE,
 MH_SONIC_CRAW,
 MH_SILVERVEIN_RUSH,
 MH_MIDNIGHT_FRENZY,
 MH_STAHL_HORN,
 MH_GOLDENE_FERSE,
 MH_STEINWAND,
 MH_HEILIGE_STANGE,
 MH_ANGRIFFS_MODUS,
 MH_TINDER_BREAKER,
 MH_CBC,
 MH_EQC,
 MH_MAGMA_FLOW,
 MH_GRANITIC_ARMOR,
 MH_LAVA_SLIDE,
 MH_PYROCLASTIC,
 MH_VOLCANIC_ASH,

 MS_BASH = 8201,
 MS_MAGNUM,
 MS_BOWLINGBASH,
 MS_PARRYING,
 MS_REFLECTSHIELD,
 MS_BERSERK,
 MA_DOUBLE,
 MA_SHOWER,
 MA_SKIDTRAP,
 MA_LANDMINE,
 MA_SANDMAN,
 MA_FREEZINGTRAP,
 MA_REMOVETRAP,
 MA_CHARGEARROW,
 MA_SHARPSHOOTING,
 ML_PIERCE,
 ML_BRANDISH,
 ML_SPIRALPIERCE,
 ML_DEFENDER,
 ML_AUTOGUARD,
 ML_DEVOTION,
 MER_MAGNIFICAT,
 MER_QUICKEN,
 MER_SIGHT,
 MER_CRASH,
 MER_REGAIN,
 MER_TENDER,
 MER_BENEDICTION,
 MER_RECUPERATE,
 MER_MENTALCURE,
 MER_COMPRESS,
 MER_PROVOKE,
 MER_AUTOBERSERK,
 MER_DECAGI,
 MER_SCAPEGOAT,
 MER_LEXDIVINA,
 MER_ESTIMATION,
 MER_KYRIE,
 MER_BLESSING,
 MER_INCAGI,
 MER_INVINCIBLEOFF2,

 EL_CIRCLE_OF_FIRE = 8401,
 EL_FIRE_CLOAK,
 EL_FIRE_MANTLE,
 EL_WATER_SCREEN,
 EL_WATER_DROP,
 EL_WATER_BARRIER,
 EL_WIND_STEP,
 EL_WIND_CURTAIN,
 EL_ZEPHYR,
 EL_SOLID_SKIN,
 EL_STONE_SHIELD,
 EL_POWER_OF_GAIA,
 EL_PYROTECHNIC,
 EL_HEATER,
 EL_TROPIC,
 EL_AQUAPLAY,
 EL_COOLER,
 EL_CHILLY_AIR,
 EL_GUST,
 EL_BLAST,
 EL_WILD_STORM,
 EL_PETROLOGY,
 EL_CURSED_SOIL,
 EL_UPHEAVAL,
 EL_FIRE_ARROW,
 EL_FIRE_BOMB,
 EL_FIRE_BOMB_ATK,
 EL_FIRE_WAVE,
 EL_FIRE_WAVE_ATK,
 EL_ICE_NEEDLE,
 EL_WATER_SCREW,
 EL_WATER_SCREW_ATK,
 EL_TIDAL_WEAPON,
 EL_WIND_SLASH,
 EL_HURRICANE,
 EL_HURRICANE_ATK,
 EL_TYPOON_MIS,
 EL_TYPOON_MIS_ATK,
 EL_STONE_HAMMER,
 EL_ROCK_CRUSHER,
 EL_ROCK_CRUSHER_ATK,
 EL_STONE_RAIN,
};


enum {
 UNT_SAFETYWALL = 0x7e,
 UNT_FIREWALL,
 UNT_WARP_WAITING,
 UNT_WARP_ACTIVE,
 UNT_BENEDICTIO,
 UNT_SANCTUARY,
 UNT_MAGNUS,
 UNT_PNEUMA,
 UNT_DUMMYSKILL,
 UNT_FIREPILLAR_WAITING,
 UNT_FIREPILLAR_ACTIVE,
 UNT_HIDDEN_TRAP,
 UNT_TRAP,
 UNT_HIDDEN_WARP_NPC,
 UNT_USED_TRAPS,
 UNT_ICEWALL,
 UNT_QUAGMIRE,
 UNT_BLASTMINE,
 UNT_SKIDTRAP,
 UNT_ANKLESNARE,
 UNT_VENOMDUST,
 UNT_LANDMINE,
 UNT_SHOCKWAVE,
 UNT_SANDMAN,
 UNT_FLASHER,
 UNT_FREEZINGTRAP,
 UNT_CLAYMORETRAP,
 UNT_TALKIEBOX,
 UNT_VOLCANO,
 UNT_DELUGE,
 UNT_VIOLENTGALE,
 UNT_LANDPROTECTOR,
 UNT_LULLABY,
 UNT_RICHMANKIM,
 UNT_ETERNALCHAOS,
 UNT_DRUMBATTLEFIELD,
 UNT_RINGNIBELUNGEN,
 UNT_ROKISWEIL,
 UNT_INTOABYSS,
 UNT_SIEGFRIED,
 UNT_DISSONANCE,
 UNT_WHISTLE,
 UNT_ASSASSINCROSS,
 UNT_POEMBRAGI,
 UNT_APPLEIDUN,
 UNT_UGLYDANCE,
 UNT_HUMMING,
 UNT_DONTFORGETME,
 UNT_FORTUNEKISS,
 UNT_SERVICEFORYOU,
 UNT_GRAFFITI,
 UNT_DEMONSTRATION,
 UNT_CALLFAMILY,
 UNT_GOSPEL,
 UNT_BASILICA,
 UNT_MOONLIT,
 UNT_FOGWALL,
 UNT_SPIDERWEB,
 UNT_GRAVITATION,
 UNT_HERMODE,
 UNT_KAENSIN,
 UNT_SUITON,
 UNT_TATAMIGAESHI,
 UNT_KAEN,
 UNT_GROUNDDRIFT_WIND,
 UNT_GROUNDDRIFT_DARK,
 UNT_GROUNDDRIFT_POISON,
 UNT_GROUNDDRIFT_WATER,
 UNT_GROUNDDRIFT_FIRE,
 UNT_DEATHWAVE,
 UNT_WATERATTACK,
 UNT_WINDATTACK,
 UNT_EARTHQUAKE,
 UNT_EVILLAND,
 UNT_DARK_RUNNER,
 UNT_DARK_TRANSFER,
 UNT_EPICLESIS,
 UNT_EARTHSTRAIN,
 UNT_MANHOLE,
 UNT_DIMENSIONDOOR,
 UNT_CHAOSPANIC,
 UNT_MAELSTROM,
 UNT_BLOODYLUST,
 UNT_FEINTBOMB,
 UNT_MAGENTATRAP,
 UNT_COBALTTRAP,
 UNT_MAIZETRAP,
 UNT_VERDURETRAP,
 UNT_FIRINGTRAP,
 UNT_ICEBOUNDTRAP,
 UNT_ELECTRICSHOCKER,
 UNT_CLUSTERBOMB,
 UNT_REVERBERATION,
 UNT_SEVERE_RAINSTORM,
 UNT_FIREWALK,
 UNT_ELECTRICWALK,
 UNT_NETHERWORLD,
 UNT_PSYCHIC_WAVE,
 UNT_CLOUD_KILL,
 UNT_POISONSMOKE,
 UNT_NEUTRALBARRIER,
 UNT_STEALTHFIELD,
 UNT_WARMER,
 UNT_THORNS_TRAP,
 UNT_WALLOFTHORN,
 UNT_DEMONIC_FIRE,
 UNT_FIRE_EXPANSION_SMOKE_POWDER,
 UNT_FIRE_EXPANSION_TEAR_GAS,
 UNT_HELLS_PLANT,
 UNT_VACUUM_EXTREME,
 UNT_BANDING,
 UNT_FIRE_MANTLE,
 UNT_WATER_BARRIER,
 UNT_ZEPHYR,
 UNT_POWER_OF_GAIA,
 UNT_FIRE_INSIGNIA,
 UNT_WATER_INSIGNIA,
 UNT_WIND_INSIGNIA,
 UNT_EARTH_INSIGNIA,
 UNT_POISON_MIST,
 UNT_LAVA_SLIDE,
 UNT_VOLCANIC_ASH,
 UNT_ZENKAI_WATER,
 UNT_ZENKAI_LAND,
 UNT_ZENKAI_FIRE,
 UNT_ZENKAI_WIND,
 UNT_MAKIBISHI,
 UNT_VENOMFOG,
 UNT_ICEMINE,
 UNT_FLAMECROSS,
 UNT_HELLBURNING,
 UNT_MAGMA_ERUPTION,
 UNT_KINGS_GRACE,
 UNT_GLITTERING_GREED,
 UNT_B_TRAP,
 UNT_FIRE_RAIN,




 UNT_GD_LEADERSHIP = 0xc1,
 UNT_GD_GLORYWOUNDS = 0xc2,
 UNT_GD_SOULCOLD = 0xc3,
 UNT_GD_HAWKEYES = 0xc4,

 UNT_MAX = 0x190
};





struct skill_condition {
 int weapon,ammo,ammo_qty,hp,sp,zeny,spiritball,mhp,state;
 int itemid[10],amount[10];
};


struct s_skill_db {
 unsigned short nameid;
 char name[30];
 char desc[40];
 int range[10],hit,inf,element[10],nk,splash[10],max;
 int num[10];
 int cast[10],walkdelay[10],delay[10];

 int fixed_cast[10];

 int upkeep_time[10],upkeep_time2[10],cooldown[10];
 int castcancel,cast_def_rate;
 int inf2,maxcount[10],skill_type;
 int blewcount[10];
 int hp[10],sp[10],mhp[10],hp_rate[10],sp_rate[10],zeny[10];
 int weapon,ammo,ammo_qty[10],state,spiritball[10];
 int itemid[10],amount[10];
 int castnodex[10], delaynodex[10];
 int nocast;
 int unit_id[2];
 int unit_layout_type[10];
 int unit_range[10];
 int unit_interval;
 int unit_target;
 int unit_flag;
};

struct s_skill_unit_layout {
 int count;
 int dx[((5*2+1)*(5*2+1))];
 int dy[((5*2+1)*(5*2+1))];
};

struct skill_timerskill {
 int timer;
 int src_id;
 int target_id;
 int map;
 short x,y;
 uint16 skill_id,skill_lv;
 int type;
 int flag;
};

struct skill_unit_group {
 int src_id;
 int party_id;
 int guild_id;
 int bg_id;
 int map;
 int target_flag;
 int bl_flag;
 int64 tick;
 int limit,interval;

 uint16 skill_id,skill_lv;
 int val1,val2,val3;
 char *valstr;
 int unit_id;
 int group_id;
 int alive_count;
 int item_id;
 struct {
  int count;
  struct skill_unit *data;
 } unit;
 struct {
  unsigned ammo_consume : 1;
  unsigned song_dance : 2;
  unsigned guildaura : 1;
 } state;
};

struct skill_unit {
 struct block_list bl;

 struct skill_unit_group *group;

 int limit;
 int val1,val2;
 short alive,range;
 int prev;
};

struct skill_unit_group_tickset {
 int64 tick;
 int id;
};


struct s_skill_produce_db {
 int nameid, trigger;
 int req_skill,req_skill_lv,itemlv;
 int mat_id[10],mat_amount[10];
};


struct s_skill_arrow_db {
 int nameid, trigger;
 int cre_id[5],cre_amount[5];
};


struct s_skill_abra_db {
 uint16 skill_id;
 int req_lv;
 int per;
};


struct s_skill_magicmushroom_db {
 uint16 skill_id;
};

struct skill_cd_entry {
 int duration;

 int total;

 short skidx;
 int64 started;
 int timer;
 uint16 skill_id;
};







struct skill_cd {
 struct skill_cd_entry *entry[86];
 unsigned char cursor;
};




struct skill_unit_save {
 uint16 skill_id, skill_lv;
};

struct s_skill_improvise_db {
 uint16 skill_id;
 short per;
};

struct s_skill_changematerial_db {
 int itemid;
 short rate;
 int qty[5];
 short qty_rate[5];
};

struct s_skill_spellbook_db {
 int nameid;
 uint16 skill_id;
 int point;
};

typedef int (*SkillFunc)(struct block_list *src, struct block_list *target, uint16 skill_id, uint16 skill_lv, int64 tick, int flag);

struct s_skill_dbs {
int8 HERC__zeroed_block_BEGIN;
 struct s_skill_db db[1478];
 struct s_skill_produce_db produce_db[270];
 struct s_skill_arrow_db arrow_db[140];
 struct s_skill_abra_db abra_db[210];
 struct s_skill_magicmushroom_db magicmushroom_db[23];
 struct s_skill_improvise_db improvise_db[30];
 struct s_skill_changematerial_db changematerial_db[270];
 struct s_skill_spellbook_db spellbook_db[17];
 
# 1845 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 1845 "../../../server-code/src/map/skill.h"
     reproduce_db[1478];
int8 HERC__zeroed_block_END;
 struct s_skill_unit_layout unit_layout[45];
};




struct skill_interface {
 int (*init) (
# 1854 "../../../server-code/src/map/skill.h" 3 4
             _Bool 
# 1854 "../../../server-code/src/map/skill.h"
                  minimal);
 int (*final) (void);
 void (*reload) (void);
 void (*read_db) (
# 1857 "../../../server-code/src/map/skill.h" 3 4
                 _Bool 
# 1857 "../../../server-code/src/map/skill.h"
                      minimal);

 struct DBMap *cd_db;
 struct DBMap *name2id_db;
 struct DBMap *unit_db;
 struct DBMap *usave_db;
 struct DBMap *group_db;
 struct DBMap *bowling_db;

 struct eri *unit_ers;
 struct eri *timer_ers;
 struct eri *cd_ers;
 struct eri *cd_entry_ers;

 struct s_skill_dbs *dbs;

 int enchant_eff[5];
 int deluge_eff[5];
 int firewall_unit_pos;
 int icewall_unit_pos;
 int earthstrain_unit_pos;
 int area_temp[8];
 int unit_temp[20];
 int unit_group_newid;

 int (*get_index) ( uint16 skill_id );
 int (*get_type) ( uint16 skill_id );
 int (*get_hit) ( uint16 skill_id );
 int (*get_inf) ( uint16 skill_id );
 int (*get_ele) ( uint16 skill_id, uint16 skill_lv );
 int (*get_nk) ( uint16 skill_id );
 int (*get_max) ( uint16 skill_id );
 int (*get_range) ( uint16 skill_id, uint16 skill_lv );
 int (*get_range2) (struct block_list *bl, uint16 skill_id, uint16 skill_lv);
 int (*get_splash) ( uint16 skill_id, uint16 skill_lv );
 int (*get_hp) ( uint16 skill_id, uint16 skill_lv );
 int (*get_mhp) ( uint16 skill_id, uint16 skill_lv );
 int (*get_sp) ( uint16 skill_id, uint16 skill_lv );
 int (*get_state) (uint16 skill_id);
 int (*get_spiritball) (uint16 skill_id, uint16 skill_lv);
 int (*get_zeny) ( uint16 skill_id, uint16 skill_lv );
 int (*get_num) ( uint16 skill_id, uint16 skill_lv );
 int (*get_cast) ( uint16 skill_id, uint16 skill_lv );
 int (*get_delay) ( uint16 skill_id, uint16 skill_lv );
 int (*get_walkdelay) ( uint16 skill_id, uint16 skill_lv );
 int (*get_time) ( uint16 skill_id, uint16 skill_lv );
 int (*get_time2) ( uint16 skill_id, uint16 skill_lv );
 int (*get_castnodex) ( uint16 skill_id, uint16 skill_lv );
 int (*get_delaynodex) ( uint16 skill_id ,uint16 skill_lv );
 int (*get_castdef) ( uint16 skill_id );
 int (*get_weapontype) ( uint16 skill_id );
 int (*get_ammotype) ( uint16 skill_id );
 int (*get_ammo_qty) ( uint16 skill_id, uint16 skill_lv );
 int (*get_unit_id) (uint16 skill_id,int flag);
 int (*get_inf2) ( uint16 skill_id );
 int (*get_castcancel) ( uint16 skill_id );
 int (*get_maxcount) ( uint16 skill_id, uint16 skill_lv );
 int (*get_blewcount) ( uint16 skill_id, uint16 skill_lv );
 int (*get_unit_flag) ( uint16 skill_id );
 int (*get_unit_target) ( uint16 skill_id );
 int (*get_unit_interval) ( uint16 skill_id );
 int (*get_unit_bl_target) ( uint16 skill_id );
 int (*get_unit_layout_type) ( uint16 skill_id ,uint16 skill_lv );
 int (*get_unit_range) ( uint16 skill_id, uint16 skill_lv );
 int (*get_cooldown) ( uint16 skill_id, uint16 skill_lv );
 int (*tree_get_max) ( uint16 skill_id, int b_class );
 const char *(*get_name) ( uint16 skill_id );
 const char *(*get_desc) ( uint16 skill_id );

 void (*chk) (uint16* skill_id);

 int (*get_casttype) (uint16 skill_id);
 int (*get_casttype2) (uint16 index);
 
# 1930 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 1930 "../../../server-code/src/map/skill.h"
     (*is_combo) (int skill_id);
 int (*name2id) (const char* name);
 int (*isammotype) (struct map_session_data *sd, int skill_id);
 int (*castend_id) (int tid, int64 tick, int id, intptr_t data);
 int (*castend_pos) (int tid, int64 tick, int id, intptr_t data);
 int (*castend_map) ( struct map_session_data *sd,uint16 skill_id, const char *mapname);
 int (*cleartimerskill) (struct block_list *src);
 int (*addtimerskill) (struct block_list *src, int64 tick, int target, int x, int y, uint16 skill_id, uint16 skill_lv, int type, int flag);
 int (*additional_effect) (struct block_list* src, struct block_list *bl, uint16 skill_id, uint16 skill_lv, int attack_type, int dmg_lv, int64 tick);
 int (*counter_additional_effect) (struct block_list* src, struct block_list *bl, uint16 skill_id, uint16 skill_lv, int attack_type, int64 tick);
 int (*blown) (struct block_list* src, struct block_list* target, int count, int8 dir, int flag);
 int (*break_equip) (struct block_list *bl, unsigned short where, int rate, int flag);
 int (*strip_equip) (struct block_list *bl, unsigned short where, int rate, int lv, int time);
 struct skill_unit_group* (*id2group) (int group_id);
 struct skill_unit_group *(*unitsetting) (struct block_list* src, uint16 skill_id, uint16 skill_lv, short x, short y, int flag);
 struct skill_unit *(*initunit) (struct skill_unit_group *group, int idx, int x, int y, int val1, int val2);
 int (*delunit) (struct skill_unit *su);
 struct skill_unit_group *(*init_unitgroup) (struct block_list* src, int count, uint16 skill_id, uint16 skill_lv, int unit_id, int limit, int interval);
 int (*del_unitgroup) (struct skill_unit_group *group, const char* file, int line, const char* func);
 int (*clear_unitgroup) (struct block_list *src);
 int (*clear_group) (struct block_list *bl, int flag);
 int (*unit_onplace) (struct skill_unit *src, struct block_list *bl, int64 tick);
 int (*unit_ondamaged) (struct skill_unit *src, struct block_list *bl, int64 damage, int64 tick);
 int (*cast_fix) ( struct block_list *bl, uint16 skill_id, uint16 skill_lv);
 int (*cast_fix_sc) ( struct block_list *bl, int time);
 int (*vf_cast_fix) ( struct block_list *bl, double time, uint16 skill_id, uint16 skill_lv);
 int (*delay_fix) ( struct block_list *bl, uint16 skill_id, uint16 skill_lv);
 int (*check_condition_castbegin) (struct map_session_data *sd, uint16 skill_id, uint16 skill_lv);
 int (*check_condition_castend) (struct map_session_data *sd, uint16 skill_id, uint16 skill_lv);
 int (*consume_requirement) (struct map_session_data *sd, uint16 skill_id, uint16 skill_lv, short type);
 struct skill_condition (*get_requirement) (struct map_session_data *sd, uint16 skill_id, uint16 skill_lv);
 int (*check_pc_partner) (struct map_session_data *sd, uint16 skill_id, uint16* skill_lv, int range, int cast_flag);
 int (*unit_move) (struct block_list *bl, int64 tick, int flag);
 int (*unit_onleft) (uint16 skill_id, struct block_list *bl, int64 tick);
 int (*unit_onout) (struct skill_unit *src, struct block_list *bl, int64 tick);
 int (*unit_move_unit_group) ( struct skill_unit_group *group, int16 m,int16 dx,int16 dy);
 int (*sit) (struct map_session_data *sd, int type);
 void (*brandishspear) (struct block_list* src, struct block_list* bl, uint16 skill_id, uint16 skill_lv, int64 tick, int flag);
 void (*repairweapon) (struct map_session_data *sd, int idx);
 void (*identify) (struct map_session_data *sd,int idx);
 void (*weaponrefine) (struct map_session_data *sd,int idx);
 int (*autospell) (struct map_session_data *md,uint16 skill_id);
 int (*calc_heal) (struct block_list *src, struct block_list *target, uint16 skill_id, uint16 skill_lv, 
# 1972 "../../../server-code/src/map/skill.h" 3 4
                                                                                                       _Bool 
# 1972 "../../../server-code/src/map/skill.h"
                                                                                                            heal);
 
# 1973 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 1973 "../../../server-code/src/map/skill.h"
     (*check_cloaking) (struct block_list *bl, struct status_change_entry *sce);
 int (*check_cloaking_end) (struct block_list *bl, va_list ap);
 
# 1975 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 1975 "../../../server-code/src/map/skill.h"
     (*can_cloak) (struct map_session_data *sd);
 int (*enchant_elemental_end) (struct block_list *bl, int type);
 int (*not_ok) (uint16 skill_id, struct map_session_data *sd);
 int (*not_ok_hom) (uint16 skill_id, struct homun_data *hd);
 int (*not_ok_mercenary) (uint16 skill_id, struct mercenary_data *md);
 int (*chastle_mob_changetarget) (struct block_list *bl,va_list ap);
 int (*can_produce_mix) ( struct map_session_data *sd, int nameid, int trigger, int qty);
 int (*produce_mix) ( struct map_session_data *sd, uint16 skill_id, int nameid, int slot1, int slot2, int slot3, int qty );
 int (*arrow_create) ( struct map_session_data *sd,int nameid);
 int (*castend_nodamage_id) (struct block_list *src, struct block_list *bl, uint16 skill_id, uint16 skill_lv, int64 tick, int flag);
 int (*castend_damage_id) (struct block_list* src, struct block_list *bl, uint16 skill_id, uint16 skill_lv, int64 tick,int flag);
 int (*castend_pos2) (struct block_list *src, int x, int y, uint16 skill_id, uint16 skill_lv, int64 tick, int flag);
 int (*blockpc_start) (struct map_session_data *sd, uint16 skill_id, int tick);
 int (*blockhomun_start) (struct homun_data *hd, uint16 skill_id, int tick);
 int (*blockmerc_start) (struct mercenary_data *md, uint16 skill_id, int tick);
 int (*attack) (int attack_type, struct block_list* src, struct block_list *dsrc, struct block_list *bl, uint16 skill_id, uint16 skill_lv, int64 tick, int flag);
 int (*attack_area) (struct block_list *bl,va_list ap);
 int (*area_sub) (struct block_list *bl, va_list ap);
 int (*area_sub_count) (struct block_list *src, struct block_list *target, uint16 skill_id, uint16 skill_lv, int64 tick, int flag);
 int (*check_unit_range) (struct block_list *bl, int x, int y, uint16 skill_id, uint16 skill_lv);
 int (*check_unit_range_sub) (struct block_list *bl, va_list ap);
 int (*check_unit_range2) (struct block_list *bl, int x, int y, uint16 skill_id, uint16 skill_lv);
 int (*check_unit_range2_sub) (struct block_list *bl, va_list ap);
 void (*toggle_magicpower) (struct block_list *bl, uint16 skill_id);
 int (*magic_reflect) (struct block_list* src, struct block_list* bl, int type);
 int (*onskillusage) (struct map_session_data *sd, struct block_list *bl, uint16 skill_id, int64 tick);
 int (*cell_overlap) (struct block_list *bl, va_list ap);
 int (*timerskill) (int tid, int64 tick, int id, intptr_t data);
 int (*trap_splash) (struct block_list *bl, va_list ap);
 int (*check_condition_mercenary) (struct block_list *bl, int skill_id, int lv, int type);
 struct skill_unit_group *(*locate_element_field) (struct block_list *bl);
 int (*graffitiremover) (struct block_list *bl, va_list ap);
 int (*activate_reverberation) ( struct block_list *bl, va_list ap);
 int (*dance_overlap_sub) (struct block_list* bl, va_list ap);
 int (*dance_overlap) (struct skill_unit* su, int flag);
 struct s_skill_unit_layout *(*get_unit_layout) (uint16 skill_id, uint16 skill_lv, struct block_list* src, int x, int y);
 int (*frostjoke_scream) (struct block_list *bl, va_list ap);
 int (*greed) (struct block_list *bl, va_list ap);
 int (*destroy_trap) ( struct block_list *bl, va_list ap );
 struct skill_unit_group_tickset *(*unitgrouptickset_search) (struct block_list *bl, struct skill_unit_group *group, int64 tick);
 
# 2015 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2015 "../../../server-code/src/map/skill.h"
     (*dance_switch) (struct skill_unit* su, int flag);
 int (*check_condition_char_sub) (struct block_list *bl, va_list ap);
 int (*check_condition_mob_master_sub) (struct block_list *bl, va_list ap);
 void (*brandishspear_first) (struct square *tc, uint8 dir, int16 x, int16 y);
 void (*brandishspear_dir) (struct square* tc, uint8 dir, int are);
 int (*get_fixed_cast) ( uint16 skill_id ,uint16 skill_lv );
 int (*sit_count) (struct block_list *bl, va_list ap);
 int (*sit_in) (struct block_list *bl, va_list ap);
 int (*sit_out) (struct block_list *bl, va_list ap);
 void (*unitsetmapcell) (struct skill_unit *src, uint16 skill_id, uint16 skill_lv, cell_t cell, 
# 2024 "../../../server-code/src/map/skill.h" 3 4
                                                                                               _Bool 
# 2024 "../../../server-code/src/map/skill.h"
                                                                                                    flag);
 int (*unit_onplace_timer) (struct skill_unit *src, struct block_list *bl, int64 tick);
 int (*unit_effect) (struct block_list* bl, va_list ap);
 int (*unit_timer_sub_onplace) (struct block_list* bl, va_list ap);
 int (*unit_move_sub) (struct block_list* bl, va_list ap);
 int (*blockpc_end) (int tid, int64 tick, int id, intptr_t data);
 int (*blockhomun_end) (int tid, int64 tick, int id, intptr_t data);
 int (*blockmerc_end) (int tid, int64 tick, int id, intptr_t data);
 int (*split_atoi) (char *str, int *val);
 int (*unit_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*unit_timer_sub) (union DBKey key, struct DBData *data, va_list ap);
 void (*init_unit_layout) (void);
 
# 2036 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2036 "../../../server-code/src/map/skill.h"
     (*parse_row_skilldb) (char* split[], int columns, int current);
 
# 2037 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2037 "../../../server-code/src/map/skill.h"
     (*parse_row_requiredb) (char* split[], int columns, int current);
 
# 2038 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2038 "../../../server-code/src/map/skill.h"
     (*parse_row_castdb) (char* split[], int columns, int current);
 
# 2039 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2039 "../../../server-code/src/map/skill.h"
     (*parse_row_castnodexdb) (char* split[], int columns, int current);
 
# 2040 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2040 "../../../server-code/src/map/skill.h"
     (*parse_row_unitdb) (char* split[], int columns, int current);
 
# 2041 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2041 "../../../server-code/src/map/skill.h"
     (*parse_row_producedb) (char* split[], int columns, int current);
 
# 2042 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2042 "../../../server-code/src/map/skill.h"
     (*parse_row_createarrowdb) (char* split[], int columns, int current);
 
# 2043 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2043 "../../../server-code/src/map/skill.h"
     (*parse_row_abradb) (char* split[], int columns, int current);
 
# 2044 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2044 "../../../server-code/src/map/skill.h"
     (*parse_row_spellbookdb) (char* split[], int columns, int current);
 
# 2045 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2045 "../../../server-code/src/map/skill.h"
     (*parse_row_magicmushroomdb) (char* split[], int column, int current);
 
# 2046 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2046 "../../../server-code/src/map/skill.h"
     (*parse_row_reproducedb) (char* split[], int column, int current);
 
# 2047 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2047 "../../../server-code/src/map/skill.h"
     (*parse_row_improvisedb) (char* split[], int columns, int current);
 
# 2048 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2048 "../../../server-code/src/map/skill.h"
     (*parse_row_changematerialdb) (char* split[], int columns, int current);

 void (*usave_add) (struct map_session_data * sd, uint16 skill_id, uint16 skill_lv);

 void (*usave_trigger) (struct map_session_data *sd);

 void (*cooldown_load) (struct map_session_data * sd);

 int (*spellbook) (struct map_session_data *sd, int nameid);

 int (*block_check) (struct block_list *bl, enum sc_type type, uint16 skill_id);
 int (*detonator) (struct block_list *bl, va_list ap);
 
# 2060 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2060 "../../../server-code/src/map/skill.h"
     (*check_camouflage) (struct block_list *bl, struct status_change_entry *sce);
 int (*magicdecoy) (struct map_session_data *sd, int nameid);
 int (*poisoningweapon) ( struct map_session_data *sd, int nameid);
 int (*select_menu) (struct map_session_data *sd,uint16 skill_id);
 int (*elementalanalysis) (struct map_session_data *sd, uint16 skill_lv, const struct itemlist *item_list);
 int (*changematerial) (struct map_session_data *sd, const struct itemlist *item_list);
 int (*get_elemental_type) (uint16 skill_id, uint16 skill_lv);
 void (*cooldown_save) (struct map_session_data * sd);
 int (*get_new_group_id) (void);
 
# 2069 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2069 "../../../server-code/src/map/skill.h"
     (*check_shadowform) (struct block_list *bl, int64 damage, int hit);

 
# 2071 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2071 "../../../server-code/src/map/skill.h"
     (*castend_damage_id_unknown) (struct block_list* src, struct block_list *bl, uint16 *skill_id, uint16 *skill_lv, int64 *tick, int *flag, struct status_data *tstatus, struct status_change *sc);
 void (*additional_effect_unknown) (struct block_list* src, struct block_list *bl, uint16 *skill_id, uint16 *skill_lv, int *attack_type, int *dmg_lv, int64 *tick);
 void (*counter_additional_effect_unknown) (struct block_list* src, struct block_list *bl, uint16 *skill_id, uint16 *skill_lv, int *attack_type, int64 *tick);
 void (*attack_combo1_unknown) (int *attack_type, struct block_list* src, struct block_list *dsrc, struct block_list *bl, uint16 *skill_id, uint16 *skill_lv, int64 *tick, int *flag, struct status_change_entry *sce, int *combo);
 void (*attack_combo2_unknown) (int *attack_type, struct block_list* src, struct block_list *dsrc, struct block_list *bl, uint16 *skill_id, uint16 *skill_lv, int64 *tick, int *flag, int *combo);
 void (*attack_display_unknown) (int *attack_type, struct block_list* src, struct block_list *dsrc, struct block_list *bl, uint16 *skill_id, uint16 *skill_lv, int64 *tick, int *flag, int *type, struct Damage *dmg, int64 *damage);
 int (*attack_copy_unknown) (int *attack_type, struct block_list* src, struct block_list *dsrc, struct block_list *bl, uint16 *skill_id, uint16 *skill_lv, int64 *tick, int *flag);
 int (*attack_dir_unknown) (int *attack_type, struct block_list* src, struct block_list *dsrc, struct block_list *bl, uint16 *skill_id, uint16 *skill_lv, int64 *tick, int *flag);
 void (*attack_blow_unknown) (int *attack_type, struct block_list* src, struct block_list *dsrc, struct block_list *bl, uint16 *skill_id, uint16 *skill_lv, int64 *tick, int *flag, int *type, struct Damage *dmg, int64 *damage, int8 *dir);
 void (*attack_post_unknown) (int *attack_type, struct block_list* src, struct block_list *dsrc, struct block_list *bl, uint16 *skill_id, uint16 *skill_lv, int64 *tick, int *flag);
 
# 2081 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2081 "../../../server-code/src/map/skill.h"
     (*timerskill_dead_unknown) (struct block_list *src, struct unit_data *ud, struct skill_timerskill *skl);
 void (*timerskill_target_unknown) (int tid, int64 tick, struct block_list *src, struct block_list *target, struct unit_data *ud, struct skill_timerskill *skl);
 void (*timerskill_notarget_unknown) (int tid, int64 tick, struct block_list *src, struct unit_data *ud, struct skill_timerskill *skl);
 
# 2084 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2084 "../../../server-code/src/map/skill.h"
     (*cleartimerskill_exception) (int skill_id);
 
# 2085 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2085 "../../../server-code/src/map/skill.h"
     (*castend_id_unknown) (struct unit_data *ud, struct block_list *src, struct block_list *target);
 
# 2086 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2086 "../../../server-code/src/map/skill.h"
     (*castend_nodamage_id_dead_unknown) (struct block_list *src, struct block_list *bl, uint16 *skill_id, uint16 *skill_lv, int64 *tick, int *flag);
 
# 2087 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2087 "../../../server-code/src/map/skill.h"
     (*castend_nodamage_id_undead_unknown) (struct block_list *src, struct block_list *bl, uint16 *skill_id, uint16 *skill_lv, int64 *tick, int *flag);
 
# 2088 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2088 "../../../server-code/src/map/skill.h"
     (*castend_nodamage_id_mado_unknown) (struct block_list *src, struct block_list *bl, uint16 *skill_id, uint16 *skill_lv, int64 *tick, int *flag);
 
# 2089 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2089 "../../../server-code/src/map/skill.h"
     (*castend_nodamage_id_unknown) (struct block_list *src, struct block_list *bl, uint16 *skill_id, uint16 *skill_lv, int64 *tick, int *flag);
 void (*castend_pos2_effect_unknown) (struct block_list* src, int *x, int *y, uint16 *skill_id, uint16 *skill_lv, int64 *tick, int *flag);
 
# 2091 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2091 "../../../server-code/src/map/skill.h"
     (*castend_pos2_unknown) (struct block_list* src, int *x, int *y, uint16 *skill_id, uint16 *skill_lv, int64 *tick, int *flag);
 void (*unitsetting1_unknown) (struct block_list *src, uint16 *skill_id, uint16 *skill_lv, int16 *x, int16 *y, int *flag, int *val1, int *val2, int *val3);
 void (*unitsetting2_unknown) (struct block_list *src, uint16 *skill_id, uint16 *skill_lv, int16 *x, int16 *y, int *flag, int *unit_flag, int *val1, int *val2, int *val3, struct skill_unit_group *group);
 void (*unit_onplace_unknown) (struct skill_unit *src, struct block_list *bl, int64 *tick);
 int (*check_condition_castbegin_off_unknown) (struct status_change *sc, uint16 *skill_id);
 int (*check_condition_castbegin_mount_unknown) (struct status_change *sc, uint16 *skill_id);
 int (*check_condition_castbegin_madogear_unknown) (struct status_change *sc, uint16 *skill_id);
 int (*check_condition_castbegin_unknown) (struct status_change *sc, uint16 *skill_id);
 void (*check_condition_castend_unknown) (struct map_session_data* sd, uint16 *skill_id, uint16 *skill_lv);
 
# 2100 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2100 "../../../server-code/src/map/skill.h"
     (*get_requirement_off_unknown) (struct status_change *sc, uint16 *skill_id);
 
# 2101 "../../../server-code/src/map/skill.h" 3 4
_Bool 
# 2101 "../../../server-code/src/map/skill.h"
     (*get_requirement_item_unknown) (struct status_change *sc, struct map_session_data* sd, uint16 *skill_id, uint16 *skill_lv, uint16 *idx, int *i);
 void (*get_requirement_unknown) (struct status_change *sc, struct map_session_data* sd, uint16 *skill_id, uint16 *skill_lv, struct skill_condition *req);
};


void skill_defaults(void);


extern struct skill_interface *skill;
# 27 "../../../server-code/src/map/unit.h" 2


struct map_session_data;
struct block_list;




enum unit_stopwalking_flag {
 STOPWALKING_FLAG_NONE = 0x00,
 STOPWALKING_FLAG_FIXPOS = 0x01,
 STOPWALKING_FLAG_ONESTEP = 0x02,
 STOPWALKING_FLAG_NEXTCELL = 0x04,

 STOPWALKING_FLAG_MASK = 0xff,

};

struct unit_data {
 struct block_list *bl;
 struct walkpath_data walkpath;
 struct skill_timerskill *skilltimerskill[15];
 struct skill_unit_group *skillunit[25];
 struct skill_unit_group_tickset skillunittick[25];
 short attacktarget_lv;
 short to_x,to_y;
 short skillx,skilly;
 uint16 skill_id,skill_lv;
 int skilltarget;
 int skilltimer;
 int target;
 int target_to;
 int attacktimer;
 int walktimer;
 int chaserange;
 
# 62 "../../../server-code/src/map/unit.h" 3 4
_Bool 
# 62 "../../../server-code/src/map/unit.h"
      stepaction;
 int steptimer;
 uint16 stepskill_id,stepskill_lv;
 int64 attackabletime;
 int64 canact_tick;
 int64 canmove_tick;
 uint8 dir;
 unsigned char walk_count;
 unsigned char target_count;
 struct {
  unsigned change_walk_target : 1 ;
  unsigned skillcastcancel : 1 ;
  unsigned attack_continue : 1 ;
  unsigned step_attack : 1;
  unsigned walk_easy : 1 ;
  unsigned running : 1;
  unsigned speed_changed : 1;
 } state;
};

struct view_data {

 uint32 class_;



 uint16 weapon,
  shield,
  robe,
  head_top,
  head_mid,
  head_bottom,
  hair_style,
  hair_color,
  cloth_color,
  body_style;
 char sex;
 unsigned dead_sit : 2;
};

struct unit_interface {
 int (*init) (
# 103 "../../../server-code/src/map/unit.h" 3 4
             _Bool 
# 103 "../../../server-code/src/map/unit.h"
                  minimal);
 int (*final) (void);

 struct unit_data* (*bl2ud) (struct block_list *bl);
 struct unit_data* (*bl2ud2) (struct block_list *bl);
 int (*attack_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*walktoxy_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*walktoxy_sub) (struct block_list *bl);
 int (*delay_walktoxy_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*walktoxy) (struct block_list *bl, short x, short y, int flag);
 int (*walktobl_sub) (int tid, int64 tick, int id, intptr_t data);
 int (*walktobl) (struct block_list *bl, struct block_list *tbl, int range, int flag);
 
# 115 "../../../server-code/src/map/unit.h" 3 4
_Bool 
# 115 "../../../server-code/src/map/unit.h"
     (*run) (struct block_list *bl, struct map_session_data *sd, enum sc_type type);
 void (*run_hit) (struct block_list *bl, struct status_change *sc, struct map_session_data *sd, enum sc_type type);
 int (*escape) (struct block_list *bl, struct block_list *target, short dist);
 int (*movepos) (struct block_list *bl, short dst_x, short dst_y, int easy, 
# 118 "../../../server-code/src/map/unit.h" 3 4
                                                                           _Bool 
# 118 "../../../server-code/src/map/unit.h"
                                                                                checkpath);
 int (*setdir) (struct block_list *bl, unsigned char dir);
 uint8 (*getdir) (struct block_list *bl);
 int (*blown) (struct block_list *bl, int dx, int dy, int count, int flag);
 int (*warp) (struct block_list *bl, short m, short x, short y, clr_type type);
 int (*stop_walking) (struct block_list *bl, int type);
 int (*skilluse_id) (struct block_list *src, int target_id, uint16 skill_id, uint16 skill_lv);
 int (*step_timer) (int tid, int64 tick, int id, intptr_t data);
 void (*stop_stepaction) (struct block_list *bl);
 int (*is_walking) (struct block_list *bl);
 int (*can_move) (struct block_list *bl);
 int (*resume_running) (int tid, int64 tick, int id, intptr_t data);
 int (*set_walkdelay) (struct block_list *bl, int64 tick, int delay, int type);
 int (*skilluse_id2) (struct block_list *src, int target_id, uint16 skill_id, uint16 skill_lv, int casttime, int castcancel);
 int (*skilluse_pos) (struct block_list *src, short skill_x, short skill_y, uint16 skill_id, uint16 skill_lv);
 int (*skilluse_pos2) (struct block_list *src, short skill_x, short skill_y, uint16 skill_id, uint16 skill_lv, int casttime, int castcancel);
 int (*set_target) (struct unit_data *ud, int target_id);
 void (*stop_attack) (struct block_list *bl);
 int (*unattackable) (struct block_list *bl);
 int (*attack) (struct block_list *src, int target_id, int continuous);
 int (*cancel_combo) (struct block_list *bl);
 
# 139 "../../../server-code/src/map/unit.h" 3 4
_Bool 
# 139 "../../../server-code/src/map/unit.h"
     (*can_reach_pos) (struct block_list *bl, int x, int y, int easy);
 
# 140 "../../../server-code/src/map/unit.h" 3 4
_Bool 
# 140 "../../../server-code/src/map/unit.h"
     (*can_reach_bl) (struct block_list *bl, struct block_list *tbl, int range, int easy, short *x, short *y);
 int (*calc_pos) (struct block_list *bl, int tx, int ty, uint8 dir);
 int (*attack_timer_sub) (struct block_list *src, int tid, int64 tick);
 int (*skillcastcancel) (struct block_list *bl, int type);
 void (*dataset) (struct block_list *bl);
 int (*counttargeted) (struct block_list *bl);
 int (*fixdamage) (struct block_list *src, struct block_list *target, int sdelay, int ddelay, int64 damage, short div, unsigned char type, int64 damage2);
 int (*changeviewsize) (struct block_list *bl, short size);
 int (*remove_map) (struct block_list *bl, clr_type clrtype, const char *file, int line, const char *func);
 void (*remove_map_pc) (struct map_session_data *sd, clr_type clrtype);
 void (*free_pc) (struct map_session_data *sd);
 int (*free) (struct block_list *bl, clr_type clrtype);
};


extern const short dirx[8];
extern const short diry[8];

void unit_defaults(void);


extern struct unit_interface *unit;
# 26 "../../../server-code/src/map/elemental.h" 2
# 35 "../../../server-code/src/map/elemental.h"
enum elemental_id {
 ELEID_EL_AGNI_S = 2114,
 ELEID_EL_AGNI_M = 2115,
 ELEID_EL_AGNI_L = 2116,
 ELEID_EL_AQUA_S = 2117,
 ELEID_EL_AQUA_M = 2118,
 ELEID_EL_AQUA_L = 2119,
 ELEID_EL_VENTUS_S = 2120,
 ELEID_EL_VENTUS_M = 2121,
 ELEID_EL_VENTUS_L = 2122,
 ELEID_EL_TERA_S = 2123,
 ELEID_EL_TERA_M = 2124,
 ELEID_EL_TERA_L = 2125,
};
# 72 "../../../server-code/src/map/elemental.h"
struct elemental_skill {
 unsigned short id, lv;
 short mode;
};

struct s_elemental_db {
 int class_;
 char sprite[(23 + 1)], name[(23 + 1)];
 unsigned short lv;
 short range2, range3;
 struct status_data status;
 struct view_data vd;
 struct elemental_skill skill[3];
};

struct elemental_data {
 struct block_list bl;
 struct unit_data ud;
 struct view_data *vd;
 struct status_data base_status, battle_status;
 struct status_change sc;
 struct regen_data regen;

 struct s_elemental_db *db;
 struct s_elemental elemental;

 struct map_session_data *master;
 int summon_timer;
 int skill_timer;

 int64 last_thinktime, last_linktime, last_spdrain_time;
 short min_chase;
 int target_id, attacked_id;
};






struct elemental_interface {


 struct s_elemental_db db[12];


 int (*init) (
# 118 "../../../server-code/src/map/elemental.h" 3 4
             _Bool 
# 118 "../../../server-code/src/map/elemental.h"
                  minimal);
 void (*final) (void);

 
# 121 "../../../server-code/src/map/elemental.h" 3 4
_Bool 
# 121 "../../../server-code/src/map/elemental.h"
     (*class) (int class_);
 struct view_data * (*get_viewdata) (int class_);

 int (*create) (struct map_session_data *sd, int class_, unsigned int lifetime);
 int (*data_received) (const struct s_elemental *ele, 
# 125 "../../../server-code/src/map/elemental.h" 3 4
                                                     _Bool 
# 125 "../../../server-code/src/map/elemental.h"
                                                          flag);
 int (*save) (struct elemental_data *ed);

 int (*change_mode_ack) (struct elemental_data *ed, int mode);
 int (*change_mode) (struct elemental_data *ed, uint32 mode);

 void (*heal) (struct elemental_data *ed, int hp, int sp);
 int (*dead) (struct elemental_data *ed);

 int (*delete) (struct elemental_data *ed, int reply);
 void (*summon_stop) (struct elemental_data *ed);

 int (*get_lifetime) (struct elemental_data *ed);

 int (*unlocktarget) (struct elemental_data *ed);
 int (*skillnotok) (uint16 skill_id, struct elemental_data *ed);
 int (*set_target) (struct map_session_data *sd, struct block_list *bl);
 int (*clean_single_effect) (struct elemental_data *ed, uint16 skill_id);
 int (*clean_effect) (struct elemental_data *ed);
 int (*action) (struct elemental_data *ed, struct block_list *bl, int64 tick);
 struct skill_condition (*skill_get_requirements) (uint16 skill_id, uint16 skill_lv);

 int (*read_skilldb) (void);
 void (*reload_db) (void);
 void (*reload_skilldb) (void);

 int (*search_index) (int class_);
 void (*summon_init) (struct elemental_data *ed);
 int (*summon_end_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*ai_sub_timer_activesearch) (struct block_list *bl, va_list ap);
 int (*ai_sub_timer) (struct elemental_data *ed, struct map_session_data *sd, int64 tick);
 int (*ai_sub_foreachclient) (struct map_session_data *sd, va_list ap);
 int (*ai_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*read_db) (void);
};


void elemental_defaults(void);


extern struct elemental_interface *elemental;
# 33 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/map/guild.h" 1
# 29 "../../../server-code/src/map/guild.h"
struct map_session_data;
# 41 "../../../server-code/src/map/guild.h"
struct eventlist {
 char name[( (23 + 1) * 2 + 3 )];
 struct eventlist *next;
};





struct guardian_data {
 int number;

 struct guild *g;
 struct guild_castle* castle;
};
struct guild_expcache {
 int guild_id, account_id, char_id;
 uint64 exp;
};
struct s_guild_skill_tree {
 int id;
 int max;
 struct {
  short id;
  short lv;
 } need[5];
};


struct guild_interface {
 void (*init) (
# 71 "../../../server-code/src/map/guild.h" 3 4
              _Bool 
# 71 "../../../server-code/src/map/guild.h"
                   minimal);
 void (*final) (void);

 struct DBMap *db;
 struct DBMap *castle_db;
 struct DBMap *expcache_db;
 struct DBMap *infoevent_db;

 struct eri *expcache_ers;

 struct s_guild_skill_tree skill_tree[15];

 struct npc_data **flags;
 unsigned short flags_count;

 int (*skill_get_max) (int id);

 int (*checkskill) (struct guild *g,int id);
 int (*check_skill_require) (struct guild *g,int id);
 int (*checkcastles) (struct guild *g);
 
# 91 "../../../server-code/src/map/guild.h" 3 4
_Bool 
# 91 "../../../server-code/src/map/guild.h"
     (*isallied) (int guild_id, int guild_id2);

 struct guild *(*search) (int guild_id);
 struct guild *(*searchname) (char *str);
 struct guild_castle *(*castle_search) (int gcid);

 struct guild_castle *(*mapname2gc) (const char* mapname);
 struct guild_castle *(*mapindex2gc) (short map_index);

 struct map_session_data *(*getavailablesd) (struct guild *g);
 int (*getindex) (const struct guild *g, int account_id, int char_id);
 int (*getposition) (struct guild *g, struct map_session_data *sd);
 unsigned int (*payexp) (struct map_session_data *sd,unsigned int exp);
 int (*getexp) (struct map_session_data *sd,int exp);

 int (*create) (struct map_session_data *sd, const char *name);
 int (*created) (int account_id,int guild_id);
 int (*request_info) (int guild_id);
 int (*recv_noinfo) (int guild_id);
 int (*recv_info) (const struct guild *sg);
 int (*npc_request_info) (int guild_id,const char *ev);
 int (*invite) (struct map_session_data *sd,struct map_session_data *tsd);
 int (*reply_invite) (struct map_session_data *sd,int guild_id,int flag);
 void (*member_joined) (struct map_session_data *sd);
 int (*member_added) (int guild_id,int account_id,int char_id,int flag);
 int (*leave) (struct map_session_data *sd,int guild_id,int account_id,int char_id,const char *mes);
 int (*member_withdraw) (int guild_id,int account_id,int char_id,int flag,const char *name,const char *mes);
 int (*expulsion) (struct map_session_data *sd,int guild_id,int account_id,int char_id,const char *mes);
 int (*skillup) (struct map_session_data* sd, uint16 skill_id);
 void (*block_skill) (struct map_session_data *sd, int time);
 int (*reqalliance) (struct map_session_data *sd,struct map_session_data *tsd);
 int (*reply_reqalliance) (struct map_session_data *sd,int account_id,int flag);
 int (*allianceack) (int guild_id1,int guild_id2,int account_id1,int account_id2,int flag,const char *name1,const char *name2);
 int (*delalliance) (struct map_session_data *sd,int guild_id,int flag);
 int (*opposition) (struct map_session_data *sd,struct map_session_data *tsd);
 int (*check_alliance) (int guild_id1, int guild_id2, int flag);

 int (*send_memberinfoshort) (struct map_session_data *sd,int online);
 int (*recv_memberinfoshort) (int guild_id,int account_id,int char_id,int online,int lv,int class_);
 int (*change_memberposition) (int guild_id,int account_id,int char_id,short idx);
 int (*memberposition_changed) (struct guild *g,int idx,int pos);
 int (*change_position) (int guild_id,int idx,int mode,int exp_mode,const char *name);
 int (*position_changed) (int guild_id, int idx, const struct guild_position *p);
 int (*change_notice) (struct map_session_data *sd,int guild_id,const char *mes1,const char *mes2);
 int (*notice_changed) (int guild_id,const char *mes1,const char *mes2);
 int (*change_emblem) (struct map_session_data *sd,int len,const char *data);
 int (*emblem_changed) (int len,int guild_id,int emblem_id,const char *data);
 int (*send_message) (struct map_session_data *sd,const char *mes,int len);
 int (*recv_message) (int guild_id,int account_id,const char *mes,int len);
 int (*send_dot_remove) (struct map_session_data *sd);
 int (*skillupack) (int guild_id,uint16 skill_id,int account_id);
 int (*dobreak) (struct map_session_data *sd, const char *name);
 int (*broken) (int guild_id,int flag);
 int (*gm_change) (int guild_id, struct map_session_data *sd);
 int (*gm_changed) (int guild_id, int account_id, int char_id);

 void (*castle_map_init) (void);
 int (*castledatasave) (int castle_id,int index,int value);
 int (*castledataloadack) (int len, const struct guild_castle *gc);
 void (*castle_reconnect) (int castle_id, int index, int value);

 void (*agit_start) (void);
 void (*agit_end) (void);
 void (*agit2_start) (void);
 void (*agit2_end) (void);

 void (*flag_add) (struct npc_data *nd);
 void (*flag_remove) (struct npc_data *nd);
 void (*flags_clear) (void);

 void (*aura_refresh) (struct map_session_data *sd, uint16 skill_id, uint16 skill_lv);

 void (*retrieveitembound) (int char_id,int aid,int guild_id);

 int (*payexp_timer) (int tid, int64 tick, int id, intptr_t data);
 struct map_session_data *(*sd_check) (int guild_id, int account_id, int char_id);
 
# 167 "../../../server-code/src/map/guild.h" 3 4
_Bool 
# 167 "../../../server-code/src/map/guild.h"
     (*read_guildskill_tree_db) (char* split[], int columns, int current);
 
# 168 "../../../server-code/src/map/guild.h" 3 4
_Bool 
# 168 "../../../server-code/src/map/guild.h"
     (*read_castledb) (char* str[], int columns, int current);
 int (*payexp_timer_sub) (union DBKey key, struct DBData *data, va_list ap);
 int (*send_xy_timer_sub) (union DBKey key, struct DBData *data, va_list ap);
 int (*send_xy_timer) (int tid, int64 tick, int id, intptr_t data);
 struct DBData (*create_expcache) (union DBKey key, va_list args);
 int (*eventlist_db_final) (union DBKey key, struct DBData *data, va_list ap);
 int (*expcache_db_final) (union DBKey key, struct DBData *data, va_list ap);
 int (*castle_db_final) (union DBKey key, struct DBData *data, va_list ap);
 int (*broken_sub) (union DBKey key, struct DBData *data, va_list ap);
 int (*castle_broken_sub) (union DBKey key, struct DBData *data, va_list ap);
 void (*makemember) (struct guild_member *m,struct map_session_data *sd);
 int (*check_member) (const struct guild *g);
 int (*get_alliance_count) (struct guild *g,int flag);
 void (*castle_reconnect_sub) (void *key, void *data, va_list ap);
};


void guild_defaults(void);


extern struct guild_interface *guild;
# 34 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/map/homunculus.h" 1
# 29 "../../../server-code/src/map/homunculus.h"
struct map_session_data;


enum homun_id {
 HOMID_LIF = 6001,
 HOMID_AMISTR = 6002,
 HOMID_FILIR = 6003,
 HOMID_VANILMIRTH = 6004,
 HOMID_LIF2 = 6005,
 HOMID_AMISTR2 = 6006,
 HOMID_FILIR2 = 6007,
 HOMID_VANILMIRTH2 = 6008,
 HOMID_LIF_E = 6009,
 HOMID_AMISTR_E = 6010,
 HOMID_FILIR_E = 6011,
 HOMID_VANILMIRTH_E = 6012,
 HOMID_LIF2_E = 6013,
 HOMID_AMISTR2_E = 6014,
 HOMID_FILIR2_E = 6015,
 HOMID_VANILMIRTH2_E = 6016,

 HOMID_EIRA = 6048,
 HOMID_BAYERI = 6049,
 HOMID_SERA = 6050,
 HOMID_DIETR = 6051,
 HOMID_ELEANOR = 6052,
};
# 77 "../../../server-code/src/map/homunculus.h"
struct h_stats {
 unsigned int HP, SP;
 unsigned short str, agi, vit, int_, dex, luk;
};

struct s_homunculus_db {
 int base_class, evo_class;
 char name[(23 + 1)];
 struct h_stats base, gmin, gmax, emin, emax;
 int foodID ;
 int baseASPD ;
 long hungryDelay ;
 unsigned char element, race, base_size, evo_size;
};

enum {
 HOMUNCULUS_CLASS,
 HOMUNCULUS_FOOD
};

enum {
 MH_MD_FIGHTING = 1,
 MH_MD_GRAPPLING
};

enum {
 SP_ACK = 0x0,
 SP_INTIMATE = 0x1,
 SP_HUNGRY = 0x2,
};

enum homun_state {
 HOM_ST_ACTIVE = 0,
 HOM_ST_REST = 1,
 HOM_ST_MORPH = 2,
};

struct homun_data {
 struct block_list bl;
 struct unit_data ud;
 struct view_data *vd;
 struct status_data base_status, battle_status;
 struct status_change sc;
 struct regen_data regen;
 struct s_homunculus_db *homunculusDB;
 struct s_homunculus homunculus;

 struct map_session_data *master;
 int hungry_timer;
 unsigned int exp_next;
 char blockskill[1478];

 int64 masterteleport_timer;
};

struct homun_skill_tree_entry {
 short id;
 unsigned char max;
 unsigned char joblv;
 short intimacylv;
 struct {
  short id;
  unsigned char lv;
 } need[5];
};

enum homun_type {
 HT_REG,
 HT_EVO,
 HT_S,
 HT_INVALID = -1,
};

struct homun_dbs {
 unsigned int exptable[175];
 struct view_data viewdb[52];
 struct s_homunculus_db db[52];
 struct homun_skill_tree_entry skill_tree[52][86];
};


struct homunculus_interface {
 struct homun_dbs *dbs;

 void (*init) (
# 161 "../../../server-code/src/map/homunculus.h" 3 4
              _Bool 
# 161 "../../../server-code/src/map/homunculus.h"
                   minimal);
 void (*final) (void);
 void (*reload) (void);
 void (*reload_skill) (void);

 struct view_data* (*get_viewdata) (int class_);
 enum homun_type (*class2type) (int class_);
 void (*damaged) (struct homun_data *hd);
 int (*dead) (struct homun_data *hd);
 int (*vaporize) (struct map_session_data *sd, enum homun_state flag);
 int (*delete) (struct homun_data *hd, int emote);
 int (*checkskill) (struct homun_data *hd, uint16 skill_id);
 int (*calc_skilltree) (struct homun_data *hd, int flag_evolve);
 int (*skill_tree_get_max) (int id, int b_class);
 void (*skillup) (struct homun_data *hd, uint16 skill_id);
 
# 176 "../../../server-code/src/map/homunculus.h" 3 4
_Bool 
# 176 "../../../server-code/src/map/homunculus.h"
     (*levelup) (struct homun_data *hd);
 int (*change_class) (struct homun_data *hd, short class_);
 
# 178 "../../../server-code/src/map/homunculus.h" 3 4
_Bool 
# 178 "../../../server-code/src/map/homunculus.h"
     (*evolve) (struct homun_data *hd);
 
# 179 "../../../server-code/src/map/homunculus.h" 3 4
_Bool 
# 179 "../../../server-code/src/map/homunculus.h"
     (*mutate) (struct homun_data *hd, int homun_id);
 int (*gainexp) (struct homun_data *hd, unsigned int exp);
 unsigned int (*add_intimacy) (struct homun_data * hd, unsigned int value);
 unsigned int (*consume_intimacy) (struct homun_data *hd, unsigned int value);
 void (*healed) (struct homun_data *hd);
 void (*save) (struct homun_data *hd);
 unsigned char (*menu) (struct map_session_data *sd,unsigned char menu_num);
 
# 186 "../../../server-code/src/map/homunculus.h" 3 4
_Bool 
# 186 "../../../server-code/src/map/homunculus.h"
     (*feed) (struct map_session_data *sd, struct homun_data *hd);
 int (*hunger_timer) (int tid, int64 tick, int id, intptr_t data);
 void (*hunger_timer_delete) (struct homun_data *hd);
 int (*change_name) (struct map_session_data *sd, const char *name);
 
# 190 "../../../server-code/src/map/homunculus.h" 3 4
_Bool 
# 190 "../../../server-code/src/map/homunculus.h"
     (*change_name_ack) (struct map_session_data *sd, const char *name, int flag);
 int (*db_search) (int key,int type);
 
# 192 "../../../server-code/src/map/homunculus.h" 3 4
_Bool 
# 192 "../../../server-code/src/map/homunculus.h"
     (*create) (struct map_session_data *sd, const struct s_homunculus *hom);
 void (*init_timers) (struct homun_data * hd);
 
# 194 "../../../server-code/src/map/homunculus.h" 3 4
_Bool 
# 194 "../../../server-code/src/map/homunculus.h"
     (*call) (struct map_session_data *sd);
 
# 195 "../../../server-code/src/map/homunculus.h" 3 4
_Bool 
# 195 "../../../server-code/src/map/homunculus.h"
     (*recv_data) (int account_id, const struct s_homunculus *sh, int flag);
 
# 196 "../../../server-code/src/map/homunculus.h" 3 4
_Bool 
# 196 "../../../server-code/src/map/homunculus.h"
     (*creation_request) (struct map_session_data *sd, int class_);
 
# 197 "../../../server-code/src/map/homunculus.h" 3 4
_Bool 
# 197 "../../../server-code/src/map/homunculus.h"
     (*ressurect) (struct map_session_data* sd, unsigned char per, short x, short y);
 void (*revive) (struct homun_data *hd, unsigned int hp, unsigned int sp);
 void (*stat_reset) (struct homun_data *hd);
 
# 200 "../../../server-code/src/map/homunculus.h" 3 4
_Bool 
# 200 "../../../server-code/src/map/homunculus.h"
     (*shuffle) (struct homun_data *hd);
 
# 201 "../../../server-code/src/map/homunculus.h" 3 4
_Bool 
# 201 "../../../server-code/src/map/homunculus.h"
     (*read_db_sub) (char* str[], int columns, int current);
 void (*read_db) (void);
 
# 203 "../../../server-code/src/map/homunculus.h" 3 4
_Bool 
# 203 "../../../server-code/src/map/homunculus.h"
     (*read_skill_db_sub) (char* split[], int columns, int current);
 void (*skill_db_read) (void);
 void (*exp_db_read) (void);
 void (*addspiritball) (struct homun_data *hd, int max);
 void (*delspiritball) (struct homun_data *hd, int count, int type);
 int8 (*get_intimacy_grade) (struct homun_data *hd);
};


void homunculus_defaults(void);


extern struct homunculus_interface *homun;
# 35 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/map/instance.h" 1
# 24 "../../../server-code/src/map/instance.h"
# 1 "../../../server-code/src/map/script.h" 1
# 28 "../../../server-code/src/map/script.h"
# 1 "../../../server-code/src/common/strlib.h" 1
# 27 "../../../server-code/src/common/strlib.h"
# 1 "/usr/include/string.h" 1 3 4
# 27 "/usr/include/string.h" 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 33 "/usr/include/string.h" 2 3 4










# 42 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 92 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 123 "/usr/include/string.h" 3 4


extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

# 162 "/usr/include/string.h" 3 4
extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));




extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 206 "/usr/include/string.h" 3 4

# 231 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 258 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 277 "/usr/include/string.h" 3 4



extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 310 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 337 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 392 "/usr/include/string.h" 3 4


extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));

# 422 "/usr/include/string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__ , __leaf__))

                        __attribute__ ((__nonnull__ (2)));
# 440 "/usr/include/string.h" 3 4
extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));





extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 484 "/usr/include/string.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 512 "/usr/include/string.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 529 "/usr/include/string.h" 3 4
extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 552 "/usr/include/string.h" 3 4
extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 639 "/usr/include/string.h" 3 4

# 28 "../../../server-code/src/common/strlib.h" 2
# 54 "../../../server-code/src/common/strlib.h"

# 54 "../../../server-code/src/common/strlib.h"
typedef enum e_svopt {

 SV_NOESCAPE_NOTERMINATE = 0,

 SV_ESCAPE_C = 1,

 SV_TERMINATE_LF = 2,
 SV_TERMINATE_CRLF = 4,
 SV_TERMINATE_CR = 8,

 SV_KEEP_TERMINATOR = 16
} e_svopt;






struct s_svstate {
 const char* str;
 int len;
 int off;
 int start;
 int end;
 enum e_svopt opt;
 char delim;
 
# 80 "../../../server-code/src/common/strlib.h" 3 4
_Bool 
# 80 "../../../server-code/src/common/strlib.h"
     done;
};



struct StringBuf {
 char *buf_;
 char *ptr_;
 unsigned int max_;
};
typedef struct StringBuf StringBuf;

struct strlib_interface {
 char *(*jstrescape) (char* pt);
 char *(*jstrescapecpy) (char* pt, const char* spt);
 int (*jmemescapecpy) (char* pt, const char* spt, int size);
 int (*remove_control_chars_) (char* str);
 char *(*trim_) (char* str);
 char *(*normalize_name_) (char* str,const char* delims);
 const char *(*stristr_) (const char *haystack, const char *needle);


 size_t (*strnlen_) (const char* string, size_t maxlen);


 char * (*strtok_r_) (char *s1, const char *s2, char **lasts);

 int (*e_mail_check_) (char* email);
 int (*config_switch_) (const char* str);


 char *(*safestrncpy_) (char* dst, const char* src, size_t n);


 size_t (*safestrnlen_) (const char* string, size_t maxlen);




 int (*safesnprintf_) (char *buf, size_t sz, const char *fmt, ...) __attribute__((format(printf, 3, 4)));



 int (*strline_) (const char* str, size_t pos);




 
# 128 "../../../server-code/src/common/strlib.h" 3 4
_Bool 
# 128 "../../../server-code/src/common/strlib.h"
     (*bin2hex_) (char* output, unsigned char* input, size_t count);
};

struct stringbuf_interface {
 StringBuf* (*Malloc) (void);
 void (*Init) (StringBuf* self);
 int (*Printf) (StringBuf *self, const char *fmt, ...) __attribute__((format(printf, 2, 3)));
 int (*Vprintf) (StringBuf* self, const char* fmt, va_list args);
 int (*Append) (StringBuf* self, const StringBuf *sbuf);
 int (*AppendStr) (StringBuf* self, const char* str);
 int (*Length) (StringBuf* self);
 char* (*Value) (StringBuf* self);
 void (*Clear) (StringBuf* self);
 void (*Destroy) (StringBuf* self);
 void (*Free) (StringBuf* self);
};

struct sv_interface {





 int (*parse_next) (struct s_svstate* svstate);






 int (*parse) (const char* str, int len, int startoff, char delim, int* out_pos, int npos, enum e_svopt opt);







 int (*split) (char* str, int len, int startoff, char delim, char** out_fields, int nfields, enum e_svopt opt);




 size_t (*escape_c) (char* out_dest, const char* src, size_t len, const char* escapes);




 size_t (*unescape_c) (char* out_dest, const char* src, size_t len);


 const char* (*skip_escaped_c) (const char* p);




 
# 184 "../../../server-code/src/common/strlib.h" 3 4
_Bool 
# 184 "../../../server-code/src/common/strlib.h"
     (*readdb) (const char* directory, const char* filename, char delim, int mincols, int maxcols, int maxrows, 
# 184 "../../../server-code/src/common/strlib.h" 3 4
                                                                                                                _Bool 
# 184 "../../../server-code/src/common/strlib.h"
                                                                                                                     (*parseproc)(char* fields[], int columns, int current));
};


void strlib_defaults(void);


extern struct strlib_interface *strlib;
extern struct stringbuf_interface *StrBuf;
extern struct sv_interface *sv;
# 29 "../../../server-code/src/map/script.h" 2

# 1 "/usr/include/errno.h" 1 3 4
# 31 "/usr/include/errno.h" 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4



# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 50 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4

# 50 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 36 "/usr/include/errno.h" 2 3 4
# 58 "/usr/include/errno.h" 3 4

# 31 "../../../server-code/src/map/script.h" 2
# 1 "/usr/include/setjmp.h" 1 3 4
# 27 "/usr/include/setjmp.h" 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 30 "/usr/include/setjmp.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 31 "/usr/include/setjmp.h" 2 3 4



struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  };




typedef struct __jmp_buf_tag jmp_buf[1];



extern int setjmp (jmp_buf __env) __attribute__ ((__nothrow__));






extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) __attribute__ ((__nothrow__));



extern int _setjmp (struct __jmp_buf_tag __env[1]) __attribute__ ((__nothrow__));










extern void longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







extern void _longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







typedef struct __jmp_buf_tag sigjmp_buf[1];
# 102 "/usr/include/setjmp.h" 3 4
extern void siglongjmp (sigjmp_buf __env, int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
# 112 "/usr/include/setjmp.h" 3 4

# 32 "../../../server-code/src/map/script.h" 2





# 36 "../../../server-code/src/map/script.h"
struct Sql;
struct eri;
struct item_data;
# 192 "../../../server-code/src/map/script.h"
typedef enum c_op {
 C_NOP,
 C_POS,
 C_INT,
 C_PARAM,
 C_FUNC,
 C_STR,
 C_CONSTSTR,
 C_ARG,
 C_NAME,
 C_EOL,
 C_RETINFO,
 C_USERFUNC,
 C_USERFUNC_POS,
 C_REF,
 C_LSTR,


 C_OP3,
 C_LOR,
 C_LAND,
 C_LE,
 C_LT,
 C_GE,
 C_GT,
 C_EQ,
 C_NE,
 C_XOR,
 C_OR,
 C_AND,
 C_ADD,
 C_SUB,
 C_MUL,
 C_DIV,
 C_MOD,
 C_NEG,
 C_LNOT,
 C_NOT,
 C_R_SHIFT,
 C_L_SHIFT,
 C_ADD_POST,
 C_SUB_POST,
 C_ADD_PRE,
 C_SUB_PRE,
 C_RE_EQ,
 C_RE_NE,
} c_op;


enum ScriptQueueOptions {
 SQO_NONE,
 SQO_ONLOGOUT,
 SQO_ONDEATH,
 SQO_ONMAPCHANGE,
 SQO_MAX,
};

enum e_script_state { RUN,STOP,END,RERUNLINE,GOTO,RETFUNC,CLOSE };

enum script_parse_options {
 SCRIPT_USE_LABEL_DB = 0x1,
 SCRIPT_IGNORE_EXTERNAL_BRACKETS = 0x2,
 SCRIPT_RETURN_EMPTY_SCRIPT = 0x4
};

enum { LABEL_NEXTLINE=1,LABEL_START };



enum curly_type {
 TYPE_NULL = 0,
 TYPE_IF,
 TYPE_SWITCH,
 TYPE_WHILE,
 TYPE_FOR,
 TYPE_DO,
 TYPE_USERFUNC,
 TYPE_ARGLIST
};

enum e_arglist {
 ARGLIST_UNDEFINED = 0,
 ARGLIST_NO_PAREN = 1,
 ARGLIST_PAREN = 2,
};







enum {
 MF_NOMEMO,
 MF_NOTELEPORT,
 MF_NOSAVE,
 MF_NOBRANCH,
 MF_NOPENALTY,
 MF_NOZENYPENALTY,
 MF_PVP,
 MF_PVP_NOPARTY,
 MF_PVP_NOGUILD,
 MF_GVG,
 MF_GVG_NOPARTY,
 MF_NOTRADE,
 MF_NOSKILL,
 MF_NOWARP,
 MF_PARTYLOCK,
 MF_NOICEWALL,
 MF_SNOW,
 MF_FOG,
 MF_SAKURA,
 MF_LEAVES,

 MF_CLOUDS = 23,
 MF_CLOUDS2,
 MF_FIREWORKS,
 MF_GVG_CASTLE,
 MF_GVG_DUNGEON,
 MF_NIGHTENABLED,
 MF_NOBASEEXP,
 MF_NOJOBEXP,
 MF_NOMOBLOOT,
 MF_NOMVPLOOT,
 MF_NORETURN,
 MF_NOWARPTO,
 MF_NIGHTMAREDROP,
 MF_ZONE,
 MF_NOCOMMAND,
 MF_NODROP,
 MF_JEXP,
 MF_BEXP,
 MF_NOVENDING,
 MF_LOADEVENT,
 MF_NOCHAT,
 MF_NOEXPPENALTY,
 MF_GUILDLOCK,
 MF_TOWN,
 MF_AUTOTRADE,
 MF_ALLOWKS,
 MF_MONSTER_NOTELEPORT,
 MF_PVP_NOCALCRANK,
 MF_BATTLEGROUND,
 MF_RESET,
 MF_NOTOMB,
 MF_NOCASHSHOP,
 MF_NOVIEWID
};





struct Script_Config {
 unsigned warn_func_mismatch_argtypes : 1;
 unsigned warn_func_mismatch_paramnum : 1;
 int check_cmdcount;
 int check_gotocount;
 int input_min_value;
 int input_max_value;

 const char *die_event_name;
 const char *kill_pc_event_name;
 const char *kill_mob_event_name;
 const char *login_event_name;
 const char *logout_event_name;
 const char *loadmap_event_name;
 const char *baselvup_event_name;
 const char *joblvup_event_name;

 const char* ontouch_name;
 const char* ontouch2_name;
 const char* onuntouch_name;
};




struct reg_db {
 struct DBMap *vars;
 struct DBMap *arrays;
};

struct script_retinfo {
 struct reg_db scope;
 struct script_code* script;
 int pos;
 int nargs;
 int defsp;
};




struct script_data {
 enum c_op type;
 union script_data_val {
  int64 num;
  char *mutstr;
  const char *str;
  struct script_retinfo *ri;
 } u;
 struct reg_db *ref;
};



struct script_code {
 int script_size;
 unsigned char *script_buf;
 struct reg_db local;
 unsigned short instances;
};

struct script_stack {
 int sp;
 int sp_max;
 int defsp;
 struct script_data *stack_data;
 struct reg_db scope;
};





struct script_queue {
 int id;
 struct { int _max_; int _len_; int *_data_; } entries;
 
# 421 "../../../server-code/src/map/script.h" 3 4
_Bool 
# 421 "../../../server-code/src/map/script.h"
     valid;

 char event_logout[( (23 + 1) * 2 + 3 )];
 char event_death[( (23 + 1) * 2 + 3 )];
 char event_mapchange[( (23 + 1) * 2 + 3 )];
};




struct script_queue_iterator {
 struct { int _max_; int _len_; int *_data_; } entries;
 
# 433 "../../../server-code/src/map/script.h" 3 4
_Bool 
# 433 "../../../server-code/src/map/script.h"
     valid;
 int pos;
};

struct script_state {
 struct script_stack* stack;
 struct reg_db **pending_refs;
 int pending_ref_count;
 int start,end;
 int pos;
 enum e_script_state state;
 int rid,oid;
 struct script_code *script;
 struct sleep_data {
  int tick,timer,charid;
 } sleep;
 int instance_id;

 struct script_state *bk_st;
 unsigned char hIterator;
 int bk_npcid;
 unsigned freeloop : 1;
 unsigned op2ref : 1;
 unsigned npc_item_flag : 1;
 unsigned int id;
};

struct script_function {
 
# 461 "../../../server-code/src/map/script.h" 3 4
_Bool 
# 461 "../../../server-code/src/map/script.h"
     (*func)(struct script_state *st);
 char *name;
 char *arg;
 
# 464 "../../../server-code/src/map/script.h" 3 4
_Bool 
# 464 "../../../server-code/src/map/script.h"
     deprecated;
};



struct str_data_struct {
 enum c_op type;
 int str;
 int backpatch;
 int label;
 
# 474 "../../../server-code/src/map/script.h" 3 4
_Bool 
# 474 "../../../server-code/src/map/script.h"
     (*func)(struct script_state *st);
 int val;
 int next;
 uint8 deprecated : 1;
};

struct script_label_entry {
 int key,pos;
};

struct script_syntax_data {
 struct {
  enum curly_type type;
  int index;
  int count;
  int flag;
  struct linkdb_node *case_label;
 } curly[256];
 int curly_count;
 int index;
 int last_func;
 unsigned int nested_call;
 
# 496 "../../../server-code/src/map/script.h" 3 4
_Bool 
# 496 "../../../server-code/src/map/script.h"
     lang_macro_active;
 struct DBMap *strings;
 struct DBMap *translation_db;
};

struct casecheck_data {
 struct str_data_struct *str_data;
 int str_data_size;
 int str_num;

 char *str_buf;
 int str_size;
 int str_pos;
 int str_hash[1021];
 const char *(*add_str) (const char* p);
 void (*clear) (void);
};

struct script_array {
 unsigned int id;
 unsigned int size;
 unsigned int *members;
};

struct script_string_buf {
 char *ptr;
 size_t pos,size;
};

struct string_translation {
 int string_id;
 uint8 translations;
 unsigned int len;
 char *buf;
};




struct script_interface {

 struct DBMap *st_db;
 unsigned int active_scripts;
 unsigned int next_id;
 struct eri *st_ers;
 struct eri *stack_ers;

 struct { int _max_; int _len_; struct script_queue *_data_; } hq;
 struct { int _max_; int _len_; struct script_queue_iterator *_data_; } hqi;

 char **buildin;
 unsigned int buildin_count;



 struct eri *array_ers;

 struct str_data_struct *str_data;
 int str_data_size;
 int str_num;

 char *str_buf;
 size_t str_size;
 int str_pos;
 int str_hash[1021];

 char *word_buf;
 size_t word_size;

 char *string_list;
 int string_list_size;
 int string_list_pos;

 unsigned short current_item_id;

 struct script_label_entry *labels;
 int label_count;
 int labels_size;

 struct Script_Config config;



 unsigned char* buf;
 int pos, size;

 struct script_syntax_data syntax;

 int parse_options;

 int buildin_set_ref;
 int buildin_callsub_ref;
 int buildin_callfunc_ref;
 int buildin_getelementofarray_ref;

 jmp_buf error_jump;
 char* error_msg;
 const char* error_pos;
 int error_report;

 const char* parser_current_src;
 const char* parser_current_file;
 int parser_current_line;
 int parse_syntax_for_flag;

 unsigned int equip[20];



 struct DBMap *autobonus_db;
 struct DBMap *userfunc_db;

 int potion_flag;
 int potion_hp, potion_per_hp, potion_sp, potion_per_sp;
 int potion_target;

 unsigned int *generic_ui_array;
 unsigned int generic_ui_array_size;

 FILE *lang_export_fp;
 char *lang_export_file;

 const char *parser_current_npc_name;

 int buildin_mes_offset;
 int buildin_select_offset;
 int buildin_lang_macro_offset;

 struct DBMap *translation_db;
 char **translation_buf;
 uint32 translation_buf_size;

 char **languages;
 uint8 max_lang_id;

 struct script_string_buf parse_simpleexpr_str;
 struct script_string_buf lang_export_line_buf;
 struct script_string_buf lang_export_unescaped_buf;

 int parse_cleanup_timer_id;

 void (*init) (
# 637 "../../../server-code/src/map/script.h" 3 4
              _Bool 
# 637 "../../../server-code/src/map/script.h"
                   minimal);
 void (*final) (void);
 int (*reload) (void);

 struct script_code* (*parse) (const char* src,const char* file,int line,int options, int *retval);
 
# 642 "../../../server-code/src/map/script.h" 3 4
_Bool 
# 642 "../../../server-code/src/map/script.h"
     (*add_builtin) (const struct script_function *buildin, 
# 642 "../../../server-code/src/map/script.h" 3 4
                                                            _Bool 
# 642 "../../../server-code/src/map/script.h"
                                                                 override);
 void (*parse_builtin) (void);
 const char* (*parse_subexpr) (const char* p,int limit);
 const char* (*skip_space) (const char* p);
 void (*error) (const char* src, const char* file, int start_line, const char* error_msg, const char* error_pos);
 void (*warning) (const char* src, const char* file, int start_line, const char* error_msg, const char* error_pos);

 
# 649 "../../../server-code/src/map/script.h" 3 4
_Bool 
# 649 "../../../server-code/src/map/script.h"
     (*addScript) (char *name, char *args, 
# 649 "../../../server-code/src/map/script.h" 3 4
                                           _Bool 
# 649 "../../../server-code/src/map/script.h"
                                                (*func)(struct script_state *st), 
# 649 "../../../server-code/src/map/script.h" 3 4
                                                                                  _Bool 
# 649 "../../../server-code/src/map/script.h"
                                                                                       isDeprecated);
 int (*conv_num) (struct script_state *st,struct script_data *data);
 const char* (*conv_str) (struct script_state *st,struct script_data *data);
 struct map_session_data *(*rid2sd) (struct script_state *st);
 struct map_session_data *(*id2sd) (struct script_state *st, int account_id);
 struct map_session_data *(*charid2sd) (struct script_state *st, int char_id);
 struct map_session_data *(*nick2sd) (struct script_state *st, const char *name);
 void (*detach_rid) (struct script_state* st);
 struct script_data* (*push_val)(struct script_stack* stack, enum c_op type, int64 val, struct reg_db *ref);
 struct script_data *(*get_val) (struct script_state* st, struct script_data* data);
 char* (*get_val_ref_str) (struct script_state* st, struct reg_db *n, struct script_data* data);
 char* (*get_val_scope_str) (struct script_state* st, struct reg_db *n, struct script_data* data);
 char* (*get_val_npc_str) (struct script_state* st, struct reg_db *n, struct script_data* data);
 char* (*get_val_instance_str) (struct script_state* st, const char* name, struct script_data* data);
 int (*get_val_ref_num) (struct script_state* st, struct reg_db *n, struct script_data* data);
 int (*get_val_scope_num) (struct script_state* st, struct reg_db *n, struct script_data* data);
 int (*get_val_npc_num) (struct script_state* st, struct reg_db *n, struct script_data* data);
 int (*get_val_instance_num) (struct script_state* st, const char* name, struct script_data* data);
 const void *(*get_val2) (struct script_state *st, int64 uid, struct reg_db *ref);
 struct script_data *(*push_str) (struct script_stack *stack, char *str);
 struct script_data *(*push_conststr) (struct script_stack *stack, const char *str);
 struct script_data *(*push_copy) (struct script_stack *stack, int pos);
 void (*pop_stack) (struct script_state* st, int start, int end);
 void (*set_constant) (const char *name, int value, 
# 672 "../../../server-code/src/map/script.h" 3 4
                                                   _Bool 
# 672 "../../../server-code/src/map/script.h"
                                                        is_parameter, 
# 672 "../../../server-code/src/map/script.h" 3 4
                                                                      _Bool 
# 672 "../../../server-code/src/map/script.h"
                                                                           is_deprecated);
 void (*set_constant2) (const char *name, int value, 
# 673 "../../../server-code/src/map/script.h" 3 4
                                                    _Bool 
# 673 "../../../server-code/src/map/script.h"
                                                         is_parameter, 
# 673 "../../../server-code/src/map/script.h" 3 4
                                                                       _Bool 
# 673 "../../../server-code/src/map/script.h"
                                                                            is_deprecated);
 
# 674 "../../../server-code/src/map/script.h" 3 4
_Bool 
# 674 "../../../server-code/src/map/script.h"
     (*get_constant) (const char* name, int* value);
 void (*label_add)(int key, int pos);
 void (*run) (struct script_code *rootscript, int pos, int rid, int oid);
 void (*run_npc) (struct script_code *rootscript, int pos, int rid, int oid);
 void (*run_pet) (struct script_code *rootscript, int pos, int rid, int oid);
 void (*run_main) (struct script_state *st);
 int (*run_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*set_var) (struct map_session_data *sd, char *name, void *val);
 void (*stop_instances) (struct script_code *code);
 void (*free_code) (struct script_code* code);
 void (*free_vars) (struct DBMap *var_storage);
 struct script_state* (*alloc_state) (struct script_code* rootscript, int pos, int rid, int oid);
 void (*free_state) (struct script_state* st);
 void (*add_pending_ref) (struct script_state *st, struct reg_db *ref);
 void (*run_autobonus) (const char *autobonus,int id, int pos);
 void (*cleararray_pc) (struct map_session_data* sd, const char* varname, void* value);
 void (*setarray_pc) (struct map_session_data* sd, const char* varname, uint32 idx, void* value, int* refcache);
 int (*config_read) (char *cfgName);
 int (*add_str) (const char* p);
 const char* (*get_str) (int id);
 int (*search_str) (const char* p);
 void (*setd_sub) (struct script_state *st, struct map_session_data *sd, const char *varname, int elem, const void *value, struct reg_db *ref);
 void (*attach_state) (struct script_state* st);

 struct script_queue *(*queue) (int idx);
 
# 699 "../../../server-code/src/map/script.h" 3 4
_Bool 
# 699 "../../../server-code/src/map/script.h"
     (*queue_add) (int idx, int var);
 
# 700 "../../../server-code/src/map/script.h" 3 4
_Bool 
# 700 "../../../server-code/src/map/script.h"
     (*queue_del) (int idx);
 
# 701 "../../../server-code/src/map/script.h" 3 4
_Bool 
# 701 "../../../server-code/src/map/script.h"
     (*queue_remove) (int idx, int var);
 int (*queue_create) (void);
 
# 703 "../../../server-code/src/map/script.h" 3 4
_Bool 
# 703 "../../../server-code/src/map/script.h"
     (*queue_clear) (int idx);

 const char * (*parse_curly_close) (const char *p);
 const char * (*parse_syntax_close) (const char *p);
 const char * (*parse_syntax_close_sub) (const char *p, int *flag);
 const char * (*parse_syntax) (const char *p);
 c_op (*get_com) (unsigned char *scriptbuf, int *pos);
 int (*get_num) (unsigned char *scriptbuf, int *pos);
 const char* (*op2name) (int op);
 void (*reportsrc) (struct script_state *st);
 void (*reportdata) (struct script_data *data);
 void (*reportfunc) (struct script_state *st);
 void (*disp_warning_message) (const char *mes, const char *pos);
 void (*check_event) (struct script_state *st, const char *evt);
 unsigned int (*calc_hash) (const char *p);
 void (*addb) (int a);
 void (*addc) (int a);
 void (*addi) (int a);
 void (*addl) (int l);
 void (*set_label) (int l, int pos, const char *script_pos);
 const char* (*skip_word) (const char *p);
 int (*add_word) (const char *p);
 const char* (*parse_callfunc) (const char *p, int require_paren, int is_custom);
 void (*parse_nextline) (
# 726 "../../../server-code/src/map/script.h" 3 4
                        _Bool 
# 726 "../../../server-code/src/map/script.h"
                             first, const char *p);
 const char* (*parse_variable) (const char *p);
 const char* (*parse_simpleexpr) (const char *p);
 const char* (*parse_expr) (const char *p);
 const char* (*parse_line) (const char *p);
 void (*read_constdb) (void);
 void (*constdb_comment) (const char *comment);
 void (*load_parameters) (void);
 const char* (*print_line) (StringBuf *buf, const char *p, const char *mark, int line);
 void (*errorwarning_sub) (StringBuf *buf, const char *src, const char *file, int start_line, const char *error_msg, const char *error_pos);
 int (*set_reg) (struct script_state *st, struct map_session_data *sd, int64 num, const char *name, const void *value, struct reg_db *ref);
 void (*set_reg_ref_str) (struct script_state* st, struct reg_db *n, int64 num, const char* name, const char *str);
 void (*set_reg_scope_str) (struct script_state* st, struct reg_db *n, int64 num, const char* name, const char *str);
 void (*set_reg_npc_str) (struct script_state* st, struct reg_db *n, int64 num, const char* name, const char *str);
 void (*set_reg_instance_str) (struct script_state* st, int64 num, const char* name, const char *str);
 void (*set_reg_ref_num) (struct script_state* st, struct reg_db *n, int64 num, const char* name, int val);
 void (*set_reg_scope_num) (struct script_state* st, struct reg_db *n, int64 num, const char* name, int val);
 void (*set_reg_npc_num) (struct script_state* st, struct reg_db *n, int64 num, const char* name, int val);
 void (*set_reg_instance_num) (struct script_state* st, int64 num, const char* name, int val);
 void (*stack_expand) (struct script_stack *stack);
 struct script_data* (*push_retinfo) (struct script_stack *stack, struct script_retinfo *ri, struct reg_db *ref);
 void (*op_3) (struct script_state *st, int op);
 void (*op_2str) (struct script_state *st, int op, const char *s1, const char *s2);
 void (*op_2num) (struct script_state *st, int op, int i1, int i2);
 void (*op_2) (struct script_state *st, int op);
 void (*op_1) (struct script_state *st, int op);
 void (*check_buildin_argtype) (struct script_state *st, int func);
 void (*detach_state) (struct script_state *st, 
# 753 "../../../server-code/src/map/script.h" 3 4
                                               _Bool 
# 753 "../../../server-code/src/map/script.h"
                                                    dequeue_event);
 int (*db_free_code_sub) (union DBKey key, struct DBData *data, va_list ap);
 void (*add_autobonus) (const char *autobonus);
 int (*menu_countoptions) (const char *str, int max_count, int *total);
 int (*buildin_areawarp_sub) (struct block_list *bl, va_list ap);
 int (*buildin_areapercentheal_sub) (struct block_list *bl, va_list ap);
 void (*buildin_delitem_delete) (struct map_session_data *sd, int idx, int *amount, 
# 759 "../../../server-code/src/map/script.h" 3 4
                                                                                   _Bool 
# 759 "../../../server-code/src/map/script.h"
                                                                                        delete_items);
 
# 760 "../../../server-code/src/map/script.h" 3 4
_Bool 
# 760 "../../../server-code/src/map/script.h"
     (*buildin_delitem_search) (struct map_session_data *sd, struct item *it, 
# 760 "../../../server-code/src/map/script.h" 3 4
                                                                              _Bool 
# 760 "../../../server-code/src/map/script.h"
                                                                                   exact_match);
 int (*buildin_killmonster_sub_strip) (struct block_list *bl, va_list ap);
 int (*buildin_killmonster_sub) (struct block_list *bl, va_list ap);
 int (*buildin_killmonsterall_sub_strip) (struct block_list *bl, va_list ap);
 int (*buildin_killmonsterall_sub) (struct block_list *bl, va_list ap);
 int (*buildin_announce_sub) (struct block_list *bl, va_list ap);
 int (*buildin_getareausers_sub) (struct block_list *bl, va_list ap);
 int (*buildin_getareadropitem_sub) (struct block_list *bl, va_list ap);
 int (*mapflag_pvp_sub) (struct block_list *bl, va_list ap);
 int (*buildin_pvpoff_sub) (struct block_list *bl, va_list ap);
 int (*buildin_maprespawnguildid_sub_pc) (struct map_session_data *sd, va_list ap);
 int (*buildin_maprespawnguildid_sub_mob) (struct block_list *bl, va_list ap);
 int (*buildin_mobcount_sub) (struct block_list *bl, va_list ap);
 int (*playbgm_sub) (struct block_list *bl, va_list ap);
 int (*playbgm_foreachpc_sub) (struct map_session_data *sd, va_list args);
 int (*soundeffect_sub) (struct block_list *bl, va_list ap);
 int (*buildin_query_sql_sub) (struct script_state *st, struct Sql *handle);
 int (*buildin_instance_warpall_sub) (struct block_list *bl, va_list ap);
 int (*buildin_mobuseskill_sub) (struct block_list *bl, va_list ap);
 int (*cleanfloor_sub) (struct block_list *bl, va_list ap);
 int (*run_func) (struct script_state *st);
 const char *(*getfuncname) (struct script_state *st);

 unsigned int (*calc_hash_ci) (const char *p);
 struct casecheck_data local_casecheck;
 struct casecheck_data global_casecheck;




 struct reg_db *(*array_src) (struct script_state *st, struct map_session_data *sd, const char *name, struct reg_db *ref);
 void (*array_update) (struct reg_db *src, int64 num, 
# 791 "../../../server-code/src/map/script.h" 3 4
                                                     _Bool 
# 791 "../../../server-code/src/map/script.h"
                                                          empty);
 void (*array_delete) (struct reg_db *src, struct script_array *sa);
 void (*array_remove_member) (struct reg_db *src, struct script_array *sa, unsigned int idx);
 void (*array_add_member) (struct script_array *sa, unsigned int idx);
 unsigned int (*array_size) (struct script_state *st, struct map_session_data *sd, const char *name, struct reg_db *ref);
 unsigned int (*array_highest_key) (struct script_state *st, struct map_session_data *sd, const char *name, struct reg_db *ref);
 int (*array_free_db) (union DBKey key, struct DBData *data, va_list ap);
 void (*array_ensure_zero) (struct script_state *st, struct map_session_data *sd, int64 uid, struct reg_db *ref);

 void (*reg_destroy_single) (struct map_session_data *sd, int64 reg, struct script_reg_state *data);
 int (*reg_destroy) (union DBKey key, struct DBData *data, va_list ap);

 void (*generic_ui_array_expand) (unsigned int plus);
 unsigned int *(*array_cpy_list) (struct script_array *sa);

 void (*hardcoded_constants) (void);
 unsigned short (*mapindexname2id) (struct script_state *st, const char* name);
 int (*string_dup) (char *str);
 void (*load_translations) (void);
 void (*load_translation) (const char *file, uint8 lang_id, uint32 *total);
 int (*translation_db_destroyer) (union DBKey key, struct DBData *data, va_list ap);
 void (*clear_translations) (
# 812 "../../../server-code/src/map/script.h" 3 4
                            _Bool 
# 812 "../../../server-code/src/map/script.h"
                                 reload);
 int (*parse_cleanup_timer) (int tid, int64 tick, int id, intptr_t data);
 uint8 (*add_language) (const char *name);
 const char *(*get_translation_file_name) (const char *file);
 void (*parser_clean_leftovers) (void);
 void (*run_use_script) (struct map_session_data *sd, struct item_data *data, int oid);
 void (*run_item_equip_script) (struct map_session_data *sd, struct item_data *data, int oid);
 void (*run_item_unequip_script) (struct map_session_data *sd, struct item_data *data, int oid);
};


void script_defaults(void);


extern struct script_interface *script;
# 25 "../../../server-code/src/map/instance.h" 2



struct hplugin_data_store;
struct block_list;
struct map_session_data;



typedef enum instance_state {
 INSTANCE_FREE,
 INSTANCE_IDLE,
 INSTANCE_BUSY
} instance_state;

enum instance_owner_type {
 IOT_NONE,
 IOT_CHAR,
 IOT_PARTY,
 IOT_GUILD,

 IOT_MAX,
};

struct instance_data {
 unsigned short id;
 char name[(60+1)];
 instance_state state;
 enum instance_owner_type owner_type;
 int owner_id;

 unsigned short *map;
 unsigned short num_map;
 unsigned short users;

 struct reg_db regs;

 int progress_timer;
 unsigned int progress_timeout;

 int idle_timer;
 unsigned int idle_timeout, idle_timeoutval;

 unsigned int original_progress_timeout;

 struct point respawn;
 struct hplugin_data_store *hdata;
};

struct instance_interface {
 void (*init) (
# 75 "../../../server-code/src/map/instance.h" 3 4
              _Bool 
# 75 "../../../server-code/src/map/instance.h"
                   minimal);
 void (*final) (void);
 void (*reload) (void);

 unsigned short start_id;
 unsigned short instances;

 struct instance_data *list;

 int (*create) (int party_id, const char *name, enum instance_owner_type type);
 int (*add_map) (const char *name, int instance_id, 
# 85 "../../../server-code/src/map/instance.h" 3 4
                                                   _Bool 
# 85 "../../../server-code/src/map/instance.h"
                                                        usebasename, const char *map_name);
 void (*del_map) (int16 m);
 int (*map2imap) (int16 m, int instance_id);
 int (*mapid2imapid) (int16 m, int instance_id);
 int (*mapname2imap) (const char *map_name, int instance_id);
 int (*map_npcsub) (struct block_list* bl, va_list args);
 int (*init_npc) (struct block_list* bl, va_list args);
 void (*destroy) (int instance_id);
 void (*start) (int instance_id);
 void (*check_idle) (int instance_id);
 void (*check_kick) (struct map_session_data *sd);
 void (*set_timeout) (int instance_id, unsigned int progress_timeout, unsigned int idle_timeout);
 
# 97 "../../../server-code/src/map/instance.h" 3 4
_Bool 
# 97 "../../../server-code/src/map/instance.h"
     (*valid) (int instance_id);
 int (*destroy_timer) (int tid, int64 tick, int id, intptr_t data);
};


void instance_defaults(void);


extern struct instance_interface *instance;
# 36 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/map/intif.h" 1
# 29 "../../../server-code/src/map/intif.h"
struct auction_data;
struct guild_member;
struct guild_position;
struct guild_storage;
struct mail_message;
struct map_session_data;
struct party_member;
struct s_elemental;
struct s_homunculus;
struct s_mercenary;
struct s_pet;
# 55 "../../../server-code/src/map/intif.h"
struct intif_interface {

 int packet_len_table[161];

 int (*parse) (int fd);
 int (*create_pet)(int account_id, int char_id, short pet_type, short pet_lv, short pet_egg_id,
                   short pet_equip, short intimate, short hungry, char rename_flag, char incubate, char *pet_name);
 int (*broadcast) (const char* mes, size_t len, int type);
 int (*broadcast2) (const char* mes, size_t len, unsigned int fontColor, short fontType, short fontSize, short fontAlign, short fontY);
 int (*main_message) (struct map_session_data* sd, const char* message);
 int (*wis_message) (struct map_session_data *sd, const char *nick, const char *mes, size_t mes_len);
 int (*wis_message_to_gm) (char *Wisp_name, int permission, char *mes);
 int (*saveregistry) (struct map_session_data *sd);
 int (*request_registry) (struct map_session_data *sd, int flag);
 int (*request_guild_storage) (int account_id, int guild_id);
 int (*send_guild_storage) (int account_id, struct guild_storage *gstor);
 int (*create_party) (struct party_member *member, const char *name, int item, int item2);
 int (*request_partyinfo) (int party_id, int char_id);
 int (*party_addmember) (int party_id,struct party_member *member);
 int (*party_changeoption) (int party_id, int account_id, int exp, int item);
 int (*party_leave) (int party_id,int account_id, int char_id);
 int (*party_changemap) (struct map_session_data *sd, int online);
 int (*break_party) (int party_id);
 int (*party_message) (int party_id, int account_id, const char *mes,int len);
 int (*party_leaderchange) (int party_id,int account_id,int char_id);
 int (*guild_create) (const char *name, const struct guild_member *master);
 int (*guild_request_info) (int guild_id);
 int (*guild_addmember) (int guild_id, struct guild_member *m);
 int (*guild_leave) (int guild_id, int account_id, int char_id, int flag, const char *mes);
 int (*guild_memberinfoshort) (int guild_id, int account_id, int char_id, int online, int lv, int class_);
 int (*guild_break) (int guild_id);
 int (*guild_message) (int guild_id, int account_id, const char *mes, int len);
 int (*guild_change_gm) (int guild_id, const char* name, size_t len);
 int (*guild_change_basicinfo) (int guild_id, int type, const void *data, int len);
 int (*guild_change_memberinfo) (int guild_id, int account_id, int char_id, int type, const void *data, int len);
 int (*guild_position) (int guild_id, int idx, struct guild_position *p);
 int (*guild_skillup) (int guild_id, uint16 skill_id, int account_id, int max);
 int (*guild_alliance) (int guild_id1, int guild_id2, int account_id1, int account_id2, int flag);
 int (*guild_notice) (int guild_id, const char *mes1, const char *mes2);
 int (*guild_emblem) (int guild_id, int len, const char *data);
 int (*guild_castle_dataload) (int num, int *castle_ids);
 int (*guild_castle_datasave) (int castle_id, int index, int value);
 void (*itembound_req) (int char_id, int aid, int guild_id);
 int (*request_petdata) (int account_id, int char_id, int pet_id);
 int (*save_petdata) (int account_id, struct s_pet *p);
 int (*delete_petdata) (int pet_id);
 int (*rename) (struct map_session_data *sd, int type, const char *name);
 int (*homunculus_create) (int account_id, struct s_homunculus *sh);
 
# 103 "../../../server-code/src/map/intif.h" 3 4
_Bool 
# 103 "../../../server-code/src/map/intif.h"
     (*homunculus_requestload) (int account_id, int homun_id);
 int (*homunculus_requestsave) (int account_id, struct s_homunculus* sh);
 int (*homunculus_requestdelete) (int homun_id);

 void (*request_questlog) (struct map_session_data * sd);
 int (*quest_save) (struct map_session_data * sd);

 int (*mercenary_create) (struct s_mercenary *merc);
 int (*mercenary_request) (int merc_id, int char_id);
 int (*mercenary_delete) (int merc_id);
 int (*mercenary_save) (struct s_mercenary *merc);

 int (*Mail_requestinbox) (int char_id, unsigned char flag);
 int (*Mail_read) (int mail_id);
 int (*Mail_getattach) (int char_id, int mail_id);
 int (*Mail_delete) (int char_id, int mail_id);
 int (*Mail_return) (int char_id, int mail_id);
 int (*Mail_send) (int account_id, struct mail_message *msg);

 int (*Auction_requestlist) (int char_id, short type, int price, const char* searchtext, short page);
 int (*Auction_register) (struct auction_data *auction);
 int (*Auction_cancel) (int char_id, unsigned int auction_id);
 int (*Auction_close) (int char_id, unsigned int auction_id);
 int (*Auction_bid) (int char_id, const char* name, unsigned int auction_id, int bid);

 int (*elemental_create) (struct s_elemental *ele);
 int (*elemental_request) (int ele_id, int char_id);
 int (*elemental_delete) (int ele_id);
 int (*elemental_save) (struct s_elemental *ele);

 void (*request_accinfo) (int u_fd, int aid, int group_lv, char* query);

 int (*CheckForCharServer) (void);

 void (*pWisMessage) (int fd);
 void (*pWisEnd) (int fd);
 int (*pWisToGM_sub) (struct map_session_data* sd,va_list va);
 void (*pWisToGM) (int fd);
 void (*pRegisters) (int fd);
 void (*pChangeNameOk) (int fd);
 void (*pMessageToFD) (int fd);
 void (*pLoadGuildStorage) (int fd);
 void (*pSaveGuildStorage) (int fd);
 void (*pPartyCreated) (int fd);
 void (*pPartyInfo) (int fd);
 void (*pPartyMemberAdded) (int fd);
 void (*pPartyOptionChanged) (int fd);
 void (*pPartyMemberWithdraw) (int fd);
 void (*pPartyMove) (int fd);
 void (*pPartyBroken) (int fd);
 void (*pPartyMessage) (int fd);
 void (*pGuildCreated) (int fd);
 void (*pGuildInfo) (int fd);
 void (*pGuildMemberAdded) (int fd);
 void (*pGuildMemberWithdraw) (int fd);
 void (*pGuildMemberInfoShort) (int fd);
 void (*pGuildBroken) (int fd);
 void (*pGuildMessage) (int fd);
 void (*pGuildBasicInfoChanged) (int fd);
 void (*pGuildMemberInfoChanged) (int fd);
 void (*pGuildPosition) (int fd);
 void (*pGuildSkillUp) (int fd);
 void (*pGuildAlliance) (int fd);
 void (*pGuildNotice) (int fd);
 void (*pGuildEmblem) (int fd);
 void (*pGuildCastleDataLoad) (int fd);
 void (*pGuildMasterChanged) (int fd);
 void (*pQuestLog) (int fd);
 void (*pQuestSave) (int fd);
 void (*pMailInboxReceived) (int fd);
 void (*pMailNew) (int fd);
 void (*pMailGetAttach) (int fd);
 void (*pMailDelete) (int fd);
 void (*pMailReturn) (int fd);
 void (*pMailSend) (int fd);
 void (*pAuctionResults) (int fd);
 void (*pAuctionRegister) (int fd);
 void (*pAuctionCancel) (int fd);
 void (*pAuctionClose) (int fd);
 void (*pAuctionMessage) (int fd);
 void (*pAuctionBid) (int fd);
 void (*pItembound_ack) (int fd);
 void (*pMercenaryReceived) (int fd);
 void (*pMercenaryDeleted) (int fd);
 void (*pMercenarySaved) (int fd);
 void (*pElementalReceived) (int fd);
 void (*pElementalDeleted) (int fd);
 void (*pElementalSaved) (int fd);
 void (*pCreatePet) (int fd);
 void (*pRecvPetData) (int fd);
 void (*pSavePetOk) (int fd);
 void (*pDeletePetOk) (int fd);
 void (*pCreateHomunculus) (int fd);
 void (*pRecvHomunculusData) (int fd);
 void (*pSaveHomunculusOk) (int fd);
 void (*pDeleteHomunculusOk) (int fd);
};


void intif_defaults(void);


extern struct intif_interface *intif;
# 37 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/map/irc-bot.h" 1
# 35 "../../../server-code/src/map/irc-bot.h"
struct channel_data;

struct irc_func {
 char name[30];
 void (*func)(int, char*, char*, char*, char*);
};

struct irc_bot_interface {
 int fd;
 
# 44 "../../../server-code/src/map/irc-bot.h" 3 4
_Bool 
# 44 "../../../server-code/src/map/irc-bot.h"
     isIn, isOn;
 int64 last_try;
 unsigned char fails;
 uint32 ip;
 unsigned short port;

 struct channel_data *channel;

 struct {
  struct irc_func **list;
  unsigned int size;
 } funcs;

 void (*init) (
# 57 "../../../server-code/src/map/irc-bot.h" 3 4
              _Bool 
# 57 "../../../server-code/src/map/irc-bot.h"
                   minimal);
 void (*final) (void);

 int (*parse) (int fd);
 void (*parse_sub) (int fd, char *str);
 void (*parse_source) (char *source, char *nick, char *ident, char *host);

 struct irc_func* (*func_search) (char* function_name);

 int (*connect_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*identify_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*join_timer) (int tid, int64 tick, int id, intptr_t data);

 void (*send)(char *str);
 void (*relay) (const char *name, const char *msg);

 void (*pong) (int fd, char *cmd, char *source, char *target, char *msg);
 void (*privmsg) (int fd, char *cmd, char *source, char *target, char *msg);
 void (*userjoin) (int fd, char *cmd, char *source, char *target, char *msg);
 void (*userleave) (int fd, char *cmd, char *source, char *target, char *msg);
 void (*usernick) (int fd, char *cmd, char *source, char *target, char *msg);
};


void ircbot_defaults(void);


extern struct irc_bot_interface *ircbot;
# 38 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/map/itemdb.h" 1
# 29 "../../../server-code/src/map/itemdb.h"
struct config_setting_t;
struct script_code;
struct hplugin_data_store;
# 51 "../../../server-code/src/map/itemdb.h"
enum item_itemid {
 ITEMID_RED_POTION = 501,
 ITEMID_YELLOW_POTION = 503,
 ITEMID_WHITE_POTION = 504,
 ITEMID_BLUE_POTION = 505,
 ITEMID_APPLE = 512,
 ITEMID_HOLY_WATER = 523,
 ITEMID_PUMPKIN = 535,
 ITEMID_RED_SLIM_POTION = 545,
 ITEMID_YELLOW_SLIM_POTION = 546,
 ITEMID_WHITE_SLIM_POTION = 547,
 ITEMID_WING_OF_FLY = 601,
 ITEMID_WING_OF_BUTTERFLY = 602,
 ITEMID_BRANCH_OF_DEAD_TREE = 604,
 ITEMID_ANODYNE = 605,
 ITEMID_ALOEBERA = 606,
 ITEMID_MAGNIFIER = 611,
 ITEMID_POISON_BOTTLE = 678,
 ITEMID_EMPTY_BOTTLE = 713,
 ITEMID_EMPERIUM = 714,
 ITEMID_YELLOW_GEMSTONE = 715,
 ITEMID_RED_GEMSTONE = 716,
 ITEMID_BLUE_GEMSTONE = 717,
 ITEMID_ORIDECON_STONE = 756,
 ITEMID_ALCHOL = 970,
 ITEMID_ORIDECON = 984,
 ITEMID_ANVIL = 986,
 ITEMID_ORIDECON_ANVIL = 987,
 ITEMID_GOLDEN_ANVIL = 988,
 ITEMID_EMPERIUM_ANVIL = 989,
 ITEMID_BOODY_RED = 990,
 ITEMID_CRYSTAL_BLUE = 991,
 ITEMID_WIND_OF_VERDURE = 992,
 ITEMID_YELLOW_LIVE = 993,
 ITEMID_FLAME_HEART = 994,
 ITEMID_MISTIC_FROZEN = 995,
 ITEMID_ROUGH_WIND = 996,
 ITEMID_GREAT_NATURE = 997,
 ITEMID_IRON = 998,
 ITEMID_STEEL = 999,
 ITEMID_STAR_CRUMB = 1000,
 ITEMID_IRON_ORE = 1002,
 ITEMID_PHRACON = 1010,
 ITEMID_EMVERETARCON = 1011,
 ITEMID_TRAP = 1065,
 ITEMID_PILEBUNCKER = 1549,
 ITEMID_ANGRA_MANYU = 1599,
 ITEMID_STRANGE_EMBRYO = 6415,
 ITEMID_FACE_PAINT = 6120,
 ITEMID_SCARLET_POINT = 6360,
 ITEMID_INDIGO_POINT = 6361,
 ITEMID_YELLOW_WISH_POINT = 6362,
 ITEMID_LIME_GREEN_POINT = 6363,
 ITEMID_STONE = 7049,
 ITEMID_FIRE_BOTTLE = 7135,
 ITEMID_ACID_BOTTLE = 7136,
 ITEMID_MENEATER_PLANT_BOTTLE = 7137,
 ITEMID_MINI_BOTTLE = 7138,
 ITEMID_COATING_BOTTLE = 7139,
 ITEMID_FRAGMENT_OF_CRYSTAL = 7321,
 ITEMID_SKULL_ = 7420,
 ITEMID_TOKEN_OF_SIEGFRIED = 7621,
 ITEMID_GOLD_KEY77 = 7782,
 ITEMID_SILVER_KEY77 = 7783,
 ITEMID_TRAP_ALLOY = 7940,
 ITEMID_RED_POUCH_OF_SURPRISE = 12024,
 ITEMID_BLOODY_DEAD_BRANCH = 12103,
 ITEMID_PORING_BOX = 12109,
 ITEMID_MERCENARY_RED_POTION = 12184,
 ITEMID_MERCENARY_BLUE_POTION = 12185,
 ITEMID_BATTLE_MANUAL = 12208,
 ITEMID_BUBBLE_GUM = 12210,
 ITEMID_GIANT_FLY_WING = 12212,
 ITEMID_NEURALIZER = 12213,
 ITEMID_M_CENTER_POTION = 12241,
 ITEMID_M_AWAKENING_POTION = 12242,
 ITEMID_M_BERSERK_POTION = 12243,
 ITEMID_COMP_BATTLE_MANUAL = 12263,
 ITEMID_COMP_BUBBLE_GUM = 12264,
 ITEMID_LOVE_ANGEL = 12287,
 ITEMID_SQUIRREL = 12288,
 ITEMID_GOGO = 12289,
 ITEMID_PICTURE_DIARY = 12304,
 ITEMID_MINI_HEART = 12305,
 ITEMID_NEWCOMER = 12306,
 ITEMID_KID = 12307,
 ITEMID_MAGIC_CASTLE = 12308,
 ITEMID_BULGING_HEAD = 12309,
 ITEMID_THICK_MANUAL50 = 12312,
 ITEMID_NOVICE_MAGNIFIER = 12325,
 ITEMID_ANCILLA = 12333,
 ITEMID_REPAIR_A = 12392,
 ITEMID_REPAIR_B = 12393,
 ITEMID_REPAIR_C = 12394,
 ITEMID_BLACK_THING = 12435,
 ITEMID_REINS_OF_MOUNT = 12622,
 ITEMID_NOBLE_NAMEPLATE = 12705,
 ITEMID_DUN_TELE_SCROLL1 = 14527,
 ITEMID_BATTLE_MANUAL25 = 14532,
 ITEMID_BATTLE_MANUAL100 = 14533,
 ITEMID_BATTLE_MANUAL_X3 = 14545,
 ITEMID_DUN_TELE_SCROLL2 = 14581,
 ITEMID_WOB_RUNE = 14582,
 ITEMID_WOB_SCHWALTZ = 14583,
 ITEMID_WOB_RACHEL = 14584,
 ITEMID_WOB_LOCAL = 14585,
 ITEMID_SIEGE_TELEPORT_SCROLL = 14591,
 ITEMID_JOB_MANUAL50 = 14592,
 ITEMID_PILEBUNCKER_S = 16030,
 ITEMID_PILEBUNCKER_P = 16031,
 ITEMID_PILEBUNCKER_T = 16032,
};

enum cards_item_list {
 ITEMID_GHOSTRING_CARD = 4047,
 ITEMID_PHREEONI_CARD = 4121,
 ITEMID_MISTRESS_CARD = 4132,
 ITEMID_ORC_LOAD_CARD = 4135,
 ITEMID_ORC_HERO_CARD = 4143,
 ITEMID_TAO_GUNKA_CARD = 4302,
};




enum mechanic_item_list {
 ITEMID_ACCELERATOR = 2800,
 ITEMID_HOVERING_BOOSTER,
 ITEMID_SUICIDAL_DEVICE,
 ITEMID_SHAPE_SHIFTER,
 ITEMID_COOLING_DEVICE,
 ITEMID_MAGNETIC_FIELD_GENERATOR,
 ITEMID_BARRIER_BUILDER,
 ITEMID_REPAIR_KIT,
 ITEMID_CAMOUFLAGE_GENERATOR,
 ITEMID_HIGH_QUALITY_COOLER,
 ITEMID_SPECIAL_COOLER,
 ITEMID_MONKEY_SPANNER = 6186,
};




enum spell_book_item_list {
 ITEMID_MAGIC_BOOK_FB = 6189,
 ITEMID_MAGIC_BOOK_CB,
 ITEMID_MAGIC_BOOK_LB,
 ITEMID_MAGIC_BOOK_SG,
 ITEMID_MAGIC_BOOK_LOV,
 ITEMID_MAGIC_BOOK_MS,
 ITEMID_MAGIC_BOOK_CM,
 ITEMID_MAGIC_BOOK_TV,
 ITEMID_MAGIC_BOOK_TS,
 ITEMID_MAGIC_BOOK_JT,
 ITEMID_MAGIC_BOOK_WB,
 ITEMID_MAGIC_BOOK_HD,
 ITEMID_MAGIC_BOOK_ES,
 ITEMID_MAGIC_BOOK_ES_,
 ITEMID_MAGIC_BOOK_CL,
 ITEMID_MAGIC_BOOK_CR,
 ITEMID_MAGIC_BOOK_DL,
};




enum mercenary_scroll_item_list {
 ITEMID_BOW_MERCENARY_SCROLL1 = 12153,
 ITEMID_BOW_MERCENARY_SCROLL2,
 ITEMID_BOW_MERCENARY_SCROLL3,
 ITEMID_BOW_MERCENARY_SCROLL4,
 ITEMID_BOW_MERCENARY_SCROLL5,
 ITEMID_BOW_MERCENARY_SCROLL6,
 ITEMID_BOW_MERCENARY_SCROLL7,
 ITEMID_BOW_MERCENARY_SCROLL8,
 ITEMID_BOW_MERCENARY_SCROLL9,
 ITEMID_BOW_MERCENARY_SCROLL10,
 ITEMID_SWORDMERCENARY_SCROLL1,
 ITEMID_SWORDMERCENARY_SCROLL2,
 ITEMID_SWORDMERCENARY_SCROLL3,
 ITEMID_SWORDMERCENARY_SCROLL4,
 ITEMID_SWORDMERCENARY_SCROLL5,
 ITEMID_SWORDMERCENARY_SCROLL6,
 ITEMID_SWORDMERCENARY_SCROLL7,
 ITEMID_SWORDMERCENARY_SCROLL8,
 ITEMID_SWORDMERCENARY_SCROLL9,
 ITEMID_SWORDMERCENARY_SCROLL10,
 ITEMID_SPEARMERCENARY_SCROLL1,
 ITEMID_SPEARMERCENARY_SCROLL2,
 ITEMID_SPEARMERCENARY_SCROLL3,
 ITEMID_SPEARMERCENARY_SCROLL4,
 ITEMID_SPEARMERCENARY_SCROLL5,
 ITEMID_SPEARMERCENARY_SCROLL6,
 ITEMID_SPEARMERCENARY_SCROLL7,
 ITEMID_SPEARMERCENARY_SCROLL8,
 ITEMID_SPEARMERCENARY_SCROLL9,
 ITEMID_SPEARMERCENARY_SCROLL10,
};




enum cash_food_item_list {
 ITEMID_STR_DISH10_ = 12202,
 ITEMID_AGI_DISH10_,
 ITEMID_INT_DISH10_,
 ITEMID_DEX_DISH10_,
 ITEMID_LUK_DISH10_,
 ITEMID_VIT_DISH10_,
};




enum poison_item_list {
 ITEMID_POISON_PARALYSIS = 12717,
 ITEMID_POISON_LEECH,
 ITEMID_POISON_OBLIVION,
 ITEMID_POISON_CONTAMINATION,
 ITEMID_POISON_NUMB,
 ITEMID_POISON_FEVER,
 ITEMID_POISON_LAUGHING,
 ITEMID_POISON_FATIGUE,
};





enum rune_item_list {
 ITEMID_NAUTHIZ = 12725,
 ITEMID_RAIDO,
 ITEMID_BERKANA,
 ITEMID_ISA,
 ITEMID_OTHILA,
 ITEMID_URUZ,
 ITEMID_THURISAZ,
 ITEMID_WYRD,
 ITEMID_HAGALAZ,
 ITEMID_LUX_ANIMA = 22540,
};




enum geneticist_item_list {

 ITEMID_SEED_OF_HORNY_PLANT = 6210,
 ITEMID_BLOODSUCK_PLANT_SEED,
 ITEMID_BOMB_MUSHROOM_SPORE,
 ITEMID_HP_INCREASE_POTIONS = 12422,
 ITEMID_HP_INCREASE_POTIONM,
 ITEMID_HP_INCREASE_POTIONL,
 ITEMID_SP_INCREASE_POTIONS,
 ITEMID_SP_INCREASE_POTIONM,
 ITEMID_SP_INCREASE_POTIONL,
 ITEMID_ENRICH_WHITE_POTIONZ,
 ITEMID_SAVAGE_BBQ,
 ITEMID_WUG_BLOOD_COCKTAIL,
 ITEMID_MINOR_BRISKET,
 ITEMID_SIROMA_ICETEA,
 ITEMID_DROCERA_HERB_STEW,
 ITEMID_PETTI_TAIL_NOODLE,
 ITEMID_VITATA500,
 ITEMID_ENRICH_CELERMINE_JUICE,
 ITEMID_CURE_FREE,

 ITEMID_APPLE_BOMB = 13260,
 ITEMID_COCONUT_BOMB,
 ITEMID_MELON_BOMB,
 ITEMID_PINEAPPLE_BOMB,
 ITEMID_BANANA_BOMB,
 ITEMID_BLACK_LUMP,
 ITEMID_BLACK_HARD_LUMP,
 ITEMID_VERY_HARD_LUMP,

 ITEMID_MYSTERIOUS_POWDER,
 ITEMID_BOOST500_TO_THROW,
 ITEMID_FULL_SWINGK_TO_THROW,
 ITEMID_MANA_PLUS_TO_THROW,
 ITEMID_CURE_FREE_TO_THROW,
 ITEMID_STAMINA_UP_M_TO_THROW,
 ITEMID_DIGESTIVE_F_TO_THROW,
 ITEMID_HP_INC_POTS_TO_THROW,
 ITEMID_HP_INC_POTM_TO_THROW,
 ITEMID_HP_INC_POTL_TO_THROW,
 ITEMID_SP_INC_POTS_TO_THROW,
 ITEMID_SP_INC_POTM_TO_THROW,
 ITEMID_SP_INC_POTL_TO_THROW,
 ITEMID_EN_WHITE_POTZ_TO_THROW,
 ITEMID_VITATA500_TO_THROW,
 ITEMID_EN_CEL_JUICE_TO_THROW,
 ITEMID_SAVAGE_BBQ_TO_THROW,
 ITEMID_WUG_COCKTAIL_TO_THROW,
 ITEMID_M_BRISKET_TO_THROW,
 ITEMID_SIROMA_ICETEA_TO_THROW,
 ITEMID_DROCERA_STEW_TO_THROW,
 ITEMID_PETTI_NOODLE_TO_THROW,
 ITEMID_BLACK_THING_TO_THROW,
};


enum e_chain_cache {
 ECC_ORE,

 ECC_MAX,
};

enum item_class_upper {
 ITEMUPPER_NONE = 0x00,
 ITEMUPPER_NORMAL = 0x01,
 ITEMUPPER_UPPER = 0x02,
 ITEMUPPER_BABY = 0x04,
 ITEMUPPER_THIRD = 0x08,
 ITEMUPPER_THURDUPPER = 0x10,
 ITEMUPPER_THIRDBABY = 0x20,
 ITEMUPPER_ALL = 0x3f,
};




enum ItemTradeRestrictions {
 ITR_NONE = 0x000,
 ITR_NODROP = 0x001,
 ITR_NOTRADE = 0x002,
 ITR_PARTNEROVERRIDE = 0x004,
 ITR_NOSELLTONPC = 0x008,
 ITR_NOCART = 0x010,
 ITR_NOSTORAGE = 0x020,
 ITR_NOGSTORAGE = 0x040,
 ITR_NOMAIL = 0x080,
 ITR_NOAUCTION = 0x100,

 ITR_ALL = 0x1ff
};




enum ItemNouseRestrictions {
 INR_NONE = 0x0,
 INR_SITTING = 0x1,

 INR_ALL = 0x1
};


struct itemlist_entry {
 int id;
 int16 amount;
};

struct itemlist { int _max_; int _len_; struct itemlist_entry *_data_; };

struct item_combo {
 struct script_code *script;
 unsigned short nameid[6];
 unsigned char count;
 unsigned short id;
};

struct item_group {
 unsigned short id;
 unsigned short *nameid;
 unsigned short qty;
};

struct item_chain_entry {
 unsigned short id;
 unsigned short rate;
 struct item_chain_entry *next;
};

struct item_chain {
 struct item_chain_entry *items;
 unsigned short qty;
};

struct item_package_rand_entry {
 unsigned short id;
 unsigned short qty;
 unsigned short rate;
 unsigned short hours;
 unsigned int announce : 1;
 unsigned int named : 1;
 unsigned int force_serial: 1;
 struct item_package_rand_entry *next;
};

struct item_package_must_entry {
 unsigned short id;
 unsigned short qty;
 unsigned short hours;
 unsigned int announce : 1;
 unsigned int named : 1;
 unsigned int force_serial : 1;
};

struct item_package_rand_group {
 struct item_package_rand_entry *random_list;
 unsigned short random_qty;
};

struct item_package {
 unsigned short id;
 struct item_package_rand_group *random_groups;
 struct item_package_must_entry *must_items;
 unsigned short random_qty;
 unsigned short must_qty;
};

struct item_data {
 uint16 nameid;
 char name[50],jname[50];


 int value_buy;
 int value_sell;
 int type;
 int maxchance;
 int sex;
 int equip;
 int weight;
 int atk;
 int def;
 int range;
 int slot;
 int look;
 int elv;
 int wlv;
 int view_id;
 int matk;
 int elvmax;

 int delay;


 uint64 class_base[3];
 unsigned class_upper : 6;
 struct {
  unsigned short chance;
  int id;
 } mob[5];
 struct script_code *script;
 struct script_code *equip_script;
 struct script_code *unequip_script;
 struct {
  unsigned available : 1;
  unsigned no_refine : 1;
  unsigned delay_consume : 1;
  unsigned trade_restriction : 9;
  unsigned autoequip: 1;
  unsigned buyingstore : 1;
  unsigned bindonequip : 1;
  unsigned keepafteruse : 1;
  unsigned force_serial : 1;
 } flag;
 struct {
  unsigned short amount;
  unsigned int inventory:1;
  unsigned int cart:1;
  unsigned int storage:1;
  unsigned int guildstorage:1;
 } stack;
 struct {
  unsigned int flag;
  unsigned short override;
 } item_usage;
 short gm_lv_trade_override;

 struct item_combo **combos;
 unsigned char combos_count;

 struct item_group *group;
 struct item_package *package;
 struct hplugin_data_store *hdata;
};
# 573 "../../../server-code/src/map/itemdb.h"
struct itemdb_interface {
 void (*init) (
# 574 "../../../server-code/src/map/itemdb.h" 3 4
              _Bool 
# 574 "../../../server-code/src/map/itemdb.h"
                   minimal);
 void (*final) (void);
 void (*reload) (void);
 void (*name_constants) (void);

 struct item_group *groups;
 unsigned short group_count;

 struct item_chain *chains;
 unsigned short chain_count;
 unsigned short chain_cache[ECC_MAX];

 struct item_package *packages;
 unsigned short package_count;

 struct item_combo **combos;
 unsigned short combo_count;

 struct DBMap *names;

 struct item_data *array[0x8000];
 struct DBMap *other;
 struct item_data dummy;

 void (*read_groups) (void);
 void (*read_chains) (void);
 void (*read_packages) (void);

 void (*write_cached_packages) (const char *config_filename);
 
# 603 "../../../server-code/src/map/itemdb.h" 3 4
_Bool 
# 603 "../../../server-code/src/map/itemdb.h"
     (*read_cached_packages) (const char *config_filename);

 struct item_data* (*name2id) (const char *str);
 struct item_data* (*search_name) (const char *name);
 int (*search_name_array) (struct item_data** data, int size, const char *str, int flag);
 struct item_data* (*load)(int nameid);
 struct item_data* (*search)(int nameid);
 struct item_data* (*exists) (int nameid);
 
# 611 "../../../server-code/src/map/itemdb.h" 3 4
_Bool 
# 611 "../../../server-code/src/map/itemdb.h"
     (*in_group) (struct item_group *group, int nameid);
 int (*group_item) (struct item_group *group);
 int (*chain_item) (unsigned short chain_id, int *rate);
 void (*package_item) (struct map_session_data *sd, struct item_package *package);
 int (*searchname_sub) (union DBKey key, struct DBData *data, va_list ap);
 int (*searchname_array_sub) (union DBKey key, struct DBData data, va_list ap);
 int (*searchrandomid) (struct item_group *group);
 const char* (*typename) (int type);
 void (*jobmask2mapid) (uint64 *bclass, uint64 jobmask);
 void (*jobid2mapid) (uint64 *bclass, int job_id, 
# 620 "../../../server-code/src/map/itemdb.h" 3 4
                                                 _Bool 
# 620 "../../../server-code/src/map/itemdb.h"
                                                      enable);
 void (*create_dummy_data) (void);
 struct item_data* (*create_item_data) (int nameid);
 int (*isequip) (int nameid);
 int (*isequip2) (struct item_data *data);
 int (*isstackable) (int nameid);
 int (*isstackable2) (struct item_data *data);
 int (*isdropable_sub) (struct item_data *item, int gmlv, int unused);
 int (*cantrade_sub) (struct item_data *item, int gmlv, int gmlv2);
 int (*canpartnertrade_sub) (struct item_data *item, int gmlv, int gmlv2);
 int (*cansell_sub) (struct item_data *item, int gmlv, int unused);
 int (*cancartstore_sub) (struct item_data *item, int gmlv, int unused);
 int (*canstore_sub) (struct item_data *item, int gmlv, int unused);
 int (*canguildstore_sub) (struct item_data *item, int gmlv, int unused);
 int (*canmail_sub) (struct item_data *item, int gmlv, int unused);
 int (*canauction_sub) (struct item_data *item, int gmlv, int unused);
 int (*isrestricted) (struct item *item, int gmlv, int gmlv2, int(*func)(struct item_data *, int, int));
 int (*isidentified) (int nameid);
 int (*isidentified2) (struct item_data *data);
 int (*combo_split_atoi) (char *str, int *val);
 void (*read_combos) (void);
 int (*gendercheck) (struct item_data *id);
 int (*validate_entry) (struct item_data *entry, int n, const char *source);
 void (*readdb_additional_fields) (int itemid, struct config_setting_t *it, int n, const char *source);
 void (*readdb_job_sub) (struct item_data *id, struct config_setting_t *t);
 int (*readdb_libconfig_sub) (struct config_setting_t *it, int n, const char *source);
 int (*readdb_libconfig) (const char *filename);
 uint64 (*unique_id) (struct map_session_data *sd);
 void (*read) (
# 648 "../../../server-code/src/map/itemdb.h" 3 4
              _Bool 
# 648 "../../../server-code/src/map/itemdb.h"
                   minimal);
 void (*destroy_item_data) (struct item_data *self, int free_self);
 int (*final_sub) (union DBKey key, struct DBData *data, va_list ap);
 void (*clear) (
# 651 "../../../server-code/src/map/itemdb.h" 3 4
               _Bool 
# 651 "../../../server-code/src/map/itemdb.h"
                    total);
 struct item_combo * (*id2combo) (unsigned short id);
 
# 653 "../../../server-code/src/map/itemdb.h" 3 4
_Bool 
# 653 "../../../server-code/src/map/itemdb.h"
     (*is_item_usable) (struct item_data *item);
 
# 654 "../../../server-code/src/map/itemdb.h" 3 4
_Bool 
# 654 "../../../server-code/src/map/itemdb.h"
     (*lookup_const) (const struct config_setting_t *it, const char *name, int *value);
};


void itemdb_defaults(void);


extern struct itemdb_interface *itemdb;
# 39 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/map/log.h" 1
# 29 "../../../server-code/src/map/log.h"
struct Sql;
struct item;
struct item_data;
struct map_session_data;
struct mob_data;
# 49 "../../../server-code/src/map/log.h"
typedef enum e_log_chat_type {
 LOG_CHAT_GLOBAL = 0x01,
 LOG_CHAT_WHISPER = 0x02,
 LOG_CHAT_PARTY = 0x04,
 LOG_CHAT_GUILD = 0x08,
 LOG_CHAT_MAINCHAT = 0x10,

 LOG_CHAT_ALL = 0xFF,
} e_log_chat_type;

typedef enum e_log_pick_type {
 LOG_TYPE_NONE = 0x00000000,
 LOG_TYPE_TRADE = 0x00000001,
 LOG_TYPE_VENDING = 0x00000002,
 LOG_TYPE_PICKDROP_PLAYER = 0x00000004,
 LOG_TYPE_PICKDROP_MONSTER = 0x00000008,
 LOG_TYPE_NPC = 0x00000010,
 LOG_TYPE_SCRIPT = 0x00000020,
 LOG_TYPE_STEAL = 0x00000040,
 LOG_TYPE_CONSUME = 0x00000080,
 LOG_TYPE_PRODUCE = 0x00000100,
 LOG_TYPE_MVP = 0x00000200,
 LOG_TYPE_COMMAND = 0x00000400,
 LOG_TYPE_STORAGE = 0x00000800,
 LOG_TYPE_GSTORAGE = 0x00001000,
 LOG_TYPE_MAIL = 0x00002000,
 LOG_TYPE_AUCTION = 0x00004000,
 LOG_TYPE_BUYING_STORE = 0x00008000,
 LOG_TYPE_OTHER = 0x00010000,
 LOG_TYPE_BANK = 0x00020000,
 LOG_TYPE_DIVORCE = 0x00040000,
 LOG_TYPE_ROULETTE = 0x00080000,
 LOG_TYPE_RENTAL = 0x00100000,
 LOG_TYPE_CARD = 0x00200000,
 LOG_TYPE_INV_INVALID = 0x00400000,
 LOG_TYPE_CART_INVALID = 0x00800000,
 LOG_TYPE_EGG = 0x01000000,
 LOG_TYPE_QUEST = 0x02000000,
 LOG_TYPE_SKILL = 0x04000000,
 LOG_TYPE_REFINE = 0x08000000,


 LOG_TYPE_LOOT = LOG_TYPE_PICKDROP_MONSTER|LOG_TYPE_CONSUME,

 LOG_TYPE_ALL = 0xFFFFFFFF,
} e_log_pick_type;


typedef enum e_log_filter {
 LOG_FILTER_NONE = 0x000,
 LOG_FILTER_ALL = 0x001,

 LOG_FILTER_HEALING = 0x002,
 LOG_FILTER_ETC_AMMO = 0x004,
 LOG_FILTER_USABLE = 0x008,
 LOG_FILTER_WEAPON = 0x010,
 LOG_FILTER_ARMOR = 0x020,
 LOG_FILTER_CARD = 0x040,
 LOG_FILTER_PETITEM = 0x080,
 LOG_FILTER_PRICE = 0x100,
 LOG_FILTER_AMOUNT = 0x200,
 LOG_FILTER_REFINE = 0x400,
 LOG_FILTER_CHANCE = 0x800,
} e_log_filter;

struct log_interface {
 struct {
  e_log_pick_type enable_logs;
  int filter;
  
# 118 "../../../server-code/src/map/log.h" 3 4
 _Bool 
# 118 "../../../server-code/src/map/log.h"
      sql_logs;
  
# 119 "../../../server-code/src/map/log.h" 3 4
 _Bool 
# 119 "../../../server-code/src/map/log.h"
      log_chat_woe_disable;
  int rare_items_log,refine_items_log,price_items_log,amount_items_log;
  int branch, mvpdrop, zeny, commands, npc, chat;
  char log_branch[64], log_pick[64], log_zeny[64], log_mvpdrop[64], log_gm[64], log_npc[64], log_chat[64];
 } config;

 char db_ip[32];
 int db_port;
 char db_id[32];
 char db_pw[100];
 char db_name[32];
 struct Sql *mysql_handle;

 void (*pick_pc) (struct map_session_data* sd, e_log_pick_type type, int amount, struct item* itm, struct item_data *data);
 void (*pick_mob) (struct mob_data* md, e_log_pick_type type, int amount, struct item* itm, struct item_data *data);
 void (*zeny) (struct map_session_data* sd, e_log_pick_type type, struct map_session_data* src_sd, int amount);
 void (*npc) (struct map_session_data* sd, const char *message);
 void (*chat) (e_log_chat_type type, int type_id, int src_charid, int src_accid, const char *mapname, int x, int y, const char* dst_charname, const char* message);
 void (*atcommand) (struct map_session_data* sd, const char* message);
 void (*branch) (struct map_session_data* sd);
 void (*mvpdrop) (struct map_session_data* sd, int monster_id, int* log_mvp);

 void (*pick_sub) (int id, int16 m, e_log_pick_type type, int amount, struct item* itm, struct item_data *data);
 void (*zeny_sub) (struct map_session_data* sd, e_log_pick_type type, struct map_session_data* src_sd, int amount);
 void (*npc_sub) (struct map_session_data* sd, const char *message);
 void (*chat_sub) (e_log_chat_type type, int type_id, int src_charid, int src_accid, const char *mapname, int x, int y, const char* dst_charname, const char* message);
 void (*atcommand_sub) (struct map_session_data* sd, const char* message);
 void (*branch_sub) (struct map_session_data* sd);
 void (*mvpdrop_sub) (struct map_session_data* sd, int monster_id, int* log_mvp);

 int (*config_read) (const char* cfgName);
 void (*config_done) (void);
 void (*sql_init) (void);
 void (*sql_final) (void);

 char (*picktype2char) (e_log_pick_type type);
 char (*chattype2char) (e_log_chat_type type);
 
# 156 "../../../server-code/src/map/log.h" 3 4
_Bool 
# 156 "../../../server-code/src/map/log.h"
     (*should_log_item) (int nameid, int amount, int refine, struct item_data *id);
};


void log_defaults(void);


extern struct log_interface *logs;
# 40 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/map/mail.h" 1
# 26 "../../../server-code/src/map/mail.h"
struct item;
struct mail_message;
struct map_session_data;

struct mail_interface {
 void (*clear) (struct map_session_data *sd);
 int (*removeitem) (struct map_session_data *sd, short flag);
 int (*removezeny) (struct map_session_data *sd, short flag);
 unsigned char (*setitem) (struct map_session_data *sd, int idx, int amount);
 
# 35 "../../../server-code/src/map/mail.h" 3 4
_Bool 
# 35 "../../../server-code/src/map/mail.h"
     (*setattachment) (struct map_session_data *sd, struct mail_message *msg);
 void (*getattachment) (struct map_session_data* sd, int zeny, struct item* item);
 int (*openmail) (struct map_session_data *sd);
 void (*deliveryfail) (struct map_session_data *sd, struct mail_message *msg);
 
# 39 "../../../server-code/src/map/mail.h" 3 4
_Bool 
# 39 "../../../server-code/src/map/mail.h"
     (*invalid_operation) (struct map_session_data *sd);
};


void mail_defaults(void);


extern struct mail_interface *mail;
# 41 "../../../server-code/src/map/clif.c" 2

# 1 "../../../server-code/src/map/mercenary.h" 1
# 28 "../../../server-code/src/map/mercenary.h"
struct map_session_data;





enum {
 ARCH_MERC_GUILD,
 SPEAR_MERC_GUILD,
 SWORD_MERC_GUILD,
};


enum merc_id {
 MERID_MER_ARCHER01 = 6017,
 MERID_MER_ARCHER02 = 6018,
 MERID_MER_ARCHER03 = 6019,
 MERID_MER_ARCHER04 = 6020,
 MERID_MER_ARCHER05 = 6021,
 MERID_MER_ARCHER06 = 6022,
 MERID_MER_ARCHER07 = 6023,
 MERID_MER_ARCHER08 = 6024,
 MERID_MER_ARCHER09 = 6025,
 MERID_MER_ARCHER10 = 6026,
 MERID_MER_LANCER01 = 6027,
 MERID_MER_LANCER02 = 6028,
 MERID_MER_LANCER03 = 6029,
 MERID_MER_LANCER04 = 6030,
 MERID_MER_LANCER05 = 6031,
 MERID_MER_LANCER06 = 6032,
 MERID_MER_LANCER07 = 6033,
 MERID_MER_LANCER08 = 6034,
 MERID_MER_LANCER09 = 6035,
 MERID_MER_LANCER10 = 6036,
 MERID_MER_SWORDMAN01 = 6037,
 MERID_MER_SWORDMAN02 = 6038,
 MERID_MER_SWORDMAN03 = 6039,
 MERID_MER_SWORDMAN04 = 6040,
 MERID_MER_SWORDMAN05 = 6041,
 MERID_MER_SWORDMAN06 = 6042,
 MERID_MER_SWORDMAN07 = 6043,
 MERID_MER_SWORDMAN08 = 6044,
 MERID_MER_SWORDMAN09 = 6045,
 MERID_MER_SWORDMAN10 = 6046,
};

struct s_mercenary_db {
 int class_;
 char sprite[(23 + 1)], name[(23 + 1)];
 unsigned short lv;
 short range2, range3;
 struct status_data status;
 struct view_data vd;
 struct {
  unsigned short id, lv;
 } skill[40];
};

struct mercenary_data {
 struct block_list bl;
 struct unit_data ud;
 struct view_data *vd;
 struct status_data base_status, battle_status;
 struct status_change sc;
 struct regen_data regen;
 struct s_mercenary_db *db;
 struct s_mercenary mercenary;
 char blockskill[1478];

 struct map_session_data *master;
 int contract_timer;

 unsigned devotion_flag : 1;
 int64 masterteleport_timer;
};






struct mercenary_interface {



 struct s_mercenary_db *db;



 void (*init) (
# 117 "../../../server-code/src/map/mercenary.h" 3 4
              _Bool 
# 117 "../../../server-code/src/map/mercenary.h"
                   minimal);

 
# 119 "../../../server-code/src/map/mercenary.h" 3 4
_Bool 
# 119 "../../../server-code/src/map/mercenary.h"
     (*class) (int class_);
 struct view_data * (*get_viewdata) (int class_);

 int (*create) (struct map_session_data *sd, int class_, unsigned int lifetime);
 int (*data_received) (const struct s_mercenary *merc, 
# 123 "../../../server-code/src/map/mercenary.h" 3 4
                                                      _Bool 
# 123 "../../../server-code/src/map/mercenary.h"
                                                           flag);
 int (*save) (struct mercenary_data *md);

 void (*heal) (struct mercenary_data *md, int hp, int sp);
 int (*dead) (struct mercenary_data *md);

 int (*delete) (struct mercenary_data *md, int reply);
 void (*contract_stop) (struct mercenary_data *md);

 int (*get_lifetime) (struct mercenary_data *md);
 int (*get_guild) (struct mercenary_data *md);
 int (*get_faith) (struct mercenary_data *md);
 int (*set_faith) (struct mercenary_data *md, int value);
 int (*get_calls) (struct mercenary_data *md);
 int (*set_calls) (struct mercenary_data *md, int value);
 int (*kills) (struct mercenary_data *md);

 int (*checkskill) (struct mercenary_data *md, uint16 skill_id);
 int (*read_db) (void);
 int (*read_skilldb) (void);

 int (*killbonus) (struct mercenary_data *md);
 int (*search_index) (int class_);

 int (*contract_end_timer) (int tid, int64 tick, int id, intptr_t data);
 
# 148 "../../../server-code/src/map/mercenary.h" 3 4
_Bool 
# 148 "../../../server-code/src/map/mercenary.h"
     (*read_db_sub) (char* str[], int columns, int current);
 
# 149 "../../../server-code/src/map/mercenary.h" 3 4
_Bool 
# 149 "../../../server-code/src/map/mercenary.h"
     (*read_skill_db_sub) (char* str[], int columns, int current);
};


void mercenary_defaults(void);


extern struct mercenary_interface *mercenary;
# 43 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/map/mob.h" 1
# 30 "../../../server-code/src/map/mob.h"
struct hplugin_data_store;
# 73 "../../../server-code/src/map/mob.h"
enum MobSkillState {
 MSS_ANY = -1,
 MSS_IDLE,
 MSS_WALK,
 MSS_LOOT,
 MSS_DEAD,
 MSS_BERSERK,
 MSS_ANGRY,
 MSS_RUSH,
 MSS_FOLLOW,
 MSS_ANYTARGET,
};

enum MobDamageLogFlag
{
 MDLF_NORMAL = 0,
 MDLF_HOMUN,
 MDLF_PET,
};

enum size {
 SZ_SMALL = 0,
 SZ_MEDIUM,
 SZ_BIG,
};

enum ai {
 AI_NONE = 0,
 AI_ATTACK,
 AI_SPHERE,
 AI_FLORA,
 AI_ZANZOU,

 AI_MAX
};




enum ksprotection_mode {
 KSPROTECT_NONE = 0,
 KSPROTECT_SELF = 1,
 KSPROTECT_PARTY = 2,
 KSPROTECT_GUILD = 3,
};

struct mob_skill {
 enum MobSkillState state;
 uint16 skill_id,skill_lv;
 short permillage;
 int casttime,delay;
 short cancel;
 short cond1,cond2;
 short target;
 int val[5];
 short emotion;
 unsigned short msg_id;
};

struct mob_chat {
 unsigned short msg_id;
 unsigned int color;
 char msg[(255 + 1)];
};

struct spawn_info {
 unsigned short mapindex;
 unsigned short qty;
};

struct mob_db {
 int mob_id;
 char sprite[(23 + 1)],name[(23 + 1)],jname[(23 + 1)];
 unsigned int base_exp,job_exp;
 unsigned int mexp;
 short range2,range3;
 short race2;
 unsigned short lv;
 struct { int nameid,p; } dropitem[10];
 struct { int nameid,p; } mvpitem[3];
 struct status_data status;
 struct view_data vd;
 unsigned int option;
 int summonper[5];
 int maxskill;
 struct mob_skill skill[50];
 struct spawn_info spawn[10];
 struct hplugin_data_store *hdata;
};

struct mob_data {
 struct block_list bl;
 struct unit_data ud;
 struct view_data *vd;
 struct status_data status, *base_status;
 struct status_change sc;
 struct mob_db *db;
 char name[(23 + 1)];
 struct {
  unsigned int size : 2;
  unsigned int ai : 4;
  unsigned int clone : 1;
 } special_state;
 struct {
  unsigned int aggressive : 1;
  unsigned int steal_coin_flag : 1;
  unsigned int soul_change_flag : 1;
  unsigned int alchemist: 1;
  unsigned int spotted: 1;
  unsigned int npc_killmonster: 1;
  unsigned int rebirth: 1;
  unsigned int boss : 1;
  enum MobSkillState skillstate;
  unsigned char steal_flag;
  unsigned char attacked_count;
  int provoke_flag;
 } state;
 struct guardian_data* guardian_data;
 struct {
  int id;
  unsigned int dmg;
  unsigned int flag : 2;
 } dmglog[30];
 struct spawn_data *spawn;
 int spawn_timer;
 struct item *lootitem;
 short class_;
 unsigned int tdmg;
 int level;
 int target_id,attacked_id;
 int areanpc_id;
 unsigned int bg_id;

 int64 next_walktime, last_thinktime, last_linktime, last_pcneartime, dmgtick;
 short move_fail_count;
 short lootitem_count;
 short min_chase;
 unsigned char walktoxy_fail_count;

 int deletetimer;
 int master_id,master_dist;

 int8 skill_idx;
 int64 skilldelay[50];
 char npc_event[( (23 + 1) * 2 + 3 )];




 
# 222 "../../../server-code/src/map/mob.h" 3 4
_Bool 
# 222 "../../../server-code/src/map/mob.h"
     can_summon;



 int tomb_nid;
 struct hplugin_data_store *hdata;
};


enum {
 MST_TARGET = 0,
 MST_RANDOM,
 MST_SELF,
 MST_FRIEND,
 MST_MASTER,
 MST_AROUND5,
 MST_AROUND6,
 MST_AROUND7,
 MST_AROUND8,
 MST_AROUND1,
 MST_AROUND2,
 MST_AROUND3,
 MST_AROUND4,
 MST_AROUND = MST_AROUND4,

 MSC_ALWAYS = 0x0000,
 MSC_MYHPLTMAXRATE,
 MSC_MYHPINRATE,
 MSC_FRIENDHPLTMAXRATE,
 MSC_FRIENDHPINRATE,
 MSC_MYSTATUSON,
 MSC_MYSTATUSOFF,
 MSC_FRIENDSTATUSON,
 MSC_FRIENDSTATUSOFF,
 MSC_ATTACKPCGT,
 MSC_ATTACKPCGE,
 MSC_SLAVELT,
 MSC_SLAVELE,
 MSC_CLOSEDATTACKED,
 MSC_LONGRANGEATTACKED,
 MSC_AFTERSKILL,
 MSC_SKILLUSED,
 MSC_CASTTARGETED,
 MSC_RUDEATTACKED,
 MSC_MASTERHPLTMAXRATE,
 MSC_MASTERATTACKED,
 MSC_ALCHEMIST,
 MSC_SPAWN,
};




enum mob_id {
 MOBID_PORING = 1002,

 MOBID_HORNET = 1004,

 MOBID_RED_PLANT = 1078,
 MOBID_BLUE_PLANT = 1079,
 MOBID_GREEN_PLANT = 1080,
 MOBID_YELLOW_PLANT = 1081,
 MOBID_WHITE_PLANT = 1082,
 MOBID_SHINING_PLANT = 1083,
 MOBID_BLACK_MUSHROOM = 1084,
 MOBID_RED_MUSHROOM = 1085,

 MOBID_MARINE_SPHERE = 1142,

 MOBID_EMPELIUM = 1288,

 MOBID_GIANT_HONET = 1303,

 MOBID_TREASURE_BOX1 = 1324,
 MOBID_TREASURE_BOX2 = 1325,
 MOBID_TREASURE_BOX3 = 1326,
 MOBID_TREASURE_BOX4 = 1327,
 MOBID_TREASURE_BOX5 = 1328,
 MOBID_TREASURE_BOX6 = 1329,
 MOBID_TREASURE_BOX7 = 1330,
 MOBID_TREASURE_BOX8 = 1331,
 MOBID_TREASURE_BOX9 = 1332,
 MOBID_TREASURE_BOX10 = 1333,
 MOBID_TREASURE_BOX11 = 1334,
 MOBID_TREASURE_BOX12 = 1335,
 MOBID_TREASURE_BOX13 = 1336,
 MOBID_TREASURE_BOX14 = 1337,
 MOBID_TREASURE_BOX15 = 1338,
 MOBID_TREASURE_BOX16 = 1339,
 MOBID_TREASURE_BOX17 = 1340,
 MOBID_TREASURE_BOX18 = 1341,
 MOBID_TREASURE_BOX19 = 1342,
 MOBID_TREASURE_BOX20 = 1343,
 MOBID_TREASURE_BOX21 = 1344,
 MOBID_TREASURE_BOX22 = 1345,
 MOBID_TREASURE_BOX23 = 1346,
 MOBID_TREASURE_BOX24 = 1347,
 MOBID_TREASURE_BOX25 = 1348,
 MOBID_TREASURE_BOX26 = 1349,
 MOBID_TREASURE_BOX27 = 1350,
 MOBID_TREASURE_BOX28 = 1351,
 MOBID_TREASURE_BOX29 = 1352,
 MOBID_TREASURE_BOX30 = 1353,
 MOBID_TREASURE_BOX31 = 1354,
 MOBID_TREASURE_BOX32 = 1355,
 MOBID_TREASURE_BOX33 = 1356,
 MOBID_TREASURE_BOX34 = 1357,
 MOBID_TREASURE_BOX35 = 1358,
 MOBID_TREASURE_BOX36 = 1359,
 MOBID_TREASURE_BOX37 = 1360,
 MOBID_TREASURE_BOX38 = 1361,
 MOBID_TREASURE_BOX39 = 1362,
 MOBID_TREASURE_BOX40 = 1363,

 MOBID_G_PARASITE = 1555,
 MOBID_G_FLORA = 1575,
 MOBID_G_HYDRA = 1579,
 MOBID_G_MANDRAGORA = 1589,
 MOBID_G_GEOGRAPHER = 1590,

 MOBID_BARRICADE = 1905,
 MOBID_BARRICADE_ = 1906,
 MOBID_S_EMPEL_1 = 1907,
 MOBID_S_EMPEL_2 = 1908,
 MOBID_OBJ_A = 1909,
 MOBID_OBJ_B = 1910,
 MOBID_OBJ_NEUTRAL = 1911,
 MOBID_OBJ_FLAG_A = 1912,
 MOBID_OBJ_FLAG_B = 1913,
 MOBID_OBJ_A2 = 1914,
 MOBID_OBJ_B2 = 1915,

 MOBID_TREASURE_BOX41 = 1938,
 MOBID_TREASURE_BOX42 = 1939,
 MOBID_TREASURE_BOX43 = 1940,
 MOBID_TREASURE_BOX44 = 1941,
 MOBID_TREASURE_BOX45 = 1942,
 MOBID_TREASURE_BOX46 = 1943,
 MOBID_TREASURE_BOX47 = 1944,
 MOBID_TREASURE_BOX48 = 1945,
 MOBID_TREASURE_BOX49 = 1946,


 MOBID_TATACHO = 1986,
 MOBID_CENTIPEDE = 1987,
 MOBID_NEPENTHES = 1988,
 MOBID_HILLSRION = 1989,
 MOBID_HARDROCK_MOMMOTH = 1990,


 MOBID_TENDRILRION = 1991,
 MOBID_CORNUS = 1992,
 MOBID_NAGA = 1993,
 MOBID_LUCIOLA_VESPA = 1994,
 MOBID_PINGUICULA = 1995,


 MOBID_G_TATACHO = 1997,
 MOBID_G_HILLSRION = 1998,
 MOBID_CENTIPEDE_LARVA = 1999,

 MOBID_SILVERSNIPER = 2042,
 MOBID_MAGICDECOY_FIRE = 2043,
 MOBID_MAGICDECOY_WATER = 2044,
 MOBID_MAGICDECOY_EARTH = 2045,
 MOBID_MAGICDECOY_WIND = 2046,


 MOBID_POM_SPIDER = 2132,
 MOBID_ANGRA_MANTIS = 2133,
 MOBID_PARUS = 2134,

 MOBID_LITTLE_FATUM = 2136,
 MOBID_MIMING = 2137,

 MOBID_KO_KAGE = 2308,
};


struct item_drop {
 struct item item_data;
 struct item_drop* next;
};
struct item_drop_list {
 int16 m, x, y;
 int first_charid, second_charid, third_charid;
 struct item_drop* item;
};
# 419 "../../../server-code/src/map/mob.h"
struct mob_interface {

 struct mob_db *db_data[5000 + 1];
 struct mob_db *dummy;

 struct mob_chat *chat_db[250 + 1];

 int manuk[8];
 int splendide[5];
 int mora[5];

 int (*init) (
# 430 "../../../server-code/src/map/mob.h" 3 4
             _Bool 
# 430 "../../../server-code/src/map/mob.h"
                  mimimal);
 int (*final) (void);
 void (*reload) (void);

 struct mob_db* (*db) (int index);
 struct mob_chat* (*chat) (short id);
 int (*makedummymobdb) (int);
 int (*spawn_guardian_sub) (int tid, int64 tick, int id, intptr_t data);
 int (*skill_id2skill_idx) (int class_, uint16 skill_id);
 int (*db_searchname) (const char *str);
 int (*db_searchname_array_sub) (struct mob_db *monster, const char *str, int flag);

 void (*mvptomb_create) (struct mob_data *md, char *killer, time_t time);
 void (*mvptomb_destroy) (struct mob_data *md);
 int (*db_searchname_array) (struct mob_db **data, int size, const char *str, int flag);
 int (*db_checkid) (const int id);
 struct view_data* (*get_viewdata) (int class_);
 int (*parse_dataset) (struct spawn_data *data);
 struct mob_data* (*spawn_dataset) (struct spawn_data *data);
 int (*get_random_id) (int type, int flag, int lv);
 
# 450 "../../../server-code/src/map/mob.h" 3 4
_Bool 
# 450 "../../../server-code/src/map/mob.h"
     (*ksprotected) (struct block_list *src, struct block_list *target);
 struct mob_data* (*once_spawn_sub) (struct block_list *bl, int16 m, int16 x, int16 y, const char *mobname, int class_, const char *event, unsigned int size, unsigned int ai);
 int (*once_spawn) (struct map_session_data *sd, int16 m, int16 x, int16 y, const char *mobname, int class_, int amount, const char *event, unsigned int size, unsigned int ai);
 int (*once_spawn_area) (struct map_session_data *sd, int16 m, int16 x0, int16 y0, int16 x1, int16 y1, const char *mobname, int class_, int amount, const char *event, unsigned int size, unsigned int ai);
 int (*spawn_guardian) (const char *mapname, short x, short y, const char *mobname, int class_, const char *event, int guardian, 
# 454 "../../../server-code/src/map/mob.h" 3 4
                                                                                                                                _Bool 
# 454 "../../../server-code/src/map/mob.h"
                                                                                                                                     has_index);
 int (*spawn_bg) (const char *mapname, short x, short y, const char *mobname, int class_, const char *event, unsigned int bg_id);
 int (*can_reach) (struct mob_data *md, struct block_list *bl, int range, int state);
 int (*linksearch) (struct block_list *bl, va_list ap);
 int (*delayspawn) (int tid, int64 tick, int id, intptr_t data);
 int (*setdelayspawn) (struct mob_data *md);
 int (*count_sub) (struct block_list *bl, va_list ap);
 int (*spawn) (struct mob_data *md);
 int (*can_changetarget) (const struct mob_data *md, const struct block_list *target, uint32 mode);
 int (*target) (struct mob_data *md, struct block_list *bl, int dist);
 int (*ai_sub_hard_activesearch) (struct block_list *bl, va_list ap);
 int (*ai_sub_hard_changechase) (struct block_list *bl, va_list ap);
 int (*ai_sub_hard_bg_ally) (struct block_list *bl, va_list ap);
 int (*ai_sub_hard_lootsearch) (struct block_list *bl, va_list ap);
 int (*warpchase_sub) (struct block_list *bl, va_list ap);
 int (*ai_sub_hard_slavemob) (struct mob_data *md, int64 tick);
 int (*unlocktarget) (struct mob_data *md, int64 tick);
 int (*randomwalk) (struct mob_data *md, int64 tick);
 int (*warpchase) (struct mob_data *md, struct block_list *target);
 
# 473 "../../../server-code/src/map/mob.h" 3 4
_Bool 
# 473 "../../../server-code/src/map/mob.h"
     (*ai_sub_hard) (struct mob_data *md, int64 tick);
 int (*ai_sub_hard_timer) (struct block_list *bl, va_list ap);
 int (*ai_sub_foreachclient) (struct map_session_data *sd, va_list ap);
 int (*ai_sub_lazy) (struct mob_data *md, va_list args);
 int (*ai_lazy) (int tid, int64 tick, int id, intptr_t data);
 int (*ai_hard) (int tid, int64 tick, int id, intptr_t data);
 struct item_drop* (*setdropitem) (int nameid, int qty, struct item_data *data);
 struct item_drop* (*setlootitem) (struct item *item);
 int (*delay_item_drop) (int tid, int64 tick, int id, intptr_t data);
 void (*item_drop) (struct mob_data *md, struct item_drop_list *dlist, struct item_drop *ditem, int loot, int drop_rate, unsigned short flag);
 int (*timer_delete) (int tid, int64 tick, int id, intptr_t data);
 int (*deleteslave_sub) (struct block_list *bl, va_list ap);
 int (*deleteslave) (struct mob_data *md);
 int (*respawn) (int tid, int64 tick, int id, intptr_t data);
 void (*log_damage) (struct mob_data *md, struct block_list *src, int damage);
 void (*damage) (struct mob_data *md, struct block_list *src, int damage);
 int (*dead) (struct mob_data *md, struct block_list *src, int type);
 void (*revive) (struct mob_data *md, unsigned int hp);
 int (*guardian_guildchange) (struct mob_data *md);
 int (*random_class) (int *value, size_t count);
 int (*class_change) (struct mob_data *md, int class_);
 void (*heal) (struct mob_data *md, unsigned int heal);
 int (*warpslave_sub) (struct block_list *bl, va_list ap);
 int (*warpslave) (struct block_list *bl, int range);
 int (*countslave_sub) (struct block_list *bl, va_list ap);
 int (*countslave) (struct block_list *bl);
 int (*summonslave) (struct mob_data *md2, int *value, int amount, uint16 skill_id);
 int (*getfriendhprate_sub) (struct block_list *bl, va_list ap);
 struct block_list* (*getfriendhprate) (struct mob_data *md, int min_rate, int max_rate);
 struct block_list* (*getmasterhpltmaxrate) (struct mob_data *md, int rate);
 int (*getfriendstatus_sub) (struct block_list *bl, va_list ap);
 struct mob_data* (*getfriendstatus) (struct mob_data *md, int cond1, int cond2);
 int (*skill_use) (struct mob_data *md, int64 tick, int event);
 int (*skill_event) (struct mob_data *md, struct block_list *src, int64 tick, int flag);
 int (*is_clone) (int class_);
 int (*clone_spawn) (struct map_session_data *sd, int16 m, int16 x, int16 y, const char *event, int master_id, uint32 mode, int flag, unsigned int duration);
 int (*clone_delete) (struct mob_data *md);
 unsigned int (*drop_adjust) (int baserate, int rate_adjust, unsigned short rate_min, unsigned short rate_max);
 void (*item_dropratio_adjust) (int nameid, int mob_id, int *rate_adjust);
 void (*readdb) (void);
 
# 513 "../../../server-code/src/map/mob.h" 3 4
_Bool 
# 513 "../../../server-code/src/map/mob.h"
     (*lookup_const) (const struct config_setting_t *it, const char *name, int *value);
 
# 514 "../../../server-code/src/map/mob.h" 3 4
_Bool 
# 514 "../../../server-code/src/map/mob.h"
     (*get_const) (const struct config_setting_t *it, int *value);
 int (*db_validate_entry) (struct mob_db *entry, int n, const char *source);
 int (*read_libconfig) (const char *filename, 
# 516 "../../../server-code/src/map/mob.h" 3 4
                                             _Bool 
# 516 "../../../server-code/src/map/mob.h"
                                                  ignore_missing);
 void (*read_db_additional_fields) (struct mob_db *entry, struct config_setting_t *it, int n, const char *source);
 int (*read_db_sub) (struct config_setting_t *mobt, int id, const char *source);
 void (*read_db_drops_sub) (struct mob_db *entry, struct config_setting_t *t);
 void (*read_db_mvpdrops_sub) (struct mob_db *entry, struct config_setting_t *t);
 uint32 (*read_db_mode_sub) (struct mob_db *entry, struct config_setting_t *t);
 void (*read_db_stats_sub) (struct mob_db *entry, struct config_setting_t *t);
 void (*name_constants) (void);
 
# 524 "../../../server-code/src/map/mob.h" 3 4
_Bool 
# 524 "../../../server-code/src/map/mob.h"
     (*readdb_mobavail) (char *str[], int columns, int current);
 int (*read_randommonster) (void);
 
# 526 "../../../server-code/src/map/mob.h" 3 4
_Bool 
# 526 "../../../server-code/src/map/mob.h"
     (*parse_row_chatdb) (char **str, const char *source, int line, int *last_msg_id);
 void (*readchatdb) (void);
 
# 528 "../../../server-code/src/map/mob.h" 3 4
_Bool 
# 528 "../../../server-code/src/map/mob.h"
     (*parse_row_mobskilldb) (char **str, int columns, int current);
 void (*readskilldb) (void);
 
# 530 "../../../server-code/src/map/mob.h" 3 4
_Bool 
# 530 "../../../server-code/src/map/mob.h"
     (*readdb_race2) (char *fields[], int columns, int current);
 
# 531 "../../../server-code/src/map/mob.h" 3 4
_Bool 
# 531 "../../../server-code/src/map/mob.h"
     (*readdb_itemratio) (char *str[], int columns, int current);
 void (*load) (
# 532 "../../../server-code/src/map/mob.h" 3 4
              _Bool 
# 532 "../../../server-code/src/map/mob.h"
                   minimal);
 void (*clear_spawninfo) (void);
 void (*destroy_mob_db) (int index);
};


void mob_defaults(void);


extern struct mob_interface *mob;
# 44 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/map/npc.h" 1
# 30 "../../../server-code/src/map/npc.h"
# 1 "/usr/include/pcre.h" 1 3 4
# 90 "/usr/include/pcre.h" 3 4
# 1 "/usr/include/stdlib.h" 1 3 4
# 32 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 33 "/usr/include/stdlib.h" 2 3 4








# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 50 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4

# 50 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 3 4
union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 43 "/usr/include/stdlib.h" 2 3 4
# 67 "/usr/include/stdlib.h" 3 4
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));
# 95 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 139 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;




extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

# 305 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;
# 60 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 104 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __id_t id_t;
# 115 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 146 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 147 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 200 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;







# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 46 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 64 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {






    __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];


  } fd_set;






typedef __fd_mask fd_mask;
# 96 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 106 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 118 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 131 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 220 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4


__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 58 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4

# 223 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 270 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4
# 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;





typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    short __spins;
    short __elision;
    __pthread_list_t __list;
# 125 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    signed char __rwelision;




    unsigned char __pad1[7];


    unsigned long int __pad2;


    unsigned int __flags;

  } __data;
# 220 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 271 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 315 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));




extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 493 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;




extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));







extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;

# 578 "/usr/include/stdlib.h" 3 4
extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 619 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 641 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 662 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 711 "/usr/include/stdlib.h" 3 4





extern int system (const char *__command) ;

# 733 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);
# 751 "/usr/include/stdlib.h" 3 4



extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
# 774 "/usr/include/stdlib.h" 3 4
extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;

# 811 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));








extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 898 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;
# 950 "/usr/include/stdlib.h" 3 4
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 955 "/usr/include/stdlib.h" 2 3 4
# 967 "/usr/include/stdlib.h" 3 4

# 91 "/usr/include/pcre.h" 2 3 4
# 324 "/usr/include/pcre.h" 3 4
struct real_pcre;
typedef struct real_pcre pcre;

struct real_pcre16;
typedef struct real_pcre16 pcre16;

struct real_pcre32;
typedef struct real_pcre32 pcre32;

struct real_pcre_jit_stack;
typedef struct real_pcre_jit_stack pcre_jit_stack;

struct real_pcre16_jit_stack;
typedef struct real_pcre16_jit_stack pcre16_jit_stack;

struct real_pcre32_jit_stack;
typedef struct real_pcre32_jit_stack pcre32_jit_stack;
# 376 "/usr/include/pcre.h" 3 4
typedef struct pcre_extra {
  unsigned long int flags;
  void *study_data;
  unsigned long int match_limit;
  void *callout_data;
  const unsigned char *tables;
  unsigned long int match_limit_recursion;
  unsigned char **mark;
  void *executable_jit;
} pcre_extra;



typedef struct pcre16_extra {
  unsigned long int flags;
  void *study_data;
  unsigned long int match_limit;
  void *callout_data;
  const unsigned char *tables;
  unsigned long int match_limit_recursion;
  unsigned short **mark;
  void *executable_jit;
} pcre16_extra;



typedef struct pcre32_extra {
  unsigned long int flags;
  void *study_data;
  unsigned long int match_limit;
  void *callout_data;
  const unsigned char *tables;
  unsigned long int match_limit_recursion;
  unsigned int **mark;
  void *executable_jit;
} pcre32_extra;






typedef struct pcre_callout_block {
  int version;

  int callout_number;
  int *offset_vector;
  const char * subject;
  int subject_length;
  int start_match;
  int current_position;
  int capture_top;
  int capture_last;
  void *callout_data;

  int pattern_position;
  int next_item_length;

  const unsigned char *mark;

} pcre_callout_block;



typedef struct pcre16_callout_block {
  int version;

  int callout_number;
  int *offset_vector;
  const unsigned short * subject;
  int subject_length;
  int start_match;
  int current_position;
  int capture_top;
  int capture_last;
  void *callout_data;

  int pattern_position;
  int next_item_length;

  const unsigned short *mark;

} pcre16_callout_block;



typedef struct pcre32_callout_block {
  int version;

  int callout_number;
  int *offset_vector;
  const unsigned int * subject;
  int subject_length;
  int start_match;
  int current_position;
  int capture_top;
  int capture_last;
  void *callout_data;

  int pattern_position;
  int next_item_length;

  const unsigned int *mark;

} pcre32_callout_block;
# 489 "/usr/include/pcre.h" 3 4
extern void *(*pcre_malloc)(size_t);
extern void (*pcre_free)(void *);
extern void *(*pcre_stack_malloc)(size_t);
extern void (*pcre_stack_free)(void *);
extern int (*pcre_callout)(pcre_callout_block *);
extern int (*pcre_stack_guard)(void);

extern void *(*pcre16_malloc)(size_t);
extern void (*pcre16_free)(void *);
extern void *(*pcre16_stack_malloc)(size_t);
extern void (*pcre16_stack_free)(void *);
extern int (*pcre16_callout)(pcre16_callout_block *);
extern int (*pcre16_stack_guard)(void);

extern void *(*pcre32_malloc)(size_t);
extern void (*pcre32_free)(void *);
extern void *(*pcre32_stack_malloc)(size_t);
extern void (*pcre32_stack_free)(void *);
extern int (*pcre32_callout)(pcre32_callout_block *);
extern int (*pcre32_stack_guard)(void);
# 534 "/usr/include/pcre.h" 3 4
typedef pcre_jit_stack *(*pcre_jit_callback)(void *);
typedef pcre16_jit_stack *(*pcre16_jit_callback)(void *);
typedef pcre32_jit_stack *(*pcre32_jit_callback)(void *);



extern pcre *pcre_compile(const char *, int, const char **, int *,
                  const unsigned char *);
extern pcre16 *pcre16_compile(const unsigned short *, int, const char **, int *,
                  const unsigned char *);
extern pcre32 *pcre32_compile(const unsigned int *, int, const char **, int *,
                  const unsigned char *);
extern pcre *pcre_compile2(const char *, int, int *, const char **,
                  int *, const unsigned char *);
extern pcre16 *pcre16_compile2(const unsigned short *, int, int *, const char **,
                  int *, const unsigned char *);
extern pcre32 *pcre32_compile2(const unsigned int *, int, int *, const char **,
                  int *, const unsigned char *);
extern int pcre_config(int, void *);
extern int pcre16_config(int, void *);
extern int pcre32_config(int, void *);
extern int pcre_copy_named_substring(const pcre *, const char *,
                  int *, int, const char *, char *, int);
extern int pcre16_copy_named_substring(const pcre16 *, const unsigned short *,
                  int *, int, const unsigned short *, unsigned short *, int);
extern int pcre32_copy_named_substring(const pcre32 *, const unsigned int *,
                  int *, int, const unsigned int *, unsigned int *, int);
extern int pcre_copy_substring(const char *, int *, int, int,
                  char *, int);
extern int pcre16_copy_substring(const unsigned short *, int *, int, int,
                  unsigned short *, int);
extern int pcre32_copy_substring(const unsigned int *, int *, int, int,
                  unsigned int *, int);
extern int pcre_dfa_exec(const pcre *, const pcre_extra *,
                  const char *, int, int, int, int *, int , int *, int);
extern int pcre16_dfa_exec(const pcre16 *, const pcre16_extra *,
                  const unsigned short *, int, int, int, int *, int , int *, int);
extern int pcre32_dfa_exec(const pcre32 *, const pcre32_extra *,
                  const unsigned int *, int, int, int, int *, int , int *, int);
extern int pcre_exec(const pcre *, const pcre_extra *, const char *,
                   int, int, int, int *, int);
extern int pcre16_exec(const pcre16 *, const pcre16_extra *,
                   const unsigned short *, int, int, int, int *, int);
extern int pcre32_exec(const pcre32 *, const pcre32_extra *,
                   const unsigned int *, int, int, int, int *, int);
extern int pcre_jit_exec(const pcre *, const pcre_extra *,
                   const char *, int, int, int, int *, int,
                   pcre_jit_stack *);
extern int pcre16_jit_exec(const pcre16 *, const pcre16_extra *,
                   const unsigned short *, int, int, int, int *, int,
                   pcre16_jit_stack *);
extern int pcre32_jit_exec(const pcre32 *, const pcre32_extra *,
                   const unsigned int *, int, int, int, int *, int,
                   pcre32_jit_stack *);
extern void pcre_free_substring(const char *);
extern void pcre16_free_substring(const unsigned short *);
extern void pcre32_free_substring(const unsigned int *);
extern void pcre_free_substring_list(const char **);
extern void pcre16_free_substring_list(const unsigned short * *);
extern void pcre32_free_substring_list(const unsigned int * *);
extern int pcre_fullinfo(const pcre *, const pcre_extra *, int,
                  void *);
extern int pcre16_fullinfo(const pcre16 *, const pcre16_extra *, int,
                  void *);
extern int pcre32_fullinfo(const pcre32 *, const pcre32_extra *, int,
                  void *);
extern int pcre_get_named_substring(const pcre *, const char *,
                  int *, int, const char *, const char **);
extern int pcre16_get_named_substring(const pcre16 *, const unsigned short *,
                  int *, int, const unsigned short *, const unsigned short * *);
extern int pcre32_get_named_substring(const pcre32 *, const unsigned int *,
                  int *, int, const unsigned int *, const unsigned int * *);
extern int pcre_get_stringnumber(const pcre *, const char *);
extern int pcre16_get_stringnumber(const pcre16 *, const unsigned short *);
extern int pcre32_get_stringnumber(const pcre32 *, const unsigned int *);
extern int pcre_get_stringtable_entries(const pcre *, const char *,
                  char **, char **);
extern int pcre16_get_stringtable_entries(const pcre16 *, const unsigned short *,
                  unsigned short **, unsigned short **);
extern int pcre32_get_stringtable_entries(const pcre32 *, const unsigned int *,
                  unsigned int **, unsigned int **);
extern int pcre_get_substring(const char *, int *, int, int,
                  const char **);
extern int pcre16_get_substring(const unsigned short *, int *, int, int,
                  const unsigned short * *);
extern int pcre32_get_substring(const unsigned int *, int *, int, int,
                  const unsigned int * *);
extern int pcre_get_substring_list(const char *, int *, int,
                  const char ***);
extern int pcre16_get_substring_list(const unsigned short *, int *, int,
                  const unsigned short * **);
extern int pcre32_get_substring_list(const unsigned int *, int *, int,
                  const unsigned int * **);
extern const unsigned char *pcre_maketables(void);
extern const unsigned char *pcre16_maketables(void);
extern const unsigned char *pcre32_maketables(void);
extern int pcre_refcount(pcre *, int);
extern int pcre16_refcount(pcre16 *, int);
extern int pcre32_refcount(pcre32 *, int);
extern pcre_extra *pcre_study(const pcre *, int, const char **);
extern pcre16_extra *pcre16_study(const pcre16 *, int, const char **);
extern pcre32_extra *pcre32_study(const pcre32 *, int, const char **);
extern void pcre_free_study(pcre_extra *);
extern void pcre16_free_study(pcre16_extra *);
extern void pcre32_free_study(pcre32_extra *);
extern const char *pcre_version(void);
extern const char *pcre16_version(void);
extern const char *pcre32_version(void);


extern int pcre_pattern_to_host_byte_order(pcre *, pcre_extra *,
                  const unsigned char *);
extern int pcre16_pattern_to_host_byte_order(pcre16 *, pcre16_extra *,
                  const unsigned char *);
extern int pcre32_pattern_to_host_byte_order(pcre32 *, pcre32_extra *,
                  const unsigned char *);
extern int pcre16_utf16_to_host_byte_order(unsigned short *,
                  const unsigned short *, int, int *, int);
extern int pcre32_utf32_to_host_byte_order(unsigned int *,
                  const unsigned int *, int, int *, int);



extern pcre_jit_stack *pcre_jit_stack_alloc(int, int);
extern pcre16_jit_stack *pcre16_jit_stack_alloc(int, int);
extern pcre32_jit_stack *pcre32_jit_stack_alloc(int, int);
extern void pcre_jit_stack_free(pcre_jit_stack *);
extern void pcre16_jit_stack_free(pcre16_jit_stack *);
extern void pcre32_jit_stack_free(pcre32_jit_stack *);
extern void pcre_assign_jit_stack(pcre_extra *,
                  pcre_jit_callback, void *);
extern void pcre16_assign_jit_stack(pcre16_extra *,
                  pcre16_jit_callback, void *);
extern void pcre32_assign_jit_stack(pcre32_extra *,
                  pcre32_jit_callback, void *);
extern void pcre_jit_free_unused_memory(void);
extern void pcre16_jit_free_unused_memory(void);
extern void pcre32_jit_free_unused_memory(void);
# 31 "../../../server-code/src/map/npc.h" 2



# 33 "../../../server-code/src/map/npc.h"
struct hplugin_data_store;
struct itemlist;
struct view_data;

enum npc_parse_options {
 NPO_NONE = 0x0,
 NPO_ONINIT = 0x1,
 NPO_TRADER = 0x2,
};

enum npc_shop_types {
 NST_ZENY,
 NST_CASH,
 NST_MARKET,
 NST_CUSTOM,

 NST_MAX,
};

struct npc_timerevent_list {
 int timer,pos;
};
struct npc_label_list {
 char name[(23 + 1)];
 int pos;
};
struct npc_item_list {
 unsigned short nameid;
 unsigned int value;
 unsigned int qty;
};
struct npc_shop_data {
 unsigned char type;
 struct npc_item_list *item;
 unsigned short items;
};
struct npc_parse;
struct npc_data {
 struct block_list bl;
 struct unit_data *ud;
 struct view_data *vd;
 unsigned int option;
 struct npc_data *master_nd;
 short class_;
 short speed;
 char name[(23 + 1)+1];
 char exname[(23 + 1)+1];
 int chat_id;
 int touching_id;
 int64 next_walktime;
 uint8 dir;
 uint8 area_size;

 unsigned size : 2;

 struct status_data status;
 unsigned short level;
 unsigned short stat_point;

 struct npc_parse *chatdb;
 const char *path;
 enum npc_subtype subtype;
 int src_id;
 union {
  struct {
   struct script_code *script;
   short xs,ys;
   int guild_id;
   int timer,timerid,timeramount,rid;
   int64 timertick;
   struct npc_timerevent_list *timer_event;
   int label_list_num;
   struct npc_label_list *label_list;

   struct npc_shop_data *shop;
   
# 108 "../../../server-code/src/map/npc.h" 3 4
  _Bool 
# 108 "../../../server-code/src/map/npc.h"
       trader;
  } scr;
  struct {
   struct npc_item_list* shop_item;
   unsigned short count;
  } shop;
  struct {
   short xs,ys;
   short x,y;
   unsigned short mapindex;
  } warp;
  struct {
   struct mob_data *md;
   time_t kill_time;
   char killer_name[(23 + 1)];
  } tomb;
 } u;
 struct hplugin_data_store *hdata;
};




enum actor_classes {
 FAKE_NPC = -1,
 WARP_CLASS = 45,
 HIDDEN_WARP_CLASS = 139,
 MOB_TOMB = 565,
 WARP_DEBUG_CLASS = 722,
 FLAG_CLASS = 722,
 INVISIBLE_CLASS = 32767,
};
# 148 "../../../server-code/src/map/npc.h"
enum npce_event {
 NPCE_LOGIN,
 NPCE_LOGOUT,
 NPCE_LOADMAP,
 NPCE_BASELVUP,
 NPCE_JOBLVUP,
 NPCE_DIE,
 NPCE_KILLPC,
 NPCE_KILLNPC,
 NPCE_MAX
};


struct npc_src_list {
 struct npc_src_list* next;
 char name[4];
};

struct event_data {
 struct npc_data *nd;
 int pos;
};

struct npc_path_data {
 char* path;
 unsigned short references;
};


struct npc_interface {

 struct npc_data *motd;
 struct DBMap *ev_db;
 struct DBMap *ev_label_db;
 struct DBMap *name_db;
 struct DBMap *path_db;
 struct eri *timer_event_ers;
 struct npc_data *fake_nd;
 struct npc_src_list *src_files;
 struct unit_data base_ud;

 
# 189 "../../../server-code/src/map/npc.h" 3 4
_Bool 
# 189 "../../../server-code/src/map/npc.h"
     trader_ok;
 int trader_funds[2];

 int (*init) (
# 192 "../../../server-code/src/map/npc.h" 3 4
             _Bool 
# 192 "../../../server-code/src/map/npc.h"
                  minimal);
 int (*final) (void);

 int (*get_new_npc_id) (void);
 struct view_data* (*get_viewdata) (int class_);
 int (*isnear_sub) (struct block_list *bl, va_list args);
 
# 198 "../../../server-code/src/map/npc.h" 3 4
_Bool 
# 198 "../../../server-code/src/map/npc.h"
     (*isnear) (struct block_list *bl);
 int (*ontouch_event) (struct map_session_data *sd, struct npc_data *nd);
 int (*ontouch2_event) (struct map_session_data *sd, struct npc_data *nd);
 int (*onuntouch_event) (struct map_session_data *sd, struct npc_data *nd);
 int (*enable_sub) (struct block_list *bl, va_list ap);
 int (*enable) (const char *name, int flag);
 struct npc_data* (*name2id) (const char *name);
 int (*event_dequeue) (struct map_session_data *sd);
 struct DBData (*event_export_create) (union DBKey key, va_list args);
 int (*event_export) (struct npc_data *nd, int i);
 int (*event_sub) (struct map_session_data *sd, struct event_data *ev, const char *eventname);
 void (*event_doall_sub) (void *key, void *data, va_list ap);
 int (*event_do) (const char *name);
 int (*event_doall_id) (const char *name, int rid);
 int (*event_doall) (const char *name);
 int (*event_do_clock) (int tid, int64 tick, int id, intptr_t data);
 void (*event_do_oninit) ( 
# 214 "../../../server-code/src/map/npc.h" 3 4
                          _Bool 
# 214 "../../../server-code/src/map/npc.h"
                               reload );
 int (*timerevent_export) (struct npc_data *nd, int i);
 int (*timerevent) (int tid, int64 tick, int id, intptr_t data);
 int (*timerevent_start) (struct npc_data *nd, int rid);
 int (*timerevent_stop) (struct npc_data *nd);
 void (*timerevent_quit) (struct map_session_data *sd);
 int64 (*gettimerevent_tick) (struct npc_data *nd);
 int (*settimerevent_tick) (struct npc_data *nd, int newtimer);
 int (*event) (struct map_session_data *sd, const char *eventname, int ontouch);
 int (*touch_areanpc_sub) (struct block_list *bl, va_list ap);
 int (*touchnext_areanpc) (struct map_session_data *sd, 
# 224 "../../../server-code/src/map/npc.h" 3 4
                                                       _Bool 
# 224 "../../../server-code/src/map/npc.h"
                                                            leavemap);
 int (*touch_areanpc) (struct map_session_data *sd, int16 m, int16 x, int16 y);
 int (*untouch_areanpc) (struct map_session_data *sd, int16 m, int16 x, int16 y);
 int (*touch_areanpc2) (struct mob_data *md);
 int (*check_areanpc) (int flag, int16 m, int16 x, int16 y, int16 range);
 struct npc_data* (*checknear) (struct map_session_data *sd, struct block_list *bl);
 int (*globalmessage) (const char *name, const char *mes);
 void (*run_tomb) (struct map_session_data *sd, struct npc_data *nd);
 int (*click) (struct map_session_data *sd, struct npc_data *nd);
 int (*scriptcont) (struct map_session_data *sd, int id, 
# 233 "../../../server-code/src/map/npc.h" 3 4
                                                        _Bool 
# 233 "../../../server-code/src/map/npc.h"
                                                             closing);
 int (*buysellsel) (struct map_session_data *sd, int id, int type);
 int (*cashshop_buylist) (struct map_session_data *sd, int points, struct itemlist *item_list);
 int (*buylist_sub) (struct map_session_data *sd, struct itemlist *item_list, struct npc_data *nd);
 int (*cashshop_buy) (struct map_session_data *sd, int nameid, int amount, int points);
 int (*buylist) (struct map_session_data *sd, struct itemlist *item_list);
 int (*selllist_sub) (struct map_session_data *sd, struct itemlist *item_list, struct npc_data *nd);
 int (*selllist) (struct map_session_data *sd, struct itemlist *item_list);
 int (*remove_map) (struct npc_data *nd);
 int (*unload_ev) (union DBKey key, struct DBData *data, va_list ap);
 int (*unload_ev_label) (union DBKey key, struct DBData *data, va_list ap);
 int (*unload_dup_sub) (struct npc_data *nd, va_list args);
 void (*unload_duplicates) (struct npc_data *nd);
 int (*unload) (struct npc_data *nd, 
# 246 "../../../server-code/src/map/npc.h" 3 4
                                    _Bool 
# 246 "../../../server-code/src/map/npc.h"
                                         single);
 void (*clearsrcfile) (void);
 void (*addsrcfile) (const char *name);
 void (*delsrcfile) (const char *name);
 const char *(*retainpathreference) (const char *filepath);
 void (*releasepathreference) (const char *filepath);
 void (*parsename) (struct npc_data *nd, const char *name, const char *start, const char *buffer, const char *filepath);
 int (*parseview) (const char *w4, const char *start, const char *buffer, const char *filepath);
 
# 254 "../../../server-code/src/map/npc.h" 3 4
_Bool 
# 254 "../../../server-code/src/map/npc.h"
     (*viewisid) (const char *viewid);
 struct npc_data *(*create_npc) (enum npc_subtype subtype, int m, int x, int y, uint8 dir, int16 class_);
 struct npc_data* (*add_warp) (char *name, short from_mapid, short from_x, short from_y, short xs, short ys, unsigned short to_mapindex, short to_x, short to_y);
 const char *(*parse_warp) (const char *w1, const char *w2, const char *w3, const char *w4, const char *start, const char *buffer, const char *filepath, int *retval);
 const char *(*parse_shop) (const char *w1, const char *w2, const char *w3, const char *w4, const char *start, const char *buffer, const char *filepath, int *retval);
 const char *(*parse_unknown_object) (const char *w1, const char *w2, const char *w3, const char *w4, const char *start, const char *buffer, const char *filepath, int *retval);
 void (*convertlabel_db) (struct npc_label_list *label_list, const char *filepath);
 const char* (*skip_script) (const char *start, const char *buffer, const char *filepath, int *retval);
 const char *(*parse_script) (const char *w1, const char *w2, const char *w3, const char *w4, const char *start, const char *buffer, const char *filepath, int options, int *retval);
 void (*add_to_location) (struct npc_data *nd);
 
# 264 "../../../server-code/src/map/npc.h" 3 4
_Bool 
# 264 "../../../server-code/src/map/npc.h"
     (*duplicate_script_sub) (struct npc_data *nd, const struct npc_data *snd, int xs, int ys, int options);
 
# 265 "../../../server-code/src/map/npc.h" 3 4
_Bool 
# 265 "../../../server-code/src/map/npc.h"
     (*duplicate_shop_sub) (struct npc_data *nd, const struct npc_data *snd, int xs, int ys, int options);
 
# 266 "../../../server-code/src/map/npc.h" 3 4
_Bool 
# 266 "../../../server-code/src/map/npc.h"
     (*duplicate_warp_sub) (struct npc_data *nd, const struct npc_data *snd, int xs, int ys, int options);
 
# 267 "../../../server-code/src/map/npc.h" 3 4
_Bool 
# 267 "../../../server-code/src/map/npc.h"
     (*duplicate_sub) (struct npc_data *nd, const struct npc_data *snd, int xs, int ys, int options);
 const char *(*parse_duplicate) (const char *w1, const char *w2, const char *w3, const char *w4, const char *start, const char *buffer, const char *filepath, int options, int *retval);
 int (*duplicate4instance) (struct npc_data *snd, int16 m);
 void (*setcells) (struct npc_data *nd);
 int (*unsetcells_sub) (struct block_list *bl, va_list ap);
 void (*unsetcells) (struct npc_data *nd);
 void (*movenpc) (struct npc_data *nd, int16 x, int16 y);
 void (*setdisplayname) (struct npc_data *nd, const char *newname);
 void (*setclass) (struct npc_data *nd, short class_);
 int (*do_atcmd_event) (struct map_session_data *sd, const char *command, const char *message, const char *eventname);
 const char *(*parse_function) (const char *w1, const char *w2, const char *w3, const char *w4, const char *start, const char *buffer, const char *filepath, int *retval);
 void (*parse_mob2) (struct spawn_data *mobspawn);
 const char *(*parse_mob) (const char *w1, const char *w2, const char *w3, const char *w4, const char *start, const char *buffer, const char *filepath, int *retval);
 const char *(*parse_mapflag) (const char *w1, const char *w2, const char *w3, const char *w4, const char *start, const char *buffer, const char *filepath, int *retval);
 void (*parse_unknown_mapflag) (const char *name, const char *w3, const char *w4, const char *start, const char *buffer, const char *filepath, int *retval);
 int (*parsesrcfile) (const char *filepath, 
# 282 "../../../server-code/src/map/npc.h" 3 4
                                           _Bool 
# 282 "../../../server-code/src/map/npc.h"
                                                runOnInit);
 int (*script_event) (struct map_session_data *sd, enum npce_event type);
 void (*read_event_script) (void);
 int (*path_db_clear_sub) (union DBKey key, struct DBData *data, va_list args);
 int (*ev_label_db_clear_sub) (union DBKey key, struct DBData *data, va_list args);
 int (*reload) (void);
 
# 288 "../../../server-code/src/map/npc.h" 3 4
_Bool 
# 288 "../../../server-code/src/map/npc.h"
     (*unloadfile) (const char *filepath);
 void (*do_clear_npc) (void);
 void (*debug_warps_sub) (struct npc_data *nd);
 void (*debug_warps) (void);

 void (*trader_count_funds) (struct npc_data *nd, struct map_session_data *sd);
 
# 294 "../../../server-code/src/map/npc.h" 3 4
_Bool 
# 294 "../../../server-code/src/map/npc.h"
     (*trader_pay) (struct npc_data *nd, struct map_session_data *sd, int price, int points);
 void (*trader_update) (int master);
 int (*market_buylist) (struct map_session_data *sd, struct itemlist *item_list);
 
# 297 "../../../server-code/src/map/npc.h" 3 4
_Bool 
# 297 "../../../server-code/src/map/npc.h"
     (*trader_open) (struct map_session_data *sd, struct npc_data *nd);
 void (*market_fromsql) (void);
 void (*market_tosql) (struct npc_data *nd, unsigned short index);
 void (*market_delfromsql) (struct npc_data *nd, unsigned short index);
 void (*market_delfromsql_sub) (const char *npcname, unsigned short index);
 
# 302 "../../../server-code/src/map/npc.h" 3 4
_Bool 
# 302 "../../../server-code/src/map/npc.h"
     (*db_checkid) (const int id);



 int (*secure_timeout_timer) (int tid, int64 tick, int id, intptr_t data);
};


void npc_defaults(void);


extern struct npc_interface *npc;




struct pcrematch_entry {
 struct pcrematch_entry* next;
 char* pattern;
 pcre* pcre_;
 pcre_extra* pcre_extra_;
 char* label;
};




struct pcrematch_set {
 struct pcrematch_set* prev;
 struct pcrematch_set* next;
 struct pcrematch_entry* head;
 int setid;
};




struct npc_parse {
 struct pcrematch_set* active;
 struct pcrematch_set* inactive;
};

struct npc_chat_interface {
 int (*sub) (struct block_list* bl, va_list ap);
 void (*finalize) (struct npc_data* nd);
 void (*def_pattern) (struct npc_data* nd, int setid, const char* pattern, const char* label);
 struct pcrematch_entry* (*create_pcrematch_entry) (struct pcrematch_set* set);
 void (*delete_pcreset) (struct npc_data* nd, int setid);
 void (*deactivate_pcreset) (struct npc_data* nd, int setid);
 void (*activate_pcreset) (struct npc_data* nd, int setid);
 struct pcrematch_set* (*lookup_pcreset) (struct npc_data* nd, int setid);
 void (*finalize_pcrematch_entry) (struct pcrematch_entry* e);
};






struct pcre_interface {
 pcre *(*compile) (const char *pattern, int options, const char **errptr, int *erroffset, const unsigned char *tableptr);
 pcre_extra *(*study) (const pcre *code, int options, const char **errptr);
 int (*exec) (const pcre *code, const pcre_extra *extra, 
# 364 "../../../server-code/src/map/npc.h" 3 4
                                                        const char * 
# 364 "../../../server-code/src/map/npc.h"
                                                                  subject, int length, int startoffset, int options, int *ovector, int ovecsize);
 void (*free) (void *ptr);
 int (*copy_substring) (const char *subject, int *ovector, int stringcount, int stringnumber, char *buffer, int buffersize);
 void (*free_substring) (const char *stringptr);
 int (*copy_named_substring) (const pcre *code, const char *subject, int *ovector, int stringcount, const char *stringname, char *buffer, int buffersize);
 int (*get_substring) (const char *subject, int *ovector, int stringcount, int stringnumber, const char **stringptr);
};





void npc_chat_defaults(void);


extern struct npc_chat_interface *npc_chat;
extern struct pcre_interface *libpcre;
# 45 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/map/party.h" 1
# 33 "../../../server-code/src/map/party.h"
struct block_list;
struct hplugin_data_store;
struct map_session_data;

struct party_member_data {
 struct map_session_data *sd;
 unsigned int hp;
 unsigned short x, y;
};

struct party_data {
 struct party party;
 struct party_member_data data[12];
 uint8 itemc;
 short *instance;
 unsigned short instances;
 struct {
  unsigned monk : 1;
  unsigned sg : 1;
  unsigned snovice :1;
  unsigned tk : 1;
 } state;
 struct hplugin_data_store *hdata;
};



struct party_booking_detail {
 short level;



 short mapid;
 short job[6];

};

struct party_booking_ad_info {
 unsigned int index;




 char charname[(23 + 1)];
 int expiretime;

 struct party_booking_detail p_detail;
};






struct party_interface {
 struct DBMap *db;
 struct DBMap *booking_db;
 unsigned int booking_nextid;

 void (*init) (
# 92 "../../../server-code/src/map/party.h" 3 4
              _Bool 
# 92 "../../../server-code/src/map/party.h"
                   minimal);
 void (*final) (void);

 struct party_data* (*search) (int party_id);
 struct party_data* (*searchname) (const char* str);
 int (*getmemberid) (struct party_data* p, struct map_session_data* sd);
 struct map_session_data* (*getavailablesd) (struct party_data *p);

 int (*create) (struct map_session_data *sd, const char *name, int item, int item2);
 void (*created) (int account_id, int char_id, int fail, int party_id, const char *name);
 int (*request_info) (int party_id, int char_id);
 int (*invite) (struct map_session_data *sd,struct map_session_data *tsd);
 void (*member_joined) (struct map_session_data *sd);
 int (*member_added) (int party_id,int account_id,int char_id,int flag);
 int (*leave) (struct map_session_data *sd);
 int (*removemember) (struct map_session_data *sd, int account_id, const char *name);
 int (*member_withdraw) (int party_id,int account_id,int char_id);
 void (*reply_invite) (struct map_session_data *sd,int party_id,int flag);
 int (*recv_noinfo) (int party_id, int char_id);
 int (*recv_info) (const struct party *sp, int char_id);
 int (*recv_movemap) (int party_id,int account_id,int char_id, unsigned short mapid,int online,int lv);
 int (*broken) (int party_id);
 int (*optionchanged) (int party_id,int account_id,int exp,int item,int flag);
 int (*changeoption) (struct map_session_data *sd,int exp,int item);
 
# 116 "../../../server-code/src/map/party.h" 3 4
_Bool 
# 116 "../../../server-code/src/map/party.h"
     (*changeleader) (struct map_session_data *sd, struct map_session_data *t_sd);
 void (*send_movemap) (struct map_session_data *sd);
 void (*send_levelup) (struct map_session_data *sd);
 int (*send_logout) (struct map_session_data *sd);
 int (*send_message) (struct map_session_data *sd,const char *mes,int len);
 int (*recv_message) (int party_id,int account_id,const char *mes,int len);
 int (*skill_check) (struct map_session_data *sd, int party_id, uint16 skill_id, uint16 skill_lv);
 int (*send_xy_clear) (struct party_data *p);
 int (*exp_share) (struct party_data *p,struct block_list *src,unsigned int base_exp,unsigned int job_exp,int zeny);
 int (*share_loot) (struct party_data* p, struct map_session_data* sd, struct item* item_data, int first_charid);
 int (*send_dot_remove) (struct map_session_data *sd);
 int (*sub_count) (struct block_list *bl, va_list ap);
 int (*sub_count_chorus) (struct block_list *bl, va_list ap);



 void (*booking_register) (struct map_session_data *sd, short level, short mapid, short* job);
 void (*booking_update) (struct map_session_data *sd, short* job);
 void (*booking_search) (struct map_session_data *sd, short level, short mapid, short job, unsigned long lastindex, short resultcount);

 void (*recruit_register) (struct map_session_data *sd, short level, const char *notice);
 void (*recruit_update) (struct map_session_data *sd, const char *notice);
 void (*recruit_search) (struct map_session_data *sd, short level, short mapid, unsigned long lastindex, short resultcount);
 
# 139 "../../../server-code/src/map/party.h" 3 4
_Bool 
# 139 "../../../server-code/src/map/party.h"
     (*booking_delete) (struct map_session_data *sd);

 int (*vforeachsamemap) (int (*func)(struct block_list *,va_list),struct map_session_data *sd,int range, va_list ap);
 int (*foreachsamemap) (int (*func)(struct block_list *,va_list),struct map_session_data *sd,int range,...);
 int (*send_xy_timer) (int tid, int64 tick, int id, intptr_t data);
 void (*fill_member) (struct party_member* member, struct map_session_data* sd, unsigned int leader);
 struct map_session_data *(*sd_check) (int party_id, int account_id, int char_id);
 void (*check_state) (struct party_data *p);
 struct party_booking_ad_info* (*create_booking_data) (void);
 int (*db_final) (union DBKey key, struct DBData *data, va_list ap);
};


void party_defaults(void);


extern struct party_interface *party;
# 46 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/map/pc.h" 1
# 26 "../../../server-code/src/map/pc.h"
# 1 "../../../server-code/src/map/buyingstore.h" 1
# 27 "../../../server-code/src/map/buyingstore.h"
struct map_session_data;




struct s_search_store_search;
# 47 "../../../server-code/src/map/buyingstore.h"
enum e_buyingstore_failure {
 BUYINGSTORE_CREATE = 1,
 BUYINGSTORE_CREATE_OVERWEIGHT = 2,
 BUYINGSTORE_TRADE_BUYER_ZENY = 3,
 BUYINGSTORE_TRADE_BUYER_NO_ITEMS = 4,
 BUYINGSTORE_TRADE_SELLER_FAILED = 5,
 BUYINGSTORE_TRADE_SELLER_COUNT = 6,
 BUYINGSTORE_TRADE_SELLER_ZENY = 7,
 BUYINGSTORE_CREATE_NO_INFO = 8,
};




struct s_buyingstore_item {
 int price;
 unsigned short amount;
 unsigned short nameid;
};

struct s_buyingstore {
 struct s_buyingstore_item items[5];
 int zenylimit;
 unsigned char slots;
};




struct buyingstore_interface {
 unsigned int nextid;
 short blankslots[4];

 
# 80 "../../../server-code/src/map/buyingstore.h" 3 4
_Bool 
# 80 "../../../server-code/src/map/buyingstore.h"
     (*setup) (struct map_session_data* sd, unsigned char slots);
 void (*create) (struct map_session_data* sd, int zenylimit, unsigned char result, const char* storename, const uint8* itemlist, unsigned int count);
 void (*close) (struct map_session_data* sd);
 void (*open) (struct map_session_data* sd, int account_id);
 void (*trade) (struct map_session_data* sd, int account_id, unsigned int buyer_id, const uint8* itemlist, unsigned int count);
 
# 85 "../../../server-code/src/map/buyingstore.h" 3 4
_Bool 
# 85 "../../../server-code/src/map/buyingstore.h"
     (*search) (struct map_session_data* sd, unsigned short nameid);
 
# 86 "../../../server-code/src/map/buyingstore.h" 3 4
_Bool 
# 86 "../../../server-code/src/map/buyingstore.h"
     (*searchall) (struct map_session_data* sd, const struct s_search_store_search* s);
 unsigned int (*getuid) (void);
};


void buyingstore_defaults (void);


extern struct buyingstore_interface *buyingstore;
# 27 "../../../server-code/src/map/pc.h" 2





# 1 "../../../server-code/src/map/searchstore.h" 1
# 38 "../../../server-code/src/map/searchstore.h"
enum e_searchstore_searchtype {
 SEARCHTYPE_VENDING = 0,
 SEARCHTYPE_BUYING_STORE = 1,
};

enum e_searchstore_effecttype {
 EFFECTTYPE_NORMAL = 0,
 EFFECTTYPE_CASH = 1,
 EFFECTTYPE_MAX
};

enum e_searchstore_failure {
 SSI_FAILED_NOTHING_SEARCH_ITEM = 0,
 SSI_FAILED_OVER_MAXCOUNT = 1,
 SSI_FAILED_SEARCH_CNT = 2,
 SSI_FAILED_LIMIT_SEARCH_TIME = 3,
 SSI_FAILED_SSILIST_CLICK_TO_OPEN_STORE = 4,
};





struct s_search_store_search {
 struct map_session_data* search_sd;
 const unsigned short* itemlist;
 const unsigned short* cardlist;
 unsigned int item_count;
 unsigned int card_count;
 unsigned int min_price;
 unsigned int max_price;
};

struct s_search_store_info_item {
 unsigned int store_id;
 int account_id;
 char store_name[(79 + 1)];
 unsigned short nameid;
 unsigned short amount;
 unsigned int price;
 short card[4];
 unsigned char refine;
};

struct s_search_store_info {
 unsigned int count;
 struct s_search_store_info_item* items;
 unsigned int pages;
 unsigned int uses;
 int remote_id;
 time_t nextquerytime;
 unsigned short effect;
 unsigned char type;
 
# 91 "../../../server-code/src/map/searchstore.h" 3 4
_Bool 
# 91 "../../../server-code/src/map/searchstore.h"
     open;
};


typedef 
# 95 "../../../server-code/src/map/searchstore.h" 3 4
       _Bool 
# 95 "../../../server-code/src/map/searchstore.h"
            (*searchstore_search_t)(struct map_session_data* sd, unsigned short nameid);
typedef 
# 96 "../../../server-code/src/map/searchstore.h" 3 4
       _Bool 
# 96 "../../../server-code/src/map/searchstore.h"
            (*searchstore_searchall_t)(struct map_session_data* sd, const struct s_search_store_search* s);




struct searchstore_interface {
 
# 102 "../../../server-code/src/map/searchstore.h" 3 4
_Bool 
# 102 "../../../server-code/src/map/searchstore.h"
     (*open) (struct map_session_data* sd, unsigned int uses, unsigned short effect);
 void (*query) (struct map_session_data* sd, unsigned char type, unsigned int min_price, unsigned int max_price, const unsigned short* itemlist, unsigned int item_count, const unsigned short* cardlist, unsigned int card_count);
 
# 104 "../../../server-code/src/map/searchstore.h" 3 4
_Bool 
# 104 "../../../server-code/src/map/searchstore.h"
     (*querynext) (struct map_session_data* sd);
 void (*next) (struct map_session_data* sd);
 void (*clear) (struct map_session_data* sd);
 void (*close) (struct map_session_data* sd);
 void (*click) (struct map_session_data* sd, int account_id, int store_id, unsigned short nameid);
 
# 109 "../../../server-code/src/map/searchstore.h" 3 4
_Bool 
# 109 "../../../server-code/src/map/searchstore.h"
     (*queryremote) (struct map_session_data* sd, int account_id);
 void (*clearremote) (struct map_session_data* sd);
 
# 111 "../../../server-code/src/map/searchstore.h" 3 4
_Bool 
# 111 "../../../server-code/src/map/searchstore.h"
     (*result) (struct map_session_data* sd, unsigned int store_id, int account_id, const char* store_name, unsigned short nameid, unsigned short amount, unsigned int price, const short* card, unsigned char refine);
};


void searchstore_defaults(void);


extern struct searchstore_interface *searchstore;
# 33 "../../../server-code/src/map/pc.h" 2


# 1 "../../../server-code/src/map/vending.h" 1
# 27 "../../../server-code/src/map/vending.h"
struct DBMap;
struct map_session_data;
struct s_search_store_search;

struct s_vending {
 short index;
 short amount;
 unsigned int value;
};

struct vending_interface {
 unsigned int next_id;
 struct DBMap *db;

 void (*init) (
# 41 "../../../server-code/src/map/vending.h" 3 4
              _Bool 
# 41 "../../../server-code/src/map/vending.h"
                   minimal);
 void (*final) (void);

 void (*close) (struct map_session_data* sd);
 void (*open) (struct map_session_data* sd, const char* message, const uint8* data, int count);
 void (*list) (struct map_session_data* sd, unsigned int id);
 void (*purchase) (struct map_session_data* sd, int aid, unsigned int uid, const uint8* data, int count);
 
# 48 "../../../server-code/src/map/vending.h" 3 4
_Bool 
# 48 "../../../server-code/src/map/vending.h"
     (*search) (struct map_session_data* sd, unsigned short nameid);
 
# 49 "../../../server-code/src/map/vending.h" 3 4
_Bool 
# 49 "../../../server-code/src/map/vending.h"
     (*searchall) (struct map_session_data* sd, const struct s_search_store_search* s);
};


void vending_defaults(void);


extern struct vending_interface *vending;
# 36 "../../../server-code/src/map/pc.h" 2

# 1 "../../../server-code/src/common/ers.h" 1
# 91 "../../../server-code/src/common/ers.h"
enum ERSOptions {
 ERS_OPT_NONE = 0x00,
 ERS_OPT_CLEAR = 0x01,
 ERS_OPT_WAIT = 0x02,
 ERS_OPT_FREE_NAME = 0x04,
 ERS_OPT_CLEAN = 0x08,
 ERS_OPT_FLEX_CHUNK = 0x10,


 ERS_CACHE_OPTIONS = ERS_OPT_CLEAN|ERS_OPT_FLEX_CHUNK,
};
# 110 "../../../server-code/src/common/ers.h"
typedef struct eri {







 void *(*alloc)(struct eri *self);
# 127 "../../../server-code/src/common/ers.h"
 void (*free)(struct eri *self, void *entry);






 size_t (*entry_size)(struct eri *self);
# 143 "../../../server-code/src/common/ers.h"
 void (*destroy)(struct eri *self);


 void (*chunk_size) (struct eri *self, unsigned int new_size);
} ERS;
# 180 "../../../server-code/src/common/ers.h"
ERS *ers_new(uint32 size, char *name, enum ERSOptions options);
# 189 "../../../server-code/src/common/ers.h"
void ers_report(void);




void ers_final(void);
# 38 "../../../server-code/src/map/pc.h" 2
# 51 "../../../server-code/src/map/pc.h"
enum equip_index {
 EQI_ACC_L = 0,
 EQI_ACC_R,
 EQI_SHOES,
 EQI_GARMENT,
 EQI_HEAD_LOW,
 EQI_HEAD_MID,
 EQI_HEAD_TOP,
 EQI_ARMOR,
 EQI_HAND_L,
 EQI_HAND_R,
 EQI_COSTUME_TOP,
 EQI_COSTUME_MID,
 EQI_COSTUME_LOW,
 EQI_COSTUME_GARMENT,
 EQI_AMMO,
 EQI_SHADOW_ARMOR,
 EQI_SHADOW_WEAPON,
 EQI_SHADOW_SHIELD,
 EQI_SHADOW_SHOES,
 EQI_SHADOW_ACC_R,
 EQI_SHADOW_ACC_L,
 EQI_MAX
};

enum pc_unequipitem_flag {
 PCUNEQUIPITEM_NONE = 0x0,
 PCUNEQUIPITEM_RECALC = 0x1,
 PCUNEQUIPITEM_FORCE = 0x2,
};

enum pc_resetskill_flag {
 PCRESETSKILL_NONE = 0x0,
 PCRESETSKILL_RESYNC = 0x1,
 PCRESETSKILL_RECOUNT = 0x2,
 PCRESETSKILL_CHSEX = 0x4,
};

struct weapon_data {
 int atkmods[3];
int8 HERC__zeroed_block_BEGIN;
 int overrefine;
 int star;
 int ignore_def_ele;
 int ignore_def_race;
 int def_ratio_atk_ele;
 int def_ratio_atk_race;
 int addele[ELE_MAX];
 int addrace[RC_MAX];
 int addrace2[RC2_MAX];
 int addsize[3];
 struct drain_data {
  short rate;
  short per;
  short value;
  unsigned type:1;
 } hp_drain[RC_MAX], sp_drain[RC_MAX];
 struct {
  short class_, rate;
 } add_dmg[10];
 struct {
  short flag, rate;
  unsigned char ele;
 } addele2[10];
int8 HERC__zeroed_block_END;
};
struct s_autospell {
 short id, lv, rate, card_id, flag;
 
# 119 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 119 "../../../server-code/src/map/pc.h"
     lock;
};

struct s_addeffect {
 enum sc_type id;
 int16 rate;
 int16 arrow_rate;
 uint8 flag;
 uint16 duration;

};
struct s_addeffectonskill {
 enum sc_type id;
 short rate, skill;
 unsigned char target;
};
struct s_add_drop {
 short id, group;
 int race, rate;
};
struct s_autobonus {
 short rate,atk_type;
 unsigned int duration;
 char *bonus_script, *other_script;
 int active;
 unsigned short pos;
};
enum npc_timeout_type {
 NPCT_INPUT = 0,
 NPCT_MENU = 1,
 NPCT_WAIT = 2,
};

struct pc_combos {
 struct script_code *bonus;
 unsigned short id;
};

struct map_session_data {
 struct block_list bl;
 struct unit_data ud;
 struct view_data vd;
 struct status_data base_status, battle_status;
 struct status_change sc;
 struct regen_data regen;
 struct regen_data_sub sregen, ssregen;


 struct {
  unsigned int active : 1;
  unsigned int menu_or_input : 1;
  unsigned int dead_sit : 2;
  unsigned int lr_flag : 3;
  unsigned int connect_new : 1;
  unsigned int arrow_atk : 1;
  unsigned int gangsterparadise : 1;
  unsigned int rest : 1;
  unsigned int storage_flag : 2;
  unsigned int snovice_dead_flag : 1;
  unsigned int abra_flag : 2;
  unsigned int autocast : 1;
  unsigned int autotrade : 2;
  unsigned int showdelay :1;
  unsigned int showexp :1;
  unsigned int showzeny :1;
  unsigned int noask :1;
  unsigned int trading :1;
  unsigned int deal_locked :2;
  unsigned int monster_ignore :1;
  unsigned int size :2;
  unsigned int night :1;
  unsigned int blockedmove :1;
  unsigned int using_fake_npc :1;
  unsigned int rewarp :1;
  unsigned int killer : 1;
  unsigned int killable : 1;
  unsigned int doridori : 1;
  unsigned int ignoreAll : 1;
  unsigned int debug_remove_map : 1;
  unsigned int buyingstore : 1;
  unsigned int lesseffect : 1;
  unsigned int vending : 1;
  unsigned int noks : 3;
  unsigned int changemap : 1;
  unsigned int callshop : 1;
  short pmap;
  unsigned short autoloot;
  unsigned short autolootid[10];
  unsigned short autoloottype;
  unsigned int autolooting : 1;
  unsigned short autobonus;
  unsigned int gmaster_flag : 1;
  unsigned int prevend : 1;
  unsigned int warping : 1;
  unsigned int permanent_speed : 1;
  unsigned int dialog : 1;
  unsigned int prerefining : 1;
  unsigned int workinprogress : 3;
  unsigned int hold_recalc : 1;
  unsigned int snovice_call_flag : 3;
  unsigned int hpmeter_visible : 1;
  unsigned int itemcheck : 1;
  unsigned int standalone : 1;
  unsigned int loggingout : 1;
  unsigned int warp_clean : 1;
 } state;
 struct {
  unsigned char no_weapon_damage, no_magic_damage, no_misc_damage;
  unsigned int restart_full_recover : 1;
  unsigned int no_castcancel : 1;
  unsigned int no_castcancel2 : 1;
  unsigned int no_sizefix : 1;
  unsigned int no_gemstone : 1;
  unsigned int intravision : 1;
  unsigned int perfect_hiding : 1;
  unsigned int no_knockback : 1;
  unsigned int bonus_coma : 1;
 } special_state;
 int login_id1, login_id2;
 unsigned short class_;


 int group_id;
 GroupSettings *group;
 unsigned int extra_temp_permissions;

 struct mmo_charstatus status;
 struct item_data* inventory_data[100];
 short equip_index[EQI_MAX];
 unsigned int weight,max_weight;
 int cart_weight,cart_num,cart_weight_max;
 int fd;
 unsigned short mapindex;
 unsigned char head_dir;
 unsigned int client_tick;
 int npc_id,areanpc_id,npc_shopid,touching_id;
 int npc_item_flag;
 int npc_menu;
 int npc_amount;
 struct script_state *st;
 char npc_str[(70 + 1)];
 int npc_timer_id;
 unsigned int chatID;
 int64 idletime;
 struct {
  int npc_id;
  int64 timeout;
 } progressbar;
 struct{
  char name[(23 + 1)];
 } ignore[20];
 int followtimer;
 int followtarget;
 time_t emotionlasttime;
 short skillitem,skillitemlv;
 uint16 skill_id_old,skill_lv_old;
 uint16 skill_id_dance,skill_lv_dance;
 short cook_mastery;
 
# 277 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 277 "../../../server-code/src/map/pc.h"
     blockskill[1478];
 int cloneskill_id, reproduceskill_id;
 int menuskill_id, menuskill_val, menuskill_val2;
 int invincible_timer;
 int64 canlog_tick;
 int64 canuseitem_tick;
 int64 canusecashfood_tick;
 int64 canequip_tick;
 int64 cantalk_tick;
 int64 canskill_tick;
 int64 cansendmail_tick;
 int64 ks_floodprotect_tick;
 struct {
  short nameid;
  int64 tick;
 } item_delay[10];
 short weapontype1,weapontype2;
 short disguise;
 struct weapon_data right_weapon, left_weapon;

int8 HERC__zeroed_block_BEGIN;
 int param_bonus[6],param_equip[6];
 int subele[ELE_MAX];
 int subrace[RC_MAX];
 int subrace2[RC2_MAX];
 int subsize[3];
 int reseff[SC_COMMON_MAX-SC_COMMON_MIN+1];
 int weapon_coma_ele[ELE_MAX];
 int weapon_coma_race[RC_MAX];
 int weapon_atk[MAX_WEAPON_TYPE];
 int weapon_atk_rate[MAX_WEAPON_TYPE];
 int arrow_addele[ELE_MAX];
 int arrow_addrace[RC_MAX];
 int arrow_addsize[3];
 int magic_addele[ELE_MAX];
 int magic_addrace[RC_MAX];
 int magic_addsize[3];
 int magic_atk_ele[ELE_MAX];
 int critaddrace[RC_MAX];
 int expaddrace[RC_MAX];
 int ignore_mdef[RC_MAX];
 int ignore_def[RC_MAX];
 short sp_gain_race[RC_MAX];
 short sp_gain_race_attack[RC_MAX];
 short hp_gain_race_attack[RC_MAX];

 int race_tolerance[RC_MAX];

 struct s_autospell autospell[15], autospell2[15], autospell3[15];
 struct s_addeffect addeff[10], addeff2[10];
 struct s_addeffectonskill addeff3[10];
 struct {
  unsigned short id;
  short val;
 } skillatk[10], skillusesprate[10], skillusesp[10], skillheal[5], skillheal2[5], skillblown[10], skillcast[10], skillcooldown[10], skillfixcast[10], skillvarcast[10], skillfixcastrate[10];
 struct {
  short value;
  int rate;
  int tick;
 } hp_loss, sp_loss, hp_regen, sp_regen;
 struct {
  short class_, rate;
 } add_def[10], add_mdef[10], add_mdmg[10];
 struct s_add_drop add_drop[10];
 struct {
  int nameid;
  int rate;
 } itemhealrate[10];
 struct {
  short flag, rate;
  unsigned char ele;
 } subele2[10];
 struct {
  short value;
  int rate, tick;
 } def_set_race[RC_MAX], mdef_set_race[RC_MAX];
 struct {
  int atk_rate;
  int arrow_atk,arrow_ele,arrow_cri,arrow_hit;
  int nsshealhp,nsshealsp;
  int critical_def,double_rate;
  int long_attack_atk_rate;
  int near_attack_def_rate,long_attack_def_rate,magic_def_rate,misc_def_rate;
  int ignore_mdef_ele;
  int ignore_mdef_race;
  int perfect_hit;
  int perfect_hit_add;
  int get_zeny_rate;
  int get_zeny_num;
  int double_add_rate;
  int short_weapon_damage_return,long_weapon_damage_return;
  int magic_damage_return;
  int break_weapon_rate,break_armor_rate;
  int crit_atk_rate;
  int classchange;
  int speed_rate, speed_add_rate, aspd_add;
  int itemhealrate2;
  int shieldmdef;
  unsigned int setitem_hash, setitem_hash2;
  short splash_range, splash_add_range;
  short add_steal_rate;
  short add_heal_rate, add_heal2_rate;
  short sp_gain_value, hp_gain_value, magic_sp_gain_value, magic_hp_gain_value;
  short hp_vanish_rate;
  short hp_vanish_per, hp_vanish_trigger;
  short sp_vanish_rate;
  short sp_vanish_per, sp_vanish_trigger;
  unsigned short unbreakable;
  unsigned short unbreakable_equip;
  unsigned short unstripable_equip;
  int fixcastrate,varcastrate;
  int add_fixcast,add_varcast;
  int ematk;
 } bonus;
int8 HERC__zeroed_block_END;


 struct s_autobonus autobonus[10], autobonus2[10], autobonus3[10];

 int castrate,delayrate,hprate,sprate,dsprate;
 int hprecov_rate,sprecov_rate;
 int matk_rate;
 int critical_rate,hit_rate,flee_rate,flee2_rate,def_rate,def2_rate,mdef_rate,mdef2_rate;
 int itemid;
 short itemindex;
 short catch_target_class;
 short spiritball, spiritball_old;
 int spirit_timer[15];
 short charm_count;
 int charm_type;
 int charm_timer[10];
 unsigned char potion_success_counter;
 unsigned char mission_count;
 short mission_mobid;
 int die_counter;
 int devotion[5];
 int trade_partner;
 struct {
  struct {
   short index, amount;
  } item[10];
  int zeny, weight;
 } deal;
 
# 420 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 420 "../../../server-code/src/map/pc.h"
     party_creating;
 
# 421 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 421 "../../../server-code/src/map/pc.h"
     party_joining;
 int party_invite, party_invite_account;
 int adopt_invite;
 struct guild *guild;
 int guild_invite,guild_invite_account;
 int guild_emblem_id,guild_alliance,guild_alliance_account;
 short guild_x,guild_y;
 int guildspy;
 int partyspy;
 unsigned int vended_id;
 unsigned int vender_id;
 int vend_num;
 char message[(79 + 1)];
 struct s_vending vending[12];
 unsigned int buyer_id;
 struct s_buyingstore buyingstore;
 struct s_search_store_info searchstore;

 struct pet_data *pd;
 struct homun_data *hd;
 struct mercenary_data *md;
 struct elemental_data *ed;

 struct {
  int m;
  unsigned short index;
 } feel_map[3];
 short hate_mob[3];

 int pvp_timer;
 short pvp_point;
 unsigned short pvp_rank, pvp_lastusers;
 unsigned short pvp_won, pvp_lost;

 char eventqueue[2][( (23 + 1) * 2 + 3 )];
 int eventtimer[32];
 unsigned short eventcount;

 unsigned char change_level_2nd;
 unsigned char change_level_3rd;

 char fakename[(23 + 1)];

 int duel_group;
 int duel_invite;

 int killerrid, killedrid;

 int cashPoints, kafraPoints;
 int rental_timer;


 struct {
  int index, amount;
 } auction;


 struct {
  short nameid;
  int index, amount, zeny;
  struct mail_data inbox;
  
# 482 "../../../server-code/src/map/pc.h" 3 4
 _Bool 
# 482 "../../../server-code/src/map/pc.h"
      changed;
 } mail;


 int num_quests;
 int avail_quests;
 struct quest *quest_log;
 
# 489 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 489 "../../../server-code/src/map/pc.h"
     save_quest;


 const char* debug_file;
 int debug_line;
 const char* debug_func;

 unsigned int bg_id;
# 519 "../../../server-code/src/map/pc.h"
 struct pc_combos *combos;
 unsigned char combo_count;




 int friend_req;

 int shadowform_id;


 struct channel_data **channels;
 unsigned char channel_count;
 struct channel_data *gcbind;
 unsigned char fontcolor;
 unsigned int fontcolor_tid;
 int64 hchsysch_tick;


 struct sc_display_entry **sc_display;
 unsigned char sc_display_count;

 short *instance;
 unsigned short instances;


 struct {
  unsigned int ready : 1;
  unsigned int client_has_bg_data : 1;
  struct bg_arena *arena;
  enum bg_queue_types type;
 } bg_queue;

 struct { int _max_; int _len_; int *_data_; } script_queues;


 unsigned int cryptKey;
 unsigned short (*parse_cmd_func)(int fd, struct map_session_data *sd);

 unsigned char delayed_damage;
 struct hplugin_data_store *hdata;


 int expiration_tid;
 time_t expiration_time;


 struct {
  unsigned int second,third;
 } sktree;




 struct reg_db regs;
 unsigned char vars_received;
 
# 575 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 575 "../../../server-code/src/map/pc.h"
     vars_ok;
 
# 576 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 576 "../../../server-code/src/map/pc.h"
     vars_dirty;

 struct {
  short stage;
  short prizeIdx;
  short prizeStage;
  
# 582 "../../../server-code/src/map/pc.h" 3 4
 _Bool 
# 582 "../../../server-code/src/map/pc.h"
      claimPrize;
 } roulette;

 uint8 lang_id;


 const char* delunit_prevfile;
 int delunit_prevline;

};
# 717 "../../../server-code/src/map/pc.h"
struct skill_tree_requirement {
 short id;
 unsigned short idx;
 unsigned char lv;
};

struct skill_tree_entry {
 short id;
 unsigned short idx;
 unsigned char max;
 unsigned char joblv;
 short inherited;
 struct { int _max_; int _len_; struct skill_tree_requirement *_data_; } need;
};

struct sg_data {
 short anger_id;
 short bless_id;
 short comfort_id;
 char feel_var[(23 + 1)];
 char hate_var[(23 + 1)];
 
# 738 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 738 "../../../server-code/src/map/pc.h"
     (*day_func)(void);
};

enum { ADDITEM_EXIST , ADDITEM_NEW , ADDITEM_OVERAMOUNT };







struct item_cd {
 int64 tick[10];
 short nameid[10];
};

enum e_pc_autotrade_update_action {
 PAUC_START,
 PAUC_REFRESH,
 PAUC_REMOVE,
};




enum pc_skill_flag {
 SKILL_GRANT_PERMANENT = 0,
 SKILL_GRANT_TEMPORARY = 1,
 SKILL_GRANT_TEMPSTACK = 2,
 SKILL_GRANT_UNCONDITIONAL = 3,
};




struct autotrade_vending {
 struct item list[12];
 struct s_vending vending[12];
 unsigned char vend_num;
 struct hplugin_data_store *hdata;
};






struct pc_interface {


 struct DBMap *at_db;

 struct DBMap *itemcd_db;

 int day_timer_tid;
 int night_timer_tid;


int8 HERC__zeroed_block_BEGIN;
 unsigned int exp_table[(JOB_MAX - JOB_NOVICE_HIGH + JOB_MAX_BASIC)][2][175];
 unsigned int max_level[(JOB_MAX - JOB_NOVICE_HIGH + JOB_MAX_BASIC)][2];
 unsigned int statp[175 +1];
 unsigned int level_penalty[3][RC_MAX][175*2+1];

 struct skill_tree_entry skill_tree[(JOB_MAX - JOB_NOVICE_HIGH + JOB_MAX_BASIC)][86];
 struct fame_list smith_fame_list[10];
 struct fame_list chemist_fame_list[10];
 struct fame_list taekwon_fame_list[10];
int8 HERC__zeroed_block_END;

 unsigned int equip_pos[EQI_MAX];
 struct sg_data sg_info[3];

 struct eri *sc_display_ers;

 int expiration_tid;



 struct eri *num_reg_ers;
 struct eri *str_reg_ers;

 
# 820 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 820 "../../../server-code/src/map/pc.h"
     reg_load;

 void (*init) (
# 822 "../../../server-code/src/map/pc.h" 3 4
              _Bool 
# 822 "../../../server-code/src/map/pc.h"
                   minimal);
 void (*final) (void);

 struct map_session_data* (*get_dummy_sd) (void);
 int (*class2idx) (int class_);
 
# 827 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 827 "../../../server-code/src/map/pc.h"
     (*can_talk) (struct map_session_data *sd);
 
# 828 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 828 "../../../server-code/src/map/pc.h"
     (*can_attack) ( struct map_session_data *sd, int target_id );

 
# 830 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 830 "../../../server-code/src/map/pc.h"
     (*can_use_command) (struct map_session_data *sd, const char *command);
 int (*set_group) (struct map_session_data *sd, int group_id);
 
# 832 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 832 "../../../server-code/src/map/pc.h"
     (*should_log_commands) (struct map_session_data *sd);

 int (*setrestartvalue) (struct map_session_data *sd,int type);
 int (*makesavestatus) (struct map_session_data *sd);
 void (*respawn) (struct map_session_data* sd, clr_type clrtype);
 int (*setnewpc) (struct map_session_data *sd, int account_id, int char_id, int login_id1, unsigned int client_tick, int sex, int fd);
 
# 838 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 838 "../../../server-code/src/map/pc.h"
     (*authok) (struct map_session_data *sd, int login_id2, time_t expiration_time, int group_id, const struct mmo_charstatus *st, 
# 838 "../../../server-code/src/map/pc.h" 3 4
                                                                                                                                   _Bool 
# 838 "../../../server-code/src/map/pc.h"
                                                                                                                                        changing_mapservers);
 void (*authfail) (struct map_session_data *sd);
 int (*reg_received) (struct map_session_data *sd);

 int (*isequip) (struct map_session_data *sd,int n);
 int (*equippoint) (struct map_session_data *sd,int n);
 int (*setinventorydata) (struct map_session_data *sd);

 int (*checkskill) (struct map_session_data *sd,uint16 skill_id);
 int (*checkskill2) (struct map_session_data *sd,uint16 index);
 int (*checkallowskill) (struct map_session_data *sd);
 int (*checkequip) (struct map_session_data *sd,int pos);

 int (*calc_skilltree) (struct map_session_data *sd);
 int (*calc_skilltree_normalize_job) (struct map_session_data *sd);
 int (*clean_skilltree) (struct map_session_data *sd);

 int (*setpos) (struct map_session_data* sd, unsigned short map_index, int x, int y, clr_type clrtype);
 int (*setsavepoint) (struct map_session_data *sd, short map_index, int x, int y);
 int (*randomwarp) (struct map_session_data *sd,clr_type type);
 int (*memo) (struct map_session_data* sd, int pos);

 int (*checkadditem) (struct map_session_data *sd,int nameid,int amount);
 int (*inventoryblank) (struct map_session_data *sd);
 int (*search_inventory) (struct map_session_data *sd,int item_id);
 int (*payzeny) (struct map_session_data *sd,int zeny, enum e_log_pick_type type, struct map_session_data *tsd);
 int (*additem) (struct map_session_data *sd,struct item *item_data,int amount,e_log_pick_type log_type);
 int (*getzeny) (struct map_session_data *sd,int zeny, enum e_log_pick_type type, struct map_session_data *tsd);
 int (*delitem) (struct map_session_data *sd,int n,int amount,int type, short reason, e_log_pick_type log_type);


 int (*paycash) (struct map_session_data *sd, int price, int points);
 int (*getcash) (struct map_session_data *sd, int cash, int points);

 int (*cart_additem) (struct map_session_data *sd,struct item *item_data,int amount,e_log_pick_type log_type);
 int (*cart_delitem) (struct map_session_data *sd,int n,int amount,int type,e_log_pick_type log_type);
 int (*putitemtocart) (struct map_session_data *sd,int idx,int amount);
 int (*getitemfromcart) (struct map_session_data *sd,int idx,int amount);
 int (*cartitem_amount) (struct map_session_data *sd,int idx,int amount);

 int (*takeitem) (struct map_session_data *sd,struct flooritem_data *fitem);
 int (*dropitem) (struct map_session_data *sd,int n,int amount);

 
# 881 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 881 "../../../server-code/src/map/pc.h"
     (*isequipped) (struct map_session_data *sd, int nameid);
 
# 882 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 882 "../../../server-code/src/map/pc.h"
     (*can_Adopt) (struct map_session_data *p1_sd, struct map_session_data *p2_sd, struct map_session_data *b_sd);
 
# 883 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 883 "../../../server-code/src/map/pc.h"
     (*adoption) (struct map_session_data *p1_sd, struct map_session_data *p2_sd, struct map_session_data *b_sd);

 int (*updateweightstatus) (struct map_session_data *sd);

 int (*addautobonus) (struct s_autobonus *bonus,char max,const char *bonus_script,short rate,unsigned int dur,short atk_type,const char *o_script,unsigned short pos,
# 887 "../../../server-code/src/map/pc.h" 3 4
                                                                                                                                                                    _Bool 
# 887 "../../../server-code/src/map/pc.h"
                                                                                                                                                                         onskill);
 int (*exeautobonus) (struct map_session_data* sd,struct s_autobonus *bonus);
 int (*endautobonus) (int tid, int64 tick, int id, intptr_t data);
 int (*delautobonus) (struct map_session_data* sd,struct s_autobonus *bonus,char max,
# 890 "../../../server-code/src/map/pc.h" 3 4
                                                                                    _Bool 
# 890 "../../../server-code/src/map/pc.h"
                                                                                         restore);

 int (*bonus) (struct map_session_data *sd,int type,int val);
 int (*bonus2) (struct map_session_data *sd,int type,int type2,int val);
 int (*bonus3) (struct map_session_data *sd,int type,int type2,int type3,int val);
 int (*bonus4) (struct map_session_data *sd,int type,int type2,int type3,int type4,int val);
 int (*bonus5) (struct map_session_data *sd,int type,int type2,int type3,int type4,int type5,int val);
 int (*skill) (struct map_session_data *sd, int id, int level, int flag);

 int (*insert_card) (struct map_session_data *sd,int idx_card,int idx_equip);
 
# 900 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 900 "../../../server-code/src/map/pc.h"
     (*can_insert_card) (struct map_session_data* sd, int idx_card);
 
# 901 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 901 "../../../server-code/src/map/pc.h"
     (*can_insert_card_into) (struct map_session_data* sd, int idx_card, int idx_equip);

 int (*steal_item) (struct map_session_data *sd,struct block_list *bl, uint16 skill_lv);
 int (*steal_coin) (struct map_session_data *sd,struct block_list *bl);

 int (*modifybuyvalue) (struct map_session_data *sd,int orig_value);
 int (*modifysellvalue) (struct map_session_data *sd,int orig_value);

 int (*follow) (struct map_session_data *sd, int target_id);
 int (*stop_following) (struct map_session_data *sd);

 unsigned int (*maxbaselv) (struct map_session_data *sd);
 unsigned int (*maxjoblv) (struct map_session_data *sd);
 int (*checkbaselevelup) (struct map_session_data *sd);
 int (*checkjoblevelup) (struct map_session_data *sd);
 
# 916 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 916 "../../../server-code/src/map/pc.h"
     (*gainexp) (struct map_session_data *sd, struct block_list *src, unsigned int base_exp, unsigned int job_exp, 
# 916 "../../../server-code/src/map/pc.h" 3 4
                                                                                                                   _Bool 
# 916 "../../../server-code/src/map/pc.h"
                                                                                                                        is_quest);
 unsigned int (*nextbaseexp) (struct map_session_data *sd);
 unsigned int (*thisbaseexp) (struct map_session_data *sd);
 unsigned int (*nextjobexp) (struct map_session_data *sd);
 unsigned int (*thisjobexp) (struct map_session_data *sd);
 int (*gets_status_point) (int level);
 int (*need_status_point) (struct map_session_data *sd,int type,int val);
 int (*maxparameterincrease) (struct map_session_data* sd, int type);
 
# 924 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 924 "../../../server-code/src/map/pc.h"
     (*statusup) (struct map_session_data *sd, int type, int increase);
 int (*statusup2) (struct map_session_data *sd,int type,int val);
 int (*skillup) (struct map_session_data *sd,uint16 skill_id);
 int (*allskillup) (struct map_session_data *sd);
 int (*resetlvl) (struct map_session_data *sd,int type);
 int (*resetstate) (struct map_session_data *sd);
 int (*resetskill) (struct map_session_data *sd, int flag);
 int (*resetfeel) (struct map_session_data *sd);
 int (*resethate) (struct map_session_data *sd);
 int (*equipitem) (struct map_session_data *sd,int n,int req_pos);
 void (*equipitem_pos) (struct map_session_data *sd, struct item_data *id, int n, int pos);
 int (*unequipitem) (struct map_session_data *sd,int n,int flag);
 void (*unequipitem_pos) (struct map_session_data *sd, int n, int pos);
 int (*checkitem) (struct map_session_data *sd);
 int (*useitem) (struct map_session_data *sd,int n);

 int (*skillatk_bonus) (struct map_session_data *sd, uint16 skill_id);
 int (*skillheal_bonus) (struct map_session_data *sd, uint16 skill_id);
 int (*skillheal2_bonus) (struct map_session_data *sd, uint16 skill_id);

 void (*damage) (struct map_session_data *sd,struct block_list *src,unsigned int hp, unsigned int sp);
 int (*dead) (struct map_session_data *sd,struct block_list *src);
 void (*revive) (struct map_session_data *sd,unsigned int hp, unsigned int sp);
 void (*heal) (struct map_session_data *sd,unsigned int hp,unsigned int sp, int type);
 int (*itemheal) (struct map_session_data *sd,int itemid, int hp,int sp);
 int (*percentheal) (struct map_session_data *sd,int hp,int sp);
 int (*jobchange) (struct map_session_data *sd,int job, int upper);
 int (*setoption) (struct map_session_data *sd,int type);
 int (*setcart) (struct map_session_data* sd, int type);
 void (*setfalcon) (struct map_session_data *sd, 
# 953 "../../../server-code/src/map/pc.h" 3 4
                                                _Bool 
# 953 "../../../server-code/src/map/pc.h"
                                                     flag);
 void (*setridingpeco) (struct map_session_data *sd, 
# 954 "../../../server-code/src/map/pc.h" 3 4
                                                    _Bool 
# 954 "../../../server-code/src/map/pc.h"
                                                         flag);
 void (*setmadogear) (struct map_session_data *sd, 
# 955 "../../../server-code/src/map/pc.h" 3 4
                                                  _Bool 
# 955 "../../../server-code/src/map/pc.h"
                                                       flag);
 void (*setridingdragon) (struct map_session_data *sd, unsigned int type);
 void (*setridingwug) (struct map_session_data *sd, 
# 957 "../../../server-code/src/map/pc.h" 3 4
                                                   _Bool 
# 957 "../../../server-code/src/map/pc.h"
                                                        flag);
 int (*changelook) (struct map_session_data *sd,int type,int val);
 int (*equiplookall) (struct map_session_data *sd);

 int (*readparam) (struct map_session_data *sd,int type);
 int (*setparam) (struct map_session_data *sd,int type,int val);
 int (*readreg) (struct map_session_data *sd, int64 reg);
 void (*setreg) (struct map_session_data *sd, int64 reg,int val);
 char * (*readregstr) (struct map_session_data *sd, int64 reg);
 void (*setregstr) (struct map_session_data *sd, int64 reg, const char *str);
 int (*readregistry) (struct map_session_data *sd, int64 reg);
 int (*setregistry) (struct map_session_data *sd, int64 reg, int val);
 char * (*readregistry_str) (struct map_session_data *sd, int64 reg);
 int (*setregistry_str) (struct map_session_data *sd, int64 reg, const char *val);

 int (*addeventtimer) (struct map_session_data *sd,int tick,const char *name);
 int (*deleventtimer) (struct map_session_data *sd,const char *name);
 int (*cleareventtimer) (struct map_session_data *sd);
 int (*addeventtimercount) (struct map_session_data *sd,const char *name,int tick);

 int (*calc_pvprank) (struct map_session_data *sd);
 int (*calc_pvprank_timer) (int tid, int64 tick, int id, intptr_t data);

 int (*ismarried) (struct map_session_data *sd);
 int (*marriage) (struct map_session_data *sd,struct map_session_data *dstsd);
 int (*divorce) (struct map_session_data *sd);
 struct map_session_data * (*get_partner) (struct map_session_data *sd);
 struct map_session_data * (*get_father) (struct map_session_data *sd);
 struct map_session_data * (*get_mother) (struct map_session_data *sd);
 struct map_session_data * (*get_child) (struct map_session_data *sd);

 void (*bleeding) (struct map_session_data *sd, unsigned int diff_tick);
 void (*regen) (struct map_session_data *sd, unsigned int diff_tick);

 void (*setstand) (struct map_session_data *sd);
 int (*candrop) (struct map_session_data *sd,struct item *item);

 int (*jobid2mapid) (unsigned short b_class);
 int (*mapid2jobid) (unsigned short class_, int sex);

 const char * (*job_name) (int class_);

 void (*setinvincibletimer) (struct map_session_data* sd, int val);
 void (*delinvincibletimer) (struct map_session_data* sd);

 int (*addspiritball) (struct map_session_data *sd,int interval,int max);
 int (*delspiritball) (struct map_session_data *sd,int count,int type);
 int (*getmaxspiritball) (struct map_session_data *sd, int min);
 void (*addfame) (struct map_session_data *sd,int count);
 unsigned char (*famerank) (int char_id, int job);
 int (*set_hate_mob) (struct map_session_data *sd, int pos, struct block_list *bl);

 int (*readdb) (void);
 int (*map_day_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*map_night_timer) (int tid, int64 tick, int id, intptr_t data);

 void (*inventory_rentals) (struct map_session_data *sd);
 int (*inventory_rental_clear) (struct map_session_data *sd);
 void (*inventory_rental_add) (struct map_session_data *sd, int seconds);

 int (*disguise) (struct map_session_data *sd, int class_);
 
# 1018 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 1018 "../../../server-code/src/map/pc.h"
     (*isautolooting) (struct map_session_data *sd, int nameid);

 void (*overheat) (struct map_session_data *sd, int val);

 int (*banding) (struct map_session_data *sd, uint16 skill_lv);

 void (*itemcd_do) (struct map_session_data *sd, 
# 1024 "../../../server-code/src/map/pc.h" 3 4
                                                _Bool 
# 1024 "../../../server-code/src/map/pc.h"
                                                     load);

 int (*load_combo) (struct map_session_data *sd);

 void (*add_charm) (struct map_session_data *sd, int interval, int max, int type);
 void (*del_charm) (struct map_session_data *sd, int count, int type);

 void (*baselevelchanged) (struct map_session_data *sd);
 int (*level_penalty_mod) (int diff, unsigned char race, uint32 mode, int type);
 int (*calc_skillpoint) (struct map_session_data* sd);

 int (*invincible_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*spiritball_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*check_banding) ( struct block_list *bl, va_list ap );
 int (*inventory_rental_end) (int tid, int64 tick, int id, intptr_t data);
 void (*check_skilltree) (struct map_session_data *sd, int skill_id);
 int (*bonus_autospell) (struct s_autospell *spell, int max, short id, short lv, short rate, short flag, short card_id);
 int (*bonus_autospell_onskill) (struct s_autospell *spell, int max, short src_skill, short id, short lv, short rate, short card_id);
 int (*bonus_addeff) (struct s_addeffect* effect, int max, enum sc_type id, int16 rate, int16 arrow_rate, uint8 flag, uint16 duration);
 int (*bonus_addeff_onskill) (struct s_addeffectonskill* effect, int max, enum sc_type id, short rate, short skill_id, unsigned char target);
 int (*bonus_item_drop) (struct s_add_drop *drop, const short max, short id, short group, int race, int rate);
 void (*calcexp) (struct map_session_data *sd, unsigned int *base_exp, unsigned int *job_exp, struct block_list *src);
 int (*respawn_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*jobchange_killclone) (struct block_list *bl, va_list ap);
 int (*getstat) (struct map_session_data* sd, int type);
 int (*setstat) (struct map_session_data* sd, int type, int val);
 int (*eventtimer) (int tid, int64 tick, int id, intptr_t data);
 int (*daynight_timer_sub) (struct map_session_data *sd,va_list ap);
 int (*charm_timer) (int tid, int64 tick, int id, intptr_t data);
 
# 1053 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 1053 "../../../server-code/src/map/pc.h"
     (*readdb_levelpenalty) (char* fields[], int columns, int current);
 int (*autosave) (int tid, int64 tick, int id, intptr_t data);
 int (*follow_timer) (int tid, int64 tick, int id, intptr_t data);
 void (*read_skill_tree) (void);
 void (*clear_skill_tree) (void);
 int (*isUseitem) (struct map_session_data *sd,int n);
 int (*show_steal) (struct block_list *bl,va_list ap);
 int (*checkcombo) (struct map_session_data *sd, struct item_data *data );
 int (*calcweapontype) (struct map_session_data *sd);
 int (*removecombo) (struct map_session_data *sd, struct item_data *data );

 void (*bank_deposit) (struct map_session_data *sd, int money);
 void (*bank_withdraw) (struct map_session_data *sd, int money);

 void (*rental_expire) (struct map_session_data *sd, int i);
 void (*scdata_received) (struct map_session_data *sd);

 void (*bound_clear) (struct map_session_data *sd, enum e_item_bound_type type);

 int (*expiration_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*global_expiration_timer) (int tid, int64 tick, int id, intptr_t data);
 void (*expire_check) (struct map_session_data *sd);

 
# 1076 "../../../server-code/src/map/pc.h" 3 4
_Bool 
# 1076 "../../../server-code/src/map/pc.h"
     (*db_checkid) (unsigned int class_);

 void (*validate_levels) (void);




 void (*autotrade_load) (void);
 void (*autotrade_update) (struct map_session_data *sd, enum e_pc_autotrade_update_action action);
 void (*autotrade_start) (struct map_session_data *sd);
 void (*autotrade_prepare) (struct map_session_data *sd);
 void (*autotrade_populate) (struct map_session_data *sd);
 int (*autotrade_final) (union DBKey key, struct DBData *data, va_list ap);

 int (*check_job_name) (const char *name);
 void (*update_idle_time) (struct map_session_data* sd, enum e_battle_config_idletime type);

 int (*have_magnifier) (struct map_session_data *sd);
};


void pc_defaults(void);


extern struct pc_interface *pc;
# 47 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/map/pet.h" 1
# 33 "../../../server-code/src/map/pet.h"
struct s_pet_db {
 short class_;
 char name[(23 + 1)],jname[(23 + 1)];
 short itemID;
 short EggID;
 short AcceID;
 short FoodID;
 int fullness;
 int hungry_delay;
 int r_hungry;
 int r_full;
 int intimate;
 int die;
 int capture;
 int speed;
 char s_perfor;
 int talk_convert_class;
 int attack_rate;
 int defence_attack_rate;
 int change_target_rate;
 struct script_code *equip_script;
 struct script_code *pet_script;
};

enum { PET_CLASS,PET_CATCH,PET_EGG,PET_EQUIP,PET_FOOD };

struct pet_recovery {
 enum sc_type type;
 unsigned short delay;
 int timer;
};

struct pet_bonus {
 unsigned short type;
 unsigned short val;
 unsigned short duration;
 unsigned short delay;
 int timer;
};

struct pet_skill_attack {
 unsigned short id;
 unsigned short lv;
 unsigned short div_;
 unsigned short rate;
 unsigned short bonusrate;
};

struct pet_skill_support {
 unsigned short id;
 unsigned short lv;
 unsigned short hp;
 unsigned short sp;
 unsigned short delay;
 int timer;
};

struct pet_loot {
 struct item *item;
 unsigned short count;
 unsigned short weight;
 unsigned short max;
};

struct pet_data {
 struct block_list bl;
 struct unit_data ud;
 struct view_data vd;
 struct s_pet pet;
 struct status_data status;
 struct mob_db *db;
 struct s_pet_db *petDB;
 int pet_hungry_timer;
 int target_id;
 struct {
  unsigned skillbonus : 1;
 } state;
 int move_fail_count;
 int64 next_walktime, last_thinktime;
 short rate_fix;

 struct pet_recovery* recovery;
 struct pet_bonus* bonus;
 struct pet_skill_attack* a_skill;
 struct pet_skill_support* s_skill;
 struct pet_loot* loot;

 struct map_session_data *msd;
};




struct pet_interface {
 struct s_pet_db db[300];
 struct eri *item_drop_ers;
 struct eri *item_drop_list_ers;

 int (*init) (
# 131 "../../../server-code/src/map/pet.h" 3 4
             _Bool 
# 131 "../../../server-code/src/map/pet.h"
                  minimal);
 int (*final) (void);

 int (*hungry_val) (struct pet_data *pd);
 void (*set_intimate) (struct pet_data *pd, int value);
 int (*create_egg) (struct map_session_data *sd, int item_id);
 int (*unlocktarget) (struct pet_data *pd);
 int (*attackskill) (struct pet_data *pd, int target_id);
 int (*target_check) (struct map_session_data *sd, struct block_list *bl, int type);
 int (*sc_check) (struct map_session_data *sd, int type);
 int (*hungry) (int tid, int64 tick, int id, intptr_t data);
 int (*search_petDB_index) (int key, int type);
 int (*hungry_timer_delete) (struct pet_data *pd);
 int (*performance) (struct map_session_data *sd, struct pet_data *pd);
 int (*return_egg) (struct map_session_data *sd, struct pet_data *pd);
 int (*data_init) (struct map_session_data *sd, struct s_pet *petinfo);
 int (*birth_process) (struct map_session_data *sd, struct s_pet *petinfo);
 int (*recv_petdata) (int account_id, struct s_pet *p, int flag);
 int (*select_egg) (struct map_session_data *sd, short egg_index);
 int (*catch_process1) (struct map_session_data *sd, int target_class);
 int (*catch_process2) (struct map_session_data *sd, int target_id);
 
# 152 "../../../server-code/src/map/pet.h" 3 4
_Bool 
# 152 "../../../server-code/src/map/pet.h"
     (*get_egg) (int account_id, short pet_class, int pet_id );
 int (*unequipitem) (struct map_session_data *sd, struct pet_data *pd);
 int (*food) (struct map_session_data *sd, struct pet_data *pd);
 int (*ai_sub_hard_lootsearch) (struct block_list *bl, va_list ap);
 int (*menu) (struct map_session_data *sd, int menunum);
 int (*change_name) (struct map_session_data *sd, const char *name);
 int (*change_name_ack) (struct map_session_data *sd, const char *name, int flag);
 int (*equipitem) (struct map_session_data *sd, int index);
 int (*randomwalk) (struct pet_data *pd, int64 tick);
 int (*ai_sub_hard) (struct pet_data *pd, struct map_session_data *sd, int64 tick);
 int (*ai_sub_foreachclient) (struct map_session_data *sd, va_list ap);
 int (*ai_hard) (int tid, int64 tick, int id, intptr_t data);
 int (*delay_item_drop) (int tid, int64 tick, int id, intptr_t data);
 int (*lootitem_drop) (struct pet_data *pd, struct map_session_data *sd);
 int (*skill_bonus_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*recovery_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*skill_support_timer) (int tid, int64 tick, int id, intptr_t data);
 int (*read_db) (void);
};


void pet_defaults(void);


extern struct pet_interface *pet;
# 48 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/map/quest.h" 1
# 28 "../../../server-code/src/map/quest.h"
struct block_list;
struct config_setting_t;
struct map_session_data;



struct quest_dropitem {
 int mob_id;
 int nameid;
 int rate;
};

struct quest_objective {
 int mob;
 int count;
};

struct quest_db {
 int id;
 unsigned int time;
 int objectives_count;
 struct quest_objective *objectives;
 int dropitem_count;
 struct quest_dropitem *dropitem;

};


enum quest_check_type {
 HAVEQUEST,
 PLAYTIME,
 HUNTING,
};

struct quest_interface {
 struct quest_db **db_data;
 struct quest_db dummy;

 void (*init) (
# 66 "../../../server-code/src/map/quest.h" 3 4
              _Bool 
# 66 "../../../server-code/src/map/quest.h"
                   minimal);
 void (*final) (void);
 void (*reload) (void);

 struct quest_db *(*db) (int quest_id);
 int (*pc_login) (struct map_session_data *sd);
 int (*add) (struct map_session_data *sd, int quest_id);
 int (*change) (struct map_session_data *sd, int qid1, int qid2);
 int (*delete) (struct map_session_data *sd, int quest_id);
 int (*update_objective_sub) (struct block_list *bl, va_list ap);
 void (*update_objective) (struct map_session_data *sd, int mob_id);
 int (*update_status) (struct map_session_data *sd, int quest_id, enum quest_state qs);
 int (*check) (struct map_session_data *sd, int quest_id, enum quest_check_type type);
 void (*clear) (void);
 int (*read_db) (void);
 struct quest_db *(*read_db_sub) (struct config_setting_t *cs, int n, const char *source);
};


void quest_defaults(void);


extern struct quest_interface *quest;
# 49 "../../../server-code/src/map/clif.c" 2



# 1 "../../../server-code/src/map/storage.h" 1
# 27 "../../../server-code/src/map/storage.h"
struct guild_storage;
struct item;
struct map_session_data;




enum storage_flag {
 STORAGE_FLAG_CLOSED = 0,
 STORAGE_FLAG_NORMAL = 1,
 STORAGE_FLAG_GUILD = 2,
};

struct storage_interface {

 void (*reconnect) (void);

 int (*delitem) (struct map_session_data* sd, int n, int amount);
 int (*open) (struct map_session_data *sd);
 int (*add) (struct map_session_data *sd,int index,int amount);
 int (*get) (struct map_session_data *sd,int index,int amount);
 int (*additem) (struct map_session_data* sd, struct item* item_data, int amount);
 int (*addfromcart) (struct map_session_data *sd,int index,int amount);
 int (*gettocart) (struct map_session_data *sd,int index,int amount);
 void (*close) (struct map_session_data *sd);
 void (*pc_quit) (struct map_session_data *sd, int flag);
 int (*comp_item) (const void *i1_, const void *i2_);
 void (*sortitem) (struct item* items, unsigned int size);
 int (*reconnect_sub) (union DBKey key, struct DBData *data, va_list ap);
};

struct guild_storage_interface {
 struct DBMap *db;

 struct guild_storage *(*ensure) (int guild_id);

 void (*init) (
# 63 "../../../server-code/src/map/storage.h" 3 4
              _Bool 
# 63 "../../../server-code/src/map/storage.h"
                   minimal);
 void (*final) (void);

 int (*delete) (int guild_id);
 int (*open) (struct map_session_data *sd);
 int (*additem) (struct map_session_data *sd,struct guild_storage *stor,struct item *item_data,int amount);
 int (*delitem) (struct map_session_data *sd,struct guild_storage *stor,int n,int amount);
 int (*add) (struct map_session_data *sd,int index,int amount);
 int (*get) (struct map_session_data *sd,int index,int amount);
 int (*addfromcart) (struct map_session_data *sd,int index,int amount);
 int (*gettocart) (struct map_session_data *sd,int index,int amount);
 int (*close) (struct map_session_data *sd);
 int (*pc_quit) (struct map_session_data *sd,int flag);
 int (*save) (int account_id, int guild_id, int flag);
 int (*saved) (int guild_id);
 struct DBData (*create) (union DBKey key, va_list args);
};


void storage_defaults(void);
void gstorage_defaults(void);


extern struct storage_interface *storage;
extern struct guild_storage_interface *gstorage;
# 53 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/map/trade.h" 1
# 30 "../../../server-code/src/map/trade.h"
struct map_session_data;

struct trade_interface {
 void (*request) (struct map_session_data *sd, struct map_session_data *target_sd);
 void (*ack) (struct map_session_data *sd,int type);
 int (*check_impossible) (struct map_session_data *sd);
 int (*check) (struct map_session_data *sd, struct map_session_data *tsd);
 void (*additem) (struct map_session_data *sd,short index,short amount);
 void (*addzeny) (struct map_session_data *sd,int amount);
 void (*ok) (struct map_session_data *sd);
 void (*cancel) (struct map_session_data *sd);
 void (*commit) (struct map_session_data *sd);
};


void trade_defaults(void);


extern struct trade_interface *trade;
# 54 "../../../server-code/src/map/clif.c" 2


# 1 "../../../server-code/src/common/HPM.h" 1
# 29 "../../../server-code/src/common/HPM.h"
# 1 "../../../server-code/src/common/HPMi.h" 1
# 24 "../../../server-code/src/common/HPMi.h"
# 1 "../../../server-code/src/common/console.h" 1
# 25 "../../../server-code/src/common/console.h"
# 1 "../../../server-code/src/common/mutex.h" 1
# 26 "../../../server-code/src/common/mutex.h"
typedef struct ramutex ramutex;
typedef struct racond racond;







ramutex *ramutex_create(void);






void ramutex_destroy(ramutex *m);






void ramutex_lock(ramutex *m);
# 58 "../../../server-code/src/common/mutex.h"

# 58 "../../../server-code/src/common/mutex.h" 3 4
_Bool 
# 58 "../../../server-code/src/common/mutex.h"
    ramutex_trylock(ramutex *m);






void ramutex_unlock(ramutex *m);







racond *racond_create(void);






void racond_destroy(racond *c);
# 89 "../../../server-code/src/common/mutex.h"
void racond_wait(racond *c, ramutex *m, sysint timeout_ticks);
# 99 "../../../server-code/src/common/mutex.h"
void racond_signal(racond *c);
# 108 "../../../server-code/src/common/mutex.h"
void racond_broadcast(racond *c);
# 26 "../../../server-code/src/common/console.h" 2
# 1 "../../../server-code/src/common/spinlock.h" 1
# 31 "../../../server-code/src/common/spinlock.h"
# 1 "../../../server-code/src/common/atomic.h" 1
# 110 "../../../server-code/src/common/atomic.h"
static __attribute__((always_inline)) inline int64 InterlockedExchangeAdd64(volatile int64 *addend, int64 increment){
 return __sync_fetch_and_add(addend, increment);
}

static __attribute__((always_inline)) inline int32 InterlockedExchangeAdd(volatile int32 *addend, int32 increment){
 return __sync_fetch_and_add(addend, increment);
}

static __attribute__((always_inline)) inline int64 InterlockedIncrement64(volatile int64 *addend){
 return __sync_add_and_fetch(addend, 1);
}

static __attribute__((always_inline)) inline int32 InterlockedIncrement(volatile int32 *addend){
 return __sync_add_and_fetch(addend, 1);
}

static __attribute__((always_inline)) inline int64 InterlockedDecrement64(volatile int64 *addend){
 return __sync_sub_and_fetch(addend, 1);
}

static __attribute__((always_inline)) inline int32 InterlockedDecrement(volatile int32 *addend){
 return __sync_sub_and_fetch(addend, 1);
}

static __attribute__((always_inline)) inline int64 InterlockedCompareExchange64(volatile int64 *dest, int64 exch, int64 cmp){
 return __sync_val_compare_and_swap(dest, cmp, exch);
}

static __attribute__((always_inline)) inline int32 InterlockedCompareExchange(volatile int32 *dest, int32 exch, int32 cmp){
 return __sync_val_compare_and_swap(dest, cmp, exch);
}

static __attribute__((always_inline)) inline int64 InterlockedExchange64(volatile int64 *target, int64 val){
 return __sync_lock_test_and_set(target, val);
}

static __attribute__((always_inline)) inline int32 InterlockedExchange(volatile int32 *target, int32 val){
 return __sync_lock_test_and_set(target, val);
}
# 32 "../../../server-code/src/common/spinlock.h" 2

# 1 "../../../server-code/src/common/thread.h" 1
# 26 "../../../server-code/src/common/thread.h"
typedef struct rAthread rAthread;
typedef void* (*rAthreadProc)(void*);

typedef enum RATHREAD_PRIO {
 RAT_PRIO_LOW = 0,
 RAT_PRIO_NORMAL,
 RAT_PRIO_HIGH
} RATHREAD_PRIO;
# 45 "../../../server-code/src/common/thread.h"
rAthread *rathread_create(rAthreadProc entryPoint, void *param);
# 58 "../../../server-code/src/common/thread.h"
rAthread *rathread_createEx(rAthreadProc entryPoint, void *param, size_t szStack, RATHREAD_PRIO prio);
# 68 "../../../server-code/src/common/thread.h"
void rathread_destroy(rAthread *handle);
# 79 "../../../server-code/src/common/thread.h"
rAthread *rathread_self(void);
# 90 "../../../server-code/src/common/thread.h"
int rathread_get_tid(void);
# 101 "../../../server-code/src/common/thread.h"

# 101 "../../../server-code/src/common/thread.h" 3 4
_Bool 
# 101 "../../../server-code/src/common/thread.h"
    rathread_wait(rAthread *handle, void **out_exitCode);
# 110 "../../../server-code/src/common/thread.h"
void rathread_prio_set(rAthread *handle, RATHREAD_PRIO prio);







RATHREAD_PRIO rathread_prio_get(rAthread *handle);
# 128 "../../../server-code/src/common/thread.h"
void rathread_yield(void);

void rathread_init(void);
void rathread_final(void);
# 34 "../../../server-code/src/common/spinlock.h" 2
# 47 "../../../server-code/src/common/spinlock.h"
typedef struct SPIN_LOCK{
  volatile int32 lock;
  volatile int32 nest;

  volatile int32 sync_lock;
} __attribute__((aligned(64))) SPIN_LOCK;




static __attribute__((always_inline)) inline void InitializeSpinLock(SPIN_LOCK *lck){
  lck->lock = 0;
  lck->nest = 0;
  lck->sync_lock = 0;
}

static __attribute__((always_inline)) inline void FinalizeSpinLock(SPIN_LOCK *lck){
  return;
}





static __attribute__((always_inline)) inline void EnterSpinLock(SPIN_LOCK *lck){
  int tid = rathread_get_tid();



  do { if(InterlockedCompareExchange((&lck->sync_lock), 1, 0) == 0) break; rathread_yield(); } while( 1);
  if(InterlockedCompareExchange(&lck->lock, tid, tid) == tid){
    InterlockedIncrement(&lck->nest);
    do { InterlockedExchange((&lck->sync_lock), 0); } while(0);
    return;
  }

  do { InterlockedExchange((&lck->sync_lock), 0); } while(0);


  while(1){
   if(InterlockedCompareExchange(&lck->lock, tid, 0) == 0){
    InterlockedIncrement(&lck->nest);
    return;
   }
   rathread_yield();
  }

}


static __attribute__((always_inline)) inline void LeaveSpinLock(SPIN_LOCK *lck){
  int tid = rathread_get_tid();

  do { if(InterlockedCompareExchange((&lck->sync_lock), 1, 0) == 0) break; rathread_yield(); } while( 1);

  if(InterlockedCompareExchange(&lck->lock, tid, tid) == tid){
   if(InterlockedDecrement(&lck->nest) == 0)
     InterlockedExchange(&lck->lock, 0);
  }

  do { InterlockedExchange((&lck->sync_lock), 0); } while(0);
}
# 27 "../../../server-code/src/common/console.h" 2



struct Sql;
# 41 "../../../server-code/src/common/console.h"
typedef void (*CParseFunc)(char *line);
# 56 "../../../server-code/src/common/console.h"
enum CONSOLE_PARSE_ENTRY_TYPE {
 CPET_UNKNOWN,
 CPET_FUNCTION,
 CPET_CATEGORY,
};

struct CParseEntry {
 char cmd[20];
 int type;
 union {
  CParseFunc func;
  struct { int _max_; int _len_; struct CParseEntry * *_data_; } children;
 } u;
};

struct console_input_interface {


 SPIN_LOCK ptlock;
 rAthread *pthread;
 volatile int32 ptstate;
 ramutex *ptmutex;
 racond *ptcond;

 struct { int _max_; int _len_; struct CParseEntry * *_data_; } command_list;
 struct { int _max_; int _len_; struct CParseEntry * *_data_; } commands;

 struct Sql *SQL;

 void (*parse_init) (void);
 void (*parse_final) (void);
 int (*parse_timer) (int tid, int64 tick, int id, intptr_t data);
 void *(*pthread_main) (void *x);
 void (*parse) (char* line);
 void (*parse_sub) (char* line);
 int (*key_pressed) (void);
 void (*load_defaults) (void);
 void (*parse_list_subs) (struct CParseEntry *cmd, unsigned char depth);
 void (*addCommand) (char *name, CParseFunc func);
 void (*setSQL) (struct Sql *SQL_handle);



};

struct console_interface {
 void (*init) (void);
 void (*final) (void);
 void (*display_title) (void);
 void (*display_gplnotice) (void);

 struct console_input_interface *input;
};


void console_defaults(void);


extern struct console_interface *console;
# 25 "../../../server-code/src/common/HPMi.h" 2

# 1 "../../../server-code/src/common/showmsg.h" 1
# 29 "../../../server-code/src/common/showmsg.h"
struct config_setting_t;
# 89 "../../../server-code/src/common/showmsg.h"
enum msg_type {
 MSG_NONE,
 MSG_STATUS,
 MSG_SQL,
 MSG_INFORMATION,
 MSG_NOTICE,
 MSG_WARNING,
 MSG_DEBUG,
 MSG_ERROR,
 MSG_FATALERROR
};

struct showmsg_interface {
 
# 102 "../../../server-code/src/common/showmsg.h" 3 4
_Bool 
# 102 "../../../server-code/src/common/showmsg.h"
     stdout_with_ansisequence;
 int silent;
 int console_log;
 char timestamp_format[20];

 void (*init) (void);
 void (*final) (void);

 void (*clearScreen) (void);
 int (*showMessageV) (const char *string, va_list ap);

 void (*showMessage) (const char *, ...) __attribute__((format(printf, 1, 2)));
 void (*showStatus) (const char *, ...) __attribute__((format(printf, 1, 2)));
 void (*showSQL) (const char *, ...) __attribute__((format(printf, 1, 2)));
 void (*showInfo) (const char *, ...) __attribute__((format(printf, 1, 2)));
 void (*showNotice) (const char *, ...) __attribute__((format(printf, 1, 2)));
 void (*showWarning) (const char *, ...) __attribute__((format(printf, 1, 2)));
 void (*showDebug) (const char *, ...) __attribute__((format(printf, 1, 2)));
 void (*showError) (const char *, ...) __attribute__((format(printf, 1, 2)));
 void (*showFatalError) (const char *, ...) __attribute__((format(printf, 1, 2)));
 void (*showConfigWarning) (struct config_setting_t *config, const char *string, ...) __attribute__((format(printf, 2, 3)));
};
# 140 "../../../server-code/src/common/showmsg.h"
void showmsg_defaults(void);


extern struct showmsg_interface *showmsg;
# 27 "../../../server-code/src/common/HPMi.h" 2

struct Sql;
struct script_state;
struct AtCommandInfo;
struct socket_data;
struct map_session_data;
struct hplugin_data_store;




struct hplugin_info {
 char* name;
 enum server_types type;
 char* version;
 char* req_version;
};

struct s_HPMDataCheck {
 char *name;
 unsigned int size;
 int type;
};



enum hp_event_types {
 HPET_INIT,
 HPET_FINAL,
 HPET_READY,
 HPET_POST_FINAL,
 HPET_PRE_INIT,
 HPET_MAX,
};

enum HPluginPacketHookingPoints {
 hpClif_Parse,
 hpChrif_Parse,
 hpParse_FromMap,
 hpParse_FromLogin,
 hpParse_Char,
 hpParse_FromChar,
 hpParse_Login,

 hpPHP_MAX,
};

enum HPluginHookType {
 HOOK_TYPE_PRE,
 HOOK_TYPE_POST,
};




enum HPluginDataTypes {
 HPDT_UNKNOWN,
 HPDT_SESSION,
 HPDT_MSD,
 HPDT_NPCD,
 HPDT_MAP,
 HPDT_INSTANCE,
 HPDT_GUILD,
 HPDT_PARTY,
 HPDT_MOBDB,
 HPDT_MOBDATA,
 HPDT_ITEMDATA,
 HPDT_BGDATA,
 HPDT_AUTOTRADE_VEND,
};


enum HPluginConfType {
 HPCT_BATTLE,
 HPCT_LOGIN,
 HPCT_CHAR,
 HPCT_CHAR_INTER,
 HPCT_MAP_INTER,
 HPCT_LOG,
 HPCT_SCRIPT,
 HPCT_MAX,
};
# 220 "../../../server-code/src/common/HPMi.h"
struct HPMi_interface {

 unsigned int pid;

 void (*event[HPET_MAX]) (void);
 
# 225 "../../../server-code/src/common/HPMi.h" 3 4
_Bool 
# 225 "../../../server-code/src/common/HPMi.h"
     (*addCommand) (char *name, 
# 225 "../../../server-code/src/common/HPMi.h" 3 4
                                _Bool 
# 225 "../../../server-code/src/common/HPMi.h"
                                     (*func)(const int fd, struct map_session_data* sd, const char* command, const char* message,struct AtCommandInfo *info));
 
# 226 "../../../server-code/src/common/HPMi.h" 3 4
_Bool 
# 226 "../../../server-code/src/common/HPMi.h"
     (*addScript) (char *name, char *args, 
# 226 "../../../server-code/src/common/HPMi.h" 3 4
                                           _Bool 
# 226 "../../../server-code/src/common/HPMi.h"
                                                (*func)(struct script_state *st), 
# 226 "../../../server-code/src/common/HPMi.h" 3 4
                                                                                  _Bool 
# 226 "../../../server-code/src/common/HPMi.h"
                                                                                       isDeprecated);
 void (*addCPCommand) (char *name, CParseFunc func);

 void (*addToHPData) (enum HPluginDataTypes type, uint32 pluginID, struct hplugin_data_store **storeptr, void *data, uint32 classid, 
# 229 "../../../server-code/src/common/HPMi.h" 3 4
                                                                                                                                    _Bool 
# 229 "../../../server-code/src/common/HPMi.h"
                                                                                                                                         autofree);
 void *(*getFromHPData) (enum HPluginDataTypes type, uint32 pluginID, struct hplugin_data_store *store, uint32 classid);
 void (*removeFromHPData) (enum HPluginDataTypes type, uint32 pluginID, struct hplugin_data_store *store, uint32 classid);

 
# 233 "../../../server-code/src/common/HPMi.h" 3 4
_Bool 
# 233 "../../../server-code/src/common/HPMi.h"
     (*addPacket) (unsigned short cmd, unsigned short length, void (*receive)(int fd), unsigned int point, unsigned int pluginID);

 
# 235 "../../../server-code/src/common/HPMi.h" 3 4
_Bool 
# 235 "../../../server-code/src/common/HPMi.h"
     (*AddHook) (enum HPluginHookType type, const char *target, void *hook, unsigned int pID);
 void (*HookStop) (const char *func, unsigned int pID);
 
# 237 "../../../server-code/src/common/HPMi.h" 3 4
_Bool 
# 237 "../../../server-code/src/common/HPMi.h"
     (*HookStopped) (void);

 
# 239 "../../../server-code/src/common/HPMi.h" 3 4
_Bool 
# 239 "../../../server-code/src/common/HPMi.h"
     (*addArg) (unsigned int pluginID, char *name, 
# 239 "../../../server-code/src/common/HPMi.h" 3 4
                                                   _Bool 
# 239 "../../../server-code/src/common/HPMi.h"
                                                        has_param, CmdlineExecFunc func, const char *help);

 
# 241 "../../../server-code/src/common/HPMi.h" 3 4
_Bool 
# 241 "../../../server-code/src/common/HPMi.h"
     (*addConf) (unsigned int pluginID, enum HPluginConfType type, char *name, void (*parse_func) (const char *key, const char *val), int (*return_func) (const char *key));

 void (*addPCGPermission) (unsigned int pluginID, char *name, unsigned int *mask);

 struct Sql *sql_handle;
};
# 30 "../../../server-code/src/common/HPM.h" 2
# 44 "../../../server-code/src/common/HPM.h"
# 1 "/usr/include/dlfcn.h" 1 3 4
# 24 "/usr/include/dlfcn.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 25 "/usr/include/dlfcn.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/dlfcn.h" 1 3 4
# 28 "/usr/include/dlfcn.h" 2 3 4
# 52 "/usr/include/dlfcn.h" 3 4





# 56 "/usr/include/dlfcn.h" 3 4
extern void *dlopen (const char *__file, int __mode) __attribute__ ((__nothrow__));



extern int dlclose (void *__handle) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern void *dlsym (void *__restrict __handle,
      const char *__restrict __name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 82 "/usr/include/dlfcn.h" 3 4
extern char *dlerror (void) __attribute__ ((__nothrow__ , __leaf__));
# 188 "/usr/include/dlfcn.h" 3 4

# 45 "../../../server-code/src/common/HPM.h" 2
# 68 "../../../server-code/src/common/HPM.h"

# 68 "../../../server-code/src/common/HPM.h"
struct hplugin {
 void * dll;
 unsigned int idx;
 char *filename;
 struct hplugin_info *info;
 struct HPMi_interface *hpi;
};




struct hpm_symbol {
 const char *name;
 void *ptr;
};




struct hplugin_data_entry {
 uint32 pluginID;
 uint32 classid;
 struct {
  unsigned int free : 1;
 } flag;
 void *data;
};




struct hplugin_data_store {
 enum HPluginDataTypes type;
 struct { int _max_; int _len_; struct hplugin_data_entry * *_data_; } entries;
};

struct HPluginPacket {
 unsigned int pluginID;
 unsigned short cmd;
 short len;
 void (*receive) (int fd);
};

struct HPMFileNameCache {
 const char *addr;
 char *name;
};


struct HPConfListenStorage {
 unsigned int pluginID;
 char key[40];
 void (*parse_func) (const char *key, const char *val);
 int (*return_func) (const char *key);
};


struct HPM_interface {

 unsigned int version[2];
 
# 128 "../../../server-code/src/common/HPM.h" 3 4
_Bool 
# 128 "../../../server-code/src/common/HPM.h"
     off;
 
# 129 "../../../server-code/src/common/HPM.h" 3 4
_Bool 
# 129 "../../../server-code/src/common/HPM.h"
     hooking;

 
# 131 "../../../server-code/src/common/HPM.h" 3 4
_Bool 
# 131 "../../../server-code/src/common/HPM.h"
     force_return;

 struct { int _max_; int _len_; struct hplugin * *_data_; } plugins;
 struct { int _max_; int _len_; struct hpm_symbol * *_data_; } symbols;

 struct { int _max_; int _len_; struct HPluginPacket *_data_; } packets[hpPHP_MAX];

 struct {

  int count;
  struct HPMFileNameCache *data;
 } filenames;

 struct { int _max_; int _len_; struct HPConfListenStorage *_data_; } config_listeners[HPCT_MAX];

 struct { int _max_; int _len_; char * *_data_; } cmdline_load_plugins;

 void (*init) (void);
 void (*final) (void);
 struct hplugin * (*create) (void);
 struct hplugin * (*load) (const char* filename);
 void (*unload) (struct hplugin* plugin);
 
# 153 "../../../server-code/src/common/HPM.h" 3 4
_Bool 
# 153 "../../../server-code/src/common/HPM.h"
     (*exists) (const char *filename);
 
# 154 "../../../server-code/src/common/HPM.h" 3 4
_Bool 
# 154 "../../../server-code/src/common/HPM.h"
     (*iscompatible) (char* version);
 void (*event) (enum hp_event_types type);
 void *(*import_symbol) (char *name, unsigned int pID);
 void (*share) (void *value, const char *name);
 void (*config_read) (void);
 char *(*pid2name) (unsigned int pid);
 unsigned char (*parse_packets) (int fd, int packet_id, enum HPluginPacketHookingPoints point);
 void (*load_sub) (struct hplugin *plugin);
 
# 162 "../../../server-code/src/common/HPM.h" 3 4
_Bool 
# 162 "../../../server-code/src/common/HPM.h"
     (*addhook_sub) (enum HPluginHookType type, const char *target, void *hook, unsigned int pID);

 
# 164 "../../../server-code/src/common/HPM.h" 3 4
_Bool 
# 164 "../../../server-code/src/common/HPM.h"
     (*parseConf) (const char *w1, const char *w2, enum HPluginConfType point);
 
# 165 "../../../server-code/src/common/HPM.h" 3 4
_Bool 
# 165 "../../../server-code/src/common/HPM.h"
     (*getBattleConf) (const char* w1, int *value);

 
# 167 "../../../server-code/src/common/HPM.h" 3 4
_Bool 
# 167 "../../../server-code/src/common/HPM.h"
     (*DataCheck) (struct s_HPMDataCheck *src, unsigned int size, int version, char *name);
 void (*datacheck_init) (const struct s_HPMDataCheck *src, unsigned int length, int version);
 void (*datacheck_final) (void);

 void (*data_store_create) (struct hplugin_data_store **storeptr, enum HPluginDataTypes type);
 void (*data_store_destroy) (struct hplugin_data_store **storeptr);
 
# 173 "../../../server-code/src/common/HPM.h" 3 4
_Bool 
# 173 "../../../server-code/src/common/HPM.h"
     (*data_store_validate) (enum HPluginDataTypes type, struct hplugin_data_store **storeptr, 
# 173 "../../../server-code/src/common/HPM.h" 3 4
                                                                                               _Bool 
# 173 "../../../server-code/src/common/HPM.h"
                                                                                                    initialize);

 
# 175 "../../../server-code/src/common/HPM.h" 3 4
_Bool 
# 175 "../../../server-code/src/common/HPM.h"
     (*data_store_validate_sub) (enum HPluginDataTypes type, struct hplugin_data_store **storeptr, 
# 175 "../../../server-code/src/common/HPM.h" 3 4
                                                                                                   _Bool 
# 175 "../../../server-code/src/common/HPM.h"
                                                                                                        initialize);
};


# 178 "../../../server-code/src/common/HPM.h" 3 4
_Bool 
# 178 "../../../server-code/src/common/HPM.h"
cmdline_arg_loadplugin (const char *name, const char *params);

extern struct HPM_interface *HPM;

void hpm_defaults(void);
# 57 "../../../server-code/src/map/clif.c" 2

# 1 "../../../server-code/src/common/conf.h" 1
# 26 "../../../server-code/src/common/conf.h"
# 1 "../../../server-code/3rdparty/libconfig/libconfig.h" 1
# 70 "../../../server-code/3rdparty/libconfig/libconfig.h"
union config_value_t
{
  int ival;
  long long llval;
  double fval;
  char *sval;
  struct config_list_t *list;
};

struct config_setting_t
{
  char *name;
  short type;
  short format;
  union config_value_t value;
  struct config_setting_t *parent;
  struct config_t *config;
  void *hook;
  unsigned int line;
  const char *file;
};

enum config_error_t
{
  CONFIG_ERR_NONE = 0,
  CONFIG_ERR_FILE_IO = 1,
  CONFIG_ERR_PARSE = 2
};

struct config_list_t
{
  unsigned int length;
  struct config_setting_t **elements;
};

struct config_t
{
  struct config_setting_t *root;
  void (*destructor)(void *);
  int options;
  unsigned short tab_width;
  short default_format;
  char *include_dir;
  const char *error_text;
  const char *error_file;
  int error_line;
  enum config_error_t error_type;
  char **filenames;
  unsigned int num_filenames;
};

extern int config_read(struct config_t *config, FILE *stream);
extern void config_write(const struct config_t *config, FILE *stream);

extern void config_set_default_format(struct config_t *config,
                                                    short format);

extern void config_set_options(struct config_t *config, int options);
extern int config_get_options(const struct config_t *config);

extern void config_set_auto_convert(struct config_t *config, int flag);
extern int config_get_auto_convert(const struct config_t *config);

extern int config_read_string(struct config_t *config, const char *str);

extern int config_read_file(struct config_t *config,
                                          const char *filename);
extern int config_write_file(struct config_t *config,
                                           const char *filename);

extern void config_set_destructor(struct config_t *config,
                                                void (*destructor)(void *));
extern void config_set_include_dir(struct config_t *config,
                                                 const char *include_dir);

extern void config_init(struct config_t *config);
extern void config_destroy(struct config_t *config);

extern int config_setting_get_int(
  const struct config_setting_t *setting);
extern long long config_setting_get_int64(
  const struct config_setting_t *setting);
extern double config_setting_get_float(
  const struct config_setting_t *setting);
extern int config_setting_get_bool(
  const struct config_setting_t *setting);
extern const char *config_setting_get_string(
  const struct config_setting_t *setting);

extern int config_setting_lookup_int(
  const struct config_setting_t *setting, const char *name, int *value);
extern int config_setting_lookup_int64(
  const struct config_setting_t *setting, const char *name, long long *value);
extern int config_setting_lookup_float(
  const struct config_setting_t *setting, const char *name, double *value);
extern int config_setting_lookup_bool(
  const struct config_setting_t *setting, const char *name, int *value);
extern int config_setting_lookup_string(
  const struct config_setting_t *setting, const char *name, const char **value);

extern int config_setting_set_int(struct config_setting_t *setting,
                                                int value);
extern int config_setting_set_int64(struct config_setting_t *setting,
                                                  long long value);
extern int config_setting_set_float(struct config_setting_t *setting,
                                                  double value);
extern int config_setting_set_bool(struct config_setting_t *setting,
                                                 int value);
extern int config_setting_set_string(struct config_setting_t *setting,
                                                   const char *value);

extern int config_setting_set_format(struct config_setting_t *setting,
                                                   short format);
extern short config_setting_get_format(
  const struct config_setting_t *setting);

extern int config_setting_get_int_elem(
  const struct config_setting_t *setting, int idx);
extern long long config_setting_get_int64_elem(
  const struct config_setting_t *setting, int idx);
extern double config_setting_get_float_elem(
  const struct config_setting_t *setting, int idx);
extern int config_setting_get_bool_elem(
  const struct config_setting_t *setting, int idx);
extern const char *config_setting_get_string_elem(
  const struct config_setting_t *setting, int idx);

extern struct config_setting_t *config_setting_set_int_elem(
  struct config_setting_t *setting, int idx, int value);
extern struct config_setting_t *config_setting_set_int64_elem(
  struct config_setting_t *setting, int idx, long long value);
extern struct config_setting_t *config_setting_set_float_elem(
  struct config_setting_t *setting, int idx, double value);
extern struct config_setting_t *config_setting_set_bool_elem(
  struct config_setting_t *setting, int idx, int value);
extern struct config_setting_t *config_setting_set_string_elem(
  struct config_setting_t *setting, int idx, const char *value);
# 247 "../../../server-code/3rdparty/libconfig/libconfig.h"
extern int config_setting_index(const struct config_setting_t *setting);

extern int config_setting_length(
  const struct config_setting_t *setting);
extern struct config_setting_t *config_setting_get_elem(
  const struct config_setting_t *setting, unsigned int idx);

extern struct config_setting_t *config_setting_get_member(
  const struct config_setting_t *setting, const char *name);

extern struct config_setting_t *config_setting_add(
  struct config_setting_t *parent, const char *name, int type);
extern int config_setting_remove(struct config_setting_t *parent,
                                               const char *name);
extern int config_setting_remove_elem(struct config_setting_t *parent,
                                                    unsigned int idx);
extern void config_setting_set_hook(struct config_setting_t *setting,
                                                  void *hook);



extern struct config_setting_t *config_lookup(const struct config_t *config,
                                                     const char *path);
extern struct config_setting_t *config_setting_lookup(
  struct config_setting_t *setting, const char *path);

extern int config_lookup_int(const struct config_t *config,
                                           const char *path, int *value);
extern int config_lookup_int64(const struct config_t *config,
                                             const char *path,
                                             long long *value);
extern int config_lookup_float(const struct config_t *config,
                                             const char *path, double *value);
extern int config_lookup_bool(const struct config_t *config,
                                            const char *path, int *value);
extern int config_lookup_string(const struct config_t *config,
                                              const char *path,
                                              const char **value);
# 27 "../../../server-code/src/common/conf.h" 2




struct libconfig_interface {
 int (*read) (struct config_t *config, FILE *stream);
 void (*write) (const struct config_t *config, FILE *stream);

 void (*set_options) (struct config_t *config, int options);
 int (*get_options) (const struct config_t *config);

 int (*read_string) (struct config_t *config, const char *str);
 int (*read_file_src) (struct config_t *config, const char *filename);
 int (*write_file) (struct config_t *config, const char *filename);

 void (*set_destructor) (struct config_t *config, void (*destructor)(void *));
 void (*set_include_dir) (struct config_t *config, const char *include_dir);

 void (*init) (struct config_t *config);
 void (*destroy) (struct config_t *config);

 int (*setting_get_int) (const struct config_setting_t *setting);
 long long (*setting_get_int64) (const struct config_setting_t *setting);
 double (*setting_get_float) (const struct config_setting_t *setting);

 int (*setting_get_bool) (const struct config_setting_t *setting);

 const char * (*setting_get_string) (const struct config_setting_t *setting);

 struct config_setting_t * (*setting_lookup) (struct config_setting_t *setting, const char *name);
 int (*setting_lookup_int) (const struct config_setting_t *setting, const char *name, int *value);
 int (*setting_lookup_int64) (const struct config_setting_t *setting, const char *name, long long *value);
 int (*setting_lookup_float) (const struct config_setting_t *setting, const char *name, double *value);
 int (*setting_lookup_bool) (const struct config_setting_t *setting, const char *name, int *value);
 int (*setting_lookup_string) (const struct config_setting_t *setting, const char *name, const char **value);
 int (*setting_set_int) (struct config_setting_t *setting ,int value);
 int (*setting_set_int64) (struct config_setting_t *setting, long long value);
 int (*setting_set_float) (struct config_setting_t *setting, double value);
 int (*setting_set_bool) (struct config_setting_t *setting, int value);
 int (*setting_set_string) (struct config_setting_t *setting, const char *value);

 int (*setting_set_format) (struct config_setting_t *setting, short format);
 short (*setting_get_format) (const struct config_setting_t *setting);

 int (*setting_get_int_elem) (const struct config_setting_t *setting, int idx);
 long long (*setting_get_int64_elem) (const struct config_setting_t *setting, int idx);
 double (*setting_get_float_elem) (const struct config_setting_t *setting, int idx);
 int (*setting_get_bool_elem) (const struct config_setting_t *setting, int idx);
 const char * (*setting_get_string_elem) (const struct config_setting_t *setting, int idx);
 struct config_setting_t * (*setting_set_int_elem) (struct config_setting_t *setting, int idx, int value);
 struct config_setting_t * (*setting_set_int64_elem) (struct config_setting_t *setting, int idx, long long value);
 struct config_setting_t * (*setting_set_float_elem) (struct config_setting_t *setting, int idx, double value);
 struct config_setting_t * (*setting_set_bool_elem) (struct config_setting_t *setting, int idx, int value);
 struct config_setting_t * (*setting_set_string_elem) (struct config_setting_t *setting, int idx, const char *value);

 int (*setting_index) (const struct config_setting_t *setting);
 int (*setting_length) (const struct config_setting_t *setting);

 struct config_setting_t * (*setting_get_elem) (const struct config_setting_t *setting, unsigned int idx);
 struct config_setting_t * (*setting_get_member) (const struct config_setting_t *setting, const char *name);

 struct config_setting_t * (*setting_add) (struct config_setting_t *parent, const char *name, int type);
 int (*setting_remove) (struct config_setting_t *parent, const char *name);

 int (*setting_remove_elem) (struct config_setting_t *parent, unsigned int idx);
 void (*setting_set_hook) (struct config_setting_t *setting, void *hook);

 struct config_setting_t * (*lookup) (const struct config_t *config, const char *filepath);
 int (*lookup_int) (const struct config_t *config, const char *filepath, int *value);
 int (*lookup_int64) (const struct config_t *config, const char *filepath, long long *value);
 int (*lookup_float) (const struct config_t *config, const char *filepath, double *value);
 int (*lookup_bool) (const struct config_t *config, const char *filepath, int *value);
 int (*lookup_string) (const struct config_t *config, const char *filepath, const char **value);



 int (*load_file) (struct config_t *config, const char *config_filename);
 void (*setting_copy_simple) (struct config_setting_t *parent, const struct config_setting_t *src);
 void (*setting_copy_elem) (struct config_setting_t *parent, const struct config_setting_t *src);
 void (*setting_copy_aggregate) (struct config_setting_t *parent, const struct config_setting_t *src);
 int (*setting_copy) (struct config_setting_t *parent, const struct config_setting_t *src);

 
# 109 "../../../server-code/src/common/conf.h" 3 4
_Bool 
# 109 "../../../server-code/src/common/conf.h"
     (*setting_get_bool_real) (const struct config_setting_t *setting);
 uint32 (*setting_get_uint32) (const struct config_setting_t *setting);
 uint16 (*setting_get_uint16) (const struct config_setting_t *setting);
 int16 (*setting_get_int16) (const struct config_setting_t *setting);

 int (*setting_lookup_bool_real) (const struct config_setting_t *setting, const char *name, 
# 114 "../../../server-code/src/common/conf.h" 3 4
                                                                                           _Bool 
# 114 "../../../server-code/src/common/conf.h"
                                                                                                *value);
 int (*setting_lookup_uint32) (const struct config_setting_t *setting, const char *name, uint32 *value);
 int (*setting_lookup_uint16) (const struct config_setting_t *setting, const char *name, uint16 *value);
 int (*setting_lookup_int16) (const struct config_setting_t *setting, const char *name, int16 *value);
 int (*setting_lookup_mutable_string) (const struct config_setting_t *setting, const char *name, char *out, size_t out_size);
 int (*lookup_mutable_string) (const struct config_t *config, const char *name, char *out, size_t out_size);
};


void libconfig_defaults(void);


extern struct libconfig_interface *libconfig;
# 59 "../../../server-code/src/map/clif.c" 2

# 1 "../../../server-code/src/common/grfio.h" 1
# 25 "../../../server-code/src/common/grfio.h"
void grfio_init(const char* fname);
void grfio_final(void);
void* grfio_reads(const char* fname, int* size);
char* grfio_find_file(const char* fname);


unsigned long grfio_crc32(const unsigned char *buf, unsigned int len);
int decode_zip(void* dest, unsigned long* destLen, const void* source, unsigned long sourceLen);
int encode_zip(void* dest, unsigned long* destLen, const void* source, unsigned long sourceLen);
# 61 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/common/memmgr.h" 1
# 80 "../../../server-code/src/common/memmgr.h"
struct malloc_interface {
 void (*init) (void);
 void (*final) (void);

 void* (*malloc)(size_t size, const char *file, int line, const char *func);
 void* (*calloc)(size_t num, size_t size, const char *file, int line, const char *func);
 void* (*realloc)(void *p, size_t size, const char *file, int line, const char *func);
 void* (*reallocz)(void *p, size_t size, const char *file, int line, const char *func);
 char* (*astrdup)(const char *p, const char *file, int line, const char *func);
 char *(*astrndup)(const char *p, size_t size, const char *file, int line, const char *func);
 void (*free)(void *p, const char *file, int line, const char *func);

 void (*memory_check)(void);
 
# 93 "../../../server-code/src/common/memmgr.h" 3 4
_Bool 
# 93 "../../../server-code/src/common/memmgr.h"
     (*verify_ptr)(void* ptr);
 size_t (*usage) (void);

 void (*post_shutdown) (void);
 void (*init_messages) (void);
};


void malloc_defaults(void);

void memmgr_report(int extra);


extern struct malloc_interface *iMalloc;
# 62 "../../../server-code/src/map/clif.c" 2

# 1 "../../../server-code/src/common/nullpo.h" 1
# 40 "../../../server-code/src/common/nullpo.h"
# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4




# 69 "/usr/include/assert.h" 3 4
extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



# 41 "../../../server-code/src/common/nullpo.h" 2
# 155 "../../../server-code/src/common/nullpo.h"

# 155 "../../../server-code/src/common/nullpo.h"
struct nullpo_interface {
 void (*assert_report) (const char *file, int line, const char *func, const char *targetname, const char *title);
};


void nullpo_defaults(void);


extern struct nullpo_interface *nullpo;
# 64 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/common/random.h" 1
# 27 "../../../server-code/src/common/random.h"
void rnd_init(void);
void rnd_seed(uint32);

int32 rnd(void);
uint32 rnd_roll(uint32 dice_faces);
int32 rnd_value(int32 min, int32 max);
double rnd_uniform(void);
double rnd_uniform53(void);
# 65 "../../../server-code/src/map/clif.c" 2

# 1 "../../../server-code/src/common/socket.h" 1
# 67 "../../../server-code/src/map/clif.c" 2

# 1 "../../../server-code/src/common/timer.h" 1
# 32 "../../../server-code/src/common/timer.h"
enum {
 TIMER_ONCE_AUTODEL = 0x01,
 TIMER_INTERVAL = 0x02,
 TIMER_REMOVE_HEAP = 0x10,
};



typedef int (*TimerFunc)(int tid, int64 tick, int id, intptr_t data);

struct TimerData {
 int64 tick;
 TimerFunc func;
 unsigned char type;
 int interval;


 int id;
 intptr_t data;
};







struct timer_interface {


 int64 (*gettick) (void);
 int64 (*gettick_nocache) (void);

 int (*add) (int64 tick, TimerFunc func, int id, intptr_t data);
 int (*add_interval) (int64 tick, TimerFunc func, int id, intptr_t data, int interval);
 const struct TimerData *(*get) (int tid);
 int (*delete) (int tid, TimerFunc func);

 int64 (*addtick) (int tid, int64 tick);
 int64 (*settick) (int tid, int64 tick);

 int (*add_func_list) (TimerFunc func, char* name);

 unsigned long (*get_uptime) (void);

 int (*perform) (int64 tick);
 void (*init) (void);
 void (*final) (void);
};


void timer_defaults(void);


extern struct timer_interface *timer;
# 69 "../../../server-code/src/map/clif.c" 2
# 1 "../../../server-code/src/common/utils.h" 1
# 28 "../../../server-code/src/common/utils.h"
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4

# 205 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 206 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 210 "/usr/include/unistd.h" 2 3 4
# 229 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 230 "/usr/include/unistd.h" 2 3 4
# 258 "/usr/include/unistd.h" 3 4

# 258 "/usr/include/unistd.h" 3 4
typedef __useconds_t useconds_t;
# 277 "/usr/include/unistd.h" 3 4
typedef __socklen_t socklen_t;
# 290 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 307 "/usr/include/unistd.h" 3 4
extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;
# 337 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ , __leaf__));
# 356 "/usr/include/unistd.h" 3 4
extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 379 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 420 "/usr/include/unistd.h" 3 4
extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__)) ;
# 435 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__));
# 447 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ , __leaf__));






extern int usleep (__useconds_t __useconds);
# 472 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;
# 514 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) ;
# 528 "/usr/include/unistd.h" 3 4
extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__));
# 546 "/usr/include/unistd.h" 3 4
extern char **__environ;







extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 601 "/usr/include/unistd.h" 3 4
extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 613 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__));
# 663 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__)) ;
# 703 "/usr/include/unistd.h" 3 4
extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;
# 759 "/usr/include/unistd.h" 3 4
extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__));





extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 874 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 57 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 71 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 150 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ , __leaf__));
# 875 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ , __leaf__));



extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int chroot (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);
# 972 "/usr/include/unistd.h" 3 4
extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ , __leaf__));





extern int getpagesize (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__));
# 996 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1019 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1040 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__));
# 1061 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__));
# 1084 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1115 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);
# 1154 "/usr/include/unistd.h" 3 4

# 29 "../../../server-code/src/common/utils.h" 2
# 39 "../../../server-code/src/common/utils.h"

# 39 "../../../server-code/src/common/utils.h"
void WriteDump(FILE* fp, const void* buffer, size_t length);
void ShowDump(const void* buffer, size_t length);

void findfile(const char *p, const char *pat, void (func)(const char*));

# 43 "../../../server-code/src/common/utils.h" 3 4
_Bool 
# 43 "../../../server-code/src/common/utils.h"
    exists(const char* filename);


unsigned int get_percentage(const unsigned int A, const unsigned int B);

int64 apply_percentrate64(int64 value, int rate, int maxrate);
int apply_percentrate(int value, int rate, int maxrate);

const char* timestamp2string(char* str, size_t size, time_t timestamp, const char* format);





extern uint8 GetByte(uint32 val, int idx);
extern uint16 GetWord(uint32 val, int idx);
extern uint16 MakeWord(uint8 byte0, uint8 byte1);
extern uint32 MakeDWord(uint16 word0, uint16 word1);




extern int16 MakeShortLE(int16 val);
extern int32 MakeLongLE(int32 val);
extern uint16 GetUShort(const unsigned char* buf);
extern uint32 GetULong(const unsigned char* buf);
extern int32 GetLong(const unsigned char* buf);
extern float GetFloat(const unsigned char* buf);

size_t hread(void * ptr, size_t size, size_t count, FILE * stream);
size_t hwrite(const void * ptr, size_t size, size_t count, FILE * stream);
# 83 "../../../server-code/src/common/utils.h"
struct HCache_interface {
 void (*init) (void);

 
# 86 "../../../server-code/src/common/utils.h" 3 4
_Bool 
# 86 "../../../server-code/src/common/utils.h"
     (*check) (const char *file);
 FILE *(*open) (const char *file, const char *opt);

 time_t recompile_time;
 
# 90 "../../../server-code/src/common/utils.h" 3 4
_Bool 
# 90 "../../../server-code/src/common/utils.h"
     enabled;
};


void HCache_defaults(void);


extern struct HCache_interface *HCache;
# 70 "../../../server-code/src/map/clif.c" 2







struct clif_interface clif_s;
struct clif_interface *clif;

struct s_packet_db packet_db[0x0F00 + 1];


static struct packet_itemlist_normal itemlist_normal;
static struct packet_itemlist_equip itemlist_equip;
static struct packet_storelist_normal storelist_normal;
static struct packet_storelist_equip storelist_equip;
static struct packet_viewequip_ack viewequip_list;

static struct packet_npc_market_result_ack npcmarket_result;
static struct packet_npc_market_open npcmarket_open;





static inline int itemtype(int type) {
 switch( type ) {

  case IT_WEAPON:
   return IT_ARMOR;
  case IT_ARMOR:
  case IT_PETARMOR:

  case IT_PETEGG:
   return IT_WEAPON;
  default:
   return type;
 }
}

static inline void WBUFPOS(uint8* p, unsigned short pos, short x, short y, unsigned char dir) {
 p += pos;
 p[0] = (uint8)(x>>2);
 p[1] = (uint8)((x<<6) | ((y>>4)&0x3f));
 p[2] = (uint8)((y<<4) | (dir&0xf));
}


static inline void WBUFPOS2(uint8* p, unsigned short pos, short x0, short y0, short x1, short y1, unsigned char sx0, unsigned char sy0) {
 p += pos;
 p[0] = (uint8)(x0>>2);
 p[1] = (uint8)((x0<<6) | ((y0>>4)&0x3f));
 p[2] = (uint8)((y0<<4) | ((x1>>6)&0x0f));
 p[3] = (uint8)((x1<<2) | ((y1>>8)&0x03));
 p[4] = (uint8)y1;
 p[5] = (uint8)((sx0<<4) | (sy0&0x0f));
}







static inline void WFIFOPOS2(int fd, unsigned short pos, short x0, short y0, short x1, short y1, unsigned char sx0, unsigned char sy0) {
 WBUFPOS2(WFIFOP(fd,pos), 0, x0, y0, x1, y1, sx0, sy0);
}

static inline void RBUFPOS(const uint8* p, unsigned short pos, short* x, short* y, unsigned char* dir) {
 p += pos;

 if( x ) {
  x[0] = ( ( p[0] & 0xff ) << 2 ) | ( p[1] >> 6 );
 }

 if( y ) {
  y[0] = ( ( p[1] & 0x3f ) << 4 ) | ( p[2] >> 4 );
 }

 if( dir ) {
  dir[0] = ( p[2] & 0x0f );
 }
}

static inline void RFIFOPOS(int fd, unsigned short pos, short* x, short* y, unsigned char* dir) {
 RBUFPOS(RFIFOP(fd,pos), 0, x, y, dir);
}
# 193 "../../../server-code/src/map/clif.c"
static inline 
# 193 "../../../server-code/src/map/clif.c" 3 4
             _Bool 
# 193 "../../../server-code/src/map/clif.c"
                  disguised(struct block_list* bl)
{
 struct map_session_data *sd = ( ((bl) == (struct block_list *)
# 195 "../../../server-code/src/map/clif.c" 3 4
                              ((void *)0) 
# 195 "../../../server-code/src/map/clif.c"
                              || (bl)->type != (BL_PC)) ? (TBL_PC *)
# 195 "../../../server-code/src/map/clif.c" 3 4
                              ((void *)0) 
# 195 "../../../server-code/src/map/clif.c"
                              : (TBL_PC *)(bl) );
 if (sd == 
# 196 "../../../server-code/src/map/clif.c" 3 4
          ((void *)0) 
# 196 "../../../server-code/src/map/clif.c"
               || sd->disguise == -1)
  return 
# 197 "../../../server-code/src/map/clif.c" 3 4
        0
# 197 "../../../server-code/src/map/clif.c"
             ;
 return 
# 198 "../../../server-code/src/map/clif.c" 3 4
       1
# 198 "../../../server-code/src/map/clif.c"
           ;
}





# 204 "../../../server-code/src/map/clif.c" 3 4
_Bool 
# 204 "../../../server-code/src/map/clif.c"
    clif_setip(const char* ip) {
 char ip_str[16];
 do { if (((void)(ip), 
# 206 "../../../server-code/src/map/clif.c" 3 4
0
# 206 "../../../server-code/src/map/clif.c"
)) return(
# 206 "../../../server-code/src/map/clif.c" 3 4
0
# 206 "../../../server-code/src/map/clif.c"
); } while(0);
 clif->map_ip = sockt->host2ip(ip);
 if ( !clif->map_ip ) {
  (showmsg->showWarning(("Failed to Resolve Map Server Address! (%s)\n"), ip));
  return 
# 210 "../../../server-code/src/map/clif.c" 3 4
        0
# 210 "../../../server-code/src/map/clif.c"
             ;
 }

 (strlib->safestrncpy_((clif->map_ip_str),(ip),(sizeof(clif->map_ip_str))));
 (showmsg->showInfo(("Map Server IP Address : '""\033[1;37m""%s""\033[0m""' -> '""\033[1;37m""%s""\033[0m""'.\n"), ip, sockt->ip2str(clif->map_ip, ip_str)));
 return 
# 215 "../../../server-code/src/map/clif.c" 3 4
       1
# 215 "../../../server-code/src/map/clif.c"
           ;
}


# 218 "../../../server-code/src/map/clif.c" 3 4
_Bool 
# 218 "../../../server-code/src/map/clif.c"
    clif_setbindip(const char* ip) {
 do { if (((void)(ip), 
# 219 "../../../server-code/src/map/clif.c" 3 4
0
# 219 "../../../server-code/src/map/clif.c"
)) return(
# 219 "../../../server-code/src/map/clif.c" 3 4
0
# 219 "../../../server-code/src/map/clif.c"
); } while(0);
 clif->bind_ip = sockt->host2ip(ip);
 if ( clif->bind_ip ) {
  char ip_str[16];
  (showmsg->showInfo(("Map Server Bind IP Address : '""\033[1;37m""%s""\033[0m""' -> '""\033[1;37m""%s""\033[0m""'.\n"), ip, sockt->ip2str(clif->bind_ip, ip_str)));
  return 
# 224 "../../../server-code/src/map/clif.c" 3 4
        1
# 224 "../../../server-code/src/map/clif.c"
            ;
 }
 (showmsg->showWarning(("Failed to Resolve Map Server Address! (%s)\n"), ip));
 return 
# 227 "../../../server-code/src/map/clif.c" 3 4
       0
# 227 "../../../server-code/src/map/clif.c"
            ;
}





void clif_setport(uint16 port)
{
 clif->map_port = port;
}




uint32 clif_getip(void)
{
 return clif->map_ip;
}




uint16 clif_getport(void)
{
 return clif->map_port;
}



uint32 clif_refresh_ip(void)
{
 uint32 new_ip = sockt->host2ip(clif->map_ip_str);
 if ( new_ip && new_ip != clif->map_ip ) {
  clif->map_ip = new_ip;
  (showmsg->showInfo(("Updating IP resolution of [%s].\n"), clif->map_ip_str));
  return clif->map_ip;
 }
 return 0;
}


static inline unsigned char clif_bl_type(struct block_list *bl) {
 do { if (((void)(bl), 
# 270 "../../../server-code/src/map/clif.c" 3 4
0
# 270 "../../../server-code/src/map/clif.c"
)) return(0x1); } while(0);
 switch (bl->type) {
  case BL_PC: return (disguised(bl) && !pc->db_checkid(status->get_viewdata(bl)->class_))? 0x1:0x0;
  case BL_ITEM: return 0x2;
  case BL_SKILL: return 0x3;
  case BL_CHAT: return 0x4;
  case BL_MOB: return pc->db_checkid(status->get_viewdata(bl)->class_)?0x0:0x5;
  case BL_NPC: return pc->db_checkid(status->get_viewdata(bl)->class_)?0x0:0x6;
  case BL_PET: return pc->db_checkid(status->get_viewdata(bl)->class_)?0x0:0x7;
  case BL_HOM: return 0x8;
  case BL_MER: return 0x9;
  case BL_ELEM: return 0xa;
  default: return 0x1;
 }
}
# 297 "../../../server-code/src/map/clif.c"
int clif_send_sub(struct block_list *bl, va_list ap) {
 struct block_list *src_bl;
 struct map_session_data *sd;
 void *buf;
 int len, type, fd;

 do { if (((void)(bl), 
# 303 "../../../server-code/src/map/clif.c" 3 4
0
# 303 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);
 do { if (( (bl->type == BL_PC) ? 
# 304 "../../../server-code/src/map/clif.c" 3 4
0 
# 304 "../../../server-code/src/map/clif.c"
: (nullpo->assert_report("../../../server-code/src/map/clif.c", 304, __func__, "bl->type == BL_PC", "failed assertion"), 
# 304 "../../../server-code/src/map/clif.c" 3 4
1
# 304 "../../../server-code/src/map/clif.c"
) )) return(0); } while(0);
 sd = ((TBL_PC *)BL_UCAST_(bl));

 fd = sd->fd;
 if (!fd || sockt->session[fd] == 
# 308 "../../../server-code/src/map/clif.c" 3 4
                                 ((void *)0)
# 308 "../../../server-code/src/map/clif.c"
                                     )
  return 0;

 buf = 
# 311 "../../../server-code/src/map/clif.c" 3 4
      __builtin_va_arg(
# 311 "../../../server-code/src/map/clif.c"
      ap
# 311 "../../../server-code/src/map/clif.c" 3 4
      ,
# 311 "../../../server-code/src/map/clif.c"
      void*
# 311 "../../../server-code/src/map/clif.c" 3 4
      )
# 311 "../../../server-code/src/map/clif.c"
                      ;
 len = 
# 312 "../../../server-code/src/map/clif.c" 3 4
      __builtin_va_arg(
# 312 "../../../server-code/src/map/clif.c"
      ap
# 312 "../../../server-code/src/map/clif.c" 3 4
      ,
# 312 "../../../server-code/src/map/clif.c"
      int
# 312 "../../../server-code/src/map/clif.c" 3 4
      )
# 312 "../../../server-code/src/map/clif.c"
                    ;
 do { if (((void)(src_bl = 
# 313 "../../../server-code/src/map/clif.c" 3 4
__builtin_va_arg(
# 313 "../../../server-code/src/map/clif.c"
ap
# 313 "../../../server-code/src/map/clif.c" 3 4
,
# 313 "../../../server-code/src/map/clif.c"
struct block_list*
# 313 "../../../server-code/src/map/clif.c" 3 4
)
# 313 "../../../server-code/src/map/clif.c"
), 
# 313 "../../../server-code/src/map/clif.c" 3 4
0
# 313 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);
 type = 
# 314 "../../../server-code/src/map/clif.c" 3 4
       __builtin_va_arg(
# 314 "../../../server-code/src/map/clif.c"
       ap
# 314 "../../../server-code/src/map/clif.c" 3 4
       ,
# 314 "../../../server-code/src/map/clif.c"
       int
# 314 "../../../server-code/src/map/clif.c" 3 4
       )
# 314 "../../../server-code/src/map/clif.c"
                     ;

 switch(type) {
  case AREA_WOS:
   if (bl == src_bl)
    return 0;
  break;
  case AREA_WOC:
   if (sd->chatID || bl == src_bl)
    return 0;
  break;
  case AREA_WOSC: {
   if (src_bl->type == BL_PC) {
    const struct map_session_data *ssd = ((const TBL_PC *)BL_UCCAST_(src_bl));
    if (ssd != 
# 328 "../../../server-code/src/map/clif.c" 3 4
              ((void *)0) 
# 328 "../../../server-code/src/map/clif.c"
                   && sd->chatID != 0 && (sd->chatID == ssd->chatID))
     return 0;
   } else if (src_bl->type == BL_NPC) {
    const struct npc_data *nd = ((const TBL_NPC *)BL_UCCAST_(src_bl));
    if (nd != 
# 332 "../../../server-code/src/map/clif.c" 3 4
             ((void *)0) 
# 332 "../../../server-code/src/map/clif.c"
                  && sd->chatID != 0 && (sd->chatID == nd->chat_id))
     return 0;
   }
  }
  break;







 }


 if( clif->ally_only && !sd->sc.data[SC_CLAIRVOYANCE] && !sd->special_state.intravision && battle->check_target( src_bl, &sd->bl, BCT_ENEMY ) > 0 )
  return 0;

 return clif->send_actual(fd, buf, len);
}

int clif_send_actual(int fd, void *buf, int len)
{
 do { if (((void)(buf), 
# 355 "../../../server-code/src/map/clif.c" 3 4
0
# 355 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);
 WFIFOHEAD(fd, len);
 if (WFIFOP(fd,0) == buf) {
  (showmsg->showError(("WARNING: Invalid use of clif->send function\n")));
  (showmsg->showError(("         Packet x%4x use a WFIFO of a player instead of to use a buffer.\n"), WBUFW(buf,0)));
  (showmsg->showError(("         Please correct your code.\n")));



  return 0;
 }

 memcpy(WFIFOP(fd,0), buf, len);
 WFIFOSET(fd,len);

 return 0;
}






# 377 "../../../server-code/src/map/clif.c" 3 4
_Bool 
# 377 "../../../server-code/src/map/clif.c"
    clif_send(const void* buf, int len, struct block_list* bl, enum send_target type) {
 int i;
 struct map_session_data *sd, *tsd;
 struct party_data *p = 
# 380 "../../../server-code/src/map/clif.c" 3 4
                       ((void *)0)
# 380 "../../../server-code/src/map/clif.c"
                           ;
 struct guild *g = 
# 381 "../../../server-code/src/map/clif.c" 3 4
                  ((void *)0)
# 381 "../../../server-code/src/map/clif.c"
                      ;
 struct battleground_data *bgd = 
# 382 "../../../server-code/src/map/clif.c" 3 4
                                ((void *)0)
# 382 "../../../server-code/src/map/clif.c"
                                    ;
 int x0 = 0, x1 = 0, y0 = 0, y1 = 0, fd;
 struct s_mapiterator* iter;

 if( type != ALL_CLIENT )
  do { if (((void)(bl), 
# 387 "../../../server-code/src/map/clif.c" 3 4
 0
# 387 "../../../server-code/src/map/clif.c"
 )) return(0); } while(0);

 sd = ( ((bl) == (struct block_list *)
# 389 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0) 
# 389 "../../../server-code/src/map/clif.c"
     || (bl)->type != (BL_PC)) ? (TBL_PC *)
# 389 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0) 
# 389 "../../../server-code/src/map/clif.c"
     : (TBL_PC *)(bl) );

 if (sd != 
# 391 "../../../server-code/src/map/clif.c" 3 4
          ((void *)0) 
# 391 "../../../server-code/src/map/clif.c"
               && ( (sd)->sc.option&OPTION_INVISIBLE )) {
  if (type == AREA || type == BG || type == BG_AREA)
   type = SELF;
  else if (type == AREA_WOS || type == BG_WOS || type == BG_AREA_WOS)
   return 
# 395 "../../../server-code/src/map/clif.c" 3 4
         1
# 395 "../../../server-code/src/map/clif.c"
             ;
 }

 switch(type) {
  case ALL_CLIENT:
   iter = (mapit->alloc(MAPIT_NORMAL,BL_PC));
   while ((tsd = ((TBL_PC *)BL_UCAST_(mapit->next(iter)))) != 
# 401 "../../../server-code/src/map/clif.c" 3 4
                                                       ((void *)0)
# 401 "../../../server-code/src/map/clif.c"
                                                           ) {
    WFIFOHEAD(tsd->fd, len);
    memcpy(WFIFOP(tsd->fd,0), buf, len);
    WFIFOSET(tsd->fd,len);
   }
   mapit->free(iter);
   break;

  case ALL_SAMEMAP:
   iter = (mapit->alloc(MAPIT_NORMAL,BL_PC));
   while ((tsd = ((TBL_PC *)BL_UCAST_(mapit->next(iter)))) != 
# 411 "../../../server-code/src/map/clif.c" 3 4
                                                       ((void *)0)
# 411 "../../../server-code/src/map/clif.c"
                                                           ) {
    if (bl && bl->m == tsd->bl.m) {
     WFIFOHEAD(tsd->fd, len);
     memcpy(WFIFOP(tsd->fd,0), buf, len);
     WFIFOSET(tsd->fd,len);
    }
   }
   mapit->free(iter);
   break;

  case AREA:
  case AREA_WOSC:
   if (sd && bl->prev == 
# 423 "../../../server-code/src/map/clif.c" 3 4
                        ((void *)0)
# 423 "../../../server-code/src/map/clif.c"
                            )
    clif->send (buf, len, bl, SELF);

  case AREA_WOC:
  case AREA_WOS:
   do { if (((void)(bl), 
# 428 "../../../server-code/src/map/clif.c" 3 4
  0
# 428 "../../../server-code/src/map/clif.c"
  )) return(
# 428 "../../../server-code/src/map/clif.c" 3 4
  1
# 428 "../../../server-code/src/map/clif.c"
  ); } while(0);
   map->foreachinarea(clif->send_sub, bl->m, bl->x-(battle->bc->area_size), bl->y-(battle->bc->area_size), bl->x+(battle->bc->area_size), bl->y+(battle->bc->area_size),
    BL_PC, buf, len, bl, type);
   break;
  case AREA_CHAT_WOC:
   do { if (((void)(bl), 
# 433 "../../../server-code/src/map/clif.c" 3 4
  0
# 433 "../../../server-code/src/map/clif.c"
  )) return(
# 433 "../../../server-code/src/map/clif.c" 3 4
  1
# 433 "../../../server-code/src/map/clif.c"
  ); } while(0);
   map->foreachinarea(clif->send_sub, bl->m, bl->x-((battle->bc->area_size)-5), bl->y-((battle->bc->area_size)-5),
                      bl->x+((battle->bc->area_size)-5), bl->y+((battle->bc->area_size)-5), BL_PC, buf, len, bl, AREA_WOC);
   break;

  case CHAT:
  case CHAT_WOS:
   do { if (((void)(bl), 
# 440 "../../../server-code/src/map/clif.c" 3 4
  0
# 440 "../../../server-code/src/map/clif.c"
  )) return(
# 440 "../../../server-code/src/map/clif.c" 3 4
  1
# 440 "../../../server-code/src/map/clif.c"
  ); } while(0);
   {
    const struct chat_data *cd = 
# 442 "../../../server-code/src/map/clif.c" 3 4
                                ((void *)0)
# 442 "../../../server-code/src/map/clif.c"
                                    ;
    if (sd != 
# 443 "../../../server-code/src/map/clif.c" 3 4
             ((void *)0)
# 443 "../../../server-code/src/map/clif.c"
                 ) {
     cd = map->id2cd(sd->chatID);
    } else {
     cd = ( ((bl) == (const struct block_list *)
# 446 "../../../server-code/src/map/clif.c" 3 4
         ((void *)0) 
# 446 "../../../server-code/src/map/clif.c"
         || (bl)->type != (BL_CHAT)) ? (const TBL_CHAT *)
# 446 "../../../server-code/src/map/clif.c" 3 4
         ((void *)0) 
# 446 "../../../server-code/src/map/clif.c"
         : (const TBL_CHAT *)(bl) );
    }
    if (cd == 
# 448 "../../../server-code/src/map/clif.c" 3 4
             ((void *)0)
# 448 "../../../server-code/src/map/clif.c"
                 )
     break;
    for(i = 0; i < cd->users; i++) {
     if (type == CHAT_WOS && cd->usersd[i] == sd)
      continue;
     if ((fd=cd->usersd[i]->fd) >0 && sockt->session[fd]) {
      WFIFOHEAD(fd,len);
      memcpy(WFIFOP(fd,0), buf, len);
      WFIFOSET(fd,len);
     }
    }
   }
   break;

  case PARTY_AREA:
  case PARTY_AREA_WOS:
   do { if (((void)(bl), 
# 464 "../../../server-code/src/map/clif.c" 3 4
  0
# 464 "../../../server-code/src/map/clif.c"
  )) return(
# 464 "../../../server-code/src/map/clif.c" 3 4
  1
# 464 "../../../server-code/src/map/clif.c"
  ); } while(0);
   x0 = bl->x - (battle->bc->area_size);
   y0 = bl->y - (battle->bc->area_size);
   x1 = bl->x + (battle->bc->area_size);
   y1 = bl->y + (battle->bc->area_size);

  case PARTY:
  case PARTY_WOS:
  case PARTY_SAMEMAP:
  case PARTY_SAMEMAP_WOS:
   if (sd && sd->status.party_id)
    p = party->search(sd->status.party_id);

   if (p) {
    for(i=0;i<12;i++){
     if( (sd = p->data[i].sd) == 
# 479 "../../../server-code/src/map/clif.c" 3 4
                                ((void *)0) 
# 479 "../../../server-code/src/map/clif.c"
                                     )
      continue;

     if( !(fd=sd->fd) )
      continue;

     if( sd->bl.id == bl->id && (type == PARTY_WOS || type == PARTY_SAMEMAP_WOS || type == PARTY_AREA_WOS) )
      continue;

     if( type != PARTY && type != PARTY_WOS && bl->m != sd->bl.m )
      continue;

     if( (type == PARTY_AREA || type == PARTY_AREA_WOS) && (sd->bl.x < x0 || sd->bl.y < y0 || sd->bl.x > x1 || sd->bl.y > y1) )
      continue;

     WFIFOHEAD(fd,len);
     memcpy(WFIFOP(fd,0), buf, len);
     WFIFOSET(fd,len);
    }
    if (!map->enable_spy)
     break;

    iter = (mapit->alloc(MAPIT_NORMAL,BL_PC));
    while ((tsd = ((TBL_PC *)BL_UCAST_(mapit->next(iter)))) != 
# 502 "../../../server-code/src/map/clif.c" 3 4
                                                        ((void *)0)
# 502 "../../../server-code/src/map/clif.c"
                                                            ) {
     if( tsd->partyspy == p->party.party_id ) {
      WFIFOHEAD(tsd->fd, len);
      memcpy(WFIFOP(tsd->fd,0), buf, len);
      WFIFOSET(tsd->fd,len);
     }
    }
    mapit->free(iter);
   }
   break;

  case DUEL:
  case DUEL_WOS:
   if (!sd || !sd->duel_group) break;

   iter = (mapit->alloc(MAPIT_NORMAL,BL_PC));
   while ((tsd = ((TBL_PC *)BL_UCAST_(mapit->next(iter)))) != 
# 518 "../../../server-code/src/map/clif.c" 3 4
                                                       ((void *)0)
# 518 "../../../server-code/src/map/clif.c"
                                                           ) {
    if( type == DUEL_WOS && bl->id == tsd->bl.id )
     continue;
    if( sd->duel_group == tsd->duel_group ) {
     WFIFOHEAD(tsd->fd, len);
     memcpy(WFIFOP(tsd->fd,0), buf, len);
     WFIFOSET(tsd->fd,len);
    }
   }
   mapit->free(iter);
   break;

  case SELF:
   if (sd && (fd=sd->fd) != 0) {
    WFIFOHEAD(fd,len);
    memcpy(WFIFOP(fd,0), buf, len);
    WFIFOSET(fd,len);
   }
   break;


  case GUILD_AREA:
  case GUILD_AREA_WOS:
   do { if (((void)(bl), 
# 541 "../../../server-code/src/map/clif.c" 3 4
  0
# 541 "../../../server-code/src/map/clif.c"
  )) return(
# 541 "../../../server-code/src/map/clif.c" 3 4
  1
# 541 "../../../server-code/src/map/clif.c"
  ); } while(0);
   x0 = bl->x - (battle->bc->area_size);
   y0 = bl->y - (battle->bc->area_size);
   x1 = bl->x + (battle->bc->area_size);
   y1 = bl->y + (battle->bc->area_size);

  case GUILD_SAMEMAP:
  case GUILD_SAMEMAP_WOS:
  case GUILD:
  case GUILD_WOS:
  case GUILD_NOBG:
   if (sd && sd->status.guild_id)
    g = sd->guild;

   if (g) {
    for(i = 0; i < g->max_member; i++) {
     if( (sd = g->member[i].sd) != 
# 557 "../../../server-code/src/map/clif.c" 3 4
                                  ((void *)0) 
# 557 "../../../server-code/src/map/clif.c"
                                       ) {
      if( !(fd=sd->fd) )
       continue;

      if( type == GUILD_NOBG && sd->bg_id )
       continue;

      if( sd->bl.id == bl->id && (type == GUILD_WOS || type == GUILD_SAMEMAP_WOS || type == GUILD_AREA_WOS) )
       continue;

      if( type != GUILD && type != GUILD_NOBG && type != GUILD_WOS && sd->bl.m != bl->m )
       continue;

      if( (type == GUILD_AREA || type == GUILD_AREA_WOS) && (sd->bl.x < x0 || sd->bl.y < y0 || sd->bl.x > x1 || sd->bl.y > y1) )
       continue;
      WFIFOHEAD(fd,len);
      memcpy(WFIFOP(fd,0), buf, len);
      WFIFOSET(fd,len);
     }
    }
    if (!map->enable_spy)
     break;

    iter = (mapit->alloc(MAPIT_NORMAL,BL_PC));
    while ((tsd = ((TBL_PC *)BL_UCAST_(mapit->next(iter)))) != 
# 581 "../../../server-code/src/map/clif.c" 3 4
                                                        ((void *)0)
# 581 "../../../server-code/src/map/clif.c"
                                                            ) {
     if( tsd->guildspy == g->guild_id ) {
      WFIFOHEAD(tsd->fd, len);
      memcpy(WFIFOP(tsd->fd,0), buf, len);
      WFIFOSET(tsd->fd,len);
     }
    }
    mapit->free(iter);
   }
   break;

  case BG_AREA:
  case BG_AREA_WOS:
   do { if (((void)(bl), 
# 594 "../../../server-code/src/map/clif.c" 3 4
  0
# 594 "../../../server-code/src/map/clif.c"
  )) return(
# 594 "../../../server-code/src/map/clif.c" 3 4
  1
# 594 "../../../server-code/src/map/clif.c"
  ); } while(0);
   x0 = bl->x - (battle->bc->area_size);
   y0 = bl->y - (battle->bc->area_size);
   x1 = bl->x + (battle->bc->area_size);
   y1 = bl->y + (battle->bc->area_size);

  case BG_SAMEMAP:
  case BG_SAMEMAP_WOS:
  case BG:
  case BG_WOS:
   if( sd && sd->bg_id && (bgd = bg->team_search(sd->bg_id)) != 
# 604 "../../../server-code/src/map/clif.c" 3 4
                                                               ((void *)0) 
# 604 "../../../server-code/src/map/clif.c"
                                                                    ) {
    for( i = 0; i < 30; i++ ) {
     if( (sd = bgd->members[i].sd) == 
# 606 "../../../server-code/src/map/clif.c" 3 4
                                     ((void *)0) 
# 606 "../../../server-code/src/map/clif.c"
                                          || !(fd = sd->fd) )
      continue;
     if( sd->bl.id == bl->id && (type == BG_WOS || type == BG_SAMEMAP_WOS || type == BG_AREA_WOS) )
      continue;
     if( type != BG && type != BG_WOS && sd->bl.m != bl->m )
      continue;
     if( (type == BG_AREA || type == BG_AREA_WOS) && (sd->bl.x < x0 || sd->bl.y < y0 || sd->bl.x > x1 || sd->bl.y > y1) )
      continue;
     WFIFOHEAD(fd,len);
     memcpy(WFIFOP(fd,0), buf, len);
     WFIFOSET(fd,len);
    }
   }
   break;

  case BG_QUEUE:
   if( sd && sd->bg_queue.arena ) {
    struct script_queue *queue = script->queue(sd->bg_queue.arena->queue_id);

    for (i = 0; i < ( (queue->entries)._len_ ); i++) {
     struct map_session_data *qsd = map->id2sd(( ( (queue->entries)._data_ )[i] ));

     if (qsd != 
# 628 "../../../server-code/src/map/clif.c" 3 4
               ((void *)0)
# 628 "../../../server-code/src/map/clif.c"
                   ) {
      WFIFOHEAD(qsd->fd,len);
      memcpy(WFIFOP(qsd->fd,0), buf, len);
      WFIFOSET(qsd->fd,len);
     }
    }
   }
   break;

  default:
   (showmsg->showError(("clif_send: Unrecognized type %u\n"), type));
   return 
# 639 "../../../server-code/src/map/clif.c" 3 4
         0
# 639 "../../../server-code/src/map/clif.c"
              ;
 }

 return 
# 642 "../../../server-code/src/map/clif.c" 3 4
       1
# 642 "../../../server-code/src/map/clif.c"
           ;
}




void clif_authok(struct map_session_data *sd)
{
 struct packet_authok p;

 do { if (((void)(sd), 
# 652 "../../../server-code/src/map/clif.c" 3 4
0
# 652 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 p.PacketType = authokType;
 p.startTime = (unsigned int)timer->gettick();
 WBUFPOS(&p.PosDir[0],0,sd->bl.x,sd->bl.y,sd->ud.dir);
 p.xSize = p.ySize = 5;

 p.font = sd->status.font;


 p.sex = sd->status.sex;

 clif->send(&p,sizeof(p),&sd->bl,SELF);
}
# 674 "../../../server-code/src/map/clif.c"
void clif_authrefuse(int fd, uint8 error_code)
{
 WFIFOHEAD(fd,packet_db[0x74].len);
 WFIFOW(fd,0) = 0x74;
 WFIFOB(fd,2) = error_code;
 WFIFOSET(fd,packet_db[0x74].len);
}
# 715 "../../../server-code/src/map/clif.c"
void clif_authfail_fd(int fd, int type)
{
 if (!fd || !sockt->session[fd] || sockt->session[fd]->func_parse != clif->parse)
  return;

 WFIFOHEAD(fd, packet_db[0x81].len);
 WFIFOW(fd,0) = 0x81;
 WFIFOB(fd,2) = type;
 WFIFOSET(fd,packet_db[0x81].len);
 sockt->eof(fd);

}






void clif_charselectok(int id, uint8 ok) {
 struct map_session_data* sd;
 int fd;

 if ((sd = map->id2sd(id)) == 
# 737 "../../../server-code/src/map/clif.c" 3 4
                             ((void *)0) 
# 737 "../../../server-code/src/map/clif.c"
                                  || !sd->fd)
  return;

 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0xb3].len);
 WFIFOW(fd,0) = 0xb3;
 WFIFOB(fd,2) = ok;
 WFIFOSET(fd,packet_db[0xb3].len);
}




void clif_dropflooritem(struct flooritem_data* fitem) {
 struct packet_dropflooritem p;
 int view;

 do { if (((void)(fitem), 
# 754 "../../../server-code/src/map/clif.c" 3 4
0
# 754 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if (fitem->item_data.nameid <= 0)
  return;

 p.PacketType = dropflooritemType;
 p.ITAID = fitem->bl.id;
 p.ITID = ((view = (itemdb->search(fitem->item_data.nameid)->view_id)) > 0) ? view : fitem->item_data.nameid;

 p.type = itemtype((itemdb->search(fitem->item_data.nameid)->type));

 p.IsIdentified = fitem->item_data.identify ? 1 : 0;
 p.xPos = fitem->bl.x;
 p.yPos = fitem->bl.y;
 p.subX = fitem->subx;
 p.subY = fitem->suby;
 p.count = fitem->item_data.amount;

 clif->send(&p, sizeof(p), &fitem->bl, AREA);
}



void clif_clearflooritem(struct flooritem_data *fitem, int fd)
{
 unsigned char buf[16];

 do { if (((void)(fitem), 
# 781 "../../../server-code/src/map/clif.c" 3 4
0
# 781 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0xa1;
 WBUFL(buf,2) = fitem->bl.id;

 if (fd == 0) {
  clif->send(buf, packet_db[0xa1].len, &fitem->bl, AREA);
 } else {
  WFIFOHEAD(fd,packet_db[0xa1].len);
  memcpy(WFIFOP(fd,0), buf, packet_db[0xa1].len);
  WFIFOSET(fd,packet_db[0xa1].len);
 }
}
# 803 "../../../server-code/src/map/clif.c"
void clif_clearunit_single(int id, clr_type type, int fd)
{
 WFIFOHEAD(fd, packet_db[0x80].len);
 WFIFOW(fd,0) = 0x80;
 WFIFOL(fd,2) = id;
 WFIFOB(fd,6) = type;
 WFIFOSET(fd, packet_db[0x80].len);
}
# 820 "../../../server-code/src/map/clif.c"
void clif_clearunit_area(struct block_list* bl, clr_type type)
{
 unsigned char buf[8];

 do { if (((void)(bl), 
# 824 "../../../server-code/src/map/clif.c" 3 4
0
# 824 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0x80;
 WBUFL(buf,2) = bl->id;
 WBUFB(buf,6) = type;

 clif->send(buf, packet_db[0x80].len, bl, type == CLR_DEAD ? AREA : AREA_WOS);

 if(disguised(bl)) {
  WBUFL(buf,2) = -bl->id;
  clif->send(buf, packet_db[0x80].len, bl, SELF);
 }
}




int clif_clearunit_delayed_sub(int tid, int64 tick, int id, intptr_t data) {
 struct block_list *bl = (struct block_list *)data;
 clif->clearunit_area(bl, (clr_type) id);
 ((clif->delay_clearunit_ers)->free((clif->delay_clearunit_ers),(bl)));
 return 0;
}

void clif_clearunit_delayed(struct block_list* bl, clr_type type, int64 tick) {
 struct block_list *tbl;

 do { if (((void)(bl), 
# 851 "../../../server-code/src/map/clif.c" 3 4
0
# 851 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 tbl = ((struct block_list *)(clif->delay_clearunit_ers)->alloc(clif->delay_clearunit_ers));
 memcpy (tbl, bl, sizeof (struct block_list));
 timer->add(tick, clif->clearunit_delayed_sub, (int)type, (intptr_t)tbl);
}


void clif_get_weapon_view(struct map_session_data* sd, unsigned short *rhand, unsigned short *lhand)
{
 do { if (((void)(sd), 
# 860 "../../../server-code/src/map/clif.c" 3 4
0
# 860 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(rhand), 
# 861 "../../../server-code/src/map/clif.c" 3 4
0
# 861 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(lhand), 
# 862 "../../../server-code/src/map/clif.c" 3 4
0
# 862 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if(sd->sc.option&OPTION_COSTUME) {
  *rhand = *lhand = 0;
  return;
 }





 if (sd->equip_index[EQI_HAND_R] >= 0 &&
  sd->inventory_data[sd->equip_index[EQI_HAND_R]])
 {
  struct item_data* id = sd->inventory_data[sd->equip_index[EQI_HAND_R]];
  if (id->view_id > 0)
   *rhand = id->view_id;
  else
   *rhand = id->nameid;
 } else
  *rhand = 0;

 if (sd->equip_index[EQI_HAND_L] >= 0 &&
  sd->equip_index[EQI_HAND_L] != sd->equip_index[EQI_HAND_R] &&
  sd->inventory_data[sd->equip_index[EQI_HAND_L]])
 {
  struct item_data* id = sd->inventory_data[sd->equip_index[EQI_HAND_L]];
  if (id->view_id > 0)
   *lhand = id->view_id;
  else
   *lhand = id->nameid;
 } else
  *lhand = 0;

}


static int clif_setlevel_sub(int lv) {
 if( lv < battle_config.max_lv ) {
  ;
 } else if( lv < battle_config.aura_lv ) {
  lv = battle_config.max_lv - 1;
 } else {
  lv = battle_config.max_lv;
 }

 return lv;
}

static int clif_setlevel(struct block_list* bl) {
 int lv = status->get_lv(bl);
 do { if (((void)(bl), 
# 912 "../../../server-code/src/map/clif.c" 3 4
0
# 912 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);
 if( battle_config.client_limit_unit_lv&bl->type )
  return clif_setlevel_sub(lv);
 switch( bl->type ) {
  case BL_NPC:
  case BL_PET:

   return 0;
 }
 return lv;
}

void clif_set_unit_idle2(struct block_list* bl, struct map_session_data *tsd, enum send_target target) {
# 972 "../../../server-code/src/map/clif.c"
 return;

}



void clif_set_unit_idle(struct block_list* bl, struct map_session_data *tsd, enum send_target target) {
 struct map_session_data* sd;
 struct status_change* sc = status->get_sc(bl);
 struct view_data* vd = status->get_viewdata(bl);
 struct packet_idle_unit p;
 int g_id = status->get_guild_id(bl);

 do { if (((void)(bl), 
# 985 "../../../server-code/src/map/clif.c" 3 4
0
# 985 "../../../server-code/src/map/clif.c"
)) return; } while(0);
# 994 "../../../server-code/src/map/clif.c"
 sd = ( ((bl) == (struct block_list *)
# 994 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0) 
# 994 "../../../server-code/src/map/clif.c"
     || (bl)->type != (BL_PC)) ? (TBL_PC *)
# 994 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0) 
# 994 "../../../server-code/src/map/clif.c"
     : (TBL_PC *)(bl) );

 p.PacketType = idle_unitType;

 p.PacketLength = sizeof(p);
 p.objecttype = clif_bl_type(bl);


 p.AID = bl->id;
 p.GID = (sd) ? sd->status.char_id : 0;



 p.speed = status->get_speed(bl);
 p.bodyState = (sc) ? sc->opt1 : 0;
 p.healthState = (sc) ? sc->opt2 : 0;
 p.effectState = (sc != 
# 1010 "../../../server-code/src/map/clif.c" 3 4
                       ((void *)0)
# 1010 "../../../server-code/src/map/clif.c"
                           ) ? sc->option : ((bl->type == BL_NPC) ? ((const TBL_NPC *)BL_UCCAST_(bl))->option : 0);
 p.job = vd->class_;
 p.head = vd->hair_style;
 p.weapon = vd->weapon;
 p.accessory = vd->head_bottom;



 p.accessory2 = vd->head_top;
 p.accessory3 = vd->head_mid;
 if( bl->type == BL_NPC && vd->class_ == FLAG_CLASS ) {
  p.accessory = status->get_emblem_id(bl);
  p.accessory2 = GetWord(g_id, 1);
  p.accessory3 = GetWord(g_id, 0);
 }
 p.headpalette = vd->hair_color;
 p.bodypalette = vd->cloth_color;
 p.headDir = (sd)? sd->head_dir : 0;

 p.robe = vd->robe;

 p.GUID = g_id;
 p.GEmblemVer = status->get_emblem_id(bl);
 p.honor = (sd) ? sd->status.manner : 0;
 p.virtue = (sc) ? sc->opt3 : 0;
 p.isPKModeON = (sd && sd->status.karma) ? 1 : 0;
 p.sex = vd->sex;
 WBUFPOS(&p.PosDir[0],0,bl->x,bl->y,unit->getdir(bl));
 p.xSize = p.ySize = (sd) ? 5 : 0;
 p.state = vd->dead_sit;
 p.clevel = clif_setlevel(bl);

 p.font = (sd) ? sd->status.font : 0;


 if (battle_config.show_monster_hp_bar && bl->type == BL_MOB && (status->get_status_data(bl)->hp) < (status->get_status_data(bl)->max_hp)) {
  const struct mob_data *md = ((const TBL_MOB *)BL_UCCAST_(bl));
  p.maxHP = (status->get_status_data(bl)->max_hp);
  p.HP = (status->get_status_data(bl)->hp);
  p.isBoss = (md->spawn != 
# 1049 "../../../server-code/src/map/clif.c" 3 4
                          ((void *)0) 
# 1049 "../../../server-code/src/map/clif.c"
                               && md->spawn->state.boss) ? 1 : 0;
 } else {
  p.maxHP = -1;
  p.HP = -1;
  p.isBoss = 0;
 }






 clif->send(&p,sizeof(p),tsd?&tsd->bl:bl,target);

 if( disguised(bl) ) {

  p.objecttype = pc->db_checkid(status->get_viewdata(bl)->class_) ? 0x0 : 0x5;
  p.GID = -bl->id;



  clif->send(&p,sizeof(p),bl,SELF);
 }

}

void clif_spawn_unit2(struct block_list* bl, enum send_target target) {
# 1117 "../../../server-code/src/map/clif.c"
 return;

}
void clif_spawn_unit(struct block_list* bl, enum send_target target) {
 struct map_session_data* sd;
 struct status_change* sc = status->get_sc(bl);
 struct view_data* vd = status->get_viewdata(bl);
 struct packet_spawn_unit p;
 int g_id = status->get_guild_id(bl);

 do { if (((void)(bl), 
# 1127 "../../../server-code/src/map/clif.c" 3 4
0
# 1127 "../../../server-code/src/map/clif.c"
)) return; } while(0);
# 1136 "../../../server-code/src/map/clif.c"
 sd = ( ((bl) == (struct block_list *)
# 1136 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0) 
# 1136 "../../../server-code/src/map/clif.c"
     || (bl)->type != (BL_PC)) ? (TBL_PC *)
# 1136 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0) 
# 1136 "../../../server-code/src/map/clif.c"
     : (TBL_PC *)(bl) );

 p.PacketType = spawn_unitType;

 p.PacketLength = sizeof(p);
 p.objecttype = clif_bl_type(bl);


 p.AID = bl->id;
 p.GID = (sd) ? sd->status.char_id : 0;



 p.speed = status->get_speed(bl);
 p.bodyState = (sc) ? sc->opt1 : 0;
 p.healthState = (sc) ? sc->opt2 : 0;
 p.effectState = (sc != 
# 1152 "../../../server-code/src/map/clif.c" 3 4
                       ((void *)0)
# 1152 "../../../server-code/src/map/clif.c"
                           ) ? sc->option : ((bl->type == BL_NPC) ? ((const TBL_NPC *)BL_UCCAST_(bl))->option : 0);
 p.job = vd->class_;
 p.head = vd->hair_style;
 p.weapon = vd->weapon;
 p.accessory = vd->head_bottom;



 p.accessory2 = vd->head_top;
 p.accessory3 = vd->head_mid;
 if( bl->type == BL_NPC && vd->class_ == FLAG_CLASS ) {
  p.accessory = status->get_emblem_id(bl);
  p.accessory2 = GetWord(g_id, 1);
  p.accessory3 = GetWord(g_id, 0);
 }
 p.headpalette = vd->hair_color;
 p.bodypalette = vd->cloth_color;
 p.headDir = (sd)? sd->head_dir : 0;

 p.robe = vd->robe;

 p.GUID = g_id;
 p.GEmblemVer = status->get_emblem_id(bl);
 p.honor = (sd) ? sd->status.manner : 0;
 p.virtue = (sc) ? sc->opt3 : 0;
 p.isPKModeON = (sd && sd->status.karma) ? 1 : 0;
 p.sex = vd->sex;
 WBUFPOS(&p.PosDir[0],0,bl->x,bl->y,unit->getdir(bl));
 p.xSize = p.ySize = (sd) ? 5 : 0;
 p.clevel = clif_setlevel(bl);

 p.font = (sd) ? sd->status.font : 0;


 if (battle_config.show_monster_hp_bar && bl->type == BL_MOB && (status->get_status_data(bl)->hp) < (status->get_status_data(bl)->max_hp)) {
  const struct mob_data *md = ((const TBL_MOB *)BL_UCCAST_(bl));
  p.maxHP = (status->get_status_data(bl)->max_hp);
  p.HP = (status->get_status_data(bl)->hp);
  p.isBoss = (md->spawn != 
# 1190 "../../../server-code/src/map/clif.c" 3 4
                          ((void *)0) 
# 1190 "../../../server-code/src/map/clif.c"
                               && md->spawn->state.boss) ? 1 : 0;
 } else {
  p.maxHP = -1;
  p.HP = -1;
  p.isBoss = 0;
 }





 if( disguised(bl) ) {
  do { if (((void)(sd), 
# 1202 "../../../server-code/src/map/clif.c" 3 4
 0
# 1202 "../../../server-code/src/map/clif.c"
 )) return; } while(0);
  if( sd->status.class_ != sd->disguise )
   clif->send(&p,sizeof(p),bl,target);

  p.objecttype = pc->db_checkid(status->get_viewdata(bl)->class_) ? 0x0 : 0x5;
  p.GID = -bl->id;



  clif->send(&p,sizeof(p),bl,SELF);
 } else
  clif->send(&p,sizeof(p),bl,target);

}




void clif_set_unit_walking(struct block_list* bl, struct map_session_data *tsd, struct unit_data* ud, enum send_target target) {
 struct map_session_data* sd;
 struct status_change* sc = status->get_sc(bl);
 struct view_data* vd = status->get_viewdata(bl);
 struct packet_unit_walking p;
 int g_id = status->get_guild_id(bl);

 do { if (((void)(bl), 
# 1227 "../../../server-code/src/map/clif.c" 3 4
0
# 1227 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(ud), 
# 1228 "../../../server-code/src/map/clif.c" 3 4
0
# 1228 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 sd = ( ((bl) == (struct block_list *)
# 1230 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0) 
# 1230 "../../../server-code/src/map/clif.c"
     || (bl)->type != (BL_PC)) ? (TBL_PC *)
# 1230 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0) 
# 1230 "../../../server-code/src/map/clif.c"
     : (TBL_PC *)(bl) );

 p.PacketType = unit_walkingType;

 p.PacketLength = sizeof(p);


 p.objecttype = clif_bl_type(bl);


 p.AID = bl->id;
 p.GID = (tsd) ? tsd->status.char_id : 0;



 p.speed = status->get_speed(bl);
 p.bodyState = (sc) ? sc->opt1 : 0;
 p.healthState = (sc) ? sc->opt2 : 0;
 p.effectState = (sc != 
# 1248 "../../../server-code/src/map/clif.c" 3 4
                       ((void *)0)
# 1248 "../../../server-code/src/map/clif.c"
                           ) ? sc->option : ((bl->type == BL_NPC) ? ((const TBL_NPC *)BL_UCCAST_(bl))->option : 0);
 p.job = vd->class_;
 p.head = vd->hair_style;
 p.weapon = vd->weapon;
 p.accessory = vd->head_bottom;
 p.moveStartTime = (unsigned int)timer->gettick();



 p.accessory2 = vd->head_top;
 p.accessory3 = vd->head_mid;
 p.headpalette = vd->hair_color;
 p.bodypalette = vd->cloth_color;
 p.headDir = (sd)? sd->head_dir : 0;

 p.robe = vd->robe;

 p.GUID = g_id;
 p.GEmblemVer = status->get_emblem_id(bl);
 p.honor = (sd) ? sd->status.manner : 0;
 p.virtue = (sc) ? sc->opt3 : 0;
 p.isPKModeON = (sd && sd->status.karma) ? 1 : 0;
 p.sex = vd->sex;
 WBUFPOS2(&p.MoveData[0],0,bl->x,bl->y,ud->to_x,ud->to_y,8,8);
 p.xSize = p.ySize = (sd) ? 5 : 0;
 p.clevel = clif_setlevel(bl);

 p.font = (sd) ? sd->status.font : 0;


 if (battle_config.show_monster_hp_bar && bl->type == BL_MOB && (status->get_status_data(bl)->hp) < (status->get_status_data(bl)->max_hp)) {
  const struct mob_data *md = ((const TBL_MOB *)BL_UCCAST_(bl));
  p.maxHP = (status->get_status_data(bl)->max_hp);
  p.HP = (status->get_status_data(bl)->hp);
  p.isBoss = (md->spawn != 
# 1282 "../../../server-code/src/map/clif.c" 3 4
                          ((void *)0) 
# 1282 "../../../server-code/src/map/clif.c"
                               && md->spawn->state.boss) ? 1 : 0;
 } else {
  p.maxHP = -1;
  p.HP = -1;
  p.isBoss = 0;
 }






 clif->send(&p,sizeof(p),tsd?&tsd->bl:bl,target);

 if( disguised(bl) ) {

  p.objecttype = pc->db_checkid(status->get_viewdata(bl)->class_) ? 0x0 : 0x5;
  p.GID = -bl->id;



  clif->send(&p,sizeof(p),bl,SELF);
 }
}





void clif_class_change(struct block_list *bl, int class_, int type)
{
 do { if (((void)(bl), 
# 1313 "../../../server-code/src/map/clif.c" 3 4
0
# 1313 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if(!pc->db_checkid(class_))
 {
  unsigned char buf[16];
  WBUFW(buf,0)=0x1b0;
  WBUFL(buf,2)=bl->id;
  WBUFB(buf,6)=type;
  WBUFL(buf,7)=class_;
  clif->send(buf,packet_db[0x1b0].len,bl,AREA);
 }
}




void clif_spiritball_single(int fd, struct map_session_data *sd) {
 do { if (((void)(sd), 
# 1330 "../../../server-code/src/map/clif.c" 3 4
0
# 1330 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 WFIFOHEAD(fd, packet_db[0x1e1].len);
 WFIFOW(fd,0)=0x1e1;
 WFIFOL(fd,2)=sd->bl.id;
 WFIFOW(fd,6)=sd->spiritball;
 WFIFOSET(fd, packet_db[0x1e1].len);
}




void clif_charm_single(int fd, struct map_session_data *sd)
{
 do { if (((void)(sd), 
# 1343 "../../../server-code/src/map/clif.c" 3 4
0
# 1343 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 WFIFOHEAD(fd, packet_db[0x08cf].len);
 WFIFOW(fd,0) = 0x08cf;
 WFIFOL(fd,2) = sd->bl.id;
 WFIFOW(fd,6) = sd->charm_type;
 WFIFOW(fd,8) = sd->charm_count;
 WFIFOSET(fd, packet_db[0x08cf].len);
}





void clif_weather_check(struct map_session_data *sd) {
 int16 m;
 int fd;

 do { if (((void)(sd), 
# 1360 "../../../server-code/src/map/clif.c" 3 4
0
# 1360 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 m = sd->bl.m;
 fd = sd->fd;
 if (map->list[m].flag.snow)
  clif->specialeffect_single(&sd->bl, 162, fd);
 if (map->list[m].flag.clouds)
  clif->specialeffect_single(&sd->bl, 233, fd);
 if (map->list[m].flag.clouds2)
  clif->specialeffect_single(&sd->bl, 516, fd);
 if (map->list[m].flag.fog)
  clif->specialeffect_single(&sd->bl, 515, fd);
 if (map->list[m].flag.fireworks) {
  clif->specialeffect_single(&sd->bl, 297, fd);
  clif->specialeffect_single(&sd->bl, 299, fd);
  clif->specialeffect_single(&sd->bl, 301, fd);
 }
 if (map->list[m].flag.sakura)
  clif->specialeffect_single(&sd->bl, 163, fd);
 if (map->list[m].flag.leaves)
  clif->specialeffect_single(&sd->bl, 333, fd);
}



void clif_weather(int16 m)
{
 struct s_mapiterator* iter;
 struct map_session_data *sd=
# 1387 "../../../server-code/src/map/clif.c" 3 4
                            ((void *)0)
# 1387 "../../../server-code/src/map/clif.c"
                                ;

 iter = (mapit->alloc(MAPIT_NORMAL,BL_PC));
 for (sd = ((TBL_PC *)BL_UCAST_(mapit->first(iter))); mapit->exists(iter); sd = ((TBL_PC *)BL_UCAST_(mapit->next(iter)))) {
  if( sd->bl.m == m )
   clif->weather_check(sd);
 }
 mapit->free(iter);
}




# 1399 "../../../server-code/src/map/clif.c" 3 4
_Bool 
# 1399 "../../../server-code/src/map/clif.c"
    clif_spawn(struct block_list *bl)
{
 struct view_data *vd;

 do { if (((void)(bl), 
# 1403 "../../../server-code/src/map/clif.c" 3 4
0
# 1403 "../../../server-code/src/map/clif.c"
)) return(
# 1403 "../../../server-code/src/map/clif.c" 3 4
0
# 1403 "../../../server-code/src/map/clif.c"
); } while(0);
 vd = status->get_viewdata(bl);
 if( !vd )
  return 
# 1406 "../../../server-code/src/map/clif.c" 3 4
        0
# 1406 "../../../server-code/src/map/clif.c"
             ;

 if (vd->class_ == INVISIBLE_CLASS)
  return 
# 1409 "../../../server-code/src/map/clif.c" 3 4
        1
# 1409 "../../../server-code/src/map/clif.c"
            ;

 if (bl->type == BL_NPC) {
  struct npc_data *nd = ((TBL_NPC *)BL_UCAST_(bl));
  if (nd->chat_id == 0 && (nd->option&OPTION_INVISIBLE))
   return 
# 1414 "../../../server-code/src/map/clif.c" 3 4
         1
# 1414 "../../../server-code/src/map/clif.c"
             ;
 }

 clif->spawn_unit(bl,AREA_WOS);

 if (vd->cloth_color)
  clif->refreshlook(bl,bl->id,LOOK_CLOTHES_COLOR,vd->cloth_color,AREA_WOS);
 if (vd->body_style)
  clif->refreshlook(bl,bl->id,LOOK_BODY2,vd->body_style,AREA_WOS);

 switch (bl->type) {
  case BL_PC:
  {
   struct map_session_data *sd = ((TBL_PC *)BL_UCAST_(bl));
   int i;
   if (sd->spiritball > 0)
    clif->spiritball(&sd->bl);
   if (sd->state.size == SZ_BIG)
    clif->specialeffect(bl,423,AREA);
   else if (sd->state.size == SZ_MEDIUM)
    clif->specialeffect(bl,421,AREA);
   if (sd->bg_id != 0 && map->list[sd->bl.m].flag.battleground)
    clif->sendbgemblem_area(sd);
   for (i = 0; i < sd->sc_display_count; i++) {
    clif->sc_load(&sd->bl, sd->bl.id,AREA,status->dbs->IconChangeTable[sd->sc_display[i]->type],sd->sc_display[i]->val1,sd->sc_display[i]->val2,sd->sc_display[i]->val3);
   }
   if (sd->charm_type != CHARM_TYPE_NONE && sd->charm_count > 0)
    clif->spiritcharm(sd);
   if (sd->status.robe)
    clif->refreshlook(bl,bl->id,LOOK_ROBE,sd->status.robe,AREA);
  }
   break;
  case BL_MOB:
  {
   struct mob_data *md = ((TBL_MOB *)BL_UCAST_(bl));
   if (md->special_state.size==SZ_BIG)
    clif->specialeffect(&md->bl,423,AREA);
   else if (md->special_state.size==SZ_MEDIUM)
    clif->specialeffect(&md->bl,421,AREA);
  }
   break;
  case BL_NPC:
  {
   struct npc_data *nd = ((TBL_NPC *)BL_UCAST_(bl));
   if (nd->size == SZ_BIG)
    clif->specialeffect(&nd->bl,423,AREA);
   else if (nd->size == SZ_MEDIUM)
    clif->specialeffect(&nd->bl,421,AREA);
  }
   break;
  case BL_PET:
   if (vd->head_bottom)
    clif->send_petdata(
# 1466 "../../../server-code/src/map/clif.c" 3 4
                      ((void *)0)
# 1466 "../../../server-code/src/map/clif.c"
                          , ((TBL_PET *)BL_UCAST_(bl)), 3, vd->head_bottom);
   break;
 }
 return 
# 1469 "../../../server-code/src/map/clif.c" 3 4
       1
# 1469 "../../../server-code/src/map/clif.c"
           ;
}



void clif_hominfo(struct map_session_data *sd, struct homun_data *hd, int flag) {
 struct status_data *hstatus;
 unsigned char buf[128];
 enum homun_type htype;

 do { if (((void)(sd), 
# 1479 "../../../server-code/src/map/clif.c" 3 4
0
# 1479 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(hd), 
# 1480 "../../../server-code/src/map/clif.c" 3 4
0
# 1480 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 hstatus = &hd->battle_status;
 htype = homun->class2type(hd->homunculus.class_);

 memset(buf,0,packet_db[0x22e].len);
 WBUFW(buf,0)=0x22e;
 memcpy(WBUFP(buf,2),hd->homunculus.name,(23 + 1));

 WBUFB(buf,26)=(battle_config.hom_rename && hd->homunculus.rename_flag ? 0x1 : 0x0) | (hd->homunculus.vaporize == HOM_ST_REST ? 0x2 : 0) | (hd->homunculus.hp > 0 ? 0x4 : 0);
 WBUFW(buf,27)=hd->homunculus.level;
 WBUFW(buf,29)=hd->homunculus.hunger;
 WBUFW(buf,31)=(unsigned short) (hd->homunculus.intimacy / 100) ;
 WBUFW(buf,33)=0;

 WBUFW(buf,35) = (((hstatus->rhw.atk2) >= (
# 1495 "../../../server-code/src/map/clif.c" 3 4
                 (32767)
# 1495 "../../../server-code/src/map/clif.c"
                 )) ? (
# 1495 "../../../server-code/src/map/clif.c" 3 4
                 (32767)
# 1495 "../../../server-code/src/map/clif.c"
                 ) : ((hstatus->rhw.atk2) <= (0)) ? (0) : (hstatus->rhw.atk2));



 WBUFW(buf,37)=(((hstatus->matk_max) >= (
# 1499 "../../../server-code/src/map/clif.c" 3 4
              (32767)
# 1499 "../../../server-code/src/map/clif.c"
              )) ? (
# 1499 "../../../server-code/src/map/clif.c" 3 4
              (32767)
# 1499 "../../../server-code/src/map/clif.c"
              ) : ((hstatus->matk_max) <= (0)) ? (0) : (hstatus->matk_max));
 WBUFW(buf,39)=hstatus->hit;
 if (battle_config.hom_setting&0x10)
  WBUFW(buf,41)=hstatus->luk/3 + 1;
 else
  WBUFW(buf,41)=hstatus->cri/10;

 WBUFW(buf,43) = hstatus->def + hstatus->def2;
 WBUFW(buf,45) = hstatus->mdef + hstatus->mdef2;




 WBUFW(buf,47)=hstatus->flee;
 WBUFW(buf,49)=(flag)?0:hstatus->amotion;
 if (hstatus->max_hp > 
# 1514 "../../../server-code/src/map/clif.c" 3 4
                      (32767)
# 1514 "../../../server-code/src/map/clif.c"
                               ) {
  WBUFW(buf,51) = hstatus->hp/(hstatus->max_hp/100);
  WBUFW(buf,53) = 100;
 } else {
  WBUFW(buf,51)=hstatus->hp;
  WBUFW(buf,53)=hstatus->max_hp;
 }
 if (hstatus->max_sp > 
# 1521 "../../../server-code/src/map/clif.c" 3 4
                      (32767)
# 1521 "../../../server-code/src/map/clif.c"
                               ) {
  WBUFW(buf,55) = hstatus->sp/(hstatus->max_sp/100);
  WBUFW(buf,57) = 100;
 } else {
  WBUFW(buf,55)=hstatus->sp;
  WBUFW(buf,57)=hstatus->max_sp;
 }
 WBUFL(buf,59)=hd->homunculus.exp;
 WBUFL(buf,63)=hd->exp_next;
 switch( htype ) {
  case HT_REG:
  case HT_EVO:
   if( hd->homunculus.level >= battle_config.hom_max_level )
    WBUFL(buf,63)=0;
   break;
  case HT_S:
   if( hd->homunculus.level >= battle_config.hom_S_max_level )
    WBUFL(buf,63)=0;
   break;
 }
 WBUFW(buf,67)=hd->homunculus.skillpts;
 WBUFW(buf,69)=(status->get_status_data(&hd->bl)->rhw.range);
 clif->send(buf,packet_db[0x22e].len,&sd->bl,SELF);
}
# 1556 "../../../server-code/src/map/clif.c"
void clif_send_homdata(struct map_session_data *sd, int state, int param)
{
 int fd;

 do { if (((void)(sd), 
# 1560 "../../../server-code/src/map/clif.c" 3 4
0
# 1560 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(sd->hd), 
# 1561 "../../../server-code/src/map/clif.c" 3 4
0
# 1561 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 if ( (state == SP_INTIMATE) && (param >= 910) && (sd->hd->homunculus.class_ == sd->hd->homunculusDB->evo_class) )
  homun->calc_skilltree(sd->hd, 0);

 WFIFOHEAD(fd, packet_db[0x230].len);
 WFIFOW(fd,0)=0x230;
 WFIFOB(fd,2)=0;
 WFIFOB(fd,3)=state;
 WFIFOL(fd,4)=sd->hd->bl.id;
 WFIFOL(fd,8)=param;
 WFIFOSET(fd,packet_db[0x230].len);
}


void clif_homskillinfoblock(struct map_session_data *sd) {
 struct homun_data *hd;
 int fd;
 int i,j;
 int len=4;
 do { if (((void)(sd), 
# 1582 "../../../server-code/src/map/clif.c" 3 4
0
# 1582 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 hd = sd->hd;

 if ( !hd )
  return;

 WFIFOHEAD(fd, 4+37*43);
 WFIFOW(fd,0)=0x235;

 for ( i = 0; i < 43; i++ ) {
  int id = hd->homunculus.hskill[i].id;
  if ( id != 0 ) {
   j = id - 8001;
   WFIFOW(fd,len) = id;
   WFIFOW(fd,len + 2) = skill->get_inf(id);
   WFIFOW(fd,len + 4) = 0;
   WFIFOW(fd,len + 6) = hd->homunculus.hskill[j].lv;
   if ( hd->homunculus.hskill[j].lv ) {
    WFIFOW(fd,len + 8) = skill->get_sp(id, hd->homunculus.hskill[j].lv);
    WFIFOW(fd,len + 10) = skill->get_range2(&sd->hd->bl, id, hd->homunculus.hskill[j].lv);
   } else {
    WFIFOW(fd,len + 8) = 0;
    WFIFOW(fd,len + 10) = 0;
   }
   (strlib->safestrncpy_((WFIFOP(fd, len + 12)),(skill->get_name(id)),((23 + 1))));
   WFIFOB(fd, len + 36) = (hd->homunculus.hskill[j].lv < homun->skill_tree_get_max(id, hd->homunculus.class_)) ? 1 : 0;
   len += 37;
  }
 }
 WFIFOW(fd,2)=len;
 WFIFOSET(fd,len);

 return;
}

void clif_homskillup(struct map_session_data *sd, uint16 skill_id) {
 struct homun_data *hd;
 int fd, idx;
 do { if (((void)(sd), 
# 1622 "../../../server-code/src/map/clif.c" 3 4
0
# 1622 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(sd->hd), 
# 1623 "../../../server-code/src/map/clif.c" 3 4
0
# 1623 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 idx = skill_id - 8001;

 fd=sd->fd;
 hd=sd->hd;

 WFIFOHEAD(fd, packet_db[0x239].len);
 WFIFOW(fd,0) = 0x239;
 WFIFOW(fd,2) = skill_id;
 WFIFOW(fd,4) = hd->homunculus.hskill[idx].lv;
 WFIFOW(fd,6) = skill->get_sp(skill_id,hd->homunculus.hskill[idx].lv);
 WFIFOW(fd,8) = skill->get_range2(&hd->bl, skill_id,hd->homunculus.hskill[idx].lv);
 WFIFOB(fd,10) = (hd->homunculus.hskill[idx].lv < skill->get_max(hd->homunculus.hskill[idx].id)) ? 1 : 0;
 WFIFOSET(fd,packet_db[0x239].len);
}

void clif_hom_food(struct map_session_data *sd,int foodid,int fail)
{
 int fd;
 do { if (((void)(sd), 
# 1642 "../../../server-code/src/map/clif.c" 3 4
0
# 1642 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x22f].len);
 WFIFOW(fd,0)=0x22f;
 WFIFOB(fd,2)=fail;
 WFIFOW(fd,3)=foodid;
 WFIFOSET(fd,packet_db[0x22f].len);

 return;
}



void clif_walkok(struct map_session_data *sd)
{
 int fd;

 do { if (((void)(sd), 
# 1660 "../../../server-code/src/map/clif.c" 3 4
0
# 1660 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd, packet_db[0x87].len);
 WFIFOW(fd,0)=0x87;
 WFIFOL(fd,2)=(unsigned int)timer->gettick();
 WFIFOPOS2(fd,6,sd->bl.x,sd->bl.y,sd->ud.to_x,sd->ud.to_y,8,8);
 WFIFOSET(fd,packet_db[0x87].len);
}

void clif_move2(struct block_list *bl, struct view_data *vd, struct unit_data *ud) {

 struct status_change *sc = 
# 1671 "../../../server-code/src/map/clif.c" 3 4
                           ((void *)0)
# 1671 "../../../server-code/src/map/clif.c"
                               ;


 do { if (((void)(bl), 
# 1674 "../../../server-code/src/map/clif.c" 3 4
0
# 1674 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(vd), 
# 1675 "../../../server-code/src/map/clif.c" 3 4
0
# 1675 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(ud), 
# 1676 "../../../server-code/src/map/clif.c" 3 4
0
# 1676 "../../../server-code/src/map/clif.c"
)) return; } while(0);


 if( (sc = status->get_sc(bl)) && sc->option&(OPTION_HIDE|OPTION_CLOAK|OPTION_INVISIBLE|OPTION_CHASEWALK) )
  clif->ally_only = 
# 1680 "../../../server-code/src/map/clif.c" 3 4
                   1
# 1680 "../../../server-code/src/map/clif.c"
                       ;


 clif->set_unit_walking(bl,
# 1683 "../../../server-code/src/map/clif.c" 3 4
                          ((void *)0)
# 1683 "../../../server-code/src/map/clif.c"
                              ,ud,AREA_WOS);

 if(vd->cloth_color)
  clif->refreshlook(bl,bl->id,LOOK_CLOTHES_COLOR,vd->cloth_color,AREA_WOS);
 if (vd->body_style)
  clif->refreshlook(bl,bl->id,LOOK_BODY2,vd->body_style,AREA_WOS);

 switch(bl->type) {
  case BL_PC:
  {
   struct map_session_data *sd = ((TBL_PC *)BL_UCAST_(bl));

   if(sd->state.size==SZ_BIG)
    clif->specialeffect(&sd->bl,423,AREA);
   else if(sd->state.size==SZ_MEDIUM)
    clif->specialeffect(&sd->bl,421,AREA);
  }
   break;
  case BL_MOB:
  {
   struct mob_data *md = ((TBL_MOB *)BL_UCAST_(bl));
   if (md->special_state.size == SZ_BIG)
    clif->specialeffect(&md->bl,423,AREA);
   else if (md->special_state.size == SZ_MEDIUM)
    clif->specialeffect(&md->bl,421,AREA);
  }
   break;
  case BL_PET:
   if( vd->head_bottom )
    clif->send_petdata(
# 1712 "../../../server-code/src/map/clif.c" 3 4
                      ((void *)0)
# 1712 "../../../server-code/src/map/clif.c"
                          , ((TBL_PET *)BL_UCAST_(bl)), 3, vd->head_bottom);
   break;
 }

 clif->ally_only = 
# 1716 "../../../server-code/src/map/clif.c" 3 4
                  0
# 1716 "../../../server-code/src/map/clif.c"
                       ;

}




void clif_move(struct unit_data *ud)
{
 unsigned char buf[16];
 struct view_data *vd;
 struct block_list *bl;

 struct status_change *sc = 
# 1729 "../../../server-code/src/map/clif.c" 3 4
                           ((void *)0)
# 1729 "../../../server-code/src/map/clif.c"
                               ;


 do { if (((void)(ud), 
# 1732 "../../../server-code/src/map/clif.c" 3 4
0
# 1732 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 bl = ud->bl;
 do { if (((void)(bl), 
# 1734 "../../../server-code/src/map/clif.c" 3 4
0
# 1734 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 vd = status->get_viewdata(bl);
 if (!vd || vd->class_ == INVISIBLE_CLASS)
  return;

 if (bl->type == BL_NPC) {

  struct npc_data *nd = ((TBL_NPC *)BL_UCAST_(bl));
  if (nd->chat_id == 0 && (nd->option&OPTION_INVISIBLE))
   return;
 }

 if (ud->state.speed_changed) {


  ud->state.speed_changed = 0;
  clif->move2(bl, vd, ud);
  return;
 }

 if( (sc = status->get_sc(bl)) && sc->option&(OPTION_HIDE|OPTION_CLOAK|OPTION_INVISIBLE) )
  clif->ally_only = 
# 1755 "../../../server-code/src/map/clif.c" 3 4
                   1
# 1755 "../../../server-code/src/map/clif.c"
                       ;


 WBUFW(buf,0)=0x86;
 WBUFL(buf,2)=bl->id;
 WBUFPOS2(buf,6,bl->x,bl->y,ud->to_x,ud->to_y,8,8);
 WBUFL(buf,12)=(unsigned int)timer->gettick();

 clif->send(buf, packet_db[0x86].len, bl, AREA_WOS);

 if (disguised(bl)) {
  WBUFL(buf,2)=-bl->id;
  clif->send(buf, packet_db[0x86].len, bl, SELF);
 }

 clif->ally_only = 
# 1770 "../../../server-code/src/map/clif.c" 3 4
                  0
# 1770 "../../../server-code/src/map/clif.c"
                       ;

}




int clif_delayquit(int tid, int64 tick, int id, intptr_t data) {
 struct map_session_data *sd = 
# 1778 "../../../server-code/src/map/clif.c" 3 4
                              ((void *)0)
# 1778 "../../../server-code/src/map/clif.c"
                                  ;


 if ((sd = map->id2sd(id)) != 
# 1781 "../../../server-code/src/map/clif.c" 3 4
                             ((void *)0) 
# 1781 "../../../server-code/src/map/clif.c"
                                  && sd->fd == 0)
  map->quit(sd);
 return 0;
}




void clif_quitsave(int fd, struct map_session_data *sd) {
 do { if (((void)(sd), 
# 1790 "../../../server-code/src/map/clif.c" 3 4
0
# 1790 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if (!battle_config.prevent_logout ||
  ((timer->gettick())-(sd->canlog_tick)) > battle_config.prevent_logout)
  map->quit(sd);
 else if (sd->fd) {


  sockt->session[sd->fd]->session_data = 
# 1797 "../../../server-code/src/map/clif.c" 3 4
                                        ((void *)0)
# 1797 "../../../server-code/src/map/clif.c"
                                            ;
  sd->fd = 0;
  timer->add(timer->gettick() + 10000, clif->delayquit, sd->bl.id, 0);
 }
}



void clif_changemap(struct map_session_data *sd, short m, int x, int y) {
 int fd;
 do { if (((void)(sd), 
# 1807 "../../../server-code/src/map/clif.c" 3 4
0
# 1807 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;

 WFIFOHEAD(fd,packet_db[0x91].len);
 WFIFOW(fd,0) = 0x91;
 mapindex->getmapname_ext(map->list[m].custom_name ? map->list[map->list[m].instance_src_map].name : map->list[m].name, WFIFOP(fd,2));
 WFIFOW(fd,18) = x;
 WFIFOW(fd,20) = y;
 WFIFOSET(fd,packet_db[0x91].len);
}



void clif_changemapserver(struct map_session_data* sd, unsigned short map_index, int x, int y, uint32 ip, uint16 port) {
 int fd;
 do { if (((void)(sd), 
# 1822 "../../../server-code/src/map/clif.c" 3 4
0
# 1822 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;

 WFIFOHEAD(fd,packet_db[0x92].len);
 WFIFOW(fd,0) = 0x92;
 mapindex->getmapname_ext(mapindex->id2name((map_index),"../../../server-code/src/map/clif.c", 1827, __func__), WFIFOP(fd,2));
 WFIFOW(fd,18) = x;
 WFIFOW(fd,20) = y;
 WFIFOL(fd,22) = htonl(ip);
 WFIFOW(fd,26) = sockt->ntows(htons(port));
 WFIFOSET(fd,packet_db[0x92].len);
}

void clif_blown(struct block_list *bl)
{

 do { if (((void)(bl), 
# 1838 "../../../server-code/src/map/clif.c" 3 4
0
# 1838 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 clif->fixpos(bl);
 clif->slide(bl, bl->x, bl->y);
}





void clif_fixpos(struct block_list *bl) {
 unsigned char buf[10];

 do { if (((void)(bl), 
# 1850 "../../../server-code/src/map/clif.c" 3 4
0
# 1850 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0x88;
 WBUFL(buf,2) = bl->id;
 WBUFW(buf,6) = bl->x;
 WBUFW(buf,8) = bl->y;
 clif->send(buf, packet_db[0x88].len, bl, AREA);

 if( disguised(bl) ) {
  WBUFL(buf,2) = -bl->id;
  clif->send(buf, packet_db[0x88].len, bl, SELF);
 }
}



void clif_npcbuysell(struct map_session_data* sd, int id)
{
 int fd;

 do { if (((void)(sd), 
# 1870 "../../../server-code/src/map/clif.c" 3 4
0
# 1870 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd, packet_db[0xc4].len);
 WFIFOW(fd,0)=0xc4;
 WFIFOL(fd,2)=id;
 WFIFOSET(fd,packet_db[0xc4].len);
}



void clif_buylist(struct map_session_data *sd, struct npc_data *nd) {
 struct npc_item_list *shop = 
# 1882 "../../../server-code/src/map/clif.c" 3 4
                             ((void *)0)
# 1882 "../../../server-code/src/map/clif.c"
                                 ;
 unsigned short shop_size = 0;
 int fd,i,c;

 do { if (((void)(sd), 
# 1886 "../../../server-code/src/map/clif.c" 3 4
0
# 1886 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(nd), 
# 1887 "../../../server-code/src/map/clif.c" 3 4
0
# 1887 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if( nd->subtype == SCRIPT ) {
  shop = nd->u.scr.shop->item;
  shop_size = nd->u.scr.shop->items;
 } else {
  shop = nd->u.shop.shop_item;
  shop_size = nd->u.shop.count;
 }

 fd = sd->fd;

 WFIFOHEAD(fd, 4 + shop_size * 11);
 WFIFOW(fd,0) = 0xc6;

 c = 0;
 for( i = 0; i < shop_size; i++ ) {
  if( shop[i].nameid ) {
   struct item_data* id = itemdb->exists(shop[i].nameid);
   int val = shop[i].value;
   if( id == 
# 1907 "../../../server-code/src/map/clif.c" 3 4
            ((void *)0) 
# 1907 "../../../server-code/src/map/clif.c"
                 )
    continue;
   WFIFOL(fd, 4+c*11) = val;
   WFIFOL(fd, 8+c*11) = pc->modifybuyvalue(sd,val);
   WFIFOB(fd,12+c*11) = itemtype(id->type);
   WFIFOW(fd,13+c*11) = ( id->view_id > 0 ) ? id->view_id : id->nameid;
   c++;
  }
 }

 WFIFOW(fd,2) = 4 + c*11;
 WFIFOSET(fd,WFIFOW(fd,2));
}



void clif_selllist(struct map_session_data *sd)
{
 int fd,i,c=0,val;

 do { if (((void)(sd), 
# 1927 "../../../server-code/src/map/clif.c" 3 4
0
# 1927 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd, 100 * 10 + 4);
 WFIFOW(fd,0)=0xc7;
 for( i = 0; i < 100; i++ )
 {
  if( sd->status.inventory[i].nameid > 0 && sd->inventory_data[i] )
  {
   if( !(itemdb->isrestricted((&sd->status.inventory[i]), (( (sd)->group->level )), 0, itemdb->cansell_sub)) )
    continue;

   if( sd->status.inventory[i].expire_time )
    continue;

   if( sd->status.inventory[i].bound && !( ( (((sd))->extra_temp_permissions&(PC_PERM_TRADE_BOUND)) != 0 || (((sd))->group->e_permissions&(PC_PERM_TRADE_BOUND)) != 0 ) ))
    continue;

   val=sd->inventory_data[i]->value_sell;
   if( val < 0 )
    continue;
   WFIFOW(fd,4+c*10)=i+2;
   WFIFOL(fd,6+c*10)=val;
   WFIFOL(fd,10+c*10)=pc->modifysellvalue(sd,val);
   c++;
  }
 }
 WFIFOW(fd,2)=c*10+4;
 WFIFOSET(fd,WFIFOW(fd,2));
}
# 1966 "../../../server-code/src/map/clif.c"
void clif_scriptmes(struct map_session_data *sd, int npcid, const char *mes) {
 int fd = sd->fd;
 size_t slen;

 do { if (((void)(sd), 
# 1970 "../../../server-code/src/map/clif.c" 3 4
0
# 1970 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(mes), 
# 1971 "../../../server-code/src/map/clif.c" 3 4
0
# 1971 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 slen = strlen(mes) + 9;

 sd->state.dialog = 1;

 WFIFOHEAD(fd, slen);
 WFIFOW(fd,0)=0xb4;
 WFIFOW(fd,2)=slen;
 WFIFOL(fd,4)=npcid;
 memcpy(WFIFOP(fd,8), mes, slen-8);
 WFIFOSET(fd,WFIFOW(fd,2));
}
# 1994 "../../../server-code/src/map/clif.c"
void clif_scriptnext(struct map_session_data *sd, int npcid)
{
 int fd;

 do { if (((void)(sd), 
# 1998 "../../../server-code/src/map/clif.c" 3 4
0
# 1998 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd, packet_db[0xb5].len);
 WFIFOW(fd,0)=0xb5;
 WFIFOL(fd,2)=npcid;
 WFIFOSET(fd,packet_db[0xb5].len);
}
# 2022 "../../../server-code/src/map/clif.c"
void clif_scriptclose(struct map_session_data *sd, int npcid)
{
 int fd;

 do { if (((void)(sd), 
# 2026 "../../../server-code/src/map/clif.c" 3 4
0
# 2026 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd, packet_db[0xb6].len);
 WFIFOW(fd,0)=0xb6;
 WFIFOL(fd,2)=npcid;
 WFIFOSET(fd,packet_db[0xb6].len);
}




void clif_sendfakenpc(struct map_session_data *sd, int npcid) {
 unsigned char *buf;
 int fd;

 do { if (((void)(sd), 
# 2042 "../../../server-code/src/map/clif.c" 3 4
0
# 2042 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 sd->state.using_fake_npc = 1;
 WFIFOHEAD(fd, packet_db[0x78].len);
 buf = WFIFOP(fd,0);
 memset(WBUFP(buf,0), 0, packet_db[0x78].len);
 WBUFW(buf,0)=0x78;

 WBUFB(buf,2) = 0;
 buf = WFIFOP(fd,1);

 WBUFL(buf,2)=npcid;
 WBUFW(buf,14)=111;
 WBUFPOS(buf,46,sd->bl.x,sd->bl.y,sd->ud.dir);
 WBUFB(buf,49)=5;
 WBUFB(buf,50)=5;
 WFIFOSET(fd, packet_db[0x78].len);
}
# 2081 "../../../server-code/src/map/clif.c"
void clif_scriptmenu(struct map_session_data* sd, int npcid, const char* mes) {
 int fd;
 size_t slen;
 struct block_list *bl = 
# 2084 "../../../server-code/src/map/clif.c" 3 4
                        ((void *)0)
# 2084 "../../../server-code/src/map/clif.c"
                            ;

 do { if (((void)(sd), 
# 2086 "../../../server-code/src/map/clif.c" 3 4
0
# 2086 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(mes), 
# 2087 "../../../server-code/src/map/clif.c" 3 4
0
# 2087 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 slen = strlen(mes) + 9;
 if (!sd->state.using_fake_npc && (npcid == npc->fake_nd->bl.id || ((bl = map->id2bl(npcid)) != 
# 2090 "../../../server-code/src/map/clif.c" 3 4
                                                                                               ((void *)0) 
# 2090 "../../../server-code/src/map/clif.c"
                                                                                                    && (bl->m!=sd->bl.m ||
      bl->x<sd->bl.x-(battle->bc->area_size)-1 || bl->x>sd->bl.x+(battle->bc->area_size)+1 ||
      bl->y<sd->bl.y-(battle->bc->area_size)-1 || bl->y>sd->bl.y+(battle->bc->area_size)+1))))
  clif->sendfakenpc(sd, npcid);

 WFIFOHEAD(fd, slen);
 WFIFOW(fd,0)=0xb7;
 WFIFOW(fd,2)=slen;
 WFIFOL(fd,4)=npcid;
 memcpy(WFIFOP(fd,8), mes, slen-8);
 WFIFOSET(fd,WFIFOW(fd,2));
}
# 2114 "../../../server-code/src/map/clif.c"
void clif_scriptinput(struct map_session_data *sd, int npcid) {
 int fd;
 struct block_list *bl = 
# 2116 "../../../server-code/src/map/clif.c" 3 4
                        ((void *)0)
# 2116 "../../../server-code/src/map/clif.c"
                            ;

 do { if (((void)(sd), 
# 2118 "../../../server-code/src/map/clif.c" 3 4
0
# 2118 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if (!sd->state.using_fake_npc && (npcid == npc->fake_nd->bl.id || ((bl = map->id2bl(npcid)) != 
# 2120 "../../../server-code/src/map/clif.c" 3 4
                                                                                               ((void *)0) 
# 2120 "../../../server-code/src/map/clif.c"
                                                                                                    && (bl->m!=sd->bl.m ||
      bl->x<sd->bl.x-(battle->bc->area_size)-1 || bl->x>sd->bl.x+(battle->bc->area_size)+1 ||
      bl->y<sd->bl.y-(battle->bc->area_size)-1 || bl->y>sd->bl.y+(battle->bc->area_size)+1))))
  clif->sendfakenpc(sd, npcid);

 fd=sd->fd;
 WFIFOHEAD(fd, packet_db[0x142].len);
 WFIFOW(fd,0)=0x142;
 WFIFOL(fd,2)=npcid;
 WFIFOSET(fd,packet_db[0x142].len);
}
# 2143 "../../../server-code/src/map/clif.c"
void clif_scriptinputstr(struct map_session_data *sd, int npcid) {
 int fd;
 struct block_list *bl = 
# 2145 "../../../server-code/src/map/clif.c" 3 4
                        ((void *)0)
# 2145 "../../../server-code/src/map/clif.c"
                            ;

 do { if (((void)(sd), 
# 2147 "../../../server-code/src/map/clif.c" 3 4
0
# 2147 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if (!sd->state.using_fake_npc && (npcid == npc->fake_nd->bl.id || ((bl = map->id2bl(npcid)) != 
# 2149 "../../../server-code/src/map/clif.c" 3 4
                                                                                               ((void *)0) 
# 2149 "../../../server-code/src/map/clif.c"
                                                                                                    && (bl->m!=sd->bl.m ||
      bl->x<sd->bl.x-(battle->bc->area_size)-1 || bl->x>sd->bl.x+(battle->bc->area_size)+1 ||
      bl->y<sd->bl.y-(battle->bc->area_size)-1 || bl->y>sd->bl.y+(battle->bc->area_size)+1))))
  clif->sendfakenpc(sd, npcid);

 fd=sd->fd;
 WFIFOHEAD(fd, packet_db[0x1d4].len);
 WFIFOW(fd,0)=0x1d4;
 WFIFOL(fd,2)=npcid;
 WFIFOSET(fd,packet_db[0x1d4].len);
}
# 2171 "../../../server-code/src/map/clif.c"
void clif_viewpoint(struct map_session_data *sd, int npc_id, int type, int x, int y, int id, int color)
{
 int fd;

 do { if (((void)(sd), 
# 2175 "../../../server-code/src/map/clif.c" 3 4
0
# 2175 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd, packet_db[0x144].len);
 WFIFOW(fd,0)=0x144;
 WFIFOL(fd,2)=npc_id;
 WFIFOL(fd,6)=type;
 WFIFOL(fd,10)=x;
 WFIFOL(fd,14)=y;
 WFIFOB(fd,18)=id;
 WFIFOL(fd,19)=color;
 WFIFOSET(fd,packet_db[0x144].len);
}
# 2198 "../../../server-code/src/map/clif.c"
void clif_cutin(struct map_session_data* sd, const char* image, int type)
{
 int fd;

 do { if (((void)(sd), 
# 2202 "../../../server-code/src/map/clif.c" 3 4
0
# 2202 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd, packet_db[0x1b3].len);
 WFIFOW(fd,0)=0x1b3;
 strncpy(WFIFOP(fd,2),image,64);
 WFIFOB(fd,66)=type;
 WFIFOSET(fd,packet_db[0x1b3].len);
}




void clif_addcards(unsigned char* buf, struct item* item) {
 int i=0,j;
 do { if (((void)(buf), 
# 2217 "../../../server-code/src/map/clif.c" 3 4
0
# 2217 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if( item == 
# 2218 "../../../server-code/src/map/clif.c" 3 4
            ((void *)0) 
# 2218 "../../../server-code/src/map/clif.c"
                 ) {
  WBUFW(buf,0) = 0;
  WBUFW(buf,2) = 0;
  WBUFW(buf,4) = 0;
  WBUFW(buf,6) = 0;
  return;
 }
 if( item->card[0] == ((short)0xFF00) ) {
  WBUFW(buf,0) = 0;
  WBUFW(buf,2) = 0;
  WBUFW(buf,4) = 0;
  WBUFW(buf,6) = item->card[3];
  return;
 }
 if( item->card[0] == 0x00FF || item->card[0] == 0x00FE ) {
  WBUFW(buf,0) = item->card[0];
  WBUFW(buf,2) = item->card[1];
  WBUFW(buf,4) = item->card[2];
  WBUFW(buf,6) = item->card[3];
  return;
 }

 if( 4 > 4 && (j = (itemdb->search(item->nameid)->slot)) > 4 )
  i = rnd()%(j-3);


 if( item->card[i] > 0 && (j=(itemdb->search(item->card[i])->view_id)) > 0 )
  WBUFW(buf,0) = j;
 else
  WBUFW(buf,0) = item->card[i];

 if( item->card[++i] > 0 && (j=(itemdb->search(item->card[i])->view_id)) > 0 )
  WBUFW(buf,2) = j;
 else
  WBUFW(buf,2) = item->card[i];

 if( item->card[++i] > 0 && (j=(itemdb->search(item->card[i])->view_id)) > 0 )
  WBUFW(buf,4) = j;
 else
  WBUFW(buf,4) = item->card[i];

 if( item->card[++i] > 0 && (j=(itemdb->search(item->card[i])->view_id)) > 0 )
  WBUFW(buf,6) = j;
 else
  WBUFW(buf,6) = item->card[i];
}

void clif_addcards2(unsigned short *cards, struct item* item) {
 int i=0,j;
 do { if (((void)(cards), 
# 2267 "../../../server-code/src/map/clif.c" 3 4
0
# 2267 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if( item == 
# 2268 "../../../server-code/src/map/clif.c" 3 4
            ((void *)0) 
# 2268 "../../../server-code/src/map/clif.c"
                 ) {
  cards[0] = 0;
  cards[1] = 0;
  cards[2] = 0;
  cards[3] = 0;
  return;
 }
 if( item->card[0] == ((short)0xFF00) ) {
  cards[0] = 0;
  cards[1] = 0;
  cards[2] = 0;
  cards[3] = item->card[3];
  return;
 }
 if( item->card[0] == 0x00FF || item->card[0] == 0x00FE ) {
  cards[0] = item->card[0];
  cards[1] = item->card[1];
  cards[2] = item->card[2];
  cards[3] = item->card[3];
  return;
 }

 if( 4 > 4 && (j = (itemdb->search(item->nameid)->slot)) > 4 )
  i = rnd()%(j-3);


 if( item->card[i] > 0 && (j=(itemdb->search(item->card[i])->view_id)) > 0 )
  cards[0] = j;
 else
  cards[0] = item->card[i];

 if( item->card[++i] > 0 && (j=(itemdb->search(item->card[i])->view_id)) > 0 )
  cards[1] = j;
 else
  cards[1] = item->card[i];

 if( item->card[++i] > 0 && (j=(itemdb->search(item->card[i])->view_id)) > 0 )
  cards[2] = j;
 else
  cards[2] = item->card[i];

 if( item->card[++i] > 0 && (j=(itemdb->search(item->card[i])->view_id)) > 0 )
  cards[3] = j;
 else
  cards[3] = item->card[i];
}
# 2324 "../../../server-code/src/map/clif.c"
void clif_add_random_options(unsigned char* buf, struct item* item)
{
 int i;
 do { if (((void)(buf), 
# 2327 "../../../server-code/src/map/clif.c" 3 4
0
# 2327 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 for (i = 0; i < 5; i++){
  WBUFW(buf,i*5+0) = 0;
  WBUFW(buf,i*5+2) = 0;
  WBUFB(buf,i*5+4) = 0;
 }
}







void clif_additem(struct map_session_data *sd, int n, int amount, int fail) {
 struct packet_additem p;
 do { if (((void)(sd), 
# 2343 "../../../server-code/src/map/clif.c" 3 4
0
# 2343 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if (!sockt->session_is_active(sd->fd))
  return;

 if( fail )
  memset(&p, 0, sizeof(p));

 p.PacketType = additemType;
 p.Index = n+2;
 p.count = amount;

 if( !fail ) {



  if( n < 0 || n >= 100 || sd->status.inventory[n].nameid <=0 || sd->inventory_data[n] == 
# 2359 "../../../server-code/src/map/clif.c" 3 4
                                                                                                   ((void *)0) 
# 2359 "../../../server-code/src/map/clif.c"
                                                                                                        )
   return;

  if (sd->inventory_data[n]->view_id > 0)
   p.nameid = sd->inventory_data[n]->view_id;
  else
   p.nameid = sd->status.inventory[n].nameid;

  p.IsIdentified = sd->status.inventory[n].identify ? 1 : 0;
  p.IsDamaged = sd->status.inventory[n].attribute ? 1 : 0;
  p.refiningLevel =sd->status.inventory[n].refine;
  clif->addcards2(&p.slot.card[0], &sd->status.inventory[n]);
  p.location = pc->equippoint(sd,n);
  p.type = itemtype(sd->inventory_data[n]->type);

  p.HireExpireDate = sd->status.inventory[n].expire_time;





  p.bindOnEquipType = sd->status.inventory[n].bound && !itemdb->isstackable2(sd->inventory_data[n]) ? 2 : sd->inventory_data[n]->flag.bindonequip ? 1 : 0;
# 2389 "../../../server-code/src/map/clif.c"
 }
 p.result = (unsigned char)fail;

 clif->send(&p,sizeof(p),&sd->bl,SELF);
}



void clif_dropitem(struct map_session_data *sd,int n,int amount)
{
 int fd;

 do { if (((void)(sd), 
# 2401 "../../../server-code/src/map/clif.c" 3 4
0
# 2401 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd, packet_db[0xaf].len);
 WFIFOW(fd,0)=0xaf;
 WFIFOW(fd,2)=n+2;
 WFIFOW(fd,4)=amount;
 WFIFOSET(fd,packet_db[0xaf].len);
}




void clif_delitem(struct map_session_data *sd,int n,int amount, short reason)
{



 int fd;

 do { if (((void)(sd), 
# 2421 "../../../server-code/src/map/clif.c" 3 4
0
# 2421 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;

 WFIFOHEAD(fd, packet_db[0x7fa].len);
 WFIFOW(fd,0)=0x7fa;
 WFIFOW(fd,2)=reason;
 WFIFOW(fd,4)=n+2;
 WFIFOW(fd,6)=amount;
 WFIFOSET(fd,packet_db[0x7fa].len);

}





void clif_item_sub(unsigned char *buf, int n, struct item *i, struct item_data *id, int equip) {
 if (id->view_id > 0)
  WBUFW(buf,n)=id->view_id;
 else
  WBUFW(buf,n)=i->nameid;
 WBUFB(buf,n+2)=itemtype(id->type);
 WBUFB(buf,n+3)=i->identify;
 if (equip >= 0) {
  WBUFW(buf,n+4)=equip;
  WBUFW(buf,n+6)=i->equip;
  WBUFB(buf,n+8)=i->attribute;
  WBUFB(buf,n+9)=i->refine;
 } else {
  WBUFW(buf,n+4)=i->amount;
  if (equip == -2 && id->equip == EQP_AMMO)
   WBUFW(buf,n+6)=EQP_AMMO;
  else
   WBUFW(buf,n+6)=0;
 }

}

void clif_item_equip(short idx, struct EQUIPITEM_INFO *p, struct item *i, struct item_data *id, int eqp_pos) {



 do { if (((void)(p), 
# 2464 "../../../server-code/src/map/clif.c" 3 4
0
# 2464 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(i), 
# 2465 "../../../server-code/src/map/clif.c" 3 4
0
# 2465 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(id), 
# 2466 "../../../server-code/src/map/clif.c" 3 4
0
# 2466 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 p->index = idx;

 if (id->view_id > 0)
  p->ITID = id->view_id;
 else
  p->ITID = i->nameid;

 p->type = itemtype(id->type);





 p->location = eqp_pos;
 p->WearState = i->equip;



 p->RefiningLevel = i->refine;

 clif->addcards2(&p->slot.card[0], i);


 p->HireExpireDate = i->expire_time;



 p->bindOnEquipType = i->bound ? 2 : id->flag.bindonequip ? 1 : 0;



 p->wItemSpriteNumber = (id->equip&((EQP_HEAD_LOW|EQP_HEAD_MID|EQP_HEAD_TOP)|EQP_GARMENT|(EQP_COSTUME_HEAD_TOP|EQP_COSTUME_HEAD_MID|EQP_COSTUME_HEAD_LOW|EQP_COSTUME_GARMENT))) ? id->look : 0;



 p->Flag.IsIdentified = i->identify ? 1 : 0;
 p->Flag.IsDamaged = i->attribute ? 1 : 0;
 p->Flag.PlaceETCTab = i->favorite ? 1 : 0;
 p->Flag.SpareBits = 0;
# 2516 "../../../server-code/src/map/clif.c"
}

void clif_item_normal(short idx, struct NORMALITEM_INFO *p, struct item *i, struct item_data *id) {
 do { if (((void)(p), 
# 2519 "../../../server-code/src/map/clif.c" 3 4
0
# 2519 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(i), 
# 2520 "../../../server-code/src/map/clif.c" 3 4
0
# 2520 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(id), 
# 2521 "../../../server-code/src/map/clif.c" 3 4
0
# 2521 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 p->index = idx;

 if (id->view_id > 0)
  p->ITID = id->view_id;
 else
  p->ITID = i->nameid;

 p->type = itemtype(id->type);





 p->count = i->amount;
 p->WearState = id->equip;


 clif->addcards2(&p->slot.card[0], i);



 p->HireExpireDate = i->expire_time;



 p->Flag.IsIdentified = i->identify ? 1 : 0;
 p->Flag.PlaceETCTab = i->favorite ? 1 : 0;
 p->Flag.SpareBits = 0;

}

void clif_inventorylist(struct map_session_data *sd) {
 int i, normal = 0, equip = 0;

 do { if (((void)(sd), 
# 2557 "../../../server-code/src/map/clif.c" 3 4
0
# 2557 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 for( i = 0; i < 100; i++ ) {

  if( sd->status.inventory[i].nameid <= 0 || sd->inventory_data[i] == 
# 2560 "../../../server-code/src/map/clif.c" 3 4
                                                                     ((void *)0) 
# 2560 "../../../server-code/src/map/clif.c"
                                                                          )
   continue;
  if( !itemdb->isstackable2(sd->inventory_data[i]) )
   clif->item_equip(i+2,&itemlist_equip.list[equip++],&sd->status.inventory[i],sd->inventory_data[i],pc->equippoint(sd,i));
  else
   clif->item_normal(i+2,&itemlist_normal.list[normal++],&sd->status.inventory[i],sd->inventory_data[i]);
 }

 if( normal ) {
  itemlist_normal.PacketType = inventorylistnormalType;
  itemlist_normal.PacketLength = 4 + (sizeof(struct NORMALITEM_INFO) * normal);

  clif->send(&itemlist_normal, itemlist_normal.PacketLength, &sd->bl, SELF);
 }

 if( sd->equip_index[EQI_AMMO] >= 0 )
  clif->arrowequip(sd,sd->equip_index[EQI_AMMO]);

 if( equip ) {
  itemlist_equip.PacketType = inventorylistequipType;
  itemlist_equip.PacketLength = 4 + (sizeof(struct EQUIPITEM_INFO) * equip);

  clif->send(&itemlist_equip, itemlist_equip.PacketLength, &sd->bl, SELF);
 }
# 2594 "../../../server-code/src/map/clif.c"
}


void clif_equiplist(struct map_session_data *sd) {
 int i, equip = 0;

 do { if (((void)(sd), 
# 2600 "../../../server-code/src/map/clif.c" 3 4
0
# 2600 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 for( i = 0; i < 100; i++ ) {

  if( sd->status.inventory[i].nameid <= 0 || sd->inventory_data[i] == 
# 2603 "../../../server-code/src/map/clif.c" 3 4
                                                                     ((void *)0) 
# 2603 "../../../server-code/src/map/clif.c"
                                                                          )
   continue;
  if( !itemdb->isstackable2(sd->inventory_data[i]) )
   clif->item_equip(i+2,&itemlist_equip.list[equip++],&sd->status.inventory[i],sd->inventory_data[i],pc->equippoint(sd,i));
 }

 if( equip ) {
  itemlist_equip.PacketType = inventorylistequipType;
  itemlist_equip.PacketLength = 4 + (sizeof(struct EQUIPITEM_INFO) * equip);

  clif->send(&itemlist_equip, itemlist_equip.PacketLength, &sd->bl, SELF);
 }
# 2626 "../../../server-code/src/map/clif.c"
}

void clif_storagelist(struct map_session_data* sd, struct item* items, int items_length) {
 int i = 0;
 struct item_data *id;

 do { if (((void)(sd), 
# 2632 "../../../server-code/src/map/clif.c" 3 4
0
# 2632 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(items), 
# 2633 "../../../server-code/src/map/clif.c" 3 4
0
# 2633 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do {
  int normal = 0, equip = 0, k = 0;

  for( ; i < items_length && k < 500; i++, k++ ) {

   if( items[i].nameid <= 0 )
    continue;

   id = itemdb->search(items[i].nameid);

   if( !itemdb->isstackable2(id) )
    clif->item_equip(i+1,&storelist_equip.list[equip++],&items[i],id,id->equip);
   else
    clif->item_normal(i+1,&storelist_normal.list[normal++],&items[i],id);
  }

  if( normal ) {
   storelist_normal.PacketType = storagelistnormalType;
   storelist_normal.PacketLength = ( sizeof( storelist_normal ) - sizeof( storelist_normal.list ) ) + (sizeof(struct NORMALITEM_INFO) * normal);


   (strlib->safestrncpy_((storelist_normal.name),("Storage"),((23 + 1))));


   clif->send(&storelist_normal, storelist_normal.PacketLength, &sd->bl, SELF);
  }

  if( equip ) {
   storelist_equip.PacketType = storagelistequipType;
   storelist_equip.PacketLength = ( sizeof( storelist_equip ) - sizeof( storelist_equip.list ) ) + (sizeof(struct EQUIPITEM_INFO) * equip);


   (strlib->safestrncpy_((storelist_equip.name),("Storage"),((23 + 1))));


   clif->send(&storelist_equip, storelist_equip.PacketLength, &sd->bl, SELF);
  }

 } while ( i < items_length );

}

void clif_cartlist(struct map_session_data *sd) {
 int i, normal = 0, equip = 0;
 struct item_data *id;

 do { if (((void)(sd), 
# 2680 "../../../server-code/src/map/clif.c" 3 4
0
# 2680 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 for( i = 0; i < 100; i++ ) {

  if( sd->status.cart[i].nameid <= 0 )
   continue;

  id = itemdb->search(sd->status.cart[i].nameid);
  if( !itemdb->isstackable2(id) )
   clif->item_equip(i+2,&itemlist_equip.list[equip++],&sd->status.cart[i],id,id->equip);
  else
   clif->item_normal(i+2,&itemlist_normal.list[normal++],&sd->status.cart[i],id);
 }

 if( normal ) {
  itemlist_normal.PacketType = cartlistnormalType;
  itemlist_normal.PacketLength = 4 + (sizeof(struct NORMALITEM_INFO) * normal);

  clif->send(&itemlist_normal, itemlist_normal.PacketLength, &sd->bl, SELF);
 }

 if( equip ) {
  itemlist_equip.PacketType = cartlistequipType;
  itemlist_equip.PacketLength = 4 + (sizeof(struct EQUIPITEM_INFO) * equip);

  clif->send(&itemlist_equip, itemlist_equip.PacketLength, &sd->bl, SELF);
 }
}






void clif_clearcart(int fd)
{
 WFIFOHEAD(fd, packet_db[0x12b].len);
 WFIFOW(fd,0) = 0x12b;
 WFIFOSET(fd, packet_db[0x12b].len);

}



void clif_guild_xy(struct map_session_data *sd)
{
 unsigned char buf[10];

 do { if (((void)(sd), 
# 2727 "../../../server-code/src/map/clif.c" 3 4
0
# 2727 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0)=0x1eb;
 WBUFL(buf,2)=sd->status.account_id;
 WBUFW(buf,6)=sd->bl.x;
 WBUFW(buf,8)=sd->bl.y;
 clif->send(buf,packet_db[0x1eb].len,&sd->bl,GUILD_SAMEMAP_WOS);
}




void clif_guild_xy_single(int fd, struct map_session_data *sd)
{
 if( sd->bg_id )
  return;

 do { if (((void)(sd), 
# 2744 "../../../server-code/src/map/clif.c" 3 4
0
# 2744 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 WFIFOHEAD(fd,packet_db[0x1eb].len);
 WFIFOW(fd,0)=0x1eb;
 WFIFOL(fd,2)=sd->status.account_id;
 WFIFOW(fd,6)=sd->bl.x;
 WFIFOW(fd,8)=sd->bl.y;
 WFIFOSET(fd,packet_db[0x1eb].len);
}


void clif_guild_xy_remove(struct map_session_data *sd)
{
 unsigned char buf[10];

 do { if (((void)(sd), 
# 2758 "../../../server-code/src/map/clif.c" 3 4
0
# 2758 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0)=0x1eb;
 WBUFL(buf,2)=sd->status.account_id;
 WBUFW(buf,6)=-1;
 WBUFW(buf,8)=-1;
 clif->send(buf,packet_db[0x1eb].len,&sd->bl,GUILD_SAMEMAP_WOS);
}




int clif_hpmeter_sub(struct block_list *bl, va_list ap)
{



 const int cmd = 0x80e;

 struct map_session_data *sd = 
# 2777 "../../../server-code/src/map/clif.c" 3 4
                              __builtin_va_arg(
# 2777 "../../../server-code/src/map/clif.c"
                              ap
# 2777 "../../../server-code/src/map/clif.c" 3 4
                              ,
# 2777 "../../../server-code/src/map/clif.c"
                              struct map_session_data *
# 2777 "../../../server-code/src/map/clif.c" 3 4
                              )
# 2777 "../../../server-code/src/map/clif.c"
                                                                   ;
 struct map_session_data *tsd = ( ((bl) == (struct block_list *)
# 2778 "../../../server-code/src/map/clif.c" 3 4
                               ((void *)0) 
# 2778 "../../../server-code/src/map/clif.c"
                               || (bl)->type != (BL_PC)) ? (TBL_PC *)
# 2778 "../../../server-code/src/map/clif.c" 3 4
                               ((void *)0) 
# 2778 "../../../server-code/src/map/clif.c"
                               : (TBL_PC *)(bl) );

 do { if (((void)(sd), 
# 2780 "../../../server-code/src/map/clif.c" 3 4
0
# 2780 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);
 do { if (((void)(tsd), 
# 2781 "../../../server-code/src/map/clif.c" 3 4
0
# 2781 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);

 if( !tsd->fd || tsd == sd )
  return 0;

 if( !( ((tsd)->extra_temp_permissions&(PC_PERM_VIEW_HPMETER)) != 0 || ((tsd)->group->e_permissions&(PC_PERM_VIEW_HPMETER)) != 0 ) )
  return 0;
 WFIFOHEAD(tsd->fd,packet_db[cmd].len);
 WFIFOW(tsd->fd,0) = cmd;
 WFIFOL(tsd->fd,2) = sd->status.account_id;
# 2801 "../../../server-code/src/map/clif.c"
 WFIFOL(tsd->fd,6) = sd->battle_status.hp;
 WFIFOL(tsd->fd,10) = sd->battle_status.max_hp;

 WFIFOSET(tsd->fd,packet_db[cmd].len);
 return 0;
}





int clif_hpmeter(struct map_session_data *sd) {
 do { if (((void)(sd), 
# 2813 "../../../server-code/src/map/clif.c" 3 4
0
# 2813 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);
 map->foreachinarea(clif->hpmeter_sub, sd->bl.m, sd->bl.x-(battle->bc->area_size), sd->bl.y-(battle->bc->area_size), sd->bl.x+(battle->bc->area_size), sd->bl.y+(battle->bc->area_size), BL_PC, sd);
 return 0;
}
# 2826 "../../../server-code/src/map/clif.c"
void clif_updatestatus(struct map_session_data *sd,int type)
{
 int fd,len;

 do { if (((void)(sd), 
# 2830 "../../../server-code/src/map/clif.c" 3 4
0
# 2830 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;

 if (!sockt->session_is_active(fd))
  return;

 WFIFOHEAD(fd, 14);
 WFIFOW(fd,0)=0xb0;
 WFIFOW(fd,2)=type;
 len = packet_db[0xb0].len;
 switch(type){

  case SP_WEIGHT:
   pc->updateweightstatus(sd);
   WFIFOHEAD(fd,14);
   WFIFOW(fd,0)=0xb0;
   WFIFOW(fd,2)=type;
   WFIFOL(fd,4)=sd->weight;
   break;
  case SP_MAXWEIGHT:
   WFIFOL(fd,4)=sd->max_weight;
   break;
  case SP_SPEED:
   WFIFOL(fd,4)=sd->battle_status.speed;
   break;
  case SP_BASELEVEL:
   WFIFOL(fd,4)=sd->status.base_level;
   break;
  case SP_JOBLEVEL:
   WFIFOL(fd,4)=sd->status.job_level;
   break;
  case SP_KARMA:
   WFIFOL(fd,4)=sd->status.karma;
   break;
  case SP_MANNER:
   WFIFOL(fd,4)=sd->status.manner;
   break;
  case SP_STATUSPOINT:
   WFIFOL(fd,4)=sd->status.status_point;
   break;
  case SP_SKILLPOINT:
   WFIFOL(fd,4)=sd->status.skill_point;
   break;
  case SP_HIT:
   WFIFOL(fd,4)=sd->battle_status.hit;
   break;
  case SP_FLEE1:
   WFIFOL(fd,4)=sd->battle_status.flee;
   break;
  case SP_FLEE2:
   WFIFOL(fd,4)=sd->battle_status.flee2/10;
   break;
  case SP_MAXHP:
   WFIFOL(fd,4)=sd->battle_status.max_hp;
   break;
  case SP_MAXSP:
   WFIFOL(fd,4)=sd->battle_status.max_sp;
   break;
  case SP_HP:
   WFIFOL(fd,4)=sd->battle_status.hp;

   if( map->list[sd->bl.m].hpmeter_visible )
    clif->hpmeter(sd);
   if( !battle_config.party_hp_mode && sd->status.party_id )
    clif->party_hp(sd);
   if( sd->bg_id )
    clif->bg_hp(sd);
   break;
  case SP_SP:
   WFIFOL(fd,4)=sd->battle_status.sp;
   break;
  case SP_ASPD:
   WFIFOL(fd,4)=sd->battle_status.amotion;
   break;
  case SP_ATK1:
   WFIFOL(fd,4)=((sd)->battle_status.batk);
   break;
  case SP_DEF1:
   WFIFOL(fd,4)=((sd)->battle_status.def2);
   break;
  case SP_MDEF1:
   WFIFOL(fd,4)=((sd)->battle_status.mdef2);
   break;
  case SP_ATK2:
   WFIFOL(fd,4)=((sd)->battle_status.rhw.atk + (sd)->battle_status.lhw.atk + (sd)->battle_status.rhw.atk2 + (sd)->battle_status.lhw.atk2 + (sd)->battle_status.equip_atk );
   break;
  case SP_DEF2:
   WFIFOL(fd,4)=((sd)->battle_status.def);
   break;
  case SP_MDEF2: {

    int mdef2 = ((sd)->battle_status.mdef);

    WFIFOL(fd,4)=



    mdef2;

   }
   break;
  case SP_CRITICAL:
   WFIFOL(fd,4)=sd->battle_status.cri/10;
   break;
  case SP_MATK1:
   WFIFOL(fd,4)=((sd)->battle_status.rhw.matk+(sd)->battle_status.lhw.matk+(sd)->bonus.ematk);
   break;
  case SP_MATK2:
   WFIFOL(fd,4)=(status->base_matk(&(sd)->bl, status->get_status_data(&(sd)->bl), (sd)->status.base_level));
   break;
  case SP_ZENY:
   WFIFOW(fd,0)=0xb1;
   WFIFOL(fd,4)=sd->status.zeny;
   len = packet_db[0xb1].len;
   break;
  case SP_BASEEXP:
   WFIFOW(fd,0)=0xb1;
   WFIFOL(fd,4)=sd->status.base_exp;
   len = packet_db[0xb1].len;
   break;
  case SP_JOBEXP:
   WFIFOW(fd,0)=0xb1;
   WFIFOL(fd,4)=sd->status.job_exp;
   len = packet_db[0xb1].len;
   break;
  case SP_NEXTBASEEXP:
   WFIFOW(fd,0)=0xb1;
   WFIFOL(fd,4)=pc->nextbaseexp(sd);
   len = packet_db[0xb1].len;
   break;
  case SP_NEXTJOBEXP:
   WFIFOW(fd,0)=0xb1;
   WFIFOL(fd,4)=pc->nextjobexp(sd);
   len = packet_db[0xb1].len;
   break;




  case SP_USTR:
  case SP_UAGI:
  case SP_UVIT:
  case SP_UINT:
  case SP_UDEX:
  case SP_ULUK:
   WFIFOW(fd,0)=0xbe;
   WFIFOB(fd,4)=pc->need_status_point(sd,type-SP_USTR+SP_STR,1);
   len = packet_db[0xbe].len;
   break;




  case SP_ATTACKRANGE:
   WFIFOW(fd,0)=0x13a;
   WFIFOW(fd,2)=sd->battle_status.rhw.range;
   len = packet_db[0x13a].len;
   break;

  case SP_STR:
   WFIFOW(fd,0)=0x141;
   WFIFOL(fd,2)=type;
   WFIFOL(fd,6)=sd->status.str;
   WFIFOL(fd,10)=sd->battle_status.str - sd->status.str;
   len = packet_db[0x141].len;
   break;
  case SP_AGI:
   WFIFOW(fd,0)=0x141;
   WFIFOL(fd,2)=type;
   WFIFOL(fd,6)=sd->status.agi;
   WFIFOL(fd,10)=sd->battle_status.agi - sd->status.agi;
   len = packet_db[0x141].len;
   break;
  case SP_VIT:
   WFIFOW(fd,0)=0x141;
   WFIFOL(fd,2)=type;
   WFIFOL(fd,6)=sd->status.vit;
   WFIFOL(fd,10)=sd->battle_status.vit - sd->status.vit;
   len = packet_db[0x141].len;
   break;
  case SP_INT:
   WFIFOW(fd,0)=0x141;
   WFIFOL(fd,2)=type;
   WFIFOL(fd,6)=sd->status.int_;
   WFIFOL(fd,10)=sd->battle_status.int_ - sd->status.int_;
   len = packet_db[0x141].len;
   break;
  case SP_DEX:
   WFIFOW(fd,0)=0x141;
   WFIFOL(fd,2)=type;
   WFIFOL(fd,6)=sd->status.dex;
   WFIFOL(fd,10)=sd->battle_status.dex - sd->status.dex;
   len = packet_db[0x141].len;
   break;
  case SP_LUK:
   WFIFOW(fd,0)=0x141;
   WFIFOL(fd,2)=type;
   WFIFOL(fd,6)=sd->status.luk;
   WFIFOL(fd,10)=sd->battle_status.luk - sd->status.luk;
   len = packet_db[0x141].len;
   break;

  case SP_CARTINFO:
   WFIFOW(fd,0)=0x121;
   WFIFOW(fd,2)=sd->cart_num;
   WFIFOW(fd,4)=100;
   WFIFOL(fd,6)=sd->cart_weight;
   WFIFOL(fd,10)=sd->cart_weight_max;
   len = packet_db[0x121].len;
   break;

  default:
   (showmsg->showError(("clif->updatestatus : unrecognized type %d\n"),type));
   return;
 }
 WFIFOSET(fd,len);
}



void clif_changestatus(struct map_session_data* sd,int type,int val)
{
 unsigned char buf[12];

 do { if (((void)(sd), 
# 3055 "../../../server-code/src/map/clif.c" 3 4
0
# 3055 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0)=0x1ab;
 WBUFL(buf,2)=sd->bl.id;
 WBUFW(buf,6)=type;

 switch(type)
 {
  case SP_MANNER:
   WBUFL(buf,8)=val;
   break;
  default:
   (showmsg->showError(("clif_changestatus : unrecognized type %d.\n"),type));
   return;
 }

 clif->send(buf,packet_db[0x1ab].len,&sd->bl,AREA_WOS);
}


void clif_changelook(struct block_list *bl,int type,int val)
{
 struct map_session_data* sd;
 struct status_change* sc;
 struct view_data* vd;
 enum send_target target = AREA;
 int val2 = 0;
 do { if (((void)(bl), 
# 3082 "../../../server-code/src/map/clif.c" 3 4
0
# 3082 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 sd = ( ((bl) == (struct block_list *)
# 3084 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0) 
# 3084 "../../../server-code/src/map/clif.c"
     || (bl)->type != (BL_PC)) ? (TBL_PC *)
# 3084 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0) 
# 3084 "../../../server-code/src/map/clif.c"
     : (TBL_PC *)(bl) );
 sc = status->get_sc(bl);
 vd = status->get_viewdata(bl);

 if( vd )
  switch(type) {
   case LOOK_WEAPON:
    if (sd) {
     clif->get_weapon_view(sd, &vd->weapon, &vd->shield);
     val = vd->weapon;
    }
    else
     vd->weapon = val;
   break;
   case LOOK_SHIELD:
    if (sd) {
     clif->get_weapon_view(sd, &vd->weapon, &vd->shield);
     val = vd->shield;
    }
    else
     vd->shield = val;
   break;
   case LOOK_BASE:
    if( !sd ) break;

    if ( val == INVISIBLE_CLASS )
     return;

    if( sd->sc.option&OPTION_COSTUME )
     vd->weapon = vd->shield = 0;

    if( !vd->cloth_color )
     break;

    if (sd->sc.option&OPTION_WEDDING && battle_config.wedding_ignorepalette)
     vd->cloth_color = 0;
    if (sd->sc.option&OPTION_XMAS && battle_config.xmas_ignorepalette)
     vd->cloth_color = 0;
    if (sd->sc.option&OPTION_SUMMER && battle_config.summer_ignorepalette)
     vd->cloth_color = 0;
    if (sd->sc.option&OPTION_HANBOK && battle_config.hanbok_ignorepalette)
     vd->cloth_color = 0;
    if (sd->sc.option&OPTION_OKTOBERFEST )
     vd->cloth_color = 0;
    if (vd->body_style && (
     sd->sc.option&OPTION_WEDDING || sd->sc.option&OPTION_XMAS ||
     sd->sc.option&OPTION_SUMMER || sd->sc.option&OPTION_HANBOK ||
     sd->sc.option&OPTION_OKTOBERFEST))
     vd->body_style = 0;
   break;
   case LOOK_HAIR:
    vd->hair_style = val;
   break;
   case LOOK_HEAD_BOTTOM:
    vd->head_bottom = val;
   break;
   case LOOK_HEAD_TOP:
    vd->head_top = val;
   break;
   case LOOK_HEAD_MID:
    vd->head_mid = val;
   break;
   case LOOK_HAIR_COLOR:
    vd->hair_color = val;
   break;
   case LOOK_CLOTHES_COLOR:
    if( val && sd ) {
     if( sd->sc.option&OPTION_WEDDING && battle_config.wedding_ignorepalette )
      val = 0;
     if( sd->sc.option&OPTION_XMAS && battle_config.xmas_ignorepalette )
      val = 0;
     if( sd->sc.option&OPTION_SUMMER && battle_config.summer_ignorepalette )
      val = 0;
     if( sd->sc.option&OPTION_HANBOK && battle_config.hanbok_ignorepalette )
      val = 0;
     if( sd->sc.option&OPTION_OKTOBERFEST )
      val = 0;
    }
    vd->cloth_color = val;
   break;
   case LOOK_SHOES:

    if (sd) {
     int n;
     if((n = sd->equip_index[2]) >= 0 && sd->inventory_data[n]) {
      if(sd->inventory_data[n]->view_id > 0)
       val = sd->inventory_data[n]->view_id;
      else
       val = sd->status.inventory[n].nameid;
     } else
      val = 0;
    }


   break;
   case LOOK_BODY:
   case LOOK_FLOOR:

   break;
   case LOOK_ROBE:



    vd->robe = val;

   break;
   case LOOK_BODY2:
    if (val && (
     sd->sc.option&OPTION_WEDDING || sd->sc.option&OPTION_XMAS ||
     sd->sc.option&OPTION_SUMMER || sd->sc.option&OPTION_HANBOK ||
     sd->sc.option&OPTION_OKTOBERFEST))
     val = 0;
    vd->body_style = val;
   break;
 }


 if( sc && sc->option&OPTION_INVISIBLE && !disguised(bl) )
  target = SELF;



 if(type == LOOK_WEAPON || type == LOOK_SHIELD) {
  do { if (((void)(vd), 
# 3207 "../../../server-code/src/map/clif.c" 3 4
 0
# 3207 "../../../server-code/src/map/clif.c"
 )) return; } while(0);
  type = LOOK_WEAPON;
  val = vd->weapon;
  val2 = vd->shield;
 }
 if( disguised(bl) ) {
  clif->sendlook(bl, bl->id, type, val, val2, AREA_WOS);
  clif->sendlook(bl, -bl->id, type, val, val2, SELF);
 } else
  clif->sendlook(bl, bl->id, type, val, val2, target);

}


void clif_changetraplook(struct block_list *bl,int val)
{
 clif->sendlook(bl, bl->id, LOOK_BASE, val, 0, AREA);
}



void clif_sendlook(struct block_list *bl, int id, int type, int val, int val2, enum send_target target)
{
 unsigned char buf[32];







 WBUFW(buf,0)=0x1d7;
 WBUFL(buf,2)=id;
 WBUFB(buf,6)=type;
 WBUFW(buf,7)=val;
 WBUFW(buf,9)=val2;
 clif->send(buf,packet_db[0x1d7].len,bl,target);

}


void clif_refreshlook(struct block_list *bl,int id,int type,int val,enum send_target target)
{
 clif->sendlook(bl, id, type, val, 0, target);
}






void clif_initialstatus(struct map_session_data *sd) {
 int fd, mdef2;
 unsigned char *buf;

 do { if (((void)(sd), 
# 3262 "../../../server-code/src/map/clif.c" 3 4
0
# 3262 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0xbd].len);
 buf=WFIFOP(fd,0);

 WBUFW(buf,0)=0xbd;
 WBUFW(buf,2)=(((sd->status.status_point) < (
# 3269 "../../../server-code/src/map/clif.c" 3 4
             (32767)
# 3269 "../../../server-code/src/map/clif.c"
             )) ? (sd->status.status_point) : (
# 3269 "../../../server-code/src/map/clif.c" 3 4
             (32767)
# 3269 "../../../server-code/src/map/clif.c"
             ));
 WBUFB(buf,4)=(((sd->status.str) < (((uint8) 0xFF))) ? (sd->status.str) : (((uint8) 0xFF)));
 WBUFB(buf,5)=pc->need_status_point(sd,SP_STR,1);
 WBUFB(buf,6)=(((sd->status.agi) < (((uint8) 0xFF))) ? (sd->status.agi) : (((uint8) 0xFF)));
 WBUFB(buf,7)=pc->need_status_point(sd,SP_AGI,1);
 WBUFB(buf,8)=(((sd->status.vit) < (((uint8) 0xFF))) ? (sd->status.vit) : (((uint8) 0xFF)));
 WBUFB(buf,9)=pc->need_status_point(sd,SP_VIT,1);
 WBUFB(buf,10)=(((sd->status.int_) < (((uint8) 0xFF))) ? (sd->status.int_) : (((uint8) 0xFF)));
 WBUFB(buf,11)=pc->need_status_point(sd,SP_INT,1);
 WBUFB(buf,12)=(((sd->status.dex) < (((uint8) 0xFF))) ? (sd->status.dex) : (((uint8) 0xFF)));
 WBUFB(buf,13)=pc->need_status_point(sd,SP_DEX,1);
 WBUFB(buf,14)=(((sd->status.luk) < (((uint8) 0xFF))) ? (sd->status.luk) : (((uint8) 0xFF)));
 WBUFB(buf,15)=pc->need_status_point(sd,SP_LUK,1);

 WBUFW(buf,16) = ((sd)->battle_status.batk);
 WBUFW(buf,18) = ((sd)->battle_status.rhw.atk + (sd)->battle_status.lhw.atk + (sd)->battle_status.rhw.atk2 + (sd)->battle_status.lhw.atk2 + (sd)->battle_status.equip_atk );
 WBUFW(buf,20) = ((sd)->battle_status.rhw.matk+(sd)->battle_status.lhw.matk+(sd)->bonus.ematk);
 WBUFW(buf,22) = (status->base_matk(&(sd)->bl, status->get_status_data(&(sd)->bl), (sd)->status.base_level));
 WBUFW(buf,24) = ((sd)->battle_status.def2);
 WBUFW(buf,26) = ((sd)->battle_status.def);
 WBUFW(buf,28) = ((sd)->battle_status.mdef2);
 mdef2 = ((sd)->battle_status.mdef);
 WBUFW(buf,30) =



  mdef2;
 WBUFW(buf,32) = sd->battle_status.hit;
 WBUFW(buf,34) = sd->battle_status.flee;
 WBUFW(buf,36) = sd->battle_status.flee2/10;
 WBUFW(buf,38) = sd->battle_status.cri/10;
 WBUFW(buf,40) = sd->battle_status.amotion;
 WBUFW(buf,42) = 0;

 WFIFOSET(fd,packet_db[0xbd].len);

 clif->updatestatus(sd,SP_STR);
 clif->updatestatus(sd,SP_AGI);
 clif->updatestatus(sd,SP_VIT);
 clif->updatestatus(sd,SP_INT);
 clif->updatestatus(sd,SP_DEX);
 clif->updatestatus(sd,SP_LUK);

 clif->updatestatus(sd,SP_ATTACKRANGE);
 clif->updatestatus(sd,SP_ASPD);
}



void clif_arrowequip(struct map_session_data *sd,int val)
{
 int fd;

 do { if (((void)(sd), 
# 3322 "../../../server-code/src/map/clif.c" 3 4
0
# 3322 "../../../server-code/src/map/clif.c"
)) return; } while(0);


 clif->status_change(&sd->bl, SI_CLIENT_ONLY_EQUIP_ARROW, 1, (-1), 0, 0, 0);

 fd=sd->fd;
 WFIFOHEAD(fd, packet_db[0x013c].len);
 WFIFOW(fd,0)=0x013c;
 WFIFOW(fd,2)=val+2;
 WFIFOSET(fd,packet_db[0x013c].len);
}
# 3343 "../../../server-code/src/map/clif.c"
void clif_arrow_fail(struct map_session_data *sd,int type)
{
 int fd;

 do { if (((void)(sd), 
# 3347 "../../../server-code/src/map/clif.c" 3 4
0
# 3347 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd, packet_db[0x013b].len);
 WFIFOW(fd,0)=0x013b;
 WFIFOW(fd,2)=type;
 WFIFOSET(fd,packet_db[0x013b].len);
}



void clif_arrow_create_list(struct map_session_data *sd)
{
 int i, c;
 int fd;

 do { if (((void)(sd), 
# 3363 "../../../server-code/src/map/clif.c" 3 4
0
# 3363 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 WFIFOHEAD(fd, 140*2+4);
 WFIFOW(fd,0) = 0x1ad;

 for (i = 0, c = 0; i < 140; i++) {
  int j;
  if (skill->dbs->arrow_db[i].nameid > 0
   && (j = pc->search_inventory(sd, skill->dbs->arrow_db[i].nameid)) != (-1)
   && !sd->status.inventory[j].equip && sd->status.inventory[j].identify
  ) {
   if ((j = (itemdb->search(skill->dbs->arrow_db[i].nameid)->view_id)) > 0)
    WFIFOW(fd,c*2+4) = j;
   else
    WFIFOW(fd,c*2+4) = skill->dbs->arrow_db[i].nameid;
   c++;
  }
 }
 WFIFOW(fd,2) = c*2+4;
 WFIFOSET(fd, WFIFOW(fd,2));
 if (c > 0) {
  sd->menuskill_id = AC_MAKINGARROW;
  sd->menuskill_val = c;
 }
}
# 3397 "../../../server-code/src/map/clif.c"
void clif_statusupack(struct map_session_data *sd,int type,int ok,int val)
{
 int fd;

 do { if (((void)(sd), 
# 3401 "../../../server-code/src/map/clif.c" 3 4
0
# 3401 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0xbc].len);
 WFIFOW(fd,0)=0xbc;
 WFIFOW(fd,2)=type;
 WFIFOB(fd,4)=ok;
 WFIFOB(fd,5)=(((val) >= (((uint8) 0xFF))) ? (((uint8) 0xFF)) : ((val) <= (0)) ? (0) : (val));
 WFIFOSET(fd,packet_db[0xbc].len);
}




void clif_equipitemack(struct map_session_data *sd,int n,int pos,enum e_EQUIP_ITEM_ACK result) {
 struct packet_equipitem_ack p;

 do { if (((void)(sd), 
# 3418 "../../../server-code/src/map/clif.c" 3 4
0
# 3418 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 p.PacketType = equipitemackType;
 p.index = n+2;
 p.wearLocation = pos;

 if (result == EIA_SUCCESS && sd->inventory_data[n]->equip&((EQP_HEAD_LOW|EQP_HEAD_MID|EQP_HEAD_TOP)|EQP_GARMENT|(EQP_COSTUME_HEAD_TOP|EQP_COSTUME_HEAD_MID|EQP_COSTUME_HEAD_LOW|EQP_COSTUME_GARMENT)))
  p.wItemSpriteNumber = sd->inventory_data[n]->look;
 else
  p.wItemSpriteNumber = 0;

 p.result = (unsigned char)result;

 clif->send(&p, sizeof(p), &sd->bl, SELF);
}



void clif_unequipitemack(struct map_session_data *sd,int n,int pos,enum e_UNEQUIP_ITEM_ACK result) {
 struct packet_unequipitem_ack p;

 do { if (((void)(sd), 
# 3439 "../../../server-code/src/map/clif.c" 3 4
0
# 3439 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 p.PacketType = unequipitemackType;
 p.index = n+2;
 p.wearLocation = pos;
 p.result = (unsigned char)result;

 clif->send(&p, sizeof(p), &sd->bl, SELF);
}
# 3462 "../../../server-code/src/map/clif.c"
void clif_misceffect(struct block_list* bl,int type)
{
 unsigned char buf[32];

 do { if (((void)(bl), 
# 3466 "../../../server-code/src/map/clif.c" 3 4
0
# 3466 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0x19b;
 WBUFL(buf,2) = bl->id;
 WBUFL(buf,6) = type;

 clif->send(buf,packet_db[0x19b].len,bl,AREA);
}




void clif_changeoption(struct block_list* bl)
{
 unsigned char buf[32];
 struct status_change *sc;
 struct map_session_data* sd;

 do { if (((void)(bl), 
# 3484 "../../../server-code/src/map/clif.c" 3 4
0
# 3484 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if ( !(sc = status->get_sc(bl)) && bl->type != BL_NPC ) return;

 sd = ( ((bl) == (struct block_list *)
# 3488 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0) 
# 3488 "../../../server-code/src/map/clif.c"
     || (bl)->type != (BL_PC)) ? (TBL_PC *)
# 3488 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0) 
# 3488 "../../../server-code/src/map/clif.c"
     : (TBL_PC *)(bl) );


 WBUFW(buf,0) = 0x229;
 WBUFL(buf,2) = bl->id;
 WBUFW(buf,6) = (sc) ? sc->opt1 : 0;
 WBUFW(buf,8) = (sc) ? sc->opt2 : 0;
 WBUFL(buf,10) = (sc != 
# 3495 "../../../server-code/src/map/clif.c" 3 4
                       ((void *)0)
# 3495 "../../../server-code/src/map/clif.c"
                           ) ? sc->option : ((bl->type == BL_NPC) ? ((const TBL_NPC *)BL_UCCAST_(bl))->option : 0);
 WBUFB(buf,14) = (sd)? sd->status.karma : 0;
 if(disguised(bl)) {
  clif->send(buf,packet_db[0x229].len,bl,AREA_WOS);
  WBUFL(buf,2) = -bl->id;
  clif->send(buf,packet_db[0x229].len,bl,SELF);
  WBUFL(buf,2) = bl->id;
  WBUFL(buf,10) = OPTION_INVISIBLE;
  clif->send(buf,packet_db[0x229].len,bl,SELF);
 } else
  clif->send(buf,packet_db[0x229].len,bl,AREA);
# 3523 "../../../server-code/src/map/clif.c"
}



void clif_changeoption2(struct block_list* bl) {
 unsigned char buf[20];
 struct status_change *sc;

 do { if (((void)(bl), 
# 3531 "../../../server-code/src/map/clif.c" 3 4
0
# 3531 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if ( !(sc = status->get_sc(bl)) && bl->type != BL_NPC ) return;

 WBUFW(buf,0) = 0x28a;
 WBUFL(buf,2) = bl->id;
 WBUFL(buf,6) = (sc != 
# 3536 "../../../server-code/src/map/clif.c" 3 4
                      ((void *)0)
# 3536 "../../../server-code/src/map/clif.c"
                          ) ? sc->option : ((bl->type == BL_NPC) ? ((const TBL_NPC *)BL_UCCAST_(bl))->option : 0);
 WBUFL(buf,10) = clif_setlevel(bl);
 WBUFL(buf,14) = (sc) ? sc->opt3 : 0;
 if(disguised(bl)) {
  clif->send(buf,packet_db[0x28a].len,bl,AREA_WOS);
  WBUFL(buf,2) = -bl->id;
  clif->send(buf,packet_db[0x28a].len,bl,SELF);
  WBUFL(buf,2) = bl->id;
  WBUFL(buf,6) = OPTION_INVISIBLE;
  clif->send(buf,packet_db[0x28a].len,bl,SELF);
 } else
  clif->send(buf,packet_db[0x28a].len,bl,AREA);
}




void clif_useitemack(struct map_session_data *sd,int index,int amount,
# 3553 "../../../server-code/src/map/clif.c" 3 4
                                                                     _Bool 
# 3553 "../../../server-code/src/map/clif.c"
                                                                          ok)
{
 do { if (((void)(sd), 
# 3555 "../../../server-code/src/map/clif.c" 3 4
0
# 3555 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if(!ok) {
  int fd=sd->fd;
  WFIFOHEAD(fd,packet_db[0xa8].len);
  WFIFOW(fd,0)=0xa8;
  WFIFOW(fd,2)=index+2;
  WFIFOW(fd,4)=amount;
  WFIFOB(fd,6)=ok;
  WFIFOSET(fd,packet_db[0xa8].len);
 }
 else {
# 3576 "../../../server-code/src/map/clif.c"
  unsigned char buf[32];

  WBUFW(buf,0)=0x1c8;
  WBUFW(buf,2)=index+2;
  if(sd->inventory_data[index] && sd->inventory_data[index]->view_id > 0)
   WBUFW(buf,4)=sd->inventory_data[index]->view_id;
  else
   WBUFW(buf,4)=sd->status.inventory[index].nameid;
  WBUFL(buf,6)=sd->bl.id;
  WBUFW(buf,10)=amount;
  WBUFB(buf,12)=ok;
  clif->send(buf,packet_db[0x1c8].len,&sd->bl,AREA);

 }
}
# 3599 "../../../server-code/src/map/clif.c"
void clif_createchat(struct map_session_data* sd, int flag)
{
 int fd;

 do { if (((void)(sd), 
# 3603 "../../../server-code/src/map/clif.c" 3 4
0
# 3603 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0xd6].len);
 WFIFOW(fd,0) = 0xd6;
 WFIFOB(fd,2) = flag;
 WFIFOSET(fd,packet_db[0xd6].len);
}
# 3619 "../../../server-code/src/map/clif.c"
void clif_dispchat(struct chat_data* cd, int fd)
{
 unsigned char buf[128];
 uint8 type;

 if( cd == 
# 3624 "../../../server-code/src/map/clif.c" 3 4
          ((void *)0) 
# 3624 "../../../server-code/src/map/clif.c"
               || cd->owner == 
# 3624 "../../../server-code/src/map/clif.c" 3 4
                               ((void *)0) 
# 3624 "../../../server-code/src/map/clif.c"
                                    )
  return;

 type = (cd->owner->type == BL_PC ) ? (cd->pub) ? 1 : 0
      : (cd->owner->type == BL_NPC) ? (cd->limit) ? 2 : 3
      : 1;

 WBUFW(buf,0) = 0xd7;
 WBUFW(buf,2) = 17 + strlen(cd->title);
 WBUFL(buf, 4) = cd->owner->id;
 WBUFL(buf, 8) = cd->bl.id;
 WBUFW(buf,12) = cd->limit;
 WBUFW(buf,14) = (cd->owner->type == BL_NPC) ? cd->users+1 : cd->users;
 WBUFB(buf,16) = type;
 memcpy(WBUFP(buf,17), cd->title, strlen(cd->title));

 if( fd ) {
  WFIFOHEAD(fd,WBUFW(buf,2));
  memcpy(WFIFOP(fd,0),buf,WBUFW(buf,2));
  WFIFOSET(fd,WBUFW(buf,2));
 } else {
  clif->send(buf,WBUFW(buf,2),cd->owner,AREA_WOSC);
 }
}
# 3656 "../../../server-code/src/map/clif.c"
void clif_changechatstatus(struct chat_data* cd)
{
 unsigned char buf[128];
 uint8 type;

 if( cd == 
# 3661 "../../../server-code/src/map/clif.c" 3 4
          ((void *)0) 
# 3661 "../../../server-code/src/map/clif.c"
               || cd->usersd[0] == 
# 3661 "../../../server-code/src/map/clif.c" 3 4
                                   ((void *)0) 
# 3661 "../../../server-code/src/map/clif.c"
                                        )
  return;

 type = (cd->owner->type == BL_PC ) ? (cd->pub) ? 1 : 0
      : (cd->owner->type == BL_NPC) ? (cd->limit) ? 2 : 3
      : 1;

 WBUFW(buf,0) = 0xdf;
 WBUFW(buf,2) = 17 + strlen(cd->title);
 WBUFL(buf, 4) = cd->owner->id;
 WBUFL(buf, 8) = cd->bl.id;
 WBUFW(buf,12) = cd->limit;
 WBUFW(buf,14) = (cd->owner->type == BL_NPC) ? cd->users+1 : cd->users;
 WBUFB(buf,16) = type;
 memcpy(WBUFP(buf,17), cd->title, strlen(cd->title));

 clif->send(buf,WBUFW(buf,2),cd->owner,CHAT);
}



void clif_clearchat(struct chat_data *cd,int fd)
{
 unsigned char buf[32];

 do { if (((void)(cd), 
# 3686 "../../../server-code/src/map/clif.c" 3 4
0
# 3686 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0xd8;
 WBUFL(buf,2) = cd->bl.id;
 if( fd ) {
  WFIFOHEAD(fd,packet_db[0xd8].len);
  memcpy(WFIFOP(fd,0),buf,packet_db[0xd8].len);
  WFIFOSET(fd,packet_db[0xd8].len);
 } else {
  clif->send(buf,packet_db[0xd8].len,cd->owner,AREA_WOSC);
 }
}
# 3710 "../../../server-code/src/map/clif.c"
void clif_joinchatfail(struct map_session_data *sd,int flag)
{
 int fd;

 do { if (((void)(sd), 
# 3714 "../../../server-code/src/map/clif.c" 3 4
0
# 3714 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;

 WFIFOHEAD(fd,packet_db[0xda].len);
 WFIFOW(fd,0) = 0xda;
 WFIFOB(fd,2) = flag;
 WFIFOSET(fd,packet_db[0xda].len);
}






void clif_joinchatok(struct map_session_data *sd,struct chat_data* cd)
{
 int fd;
 int i,t;

 do { if (((void)(sd), 
# 3734 "../../../server-code/src/map/clif.c" 3 4
0
# 3734 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(cd), 
# 3735 "../../../server-code/src/map/clif.c" 3 4
0
# 3735 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 if (!sockt->session_is_active(fd))
  return;
 t = (int)(cd->owner->type == BL_NPC);
 WFIFOHEAD(fd, 8 + (28*(cd->users+t)));
 WFIFOW(fd,0) = 0xdb;
 WFIFOW(fd,2) = 8 + (28*(cd->users+t));
 WFIFOL(fd, 4) = cd->bl.id;

 if(cd->owner->type == BL_NPC) {
  const struct npc_data *nd = ((const TBL_NPC *)BL_UCCAST_(cd->owner));
  WFIFOL(fd, 30) = 1;
  WFIFOL(fd, 8) = 0;
  memcpy(WFIFOP(fd, 12), nd->name, (23 + 1));
  for (i = 0; i < cd->users; i++) {
   WFIFOL(fd, 8+(i+1)*28) = 1;
   memcpy(WFIFOP(fd, 8+(i+t)*28+4), cd->usersd[i]->status.name, (23 + 1));
  }
 } else
 for (i = 0; i < cd->users; i++) {
  WFIFOL(fd, 8+i*28) = (i != 0 || cd->owner->type == BL_NPC);
  memcpy(WFIFOP(fd, 8+(i+t)*28+4), cd->usersd[i]->status.name, (23 + 1));
 }
 WFIFOSET(fd, WFIFOW(fd,2));
}



void clif_addchat(struct chat_data* cd,struct map_session_data *sd)
{
 unsigned char buf[32];

 do { if (((void)(sd), 
# 3769 "../../../server-code/src/map/clif.c" 3 4
0
# 3769 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(cd), 
# 3770 "../../../server-code/src/map/clif.c" 3 4
0
# 3770 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0xdc;
 WBUFW(buf,2) = cd->users;
 memcpy(WBUFP(buf, 4),sd->status.name,(23 + 1));
 clif->send(buf,packet_db[0xdc].len,&sd->bl,CHAT_WOS);
}






void clif_changechatowner(struct chat_data* cd, struct map_session_data* sd)
{
 unsigned char buf[64];

 do { if (((void)(sd), 
# 3787 "../../../server-code/src/map/clif.c" 3 4
0
# 3787 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(cd), 
# 3788 "../../../server-code/src/map/clif.c" 3 4
0
# 3788 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0xe1;
 WBUFL(buf, 2) = 1;
 memcpy(WBUFP(buf,6),cd->usersd[0]->status.name,(23 + 1));

 WBUFW(buf,30) = 0xe1;
 WBUFL(buf,32) = 0;
 memcpy(WBUFP(buf,36),sd->status.name,(23 + 1));

 clif->send(buf,packet_db[0xe1].len*2,&sd->bl,CHAT);
}






void clif_leavechat(struct chat_data* cd, struct map_session_data* sd, 
# 3806 "../../../server-code/src/map/clif.c" 3 4
                                                                      _Bool 
# 3806 "../../../server-code/src/map/clif.c"
                                                                           flag)
{
 unsigned char buf[32];

 do { if (((void)(sd), 
# 3810 "../../../server-code/src/map/clif.c" 3 4
0
# 3810 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(cd), 
# 3811 "../../../server-code/src/map/clif.c" 3 4
0
# 3811 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0xdd;
 WBUFW(buf,2) = cd->users-1;
 memcpy(WBUFP(buf,4),sd->status.name,(23 + 1));
 WBUFB(buf,28) = flag;

 clif->send(buf,packet_db[0xdd].len,&sd->bl,CHAT);
}




void clif_traderequest(struct map_session_data *sd, const char *name)
{
 int fd;

 struct map_session_data* tsd = 
# 3828 "../../../server-code/src/map/clif.c" 3 4
                               ((void *)0)
# 3828 "../../../server-code/src/map/clif.c"
                                   ;

 do { if (((void)(sd), 
# 3830 "../../../server-code/src/map/clif.c" 3 4
0
# 3830 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(name), 
# 3831 "../../../server-code/src/map/clif.c" 3 4
0
# 3831 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;






 tsd = map->id2sd(sd->trade_partner);
 if (!tsd)
  return;

 WFIFOHEAD(fd,packet_db[0x1f4].len);
 WFIFOW(fd,0) = 0x1f4;
 (strlib->safestrncpy_((WFIFOP(fd,2)),(name),((23 + 1))));
 WFIFOL(fd,26) = tsd->status.char_id;
 WFIFOW(fd,30) = tsd->status.base_level;
 WFIFOSET(fd,packet_db[0x1f4].len);

}
# 3863 "../../../server-code/src/map/clif.c"
void clif_tradestart(struct map_session_data *sd, uint8 type)
{
 int fd;

 struct map_session_data *tsd = 
# 3867 "../../../server-code/src/map/clif.c" 3 4
                               ((void *)0)
# 3867 "../../../server-code/src/map/clif.c"
                                   ;

 do { if (((void)(sd), 
# 3869 "../../../server-code/src/map/clif.c" 3 4
0
# 3869 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;

 tsd = map->id2sd(sd->trade_partner);
 if (tsd) {
  WFIFOHEAD(fd,packet_db[0x1f5].len);
  WFIFOW(fd,0) = 0x1f5;
  WFIFOB(fd,2) = type;
  WFIFOL(fd,3) = tsd->status.char_id;
  WFIFOW(fd,7) = tsd->status.base_level;
  WFIFOSET(fd,packet_db[0x1f5].len);
  return;
 }

 WFIFOHEAD(fd,packet_db[0xe7].len);
 WFIFOW(fd,0) = 0xe7;
 WFIFOB(fd,2) = type;
 WFIFOSET(fd,packet_db[0xe7].len);
}




void clif_tradeadditem(struct map_session_data* sd, struct map_session_data* tsd, int index, int amount)
{
 int fd;
 unsigned char *buf;
 do { if (((void)(sd), 
# 3897 "../../../server-code/src/map/clif.c" 3 4
0
# 3897 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(tsd), 
# 3898 "../../../server-code/src/map/clif.c" 3 4
0
# 3898 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = tsd->fd;
 buf = WFIFOP(fd,0);
 WFIFOHEAD(fd,packet_db[tradeaddType].len);
 WBUFW(buf,0) = tradeaddType;
 if( index == 0 )
 {




  WBUFW(buf,2) = 0;
  WBUFB(buf,4) = 0;
  WBUFL(buf,5) = amount;
  buf = WBUFP(buf,1);

  WBUFB(buf,8) = 0;
  WBUFB(buf,9) = 0;
  WBUFB(buf,10)= 0;
  WBUFW(buf,11)= 0;
  WBUFW(buf,13)= 0;
  WBUFW(buf,15)= 0;
  WBUFW(buf,17)= 0;



 }
 else
 {
  index -= 2;







  if(sd->inventory_data[index] && sd->inventory_data[index]->view_id > 0)
   WBUFW(buf,2) = sd->inventory_data[index]->view_id;
  else
   WBUFW(buf,2) = sd->status.inventory[index].nameid;
  WBUFB(buf,4) = sd->inventory_data[index]->type;
  WBUFL(buf,5) = amount;
  buf = WBUFP(buf,1);

  WBUFB(buf,8) = sd->status.inventory[index].identify;
  WBUFB(buf,9) = sd->status.inventory[index].attribute;
  WBUFB(buf,10)= sd->status.inventory[index].refine;
  clif->addcards(WBUFP(buf, 11), &sd->status.inventory[index]);



 }
 WFIFOSET(fd,packet_db[tradeaddType].len);
}







void clif_tradeitemok(struct map_session_data* sd, int index, int fail)
{
 int fd;
 do { if (((void)(sd), 
# 3964 "../../../server-code/src/map/clif.c" 3 4
0
# 3964 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0xea].len);
 WFIFOW(fd,0) = 0xea;
 WFIFOW(fd,2) = index;
 WFIFOB(fd,4) = fail;
 WFIFOSET(fd,packet_db[0xea].len);
}






void clif_tradedeal_lock(struct map_session_data* sd, int fail)
{
 int fd;
 do { if (((void)(sd), 
# 3982 "../../../server-code/src/map/clif.c" 3 4
0
# 3982 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0xec].len);
 WFIFOW(fd,0) = 0xec;
 WFIFOB(fd,2) = fail;
 WFIFOSET(fd,packet_db[0xec].len);
}



void clif_tradecancelled(struct map_session_data* sd)
{
 int fd;
 do { if (((void)(sd), 
# 3996 "../../../server-code/src/map/clif.c" 3 4
0
# 3996 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0xee].len);
 WFIFOW(fd,0) = 0xee;
 WFIFOSET(fd,packet_db[0xee].len);
}






void clif_tradecompleted(struct map_session_data* sd, int fail)
{
 int fd;
 do { if (((void)(sd), 
# 4012 "../../../server-code/src/map/clif.c" 3 4
0
# 4012 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0xf0].len);
 WFIFOW(fd,0) = 0xf0;
 WFIFOB(fd,2) = fail;
 WFIFOSET(fd,packet_db[0xf0].len);
}






void clif_tradeundo(struct map_session_data* sd)
{
 int fd;

 do { if (((void)(sd), 
# 4030 "../../../server-code/src/map/clif.c" 3 4
0
# 4030 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0xf1].len);
 WFIFOW(fd,0) = 0xf1;
 WFIFOSET(fd,packet_db[0xf1].len);
}



void clif_updatestorageamount(struct map_session_data* sd, int amount, int max_amount)
{
 int fd;

 do { if (((void)(sd), 
# 4043 "../../../server-code/src/map/clif.c" 3 4
0
# 4043 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0xf2].len);
 WFIFOW(fd,0) = 0xf2;
 WFIFOW(fd,2) = amount;
 WFIFOW(fd,4) = max_amount;
 WFIFOSET(fd,packet_db[0xf2].len);
}




void clif_storageitemadded(struct map_session_data* sd, struct item* i, int index, int amount)
{
 int view,fd;
 int offset = 0;

 do { if (((void)(sd), 
# 4061 "../../../server-code/src/map/clif.c" 3 4
0
# 4061 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(i), 
# 4062 "../../../server-code/src/map/clif.c" 3 4
0
# 4062 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd=sd->fd;
 view = (itemdb->search(i->nameid)->view_id);

 WFIFOHEAD(fd,packet_db[storageaddType].len);
 WFIFOW(fd,0) = storageaddType;
 WFIFOW(fd,2) = index+1;
 WFIFOL(fd, 4) = amount;
 WFIFOW(fd,8) = ( view > 0 ) ? view : i->nameid;

 WFIFOB(fd,10) = itemtype((itemdb->search(i->nameid)->type));
 offset += 1;

 WFIFOB(fd,10+offset) = i->identify;
 WFIFOB(fd,11+offset) = i->attribute;
 WFIFOB(fd,12+offset) = i->refine;
 clif->addcards(WFIFOP(fd,13+offset), i);



 WFIFOSET(fd,packet_db[storageaddType].len);
}



void clif_storageitemremoved(struct map_session_data* sd, int index, int amount)
{
 int fd;

 do { if (((void)(sd), 
# 4091 "../../../server-code/src/map/clif.c" 3 4
0
# 4091 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0xf6].len);
 WFIFOW(fd,0)=0xf6;
 WFIFOW(fd,2)=index+1;
 WFIFOL(fd,4)=amount;
 WFIFOSET(fd,packet_db[0xf6].len);
}



void clif_storageclose(struct map_session_data* sd)
{
 int fd;

 do { if (((void)(sd), 
# 4107 "../../../server-code/src/map/clif.c" 3 4
0
# 4107 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0xf8].len);
 WFIFOW(fd,0) = 0xf8;
 WFIFOSET(fd,packet_db[0xf8].len);
}




void clif_getareachar_pc(struct map_session_data* sd,struct map_session_data* dstsd) {
 struct block_list *d_bl;
 int i;

 do { if (((void)(sd), 
# 4122 "../../../server-code/src/map/clif.c" 3 4
0
# 4122 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(dstsd), 
# 4123 "../../../server-code/src/map/clif.c" 3 4
0
# 4123 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if( dstsd->chatID ) {
  struct chat_data *cd = map->id2cd(dstsd->chatID);
  if (cd != 
# 4126 "../../../server-code/src/map/clif.c" 3 4
           ((void *)0) 
# 4126 "../../../server-code/src/map/clif.c"
                && cd->usersd[0] == dstsd)
   clif->dispchat(cd,sd->fd);
 } else if( dstsd->state.vending )
  clif->showvendingboard(&dstsd->bl,dstsd->message,sd->fd);
 else if( dstsd->state.buyingstore )
  clif->buyingstore_entry_single(sd, dstsd);

 if(dstsd->spiritball > 0)
  clif->spiritball_single(sd->fd, dstsd);
 if (dstsd->charm_type != CHARM_TYPE_NONE && dstsd->charm_count > 0)
  clif->charm_single(sd->fd, dstsd);

 for( i = 0; i < dstsd->sc_display_count; i++ ) {
  clif->sc_load(&sd->bl,dstsd->bl.id,SELF,status->dbs->IconChangeTable[dstsd->sc_display[i]->type],dstsd->sc_display[i]->val1,dstsd->sc_display[i]->val2,dstsd->sc_display[i]->val3);
 }
 if( (sd->status.party_id && dstsd->status.party_id == sd->status.party_id) ||
  (sd->bg_id && sd->bg_id == dstsd->bg_id) ||
  ( ((sd)->extra_temp_permissions&(PC_PERM_VIEW_HPMETER)) != 0 || ((sd)->group->e_permissions&(PC_PERM_VIEW_HPMETER)) != 0 )
 )
  clif->hpmeter_single(sd->fd, dstsd->bl.id, dstsd->battle_status.hp, dstsd->battle_status.max_hp);


 do { for ((i) = (0); (i) < (5); ++(i)) if (sd->devotion[i] == dstsd->bl.id) break; } while(
# 4148 "../../../server-code/src/map/clif.c" 3 4
0
# 4148 "../../../server-code/src/map/clif.c"
);
 if( i < 5 ) clif->devotion(&sd->bl, sd);

 do { for ((i) = (0); (i) < (5); ++(i)) if (dstsd->devotion[i] > 0) break; } while(
# 4151 "../../../server-code/src/map/clif.c" 3 4
0
# 4151 "../../../server-code/src/map/clif.c"
);
 if( i < 5 ) clif->devotion(&dstsd->bl, sd);

 if( dstsd->sc.data[SC_DEVOTION] && (d_bl = map->id2bl(dstsd->sc.data[SC_DEVOTION]->val1)) != 
# 4154 "../../../server-code/src/map/clif.c" 3 4
                                                                                             ((void *)0) 
# 4154 "../../../server-code/src/map/clif.c"
                                                                                                  )
  clif->devotion(d_bl, sd);
}

void clif_getareachar_unit(struct map_session_data* sd,struct block_list *bl) {
 struct unit_data *ud;
 struct view_data *vd;

 do { if (((void)(sd), 
# 4162 "../../../server-code/src/map/clif.c" 3 4
0
# 4162 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(bl), 
# 4163 "../../../server-code/src/map/clif.c" 3 4
0
# 4163 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 vd = status->get_viewdata(bl);
 if (!vd || vd->class_ == INVISIBLE_CLASS)
  return;

 if (bl->type == BL_NPC) {

  struct npc_data *nd = ((TBL_NPC *)BL_UCAST_(bl));
  if (nd->chat_id == 0 && (nd->option&OPTION_INVISIBLE))
   return;
 }

 if ( ( ud = unit->bl2ud(bl) ) && ud->walktimer != (-1) )
  clif->set_unit_walking(bl,sd,ud,SELF);
 else
  clif->set_unit_idle(bl,sd,SELF);

 if (vd->cloth_color)
  clif->refreshlook(&sd->bl,bl->id,LOOK_CLOTHES_COLOR,vd->cloth_color,SELF);
 if (vd->body_style)
  clif->refreshlook(&sd->bl,bl->id,LOOK_BODY2,vd->body_style,SELF);

 switch (bl->type) {
  case BL_PC:
  {
   struct map_session_data *tsd = ((TBL_PC *)BL_UCAST_(bl));
   clif->getareachar_pc(sd, tsd);
   if (tsd->state.size == SZ_BIG)
    clif->specialeffect_single(bl,423,sd->fd);
   else if (tsd->state.size == SZ_MEDIUM)
    clif->specialeffect_single(bl,421,sd->fd);
   if (tsd->bg_id != 0 && map->list[tsd->bl.m].flag.battleground)
    clif->sendbgemblem_single(sd->fd,tsd);
   if (tsd->status.robe)
    clif->refreshlook(&sd->bl,bl->id,LOOK_ROBE,tsd->status.robe,SELF);
  }
   break;
  case BL_MER:
  {
   struct mercenary_data *md = ((TBL_MER *)BL_UCAST_(bl));
   if (md->devotion_flag)
    clif->devotion(bl, sd);
  }
   break;
  case BL_NPC:
  {
   struct npc_data *nd = ((TBL_NPC *)BL_UCAST_(bl));
   if (nd->chat_id != 0)
    clif->dispchat(map->id2cd(nd->chat_id), sd->fd);
   if (nd->size == SZ_BIG)
    clif->specialeffect_single(bl,423,sd->fd);
   else if (nd->size == SZ_MEDIUM)
    clif->specialeffect_single(bl,421,sd->fd);
  }
   break;
  case BL_MOB:
  {
   struct mob_data *md = ((TBL_MOB *)BL_UCAST_(bl));
   if (md->special_state.size == SZ_BIG)
    clif->specialeffect_single(bl,423,sd->fd);
   else if (md->special_state.size == SZ_MEDIUM)
    clif->specialeffect_single(bl,421,sd->fd);
# 4237 "../../../server-code/src/map/clif.c"
  }
   break;
  case BL_PET:
   if (vd->head_bottom)
    clif->send_petdata(
# 4241 "../../../server-code/src/map/clif.c" 3 4
                      ((void *)0)
# 4241 "../../../server-code/src/map/clif.c"
                          , ((TBL_PET *)BL_UCAST_(bl)), 3, vd->head_bottom);
   break;
 }
}



static inline int clif_calc_delay(int type, int div, int damage, int delay)
{
 return ( delay == 0 && damage > 0 ) ? ( div > 1 ? 9 : 4 ) : type;
}




int clif_calc_walkdelay(struct block_list *bl,int delay, int type, int damage, int div_) {
 if (type == 4 || type == 9 || damage <=0)
  return 0;

 do { if (((void)(bl), 
# 4260 "../../../server-code/src/map/clif.c" 3 4
0
# 4260 "../../../server-code/src/map/clif.c"
)) return(delay); } while(0);
 if (bl->type == BL_PC) {
  if (battle_config.pc_walk_delay_rate != 100)
   delay = delay*battle_config.pc_walk_delay_rate/100;
 } else
  if (battle_config.walk_delay_rate != 100)
   delay = delay*battle_config.walk_delay_rate/100;

 if (div_ > 1)
  delay += battle_config.multihit_delay*(div_-1);

 return delay>0?delay:1;
}







int clif_damage(struct block_list* src, struct block_list* dst, int sdelay, int ddelay, int64 in_damage, short div, unsigned char type, int64 in_damage2) {
 struct packet_damage p;
 struct status_change *sc;



 int damage,damage2;


 do { if (((void)(src), 
# 4289 "../../../server-code/src/map/clif.c" 3 4
0
# 4289 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);
 do { if (((void)(dst), 
# 4290 "../../../server-code/src/map/clif.c" 3 4
0
# 4290 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);

 sc = status->get_sc(dst);

 if(sc && sc->count && sc->data[SC_ILLUSION]) {
  if(in_damage) in_damage = in_damage*(sc->data[SC_ILLUSION]->val2) + rnd()%100;
  if(in_damage2) in_damage2 = in_damage2*(sc->data[SC_ILLUSION]->val2) + rnd()%100;
 }





 damage = (int)(((in_damage) < (0x7fffffff)) ? (in_damage) : (0x7fffffff));
 damage2 = (int)(((in_damage2) < (0x7fffffff)) ? (in_damage2) : (0x7fffffff));


 type = clif_calc_delay(type,div,damage+damage2,ddelay);

 p.PacketType = damageType;
 p.GID = src->id;
 p.targetGID = dst->id;
 p.startTime = (uint32)timer->gettick();
 p.attackMT = sdelay;
 p.attackedMT = ddelay;
 p.count = div;
 p.action = type;

 if( battle_config.hide_woe_damage && (map->list[src->m].flag.gvg || map->list[src->m].flag.gvg_castle) ) {
  p.damage = damage?div:0;
  p.leftDamage = damage2?div:0;
 } else {
  p.damage = damage;
  p.leftDamage = damage2;
 }

 p.is_sp_damaged = 0;


 if(disguised(dst)) {
  clif->send(&p,sizeof(p),dst,AREA_WOS);
  p.targetGID = -dst->id;
  clif->send(&p,sizeof(p),dst,SELF);
 } else
  clif->send(&p,sizeof(p),dst,AREA);

 if(disguised(src)) {
  p.GID = -src->id;
  if (disguised(dst))
   p.targetGID = dst->id;

  if(damage > 0) p.damage = -1;
  if(damage2 > 0) p.leftDamage = -1;

  clif->send(&p,sizeof(p),src,SELF);
 }

 if(src == dst) {
  unit->setdir(src,unit->getdir(src));
 }


 return clif->calc_walkdelay(dst,ddelay,type,damage+damage2,div);
}




void clif_takeitem(struct block_list* src, struct block_list* dst)
{

 unsigned char buf[32];

 do { if (((void)(src), 
# 4363 "../../../server-code/src/map/clif.c" 3 4
0
# 4363 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(dst), 
# 4364 "../../../server-code/src/map/clif.c" 3 4
0
# 4364 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0x8a;
 WBUFL(buf, 2) = src->id;
 WBUFL(buf, 6) = dst->id;
 WBUFB(buf,26) = 1;
 clif->send(buf, packet_db[0x8a].len, src, AREA);

}




void clif_sitting(struct block_list* bl)
{
 unsigned char buf[32];
 do { if (((void)(bl), 
# 4380 "../../../server-code/src/map/clif.c" 3 4
0
# 4380 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0x8a;
 WBUFL(buf, 2) = bl->id;
 WBUFB(buf,26) = 2;
 clif->send(buf, packet_db[0x8a].len, bl, AREA);

 if(disguised(bl)) {
  WBUFL(buf, 2) = - bl->id;
  clif->send(buf, packet_db[0x8a].len, bl, SELF);
 }
}




void clif_standing(struct block_list* bl)
{
 unsigned char buf[32];
 do { if (((void)(bl), 
# 4399 "../../../server-code/src/map/clif.c" 3 4
0
# 4399 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0x8a;
 WBUFL(buf, 2) = bl->id;
 WBUFB(buf,26) = 3;
 clif->send(buf, packet_db[0x8a].len, bl, AREA);

 if(disguised(bl)) {
  WBUFL(buf, 2) = - bl->id;
  clif->send(buf, packet_db[0x8a].len, bl, SELF);
 }
}



void clif_changemapcell(int fd, int16 m, int x, int y, int type, enum send_target target) {
 unsigned char buf[32];

 WBUFW(buf,0) = 0x192;
 WBUFW(buf,2) = x;
 WBUFW(buf,4) = y;
 WBUFW(buf,6) = type;
 mapindex->getmapname_ext(map->list[m].custom_name ? map->list[map->list[m].instance_src_map].name : map->list[m].name, WBUFP(buf,8));

 if( fd ) {
  WFIFOHEAD(fd,packet_db[0x192].len);
  memcpy(WFIFOP(fd,0), buf, packet_db[0x192].len);
  WFIFOSET(fd,packet_db[0x192].len);
 } else {
  struct block_list dummy_bl;
  dummy_bl.type = BL_NUL;
  dummy_bl.x = x;
  dummy_bl.y = y;
  dummy_bl.m = m;
  clif->send(buf,packet_db[0x192].len,&dummy_bl,target);
 }
}



void clif_getareachar_item(struct map_session_data* sd,struct flooritem_data* fitem) {
 int view,fd;

 do { if (((void)(sd), 
# 4442 "../../../server-code/src/map/clif.c" 3 4
0
# 4442 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(fitem), 
# 4443 "../../../server-code/src/map/clif.c" 3 4
0
# 4443 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd=sd->fd;

 WFIFOHEAD(fd,packet_db[0x9d].len);
 WFIFOW(fd,0)=0x9d;
 WFIFOL(fd,2)=fitem->bl.id;
 if((view = (itemdb->search(fitem->item_data.nameid)->view_id)) > 0)
  WFIFOW(fd,6)=view;
 else
  WFIFOW(fd,6)=fitem->item_data.nameid;
 WFIFOB(fd,8)=fitem->item_data.identify;
 WFIFOW(fd,9)=fitem->bl.x;
 WFIFOW(fd,11)=fitem->bl.y;
 WFIFOW(fd,13)=fitem->item_data.amount;
 WFIFOB(fd,15)=fitem->subx;
 WFIFOB(fd,16)=fitem->suby;
 WFIFOSET(fd,packet_db[0x9d].len);
}

void clif_graffiti_entry(struct block_list *bl, struct skill_unit *su, enum send_target target) {
 struct packet_graffiti_entry p;

 do { if (((void)(bl), 
# 4465 "../../../server-code/src/map/clif.c" 3 4
0
# 4465 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(su), 
# 4466 "../../../server-code/src/map/clif.c" 3 4
0
# 4466 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(su->group), 
# 4467 "../../../server-code/src/map/clif.c" 3 4
0
# 4467 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 p.PacketType = graffiti_entryType;
 p.AID = su->bl.id;
 p.creatorAID = su->group->src_id;
 p.xPos = su->bl.x;
 p.yPos = su->bl.y;
 p.job = su->group->unit_id;
 p.isContens = 1;
 p.isVisible = 1;
 (strlib->safestrncpy_((p.msg),(su->group->valstr),(80)));

 clif->send(&p,sizeof(p),bl,target);
}






void clif_getareachar_skillunit(struct block_list *bl, struct skill_unit *su, enum send_target target) {
 struct packet_skill_entry p;
 do { if (((void)(bl), 
# 4488 "../../../server-code/src/map/clif.c" 3 4
0
# 4488 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(su), 
# 4489 "../../../server-code/src/map/clif.c" 3 4
0
# 4489 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(su->group), 
# 4490 "../../../server-code/src/map/clif.c" 3 4
0
# 4490 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if( su->group->state.guildaura )
  return;


 if(su->group->unit_id == UNT_GRAFFITI) {
  clif->graffiti_entry(bl,su,target);
  return;
 }


 p.PacketType = skill_entryType;

 p.PacketLength = sizeof(p);


 p.AID = su->bl.id;
 p.creatorAID = su->group->src_id;
 p.xPos = su->bl.x;
 p.yPos = su->bl.y;


 if ((battle_config.traps_setting&1 && skill->get_inf2(su->group->skill_id)&INF2_TRAP) ||
  (skill->get_unit_flag(su->group->skill_id) & UF_RANGEDSINGLEUNIT && !(su->val2 & UF_RANGEDSINGLEUNIT)))
  p.job = UNT_DUMMYSKILL;
 else
  p.job = su->group->unit_id;


 p.RadiusRange = (unsigned char)su->range;


 p.isVisible = 1;


 p.level = (unsigned char)su->group->skill_lv;


 clif->send(&p,sizeof(p),bl,target);

 if (su->group->skill_id == WZ_ICEWALL) {
  struct map_session_data *sd = ( ((bl) == (struct block_list *)
# 4532 "../../../server-code/src/map/clif.c" 3 4
                               ((void *)0) 
# 4532 "../../../server-code/src/map/clif.c"
                               || (bl)->type != (BL_PC)) ? (TBL_PC *)
# 4532 "../../../server-code/src/map/clif.c" 3 4
                               ((void *)0) 
# 4532 "../../../server-code/src/map/clif.c"
                               : (TBL_PC *)(bl) );
  clif->changemapcell(sd != 
# 4533 "../../../server-code/src/map/clif.c" 3 4
                           ((void *)0) 
# 4533 "../../../server-code/src/map/clif.c"
                                ? sd->fd : 0, su->bl.m, su->bl.x, su->bl.y, 5, SELF);
 }
}




void clif_clearchar_skillunit(struct skill_unit *su, int fd) {
 do { if (((void)(su), 
# 4541 "../../../server-code/src/map/clif.c" 3 4
0
# 4541 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WFIFOHEAD(fd,packet_db[0x120].len);
 WFIFOW(fd,0)=0x120;
 WFIFOL(fd, 2)=su->bl.id;
 WFIFOSET(fd,packet_db[0x120].len);

 if(su->group && su->group->skill_id == WZ_ICEWALL)
  clif->changemapcell(fd,su->bl.m,su->bl.x,su->bl.y,su->val2,SELF);
}



void clif_skill_delunit(struct skill_unit *su) {
 unsigned char buf[16];

 do { if (((void)(su), 
# 4557 "../../../server-code/src/map/clif.c" 3 4
0
# 4557 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0)=0x120;
 WBUFL(buf, 2)=su->bl.id;
 clif->send(buf,packet_db[0x120].len,&su->bl,AREA);
}




void clif_skillunit_update(struct block_list* bl)
{
 unsigned char buf[6];
 do { if (((void)(bl), 
# 4570 "../../../server-code/src/map/clif.c" 3 4
0
# 4570 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0x1ac;
 WBUFL(buf,2) = bl->id;

 clif->send(buf,packet_db[0x1ac].len,bl,AREA);
}




int clif_getareachar(struct block_list* bl,va_list ap) {
 struct map_session_data *sd;

 do { if (((void)(bl), 
# 4584 "../../../server-code/src/map/clif.c" 3 4
0
# 4584 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);

 sd=
# 4586 "../../../server-code/src/map/clif.c" 3 4
   __builtin_va_arg(
# 4586 "../../../server-code/src/map/clif.c"
   ap
# 4586 "../../../server-code/src/map/clif.c" 3 4
   ,
# 4586 "../../../server-code/src/map/clif.c"
   struct map_session_data*
# 4586 "../../../server-code/src/map/clif.c" 3 4
   )
# 4586 "../../../server-code/src/map/clif.c"
                                      ;

 if (sd == 
# 4588 "../../../server-code/src/map/clif.c" 3 4
          ((void *)0) 
# 4588 "../../../server-code/src/map/clif.c"
               || !sd->fd)
  return 0;

 switch(bl->type){
  case BL_ITEM:
   clif->getareachar_item(sd, ((TBL_ITEM *)BL_UCAST_(bl)));
   break;
  case BL_SKILL:
   clif->getareachar_skillunit(&sd->bl, ((TBL_SKILL *)BL_UCAST_(bl)), SELF);
   break;
  default:
   if(&sd->bl == bl)
    break;
   clif->getareachar_unit(sd,bl);
   break;
 }
 return 0;
}




int clif_outsight(struct block_list *bl,va_list ap)
{
 struct block_list *tbl;
 struct view_data *vd;
 struct map_session_data *sd, *tsd;
 tbl=
# 4615 "../../../server-code/src/map/clif.c" 3 4
    __builtin_va_arg(
# 4615 "../../../server-code/src/map/clif.c"
    ap
# 4615 "../../../server-code/src/map/clif.c" 3 4
    ,
# 4615 "../../../server-code/src/map/clif.c"
    struct block_list*
# 4615 "../../../server-code/src/map/clif.c" 3 4
    )
# 4615 "../../../server-code/src/map/clif.c"
                                 ;
 if(bl == tbl) return 0;

 sd = ( ((bl) == (struct block_list *)
# 4618 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0) 
# 4618 "../../../server-code/src/map/clif.c"
     || (bl)->type != (BL_PC)) ? (TBL_PC *)
# 4618 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0) 
# 4618 "../../../server-code/src/map/clif.c"
     : (TBL_PC *)(bl) );
 tsd = ( ((tbl) == (struct block_list *)
# 4619 "../../../server-code/src/map/clif.c" 3 4
      ((void *)0) 
# 4619 "../../../server-code/src/map/clif.c"
      || (tbl)->type != (BL_PC)) ? (TBL_PC *)
# 4619 "../../../server-code/src/map/clif.c" 3 4
      ((void *)0) 
# 4619 "../../../server-code/src/map/clif.c"
      : (TBL_PC *)(tbl) );

 if (tsd && tsd->fd) {
  do { if (((void)(bl), 
# 4622 "../../../server-code/src/map/clif.c" 3 4
 0
# 4622 "../../../server-code/src/map/clif.c"
 )) return(0); } while(0);
  switch(bl->type){
   case BL_PC:
    if (sd->vd.class_ != INVISIBLE_CLASS)
     clif->clearunit_single(bl->id,CLR_OUTSIGHT,tsd->fd);
    if (sd->chatID) {
     struct chat_data *cd = map->id2cd(sd->chatID);
     if(cd->usersd[0]==sd)
      clif->dispchat(cd,tsd->fd);
    }
    if( sd->state.vending )
     clif->closevendingboard(bl,tsd->fd);
    if( sd->state.buyingstore )
     clif->buyingstore_disappear_entry_single(tsd, sd);
    break;
   case BL_ITEM:
    clif->clearflooritem(((TBL_ITEM *)BL_UCAST_(bl)), tsd->fd);
    break;
   case BL_SKILL:
    clif->clearchar_skillunit(((TBL_SKILL *)BL_UCAST_(bl)), tsd->fd);
    break;
   case BL_NPC:
    if (!(((TBL_NPC *)BL_UCAST_(bl))->option&OPTION_INVISIBLE))
     clif->clearunit_single(bl->id,CLR_OUTSIGHT,tsd->fd);
    break;
   default:
    if ((vd=status->get_viewdata(bl)) && vd->class_ != INVISIBLE_CLASS)
     clif->clearunit_single(bl->id,CLR_OUTSIGHT,tsd->fd);
    break;
   }
 }
 if (sd && sd->fd) {
  do { if (((void)(tbl), 
# 4654 "../../../server-code/src/map/clif.c" 3 4
 0
# 4654 "../../../server-code/src/map/clif.c"
 )) return(0); } while(0);
  if (tbl->type == BL_SKILL)
   clif->clearchar_skillunit(((TBL_SKILL *)BL_UCAST_(tbl)), sd->fd);
  else if ((vd = status->get_viewdata(tbl)) && vd->class_ != INVISIBLE_CLASS
        && !(tbl->type == BL_NPC && (((TBL_NPC *)BL_UCAST_(tbl))->option&OPTION_INVISIBLE)))
   clif->clearunit_single(tbl->id,CLR_OUTSIGHT,sd->fd);
 }
 return 0;
}




int clif_insight(struct block_list *bl,va_list ap)
{
 struct block_list *tbl;
 struct map_session_data *sd, *tsd;
 tbl=
# 4671 "../../../server-code/src/map/clif.c" 3 4
    __builtin_va_arg(
# 4671 "../../../server-code/src/map/clif.c"
    ap
# 4671 "../../../server-code/src/map/clif.c" 3 4
    ,
# 4671 "../../../server-code/src/map/clif.c"
    struct block_list*
# 4671 "../../../server-code/src/map/clif.c" 3 4
    )
# 4671 "../../../server-code/src/map/clif.c"
                                 ;

 if (bl == tbl) return 0;

 sd = ( ((bl) == (struct block_list *)
# 4675 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0) 
# 4675 "../../../server-code/src/map/clif.c"
     || (bl)->type != (BL_PC)) ? (TBL_PC *)
# 4675 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0) 
# 4675 "../../../server-code/src/map/clif.c"
     : (TBL_PC *)(bl) );
 tsd = ( ((tbl) == (struct block_list *)
# 4676 "../../../server-code/src/map/clif.c" 3 4
      ((void *)0) 
# 4676 "../../../server-code/src/map/clif.c"
      || (tbl)->type != (BL_PC)) ? (TBL_PC *)
# 4676 "../../../server-code/src/map/clif.c" 3 4
      ((void *)0) 
# 4676 "../../../server-code/src/map/clif.c"
      : (TBL_PC *)(tbl) );

 if (tsd && tsd->fd) {
  do { if (((void)(bl), 
# 4679 "../../../server-code/src/map/clif.c" 3 4
 0
# 4679 "../../../server-code/src/map/clif.c"
 )) return(0); } while(0);
  switch(bl->type) {
   case BL_ITEM:
    clif->getareachar_item(tsd, ((TBL_ITEM *)BL_UCAST_(bl)));
    break;
   case BL_SKILL:
    clif->getareachar_skillunit(&tsd->bl, ((TBL_SKILL *)BL_UCAST_(bl)), SELF);
    break;
   default:
    clif->getareachar_unit(tsd,bl);
    break;
  }
 }
 if (sd && sd->fd) {
  clif->getareachar_unit(sd,tbl);
 }
 return 0;
}



void clif_skillinfoblock(struct map_session_data *sd)
{
 int fd;
 int i,len,id;

 do { if (((void)(sd), 
# 4705 "../../../server-code/src/map/clif.c" 3 4
0
# 4705 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 if (!fd) return;

 WFIFOHEAD(fd, 1478 * 37 + 4);
 WFIFOW(fd,0) = 0x10f;
 for ( i = 0, len = 4; i < 1478; i++) {
  if( (id = sd->status.skill[i].id) != 0 ) {
   int level;

   if (len + 37 > 8192)
    break;

   WFIFOW(fd,len) = id;
   WFIFOL(fd, len + 2) = skill->get_inf(id);
   level = sd->status.skill[i].lv;
   WFIFOW(fd,len + 6) = level;
   if (level) {
    WFIFOW(fd,len + 8) = skill->get_sp(id, level);
    WFIFOW(fd,len + 10)= skill->get_range2(&sd->bl, id, level);
   }
   else {
    WFIFOW(fd,len + 8) = 0;
    WFIFOW(fd,len + 10)= 0;
   }
   (strlib->safestrncpy_((WFIFOP(fd,len+12)),(skill->get_name(id)),((23 + 1))));
   if(sd->status.skill[i].flag == SKILL_FLAG_PERMANENT)
    WFIFOB(fd,len+36) = (sd->status.skill[i].lv < skill->tree_get_max(id, sd->status.class_))? 1:0;
   else
    WFIFOB(fd,len+36) = 0;
   len += 37;
  }
 }
 WFIFOW(fd,2)=len;
 WFIFOSET(fd,len);


 for ( ; i < 1478; i++) {
  if( (id = sd->status.skill[i].id) != 0 ) {
   clif->addskill(sd, id);
   clif->skillinfo(sd, id, 0);
  }
 }
}






void clif_addskill(struct map_session_data *sd, int id)
{
 int fd, skill_lv, idx = skill->get_index(id);

 do { if (((void)(sd), 
# 4760 "../../../server-code/src/map/clif.c" 3 4
0
# 4760 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 if (!fd) return;

 if (sd->status.skill[idx].id <= 0)
  return;

 skill_lv = sd->status.skill[idx].lv;

 WFIFOHEAD(fd, packet_db[0x111].len);
 WFIFOW(fd,0) = 0x111;
 WFIFOW(fd,2) = id;
 WFIFOL(fd,4) = skill->get_inf(id);
 WFIFOW(fd,8) = skill_lv;
 if (skill_lv > 0) {
  WFIFOW(fd,10) = skill->get_sp(id, skill_lv);
  WFIFOW(fd,12) = skill->get_range2(&sd->bl, id, skill_lv);
 } else {
  WFIFOW(fd,10) = 0;
  WFIFOW(fd,12) = 0;
 }
 (strlib->safestrncpy_((WFIFOP(fd,14)),(skill->get_name(id)),((23 + 1))));
 if (sd->status.skill[idx].flag == SKILL_FLAG_PERMANENT)
  WFIFOB(fd,38) = (skill_lv < skill->tree_get_max(id, sd->status.class_))? 1:0;
 else
  WFIFOB(fd,38) = 0;
 WFIFOSET(fd,packet_db[0x111].len);
}



void clif_deleteskill(struct map_session_data *sd, int id)
{

 int fd;

 do { if (((void)(sd), 
# 4797 "../../../server-code/src/map/clif.c" 3 4
0
# 4797 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 if( !fd ) return;

 WFIFOHEAD(fd,packet_db[0x441].len);
 WFIFOW(fd,0) = 0x441;
 WFIFOW(fd,2) = id;
 WFIFOSET(fd,packet_db[0x441].len);

 clif->skillinfoblock(sd);
}







void clif_skillup(struct map_session_data *sd, uint16 skill_id, int skill_lv, int flag)
{
 int fd;
 do { if (((void)(sd), 
# 4818 "../../../server-code/src/map/clif.c" 3 4
0
# 4818 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;

 WFIFOHEAD(fd, packet_db[0x10e].len);
 WFIFOW(fd,0) = 0x10e;
 WFIFOW(fd,2) = skill_id;
 WFIFOW(fd,4) = skill_lv;
 WFIFOW(fd,6) = skill->get_sp(skill_id, skill_lv);
 WFIFOW(fd,8) = (flag)?skill->get_range2(&sd->bl, skill_id, skill_lv) : skill->get_range(skill_id, skill_lv);
 if( flag )
  WFIFOB(fd,10) = (skill_lv < skill->tree_get_max(skill_id, sd->status.class_)) ? 1 : 0;
 else
  WFIFOB(fd,10) = 1;

 WFIFOSET(fd, packet_db[0x10e].len);
}



void clif_skillinfo(struct map_session_data *sd,int skill_id, int inf)
{
 const int fd = sd->fd;
 int idx = skill->get_index(skill_id);
 int skill_lv;

 do { if (((void)(sd), 
# 4844 "../../../server-code/src/map/clif.c" 3 4
0
# 4844 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (( (idx >= 0 && idx < 1478) ? 
# 4845 "../../../server-code/src/map/clif.c" 3 4
0 
# 4845 "../../../server-code/src/map/clif.c"
: (nullpo->assert_report("../../../server-code/src/map/clif.c", 4845, __func__, "idx >= 0 && idx < 1478", "failed assertion"), 
# 4845 "../../../server-code/src/map/clif.c" 3 4
1
# 4845 "../../../server-code/src/map/clif.c"
) )) return; } while(0);

 skill_lv = sd->status.skill[idx].lv;

 WFIFOHEAD(fd,packet_db[0x7e1].len);
 WFIFOW(fd,0) = 0x7e1;
 WFIFOW(fd,2) = skill_id;
 WFIFOL(fd,4) = inf?inf:skill->get_inf(skill_id);
 WFIFOW(fd,8) = skill_lv;
 if (skill_lv > 0) {
  WFIFOW(fd,10) = skill->get_sp(skill_id, skill_lv);
  WFIFOW(fd,12) = skill->get_range2(&sd->bl, skill_id, skill_lv);
 } else {
  WFIFOW(fd,10) = 0;
  WFIFOW(fd,12) = 0;
 }
 if (sd->status.skill[idx].flag == SKILL_FLAG_PERMANENT)
  WFIFOB(fd,14) = (skill_lv < skill->tree_get_max(skill_id, sd->status.class_))? 1:0;
 else
  WFIFOB(fd,14) = 0;
 WFIFOSET(fd,packet_db[0x7e1].len);
}
# 4883 "../../../server-code/src/map/clif.c"
void clif_skillcasting(struct block_list* bl, int src_id, int dst_id, int dst_x, int dst_y, uint16 skill_id, int property, int casttime)
{



 const int cmd = 0x7fb;

 unsigned char buf[32];

 WBUFW(buf,0) = cmd;
 WBUFL(buf,2) = src_id;
 WBUFL(buf,6) = dst_id;
 WBUFW(buf,10) = dst_x;
 WBUFW(buf,12) = dst_y;
 WBUFW(buf,14) = skill_id;
 WBUFL(buf,16) = property<0?0:property;
 WBUFL(buf,20) = casttime;

 WBUFB(buf,24) = 0;


 if (disguised(bl)) {
  clif->send(buf,packet_db[cmd].len, bl, AREA_WOS);
  WBUFL(buf,2) = -src_id;
  clif->send(buf,packet_db[cmd].len, bl, SELF);
 } else
  clif->send(buf,packet_db[cmd].len, bl, AREA);
}



void clif_skillcastcancel(struct block_list* bl)
{
 unsigned char buf[16];

 do { if (((void)(bl), 
# 4918 "../../../server-code/src/map/clif.c" 3 4
0
# 4918 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0x1b9;
 WBUFL(buf,2) = bl->id;
 clif->send(buf,packet_db[0x1b9].len, bl, AREA);
}
# 4948 "../../../server-code/src/map/clif.c"
void clif_skill_fail(struct map_session_data *sd,uint16 skill_id,enum useskill_fail_cause cause,int btype)
{
 int fd;

 if (!sd) {

  (showmsg->showDebug(("clif_skill_fail: Error, received NULL sd for skill %d\n"), skill_id));
  return;
 }

 fd=sd->fd;
 if (!fd) return;

 if(battle_config.display_skill_fail&1)
  return;

 if(cause==USESKILL_FAIL_SKILLINTERVAL && !sd->state.showdelay)
  return;

 if(skill_id == RG_SNATCHER && battle_config.display_skill_fail&4)
  return;

 if(skill_id == TF_POISON && battle_config.display_skill_fail&8)
  return;

 WFIFOHEAD(fd,packet_db[0x110].len);
 WFIFOW(fd,0) = 0x110;
 WFIFOW(fd,2) = skill_id;
 WFIFOL(fd,4) = btype;
 WFIFOB(fd,8) = 0;
 WFIFOB(fd,9) = cause;
 WFIFOSET(fd,packet_db[0x110].len);
}



void clif_skill_cooldown(struct map_session_data *sd, uint16 skill_id, unsigned int duration)
{

 int fd;

 do { if (((void)(sd), 
# 4989 "../../../server-code/src/map/clif.c" 3 4
0
# 4989 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x43d].len);
 WFIFOW(fd,0) = 0x43d;
 WFIFOW(fd,2) = skill_id;
 WFIFOL(fd,4) = duration;
 WFIFOSET(fd,packet_db[0x43d].len);

}




int clif_skill_damage(struct block_list *src, struct block_list *dst, int64 tick, int sdelay, int ddelay, int64 in_damage, int div, uint16 skill_id, uint16 skill_lv, int type) {
 unsigned char buf[64];
 struct status_change *sc;
 int damage;

 do { if (((void)(src), 
# 5008 "../../../server-code/src/map/clif.c" 3 4
0
# 5008 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);
 do { if (((void)(dst), 
# 5009 "../../../server-code/src/map/clif.c" 3 4
0
# 5009 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);

 damage = (int)(((in_damage) >= (0x7fffffff)) ? (0x7fffffff) : ((in_damage) <= (
# 5011 "../../../server-code/src/map/clif.c" 3 4
              (-0x7fffffff - 1)
# 5011 "../../../server-code/src/map/clif.c"
              )) ? (
# 5011 "../../../server-code/src/map/clif.c" 3 4
              (-0x7fffffff - 1)
# 5011 "../../../server-code/src/map/clif.c"
              ) : (in_damage));
 type = clif_calc_delay(type, div, damage, ddelay);


 if (type == BDT_SKILL) type = BDT_MULTIHIT;


 if ((sc = status->get_sc(dst)) && sc->count) {
  if (sc->data[SC_ILLUSION] && damage)
   damage = damage * (sc->data[SC_ILLUSION]->val2) + rnd() % 100;
 }
# 5055 "../../../server-code/src/map/clif.c"
 WBUFW(buf,0) = 0x1de;
 WBUFW(buf,2) = skill_id;
 WBUFL(buf, 4) = src->id;
 WBUFL(buf, 8) = dst->id;
 WBUFL(buf, 12) = (uint32)tick;
 WBUFL(buf, 16) = sdelay;
 WBUFL(buf, 20) = ddelay;
 if (battle_config.hide_woe_damage && (map->list[src->m].flag.gvg || map->list[src->m].flag.gvg_castle)) {
  WBUFL(buf, 24) = damage ? div : 0;
 } else {
  WBUFL(buf, 24) = damage;
 }
 WBUFW(buf,28) = skill_lv;
 WBUFW(buf,30) = div;







 WBUFB(buf, 32) = (type == BDT_SKILL) ? BDT_MULTIHIT : type;

 if (disguised(dst)) {
  clif->send(buf, packet_db[0x1de].len, dst, AREA_WOS);
  WBUFL(buf,8)=-dst->id;
  clif->send(buf, packet_db[0x1de].len, dst, SELF);
 } else
  clif->send(buf, packet_db[0x1de].len, dst, AREA);

 if (disguised(src)) {
  WBUFL(buf, 4) = -src->id;
  if (disguised(dst))
   WBUFL(buf, 8) = dst->id;
  if (damage > 0)
   WBUFL(buf, 24) = -1;
  clif->send(buf, packet_db[0x1de].len, src, SELF);
 }



 return clif->calc_walkdelay(dst, ddelay, type, damage, div);
}
# 5158 "../../../server-code/src/map/clif.c"
int clif_skill_nodamage(struct block_list *src,struct block_list *dst,uint16 skill_id,int heal,int fail)
{
 unsigned char buf[32];

 do { if (((void)(dst), 
# 5162 "../../../server-code/src/map/clif.c" 3 4
0
# 5162 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);

 WBUFW(buf,0)=0x11a;
 WBUFW(buf,2)=skill_id;
 WBUFW(buf,4)=(((heal) < (
# 5166 "../../../server-code/src/map/clif.c" 3 4
             (32767)
# 5166 "../../../server-code/src/map/clif.c"
             )) ? (heal) : (
# 5166 "../../../server-code/src/map/clif.c" 3 4
             (32767)
# 5166 "../../../server-code/src/map/clif.c"
             ));
 WBUFL(buf,6)=dst->id;
 WBUFL(buf,10)=src?src->id:0;
 WBUFB(buf,14)=fail;

 if (disguised(dst)) {
  clif->send(buf,packet_db[0x11a].len,dst,AREA_WOS);
  WBUFL(buf,6)=-dst->id;
  clif->send(buf,packet_db[0x11a].len,dst,SELF);
 } else
  clif->send(buf,packet_db[0x11a].len,dst,AREA);

 if(src && disguised(src)) {
  WBUFL(buf,10)=-src->id;
  if (disguised(dst))
   WBUFL(buf,6)=dst->id;
  clif->send(buf,packet_db[0x11a].len,src,SELF);
 }

 return fail;
}



void clif_skill_poseffect(struct block_list *src, uint16 skill_id, int val, int x, int y, int64 tick) {
 unsigned char buf[32];

 do { if (((void)(src), 
# 5193 "../../../server-code/src/map/clif.c" 3 4
0
# 5193 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0)=0x117;
 WBUFW(buf,2)=skill_id;
 WBUFL(buf,4)=src->id;
 WBUFW(buf,8)=val;
 WBUFW(buf,10)=x;
 WBUFW(buf,12)=y;
 WBUFL(buf,14)=(uint32)tick;
 if(disguised(src)) {
  clif->send(buf,packet_db[0x117].len,src,AREA_WOS);
  WBUFL(buf,4)=-src->id;
  clif->send(buf,packet_db[0x117].len,src,SELF);
 } else
  clif->send(buf,packet_db[0x117].len,src,AREA);
}



void clif_skill_warppoint(struct map_session_data* sd, uint16 skill_id, uint16 skill_lv, unsigned short map1, unsigned short map2, unsigned short map3, unsigned short map4)
{
 int fd;

 do { if (((void)(sd), 
# 5216 "../../../server-code/src/map/clif.c" 3 4
0
# 5216 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;

 WFIFOHEAD(fd,packet_db[0x11c].len);
 WFIFOW(fd,0) = 0x11c;
 WFIFOW(fd,2) = skill_id;
 memset(WFIFOP(fd,4), 0x00, 4*((11 + 1) + 4));
 if (map1 == (unsigned short)-1) strcpy(WFIFOP(fd,4), "Random");
 else
 if (map1 > 0) mapindex->getmapname_ext(mapindex->id2name((map1),"../../../server-code/src/map/clif.c", 5225, __func__), WFIFOP(fd,4));
 if (map2 > 0) mapindex->getmapname_ext(mapindex->id2name((map2),"../../../server-code/src/map/clif.c", 5226, __func__), WFIFOP(fd,20));
 if (map3 > 0) mapindex->getmapname_ext(mapindex->id2name((map3),"../../../server-code/src/map/clif.c", 5227, __func__), WFIFOP(fd,36));
 if (map4 > 0) mapindex->getmapname_ext(mapindex->id2name((map4),"../../../server-code/src/map/clif.c", 5228, __func__), WFIFOP(fd,52));
 WFIFOSET(fd,packet_db[0x11c].len);

 sd->menuskill_id = skill_id;
 if (skill_id == AL_WARP){
  sd->menuskill_val = (sd->ud.skillx<<16)|sd->ud.skilly;
  sd->state.workinprogress = 3;
 }else
  sd->menuskill_val = skill_lv;
}
# 5248 "../../../server-code/src/map/clif.c"
void clif_skill_memomessage(struct map_session_data* sd, int type)
{
 int fd;

 do { if (((void)(sd), 
# 5252 "../../../server-code/src/map/clif.c" 3 4
0
# 5252 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x11e].len);
 WFIFOW(fd,0)=0x11e;
 WFIFOB(fd,2)=type;
 WFIFOSET(fd,packet_db[0x11e].len);
}
# 5270 "../../../server-code/src/map/clif.c"
void clif_skill_mapinfomessage(struct map_session_data *sd, int type)
{
 int fd;

 do { if (((void)(sd), 
# 5274 "../../../server-code/src/map/clif.c" 3 4
0
# 5274 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x189].len);
 WFIFOW(fd,0)=0x189;
 WFIFOW(fd,2)=type;
 WFIFOSET(fd,packet_db[0x189].len);
}




void clif_skill_estimation(struct map_session_data *sd,struct block_list *dst) {
 struct status_data *dstatus;
 unsigned char buf[64];
 int i;

 do { if (((void)(sd), 
# 5291 "../../../server-code/src/map/clif.c" 3 4
0
# 5291 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(dst), 
# 5292 "../../../server-code/src/map/clif.c" 3 4
0
# 5292 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if( dst->type != BL_MOB )
  return;

 dstatus = status->get_status_data(dst);

 WBUFW(buf,0) = 0x18c;
 WBUFW(buf,2) = status->get_class(dst);
 WBUFW(buf,4) = status->get_lv(dst);
 WBUFW(buf,6) = dstatus->size;
 WBUFL(buf, 8) = dstatus->hp;
 WBUFW(buf,12) = ((battle_config.estimation_type&1) ? dstatus->def : 0)
               + ((battle_config.estimation_type&2) ? dstatus->def2 : 0);
 WBUFW(buf,14) = dstatus->race;
 WBUFW(buf,16) = ((battle_config.estimation_type&1) ? dstatus->mdef : 0)
               + ((battle_config.estimation_type&2) ? dstatus->mdef2 : 0);
 WBUFW(buf,18) = dstatus->def_ele;
 for(i=0;i<9;i++) {
  WBUFB(buf,20+i)= (unsigned char)battle->attr_ratio(i+1,dstatus->def_ele, dstatus->ele_lv);


 }

 clif->send(buf,packet_db[0x18c].len,&sd->bl,sd->status.party_id>0?PARTY_SAMEMAP:SELF);
}





void clif_skill_produce_mix_list(struct map_session_data *sd, int skill_id , int trigger)
{
 int i,c,view,fd;
 do { if (((void)(sd), 
# 5326 "../../../server-code/src/map/clif.c" 3 4
0
# 5326 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if(sd->menuskill_id == skill_id)
  return;
 if( skill_id == GC_CREATENEWPOISON )
  skill_id = GC_RESEARCHNEWPOISON;

 fd=sd->fd;
 WFIFOHEAD(fd, 270 * 8 + 8);
 WFIFOW(fd,0)=0x18d;

 for(i=0,c=0;i<270;i++){
  if( skill->can_produce_mix(sd,skill->dbs->produce_db[i].nameid, trigger, 1) &&
   ( ( skill_id > 0 && skill->dbs->produce_db[i].req_skill == skill_id ) || skill_id < 0 )
   ){
   if((view = (itemdb->search(skill->dbs->produce_db[i].nameid)->view_id)) > 0)
    WFIFOW(fd,c*8+ 4)= view;
   else
    WFIFOW(fd,c*8+ 4)= skill->dbs->produce_db[i].nameid;
   WFIFOW(fd,c*8+ 6)= 0;
   WFIFOW(fd,c*8+ 8)= 0;
   WFIFOW(fd,c*8+10)= 0;
   c++;
  }
 }
 WFIFOW(fd,2)=c*8+8;
 WFIFOSET(fd,WFIFOW(fd,2));
 if(c > 0) {
  sd->menuskill_id = skill_id;
  sd->menuskill_val = trigger;
  return;
 }
}
# 5369 "../../../server-code/src/map/clif.c"
void clif_cooking_list(struct map_session_data *sd, int trigger, uint16 skill_id, int qty, int list_type)
{
 int fd;
 int i, c;
 int view;

 do { if (((void)(sd), 
# 5375 "../../../server-code/src/map/clif.c" 3 4
0
# 5375 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;

 WFIFOHEAD(fd, 6 + 2 * 270);
 WFIFOW(fd,0) = 0x25a;
 WFIFOW(fd,4) = list_type;

 c = 0;
 for( i = 0; i < 270; i++ ) {
  if( !skill->can_produce_mix(sd,skill->dbs->produce_db[i].nameid,trigger, qty) )
   continue;

  if( (view = (itemdb->search(skill->dbs->produce_db[i].nameid)->view_id)) > 0 )
   WFIFOW(fd,6 + 2 * c) = view;
  else
   WFIFOW(fd,6 + 2 * c) = skill->dbs->produce_db[i].nameid;

  c++;
 }

 if( skill_id == AM_PHARMACY ) {

  WFIFOW(fd,2) = 6 + 2 * c;
  WFIFOSET(fd,WFIFOW(fd,2));
 }

 if( c > 0 ) {
  sd->menuskill_id = skill_id;
  sd->menuskill_val = trigger;
  if( skill_id != AM_PHARMACY ) {
   sd->menuskill_val2 = qty;
   WFIFOW(fd,2) = 6 + 2 * c;
   WFIFOSET(fd,WFIFOW(fd,2));
  }
 } else {
  ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
  if( skill_id != AM_PHARMACY ) {


   clif->msgtable_skill(sd, skill_id, MSG_COOKING_LIST_FAIL);




  }
 }
}

void clif_status_change_notick(struct block_list *bl,int type,int flag,int tick,int val1, int val2, int val3) {
 struct packet_sc_notick p;
 struct map_session_data *sd;

 do { if (((void)(bl), 
# 5427 "../../../server-code/src/map/clif.c" 3 4
0
# 5427 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if (type == SI_BLANK)
  return;

 if (!(status->type2relevant_bl_types(type)&bl->type))
  return;

 sd = ( ((bl) == (struct block_list *)
# 5435 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0) 
# 5435 "../../../server-code/src/map/clif.c"
     || (bl)->type != (BL_PC)) ? (TBL_PC *)
# 5435 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0) 
# 5435 "../../../server-code/src/map/clif.c"
     : (TBL_PC *)(bl) );

 p.PacketType = sc_notickType;
 p.index = type;
 p.AID = bl->id;
 p.state = (unsigned char)flag;

 clif->send(&p,packet_db[p.PacketType].len, bl, (sd && sd->status.option&OPTION_INVISIBLE) ? SELF : AREA);
}







void clif_status_change(struct block_list *bl,int type,int flag,int tick,int val1, int val2, int val3) {
 struct packet_status_change p;
 struct map_session_data *sd;

 if (type == SI_BLANK)
  return;

 do { if (((void)(bl), 
# 5458 "../../../server-code/src/map/clif.c" 3 4
0
# 5458 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if (!(status->type2relevant_bl_types(type)&bl->type))
  return;

 if ( tick < 0 )
  tick = 9999;

 sd = ( ((bl) == (struct block_list *)
# 5466 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0) 
# 5466 "../../../server-code/src/map/clif.c"
     || (bl)->type != (BL_PC)) ? (TBL_PC *)
# 5466 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0) 
# 5466 "../../../server-code/src/map/clif.c"
     : (TBL_PC *)(bl) );

 p.PacketType = status_changeType;
 p.index = type;
 p.AID = bl->id;
 p.state = (unsigned char)flag;


 p.Total = tick;


 p.Left = tick;
 p.val1 = val1;
 p.val2 = val2;
 p.val3 = val3;

 clif->send(&p,sizeof(p), bl, (sd && sd->status.option&OPTION_INVISIBLE) ? SELF : AREA);
}



void clif_displaymessage(const int fd, const char* mes) {
 do { if (((void)(mes), 
# 5488 "../../../server-code/src/map/clif.c" 3 4
0
# 5488 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if( map->cpsd_active && fd == 0 ) {
  (showmsg->showInfo(("HCP: %s\n"),mes));
 } else if ( fd > 0 ) {



  clif->messagecolor_self(fd, 0x00ff00U, mes);
# 5508 "../../../server-code/src/map/clif.c"
 }
}

void clif_displaymessage2(const int fd, const char* mes) {
 do { if (((void)(mes), 
# 5512 "../../../server-code/src/map/clif.c" 3 4
0
# 5512 "../../../server-code/src/map/clif.c"
)) return; } while(0);


 if (fd == 0 && !map->cpsd_active)
  ;
 else {

  char *message, *line;

  message = (iMalloc->astrdup((mes),"../../../server-code/src/map/clif.c", 5521, __func__));
  line = strtok(message, "\n");
  while(line != 
# 5523 "../../../server-code/src/map/clif.c" 3 4
               ((void *)0)
# 5523 "../../../server-code/src/map/clif.c"
                   ) {

   size_t len = (strlib->strnlen_((line),(255)));

   if (len > 0) {
    if( map->cpsd_active && fd == 0 ) {
     (showmsg->showInfo(("HCP: %s\n"),line));
    } else {
     WFIFOHEAD(fd, 5 + len);
     WFIFOW(fd,0) = 0x8e;
     WFIFOW(fd,2) = 5 + len;
     (strlib->safestrncpy_((WFIFOP(fd,4)),(line),(len + 1)));
     WFIFOSET(fd, 5 + len);
    }
   }
   line = strtok(
# 5538 "../../../server-code/src/map/clif.c" 3 4
                ((void *)0)
# 5538 "../../../server-code/src/map/clif.c"
                    , "\n");
  }
  (iMalloc->free((message),"../../../server-code/src/map/clif.c", 5540, __func__));
 }
}

void clif_displaymessage_sprintf(const int fd, const char *mes, ...) __attribute__((format(printf, 2, 3)));
void clif_displaymessage_sprintf(const int fd, const char *mes, ...) {
 va_list ap;

 do { if (((void)(mes), 
# 5548 "../../../server-code/src/map/clif.c" 3 4
0
# 5548 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if (map->cpsd_active && fd == 0) {
  (showmsg->showInfo(("HCP: ")));
  
# 5551 "../../../server-code/src/map/clif.c" 3 4
 __builtin_va_start(
# 5551 "../../../server-code/src/map/clif.c"
 ap
# 5551 "../../../server-code/src/map/clif.c" 3 4
 ,
# 5551 "../../../server-code/src/map/clif.c"
 mes
# 5551 "../../../server-code/src/map/clif.c" 3 4
 )
# 5551 "../../../server-code/src/map/clif.c"
                 ;
  (showmsg->showMessageV((mes), (ap)));
  
# 5553 "../../../server-code/src/map/clif.c" 3 4
 __builtin_va_end(
# 5553 "../../../server-code/src/map/clif.c"
 ap
# 5553 "../../../server-code/src/map/clif.c" 3 4
 )
# 5553 "../../../server-code/src/map/clif.c"
           ;
  (showmsg->showMessage(("\n")));
 } else if (fd > 0) {
  int len = 1;
  char *ptr;

  WFIFOHEAD(fd, 5 + 255);


  
# 5562 "../../../server-code/src/map/clif.c" 3 4
 __builtin_va_start(
# 5562 "../../../server-code/src/map/clif.c"
 ap
# 5562 "../../../server-code/src/map/clif.c" 3 4
 ,
# 5562 "../../../server-code/src/map/clif.c"
 mes
# 5562 "../../../server-code/src/map/clif.c" 3 4
 )
# 5562 "../../../server-code/src/map/clif.c"
                 ;
  len += vsnprintf(WFIFOP(fd,4), 255, mes, ap);
  
# 5564 "../../../server-code/src/map/clif.c" 3 4
 __builtin_va_end(
# 5564 "../../../server-code/src/map/clif.c"
 ap
# 5564 "../../../server-code/src/map/clif.c" 3 4
 )
# 5564 "../../../server-code/src/map/clif.c"
           ;


  ptr = WFIFOP(fd,4);
  ptr[len - 1] = '\0';


  WFIFOW(fd,0) = 0x8e;
  WFIFOW(fd,2) = 5 + len;

  WFIFOSET(fd, 5 + len);
 }
}


void clif_broadcast(struct block_list *bl, const char *mes, size_t len, int type, enum send_target target)
{
 int lp = (type&BC_COLOR_MASK) ? 4 : 0;
 unsigned char *buf = 
# 5582 "../../../server-code/src/map/clif.c" 3 4
                     ((void *)0)
# 5582 "../../../server-code/src/map/clif.c"
                         ;
 do { if (((void)(mes), 
# 5583 "../../../server-code/src/map/clif.c" 3 4
0
# 5583 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 buf = (iMalloc->malloc(((4 + lp + len)*sizeof(unsigned char)),"../../../server-code/src/map/clif.c", 5585, __func__));

 WBUFW(buf,0) = 0x9a;
 WBUFW(buf,2) = 4 + lp + len;
 if( type&BC_BLUE )
  WBUFL(buf,4) = 0x65756c62;
 else if( type&BC_WOE )
  WBUFL(buf,4) = 0x73737373;
 memcpy(WBUFP(buf, 4 + lp), mes, len);
 clif->send(buf, WBUFW(buf,2), bl, target);

 (iMalloc->free((buf),"../../../server-code/src/map/clif.c", 5596, __func__));
}





void clif_GlobalMessage(struct block_list* bl, const char* message) {
 char buf[256];
 size_t len;
 do { if (((void)(bl), 
# 5606 "../../../server-code/src/map/clif.c" 3 4
0
# 5606 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if(!message)
  return;

 len = strlen(message)+1;

 if (len > sizeof(buf)-8) {
  (showmsg->showWarning(("clif_GlobalMessage: Truncating too long message '%s' (len=%""z" "u"").\n"), message, len));
  len = sizeof(buf)-8;
 }

 WBUFW(buf,0)=0x8d;
 WBUFW(buf,2)=len+8;
 WBUFL(buf,4)=bl->id;
 (strlib->safestrncpy_((WBUFP(buf,8)),(message),(len)));
 clif->send((unsigned char *) buf,WBUFW(buf,2),bl,ALL_CLIENT);

}



void clif_broadcast2(struct block_list* bl, const char* mes, size_t len, unsigned int fontColor, short fontType, short fontSize, short fontAlign, short fontY, enum send_target target)
{
 unsigned char *buf;

 do { if (((void)(mes), 
# 5632 "../../../server-code/src/map/clif.c" 3 4
0
# 5632 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 buf = (unsigned char*)(iMalloc->malloc(((16 + len)*sizeof(unsigned char)),"../../../server-code/src/map/clif.c", 5634, __func__));
 WBUFW(buf,0) = 0x1c3;
 WBUFW(buf,2) = len + 16;
 WBUFL(buf,4) = fontColor;
 WBUFW(buf,8) = fontType;
 WBUFW(buf,10) = fontSize;
 WBUFW(buf,12) = fontAlign;
 WBUFW(buf,14) = fontY;
 memcpy(WBUFP(buf,16), mes, len);
 clif->send(buf, WBUFW(buf,2), bl, target);

 (iMalloc->free((buf),"../../../server-code/src/map/clif.c", 5645, __func__));
}







void clif_heal(int fd,int type,int val)
{
 WFIFOHEAD(fd,packet_db[0x13d].len);
 WFIFOW(fd,0)=0x13d;
 WFIFOW(fd,2)=type;
 WFIFOW(fd,4)=(((val) >= (
# 5659 "../../../server-code/src/map/clif.c" 3 4
             (32767)
# 5659 "../../../server-code/src/map/clif.c"
             )) ? (
# 5659 "../../../server-code/src/map/clif.c" 3 4
             (32767)
# 5659 "../../../server-code/src/map/clif.c"
             ) : ((val) <= (0)) ? (0) : (val));
 WFIFOSET(fd,packet_db[0x13d].len);
}





void clif_resurrection(struct block_list *bl,int type)
{
 unsigned char buf[16];

 do { if (((void)(bl), 
# 5671 "../../../server-code/src/map/clif.c" 3 4
0
# 5671 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0)=0x148;
 WBUFL(buf,2)=bl->id;
 WBUFW(buf,6)=0;

 clif->send(buf,packet_db[0x148].len,bl, type == 1 ? AREA : AREA_WOS);
 if (disguised(bl)) {
  struct map_session_data *sd = ((TBL_PC *)BL_UCAST_(bl));
  if (sd->fontcolor) {
   WBUFL(buf,2)=-bl->id;
   clif->send(buf,packet_db[0x148].len,bl, SELF);
  } else {
   clif->spawn(bl);
  }
 }
}



void clif_map_property(struct map_session_data* sd, enum map_property property)
{
 int fd;

 do { if (((void)(sd), 
# 5695 "../../../server-code/src/map/clif.c" 3 4
0
# 5695 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x199].len);
 WFIFOW(fd,0)=0x199;
 WFIFOW(fd,2)=property;
 WFIFOSET(fd,packet_db[0x199].len);
}



void clif_map_type(struct map_session_data* sd, enum map_type type) {
 int fd;

 do { if (((void)(sd), 
# 5709 "../../../server-code/src/map/clif.c" 3 4
0
# 5709 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x1D6].len);
 WFIFOW(fd,0)=0x1D6;
 WFIFOW(fd,2)=type;
 WFIFOSET(fd,packet_db[0x1D6].len);
}




void clif_pvpset(struct map_session_data *sd,int pvprank,int pvpnum,int type)
{
 do { if (((void)(sd), 
# 5723 "../../../server-code/src/map/clif.c" 3 4
0
# 5723 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if(type == 2) {
  int fd = sd->fd;
  WFIFOHEAD(fd,packet_db[0x19a].len);
  WFIFOW(fd,0) = 0x19a;
  WFIFOL(fd,2) = sd->bl.id;
  WFIFOL(fd,6) = pvprank;
  WFIFOL(fd,10) = pvpnum;
  WFIFOSET(fd,packet_db[0x19a].len);
 } else {
  unsigned char buf[32];
  WBUFW(buf,0) = 0x19a;
  WBUFL(buf,2) = sd->bl.id;
  if (sd->sc.option&(OPTION_HIDE|OPTION_CLOAK))
   WBUFL(buf,6) = ((uint32)0xFFFFFFFFU);
  else
   WBUFL(buf,6) = pvprank;
  WBUFL(buf,10) = pvpnum;
  if (( (sd)->sc.option&OPTION_INVISIBLE ) || sd->disguise != -1)
   clif->send(buf,packet_db[0x19a].len,&sd->bl,SELF);
  else if(!type)
   clif->send(buf,packet_db[0x19a].len,&sd->bl,AREA);
  else
   clif->send(buf,packet_db[0x19a].len,&sd->bl,ALL_SAMEMAP);
 }
}




void clif_map_property_mapall(int mapid, enum map_property property)
{
 struct block_list bl;
 unsigned char buf[16];

 bl.id = 0;
 bl.type = BL_NUL;
 bl.m = mapid;
 WBUFW(buf,0)=0x199;
 WBUFW(buf,2)=property;
 clif->send(buf,packet_db[0x199].len,&bl,ALL_SAMEMAP);
}







void clif_refine(int fd, int fail, int index, int val)
{
 WFIFOHEAD(fd,packet_db[0x188].len);
 WFIFOW(fd,0)=0x188;
 WFIFOW(fd,2)=fail;
 WFIFOW(fd,4)=index+2;
 WFIFOW(fd,6)=val;
 WFIFOSET(fd,packet_db[0x188].len);
}
# 5790 "../../../server-code/src/map/clif.c"
void clif_upgrademessage(int fd, int result, int item_id)
{
 WFIFOHEAD(fd,packet_db[0x223].len);
 WFIFOW(fd,0)=0x223;
 WFIFOL(fd,2)=result;
 WFIFOW(fd,6)=item_id;
 WFIFOSET(fd,packet_db[0x223].len);
}




void clif_wis_message(int fd, const char *nick, const char *mes, size_t mes_len)
{

 struct map_session_data *ssd = 
# 5805 "../../../server-code/src/map/clif.c" 3 4
                               ((void *)0)
# 5805 "../../../server-code/src/map/clif.c"
                                   ;

 do { if (((void)(nick), 
# 5807 "../../../server-code/src/map/clif.c" 3 4
0
# 5807 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(mes), 
# 5808 "../../../server-code/src/map/clif.c" 3 4
0
# 5808 "../../../server-code/src/map/clif.c"
)) return; } while(0);
# 5818 "../../../server-code/src/map/clif.c"
 ssd = map->nick2sd(nick);

 WFIFOHEAD(fd, mes_len + (23 + 1) + 8);
 WFIFOW(fd,0) = 0x97;
 WFIFOW(fd,2) = mes_len + (23 + 1) + 8;
 (strlib->safestrncpy_((WFIFOP(fd,4)),(nick),((23 + 1))));
 WFIFOL(fd,28) = (ssd && ( (ssd)->group->level ) == 99) ? 1 : 0;
 (strlib->safestrncpy_((WFIFOP(fd,32)),(mes),(mes_len)));
 WFIFOSET(fd,WFIFOW(fd,2));

}
# 5837 "../../../server-code/src/map/clif.c"
void clif_wis_end(int fd, int flag) {
 struct map_session_data *sd = sockt->session_is_valid(fd) ? sockt->session[fd]->session_data : 
# 5838 "../../../server-code/src/map/clif.c" 3 4
                                                                                               ((void *)0)
# 5838 "../../../server-code/src/map/clif.c"
                                                                                                   ;
 struct packet_wis_end p;

 if( !sd )
  return;

 p.PacketType = wisendType;
 p.result = (char)flag;

 p.unknown = 0;


 clif->send(&p, sizeof(p), &sd->bl, SELF);
}



void clif_solved_charname(int fd, int charid, const char* name)
{
 do { if (((void)(name), 
# 5857 "../../../server-code/src/map/clif.c" 3 4
0
# 5857 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 WFIFOHEAD(fd,packet_db[0x194].len);
 WFIFOW(fd,0)=0x194;
 WFIFOL(fd,2)=charid;
 (strlib->safestrncpy_((WFIFOP(fd,6)),(name),((23 + 1))));
 WFIFOSET(fd,packet_db[0x194].len);
}



void clif_use_card(struct map_session_data *sd,int idx)
{
 int i, c;
 int fd;

 do { if (((void)(sd), 
# 5872 "../../../server-code/src/map/clif.c" 3 4
0
# 5872 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 if (sd->state.trading != 0)
  return;
 if (!pc->can_insert_card(sd, idx))
  return;

 WFIFOHEAD(fd, 100 * 2 + 4);
 WFIFOW(fd,0) = 0x17b;

 for (i = c = 0; i < 100; i++) {
  if (!pc->can_insert_card_into(sd, idx, i))
   continue;
  WFIFOW(fd,4 + c * 2) = i + 2;
  c++;
 }

 if (!c) return;

 WFIFOW(fd,2) = 4 + c * 2;
 WFIFOSET(fd, WFIFOW(fd,2));
}






void clif_insert_card(struct map_session_data *sd,int idx_equip,int idx_card,int flag)
{
 int fd;

 do { if (((void)(sd), 
# 5904 "../../../server-code/src/map/clif.c" 3 4
0
# 5904 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x17d].len);
 WFIFOW(fd,0)=0x17d;
 WFIFOW(fd,2)=idx_equip+2;
 WFIFOW(fd,4)=idx_card+2;
 WFIFOB(fd,6)=flag;
 WFIFOSET(fd,packet_db[0x17d].len);
}



void clif_item_identify_list(struct map_session_data *sd)
{
 int i,c;
 int fd;

 do { if (((void)(sd), 
# 5922 "../../../server-code/src/map/clif.c" 3 4
0
# 5922 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;

 WFIFOHEAD(fd,100 * 2 + 4);
 WFIFOW(fd,0)=0x177;
 for(i=c=0;i<100;i++){
  if(sd->status.inventory[i].nameid > 0 && !sd->status.inventory[i].identify){
   WFIFOW(fd,c*2+4)=i+2;
   c++;
  }
 }
 if(c > 0) {
  WFIFOW(fd,2)=c*2+4;
  WFIFOSET(fd,WFIFOW(fd,2));
  sd->menuskill_id = MC_IDENTIFY;
  sd->menuskill_val = c;
  sd->state.workinprogress = 3;
 }
}



void clif_item_identified(struct map_session_data *sd,int idx,int flag)
{
 int fd;

 do { if (((void)(sd), 
# 5949 "../../../server-code/src/map/clif.c" 3 4
0
# 5949 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x179].len);
 WFIFOW(fd,0)=0x179;
 WFIFOW(fd,2)=idx+2;
 WFIFOB(fd, 4)=flag;
 WFIFOSET(fd,packet_db[0x179].len);
}



void clif_item_repair_list(struct map_session_data *sd,struct map_session_data *dstsd, int lv)
{
 int i,c;
 int fd;

 do { if (((void)(sd), 
# 5966 "../../../server-code/src/map/clif.c" 3 4
0
# 5966 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(dstsd), 
# 5967 "../../../server-code/src/map/clif.c" 3 4
0
# 5967 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;

 WFIFOHEAD(fd, 100 * 13 + 4);
 WFIFOW(fd,0)=0x1fc;
 for (i = c = 0; i < 100; i++) {
  int nameid = dstsd->status.inventory[i].nameid;
  if (nameid > 0 && dstsd->status.inventory[i].attribute != 0) {
   WFIFOW(fd,c*13+4) = i;
   WFIFOW(fd,c*13+6) = nameid;
   WFIFOB(fd,c*13+8) = dstsd->status.inventory[i].refine;
   clif->addcards(WFIFOP(fd,c*13+9), &dstsd->status.inventory[i]);
   c++;
  }
 }
 if(c > 0) {
  WFIFOW(fd,2)=c*13+4;
  WFIFOSET(fd,WFIFOW(fd,2));
  sd->menuskill_id = BS_REPAIRWEAPON;
  sd->menuskill_val = dstsd->bl.id;
  sd->menuskill_val2 = lv;
 }else
  clif->skill_fail(sd,sd->ud.skill_id,USESKILL_FAIL_LEVEL,0);
}
# 6000 "../../../server-code/src/map/clif.c"
void clif_item_repaireffect(struct map_session_data *sd,int idx,int flag)
{
 int fd;

 do { if (((void)(sd), 
# 6004 "../../../server-code/src/map/clif.c" 3 4
0
# 6004 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;

 WFIFOHEAD(fd,packet_db[0x1fe].len);
 WFIFOW(fd,0)=0x1fe;
 WFIFOW(fd,2)=idx+2;
 WFIFOB(fd, 4)=flag;
 WFIFOSET(fd,packet_db[0x1fe].len);

}



void clif_item_damaged(struct map_session_data* sd, unsigned short position)
{
 int fd;

 do { if (((void)(sd), 
# 6022 "../../../server-code/src/map/clif.c" 3 4
0
# 6022 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;

 WFIFOHEAD(fd,packet_db[0x2bb].len);
 WFIFOW(fd,0) = 0x2bb;
 WFIFOW(fd,2) = position;
 WFIFOL(fd,4) = sd->bl.id;
 WFIFOSET(fd,packet_db[0x2bb].len);
}



void clif_item_refine_list(struct map_session_data *sd)
{
 int i,c;
 int fd;
 uint16 skill_lv;

 do { if (((void)(sd), 
# 6040 "../../../server-code/src/map/clif.c" 3 4
0
# 6040 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 skill_lv = pc->checkskill(sd,WS_WEAPONREFINE);

 fd=sd->fd;

 WFIFOHEAD(fd, 100 * 13 + 4);
 WFIFOW(fd,0)=0x221;
 for (i = c = 0; i < 100; i++) {
  if(sd->status.inventory[i].nameid > 0 && sd->status.inventory[i].identify
   && (itemdb->search(sd->status.inventory[i].nameid)->wlv) >= 1
   && !sd->inventory_data[i]->flag.no_refine
   && !(sd->status.inventory[i].equip&(EQP_HAND_R|EQP_HAND_L))){
   WFIFOW(fd,c*13+ 4)=i+2;
   WFIFOW(fd,c*13+ 6)=sd->status.inventory[i].nameid;
   WFIFOB(fd,c*13+ 8)=sd->status.inventory[i].refine;
   clif->addcards(WFIFOP(fd,c*13+9), &sd->status.inventory[i]);
   c++;
  }
 }
 WFIFOW(fd,2)=c*13+4;
 WFIFOSET(fd,WFIFOW(fd,2));
 if (c > 0) {
  sd->menuskill_id = WS_WEAPONREFINE;
  sd->menuskill_val = skill_lv;
 }
}



void clif_item_skill(struct map_session_data *sd,uint16 skill_id,uint16 skill_lv)
{
 int fd;

 do { if (((void)(sd), 
# 6074 "../../../server-code/src/map/clif.c" 3 4
0
# 6074 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x147].len);
 WFIFOW(fd,0)=0x147;
 WFIFOW(fd,2)=skill_id;
 WFIFOW(fd,4)=skill->get_inf(skill_id);
 WFIFOW(fd,6)=0;
 WFIFOW(fd,8)=skill_lv;
 WFIFOW(fd,10)=skill->get_sp(skill_id,skill_lv);
 WFIFOW(fd,12)=skill->get_range2(&sd->bl, skill_id,skill_lv);
 (strlib->safestrncpy_((WFIFOP(fd,14)),(skill->get_name(skill_id)),((23 + 1))));
 WFIFOB(fd,38)=0;
 WFIFOSET(fd,packet_db[0x147].len);
}




void clif_cart_additem(struct map_session_data *sd,int n,int amount,int fail)
{
 int view,fd;
 unsigned char *buf;
 int offset = 0;

 do { if (((void)(sd), 
# 6099 "../../../server-code/src/map/clif.c" 3 4
0
# 6099 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 if(n<0 || n>=100 || sd->status.cart[n].nameid<=0)
  return;

 WFIFOHEAD(fd,packet_db[cartaddType].len);
 buf=WFIFOP(fd,0);
 WBUFW(buf,0)=cartaddType;
 WBUFW(buf,2)=n+2;
 WBUFL(buf,4)=amount;
 if((view = (itemdb->search(sd->status.cart[n].nameid)->view_id)) > 0)
  WBUFW(buf,8)=view;
 else
  WBUFW(buf,8)=sd->status.cart[n].nameid;

 WBUFB(buf,10)=(itemdb->search(sd->status.cart[n].nameid)->type);
 offset = 1;

 WBUFB(buf,10+offset)=sd->status.cart[n].identify;
 WBUFB(buf,11+offset)=sd->status.cart[n].attribute;
 WBUFB(buf,12+offset)=sd->status.cart[n].refine;
 clif->addcards(WBUFP(buf,13+offset), &sd->status.cart[n]);



 WFIFOSET(fd,packet_db[cartaddType].len);
}



void clif_cart_delitem(struct map_session_data *sd,int n,int amount)
{
 int fd;

 do { if (((void)(sd), 
# 6134 "../../../server-code/src/map/clif.c" 3 4
0
# 6134 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;

 WFIFOHEAD(fd,packet_db[0x125].len);
 WFIFOW(fd,0)=0x125;
 WFIFOW(fd,2)=n+2;
 WFIFOL(fd,4)=amount;
 WFIFOSET(fd,packet_db[0x125].len);
}





void clif_openvendingreq(struct map_session_data* sd, int num)
{
 int fd;

 do { if (((void)(sd), 
# 6153 "../../../server-code/src/map/clif.c" 3 4
0
# 6153 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x12d].len);
 WFIFOW(fd,0) = 0x12d;
 WFIFOW(fd,2) = num;
 WFIFOSET(fd,packet_db[0x12d].len);
}



void clif_showvendingboard(struct block_list* bl, const char* message, int fd)
{
 unsigned char buf[128];

 do { if (((void)(bl), 
# 6168 "../../../server-code/src/map/clif.c" 3 4
0
# 6168 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0x131;
 WBUFL(buf,2) = bl->id;
 (strlib->safestrncpy_((WBUFP(buf,6)),(message),(80)));

 if( fd ) {
  WFIFOHEAD(fd,packet_db[0x131].len);
  memcpy(WFIFOP(fd,0),buf,packet_db[0x131].len);
  WFIFOSET(fd,packet_db[0x131].len);
 } else {
  clif->send(buf,packet_db[0x131].len,bl,AREA_WOS);
 }
}



void clif_closevendingboard(struct block_list* bl, int fd)
{
 unsigned char buf[16];

 do { if (((void)(bl), 
# 6189 "../../../server-code/src/map/clif.c" 3 4
0
# 6189 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0x132;
 WBUFL(buf,2) = bl->id;
 if( fd ) {
  WFIFOHEAD(fd,packet_db[0x132].len);
  memcpy(WFIFOP(fd,0),buf,packet_db[0x132].len);
  WFIFOSET(fd,packet_db[0x132].len);
 } else {
  clif->send(buf,packet_db[0x132].len,bl,AREA_WOS);
 }
}




void clif_vendinglist(struct map_session_data* sd, unsigned int id, struct s_vending* vending_items) {
 int i,fd;
 int count;
 struct map_session_data* vsd;




 const int cmd = 0x800;
 const int offset = 12;





 const int item_length = 22;


 do { if (((void)(sd), 
# 6223 "../../../server-code/src/map/clif.c" 3 4
0
# 6223 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(vending_items), 
# 6224 "../../../server-code/src/map/clif.c" 3 4
0
# 6224 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(vsd=map->id2sd(id)), 
# 6225 "../../../server-code/src/map/clif.c" 3 4
0
# 6225 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 count = vsd->vend_num;

 WFIFOHEAD(fd, offset+count*item_length);
 WFIFOW(fd,0) = cmd;
 WFIFOW(fd,2) = offset+count*item_length;
 WFIFOL(fd,4) = id;

 WFIFOL(fd,8) = vsd->vender_id;


 for( i = 0; i < count; i++ ) {
  int index = vending_items[i].index;
  struct item_data* data = itemdb->search(vsd->status.cart[index].nameid);
  WFIFOL(fd,offset+ 0+i*item_length) = vending_items[i].value;
  WFIFOW(fd,offset+ 4+i*item_length) = vending_items[i].amount;
  WFIFOW(fd,offset+ 6+i*item_length) = vending_items[i].index + 2;
  WFIFOB(fd,offset+ 8+i*item_length) = itemtype(data->type);
  WFIFOW(fd,offset+ 9+i*item_length) = ( data->view_id > 0 ) ? data->view_id : vsd->status.cart[index].nameid;
  WFIFOB(fd,offset+11+i*item_length) = vsd->status.cart[index].identify;
  WFIFOB(fd,offset+12+i*item_length) = vsd->status.cart[index].attribute;
  WFIFOB(fd,offset+13+i*item_length) = vsd->status.cart[index].refine;
  clif->addcards(WFIFOP(fd,offset+14+i*item_length), &vsd->status.cart[index]);



 }
 WFIFOSET(fd,WFIFOW(fd,2));
}
# 6267 "../../../server-code/src/map/clif.c"
void clif_buyvending(struct map_session_data* sd, int index, int amount, int fail)
{
 int fd;

 do { if (((void)(sd), 
# 6271 "../../../server-code/src/map/clif.c" 3 4
0
# 6271 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x135].len);
 WFIFOW(fd,0) = 0x135;
 WFIFOW(fd,2) = index+2;
 WFIFOW(fd,4) = amount;
 WFIFOB(fd,6) = fail;
 WFIFOSET(fd,packet_db[0x135].len);
}



void clif_openvending(struct map_session_data* sd, int id, struct s_vending* vending_items) {
 int i,fd;
 int count;




 const int item_length = 22;


 do { if (((void)(sd), 
# 6294 "../../../server-code/src/map/clif.c" 3 4
0
# 6294 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(vending_items), 
# 6295 "../../../server-code/src/map/clif.c" 3 4
0
# 6295 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 count = sd->vend_num;

 WFIFOHEAD(fd, 8+count*item_length);
 WFIFOW(fd,0) = 0x136;
 WFIFOW(fd,2) = 8+count*item_length;
 WFIFOL(fd,4) = id;
 for( i = 0; i < count; i++ ) {
  int index = vending_items[i].index;
  struct item_data* data = itemdb->search(sd->status.cart[index].nameid);
  WFIFOL(fd, 8+i*item_length) = vending_items[i].value;
  WFIFOW(fd,12+i*item_length) = vending_items[i].index + 2;
  WFIFOW(fd,14+i*item_length) = vending_items[i].amount;
  WFIFOB(fd,16+i*item_length) = itemtype(data->type);
  WFIFOW(fd,17+i*item_length) = ( data->view_id > 0 ) ? data->view_id : sd->status.cart[index].nameid;
  WFIFOB(fd,19+i*item_length) = sd->status.cart[index].identify;
  WFIFOB(fd,20+i*item_length) = sd->status.cart[index].attribute;
  WFIFOB(fd,21+i*item_length) = sd->status.cart[index].refine;
  clif->addcards(WFIFOP(fd,22+i*item_length), &sd->status.cart[index]);



 }
 WFIFOSET(fd,WFIFOW(fd,2));



 WFIFOHEAD(fd, 3);
 WFIFOW(fd,0) = 0xa28;
 WFIFOB(fd, 2) = 0;
 WFIFOSET(fd, 3);

}



void clif_vendingreport(struct map_session_data* sd, int index, int amount)
{
 int fd;

 do { if (((void)(sd), 
# 6337 "../../../server-code/src/map/clif.c" 3 4
0
# 6337 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x137].len);
 WFIFOW(fd,0) = 0x137;
 WFIFOW(fd,2) = index+2;
 WFIFOW(fd,4) = amount;
 WFIFOSET(fd,packet_db[0x137].len);
}
# 6355 "../../../server-code/src/map/clif.c"
void clif_party_created(struct map_session_data *sd,int result)
{
 int fd;

 do { if (((void)(sd), 
# 6359 "../../../server-code/src/map/clif.c" 3 4
0
# 6359 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0xfa].len);
 WFIFOW(fd,0)=0xfa;
 WFIFOB(fd,2)=result;
 WFIFOSET(fd,packet_db[0xfa].len);
}
# 6377 "../../../server-code/src/map/clif.c"
void clif_party_member_info(struct party_data *p, struct map_session_data *sd)
{
 unsigned char buf[81];
 int i;

 do { if (((void)(p), 
# 6382 "../../../server-code/src/map/clif.c" 3 4
0
# 6382 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(sd), 
# 6383 "../../../server-code/src/map/clif.c" 3 4
0
# 6383 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if (!sd) {
  do { for ((i) = (0); (i) < (12); ++(i)) if (p->data[i].sd != 0) break; } while(
# 6385 "../../../server-code/src/map/clif.c" 3 4
 0
# 6385 "../../../server-code/src/map/clif.c"
 );
 } else {
  do { for ((i) = (0); (i) < (12); ++(i)) if (p->data[i].sd == sd) break; } while(
# 6387 "../../../server-code/src/map/clif.c" 3 4
 0
# 6387 "../../../server-code/src/map/clif.c"
 );
 }
 if (i >= 12) return;
 sd = p->data[i].sd;

 WBUFW(buf,0) = 0x1e9;
 WBUFL(buf, 2) = sd->status.account_id;
 WBUFL(buf, 6) = (p->party.member[i].leader)?0:1;
 WBUFW(buf,10) = sd->bl.x;
 WBUFW(buf,12) = sd->bl.y;
 WBUFB(buf,14) = (p->party.member[i].online)?0:1;
 memcpy(WBUFP(buf,15), p->party.name, (23 + 1));
 memcpy(WBUFP(buf,39), sd->status.name, (23 + 1));
 mapindex->getmapname_ext(map->list[sd->bl.m].custom_name ? map->list[map->list[sd->bl.m].instance_src_map].name : map->list[sd->bl.m].name, WBUFP(buf,63));
 WBUFB(buf,79) = (p->party.item&1)?1:0;
 WBUFB(buf,80) = (p->party.item&2)?1:0;
 clif->send(buf,packet_db[0x1e9].len,&sd->bl,PARTY);
}
# 6414 "../../../server-code/src/map/clif.c"
void clif_party_info(struct party_data* p, struct map_session_data *sd)
{
 unsigned char buf[2+2+(23 + 1)+(4+(23 + 1)+((11 + 1) + 4)+1+1)*12];
 struct map_session_data* party_sd = 
# 6417 "../../../server-code/src/map/clif.c" 3 4
                                    ((void *)0)
# 6417 "../../../server-code/src/map/clif.c"
                                        ;
 int i, c;

 do { if (((void)(p), 
# 6420 "../../../server-code/src/map/clif.c" 3 4
0
# 6420 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0xfb;
 memcpy(WBUFP(buf,4), p->party.name, (23 + 1));
 for(i = 0, c = 0; i < 12; i++)
 {
  struct party_member* m = &p->party.member[i];
  if(!m->account_id) continue;

  if(party_sd == 
# 6429 "../../../server-code/src/map/clif.c" 3 4
                ((void *)0)
# 6429 "../../../server-code/src/map/clif.c"
                    ) party_sd = p->data[i].sd;

  WBUFL(buf,28+c*46) = m->account_id;
  memcpy(WBUFP(buf,28+c*46+4), m->name, (23 + 1));
  mapindex->getmapname_ext(mapindex->id2name((m->map),"../../../server-code/src/map/clif.c", 6433, __func__), WBUFP(buf,28+c*46+28));
  WBUFB(buf,28+c*46+44) = (m->leader) ? 0 : 1;
  WBUFB(buf,28+c*46+45) = (m->online) ? 0 : 1;
  c++;
 }
 WBUFW(buf,2) = 28+c*46;

 if(sd) {
  clif->send(buf, WBUFW(buf,2), &sd->bl, SELF);
 } else if (party_sd) {
  clif->send(buf, WBUFW(buf,2), &party_sd->bl, PARTY);
 }
}






void clif_partyinvitationstate(struct map_session_data* sd)
{
 int fd;
 do { if (((void)(sd), 
# 6455 "../../../server-code/src/map/clif.c" 3 4
0
# 6455 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;

 WFIFOHEAD(fd, packet_db[0x2c9].len);
 WFIFOW(fd,0) = 0x2c9;
 WFIFOB(fd, 2) = sd->status.allow_party ? 1 : 0;
 WFIFOSET(fd, packet_db[0x2c9].len);
}




void clif_party_invite(struct map_session_data *sd,struct map_session_data *tsd)
{



 const int cmd = 0x2c6;

 int fd;
 struct party_data *p;

 do { if (((void)(sd), 
# 6477 "../../../server-code/src/map/clif.c" 3 4
0
# 6477 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(tsd), 
# 6478 "../../../server-code/src/map/clif.c" 3 4
0
# 6478 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=tsd->fd;

 if( (p=party->search(sd->status.party_id))==
# 6482 "../../../server-code/src/map/clif.c" 3 4
                                            ((void *)0) 
# 6482 "../../../server-code/src/map/clif.c"
                                                 )
  return;

 WFIFOHEAD(fd,packet_db[cmd].len);
 WFIFOW(fd,0)=cmd;
 WFIFOL(fd,2)=sd->status.party_id;
 memcpy(WFIFOP(fd,6),p->party.name,(23 + 1));
 WFIFOSET(fd,packet_db[cmd].len);
}
# 6504 "../../../server-code/src/map/clif.c"
void clif_party_inviteack(struct map_session_data* sd, const char* nick, int result)
{
 int fd;
 do { if (((void)(sd), 
# 6507 "../../../server-code/src/map/clif.c" 3 4
0
# 6507 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(nick), 
# 6508 "../../../server-code/src/map/clif.c" 3 4
0
# 6508 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd=sd->fd;
# 6525 "../../../server-code/src/map/clif.c"
 WFIFOHEAD(fd,packet_db[0x2c5].len);
 WFIFOW(fd,0) = 0x2c5;
 (strlib->safestrncpy_((WFIFOP(fd,2)),(nick),((23 + 1))));
 WFIFOL(fd,26) = result;
 WFIFOSET(fd,packet_db[0x2c5].len);

}
# 6544 "../../../server-code/src/map/clif.c"
void clif_party_option(struct party_data *p,struct map_session_data *sd,int flag)
{
 unsigned char buf[16];



 const int cmd = 0x7d8;


 do { if (((void)(p), 
# 6553 "../../../server-code/src/map/clif.c" 3 4
0
# 6553 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if(!sd && flag==0){
  int i;
  for(i=0;i<12 && !p->data[i].sd;i++)
   ;
  if (i < 12)
   sd = p->data[i].sd;
 }
 if(!sd) return;
 WBUFW(buf,0)=cmd;
 WBUFL(buf,2)=((flag&0x01)?2:p->party.exp);

 WBUFB(buf,6)=(p->party.item&1)?1:0;
 WBUFB(buf,7)=(p->party.item&2)?1:0;

 if(flag==0)
  clif->send(buf,packet_db[cmd].len,&sd->bl,PARTY);
 else
  clif->send(buf,packet_db[cmd].len,&sd->bl,SELF);
}







void clif_party_withdraw(struct party_data* p, struct map_session_data* sd, int account_id, const char* name, int flag)
{
 unsigned char buf[64];

 do { if (((void)(p), 
# 6585 "../../../server-code/src/map/clif.c" 3 4
0
# 6585 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(name), 
# 6586 "../../../server-code/src/map/clif.c" 3 4
0
# 6586 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if(!sd && (flag&0xf0)==0) {
  int i;

  do { for ((i) = (0); (i) < (12); ++(i)) if (p->data[i].sd != 
# 6591 "../../../server-code/src/map/clif.c" 3 4
 ((void *)0)
# 6591 "../../../server-code/src/map/clif.c"
 ) break; } while(
# 6591 "../../../server-code/src/map/clif.c" 3 4
 0
# 6591 "../../../server-code/src/map/clif.c"
 );
  if (i != 12)
   sd = p->data[i].sd;
 }

 if (!sd)
  return;

 WBUFW(buf,0)=0x105;
 WBUFL(buf,2)=account_id;
 memcpy(WBUFP(buf,6),name,(23 + 1));
 WBUFB(buf,30)=flag&0x0f;
 if((flag&0xf0)==0)
  clif->send(buf,packet_db[0x105].len,&sd->bl,PARTY);
 else
  clif->send(buf,packet_db[0x105].len,&sd->bl,SELF);
}



void clif_party_message(struct party_data* p, int account_id, const char* mes, int len)
{
 struct map_session_data *sd;
 int i;

 do { if (((void)(p), 
# 6616 "../../../server-code/src/map/clif.c" 3 4
0
# 6616 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(mes), 
# 6617 "../../../server-code/src/map/clif.c" 3 4
0
# 6617 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 for(i=0; i < 12 && !p->data[i].sd;i++);
 if(i < 12){
  unsigned char buf[1024];

  if (len > sizeof(buf)-8) {
   (showmsg->showWarning(("clif_party_message: Truncated message '%s' (len=%d, max=%""z" "u"", party_id=%d).\n"), mes, len, sizeof(buf)-8, p->party.party_id))
                                                          ;
   len = sizeof(buf)-8;
  }

  sd = p->data[i].sd;
  WBUFW(buf,0)=0x109;
  WBUFW(buf,2)=len+8;
  WBUFL(buf,4)=account_id;
  (strlib->safestrncpy_((WBUFP(buf,8)),(mes),(len)));
  clif->send(buf,len+8,&sd->bl,PARTY);
 }
}



void clif_party_xy(struct map_session_data *sd)
{
 unsigned char buf[16];

 do { if (((void)(sd), 
# 6644 "../../../server-code/src/map/clif.c" 3 4
0
# 6644 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0)=0x107;
 WBUFL(buf,2)=sd->status.account_id;
 WBUFW(buf,6)=sd->bl.x;
 WBUFW(buf,8)=sd->bl.y;
 clif->send(buf,packet_db[0x107].len,&sd->bl,PARTY_SAMEMAP_WOS);
}




void clif_party_xy_single(int fd, struct map_session_data *sd)
{
 do { if (((void)(sd), 
# 6658 "../../../server-code/src/map/clif.c" 3 4
0
# 6658 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 WFIFOHEAD(fd,packet_db[0x107].len);
 WFIFOW(fd,0)=0x107;
 WFIFOL(fd,2)=sd->status.account_id;
 WFIFOW(fd,6)=sd->bl.x;
 WFIFOW(fd,8)=sd->bl.y;
 WFIFOSET(fd,packet_db[0x107].len);
}




void clif_party_hp(struct map_session_data *sd)
{
 unsigned char buf[16];



 const int cmd = 0x80e;


 do { if (((void)(sd), 
# 6679 "../../../server-code/src/map/clif.c" 3 4
0
# 6679 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0)=cmd;
 WBUFL(buf,2)=sd->status.account_id;
# 6692 "../../../server-code/src/map/clif.c"
 WBUFL(buf,6) = sd->battle_status.hp;
 WBUFL(buf,10) = sd->battle_status.max_hp;

 clif->send(buf,packet_db[cmd].len,&sd->bl,PARTY_AREA_WOS);
}




void clif_hpmeter_single(int fd, int id, unsigned int hp, unsigned int maxhp)
{



 const int cmd = 0x80e;

 WFIFOHEAD(fd,packet_db[cmd].len);
 WFIFOW(fd,0) = cmd;
 WFIFOL(fd,2) = id;
# 6721 "../../../server-code/src/map/clif.c"
 WFIFOL(fd,6) = hp;
 WFIFOL(fd,10) = maxhp;

 WFIFOSET(fd, packet_db[cmd].len);
}



void clif_movetoattack(struct map_session_data *sd,struct block_list *bl)
{
 int fd;

 do { if (((void)(sd), 
# 6733 "../../../server-code/src/map/clif.c" 3 4
0
# 6733 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(bl), 
# 6734 "../../../server-code/src/map/clif.c" 3 4
0
# 6734 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x139].len);
 WFIFOW(fd,0)=0x139;
 WFIFOL(fd, 2)=bl->id;
 WFIFOW(fd,6)=bl->x;
 WFIFOW(fd,8)=bl->y;
 WFIFOW(fd,10)=sd->bl.x;
 WFIFOW(fd,12)=sd->bl.y;
 WFIFOW(fd,14)=sd->battle_status.rhw.range;
 WFIFOSET(fd,packet_db[0x139].len);
}
# 6755 "../../../server-code/src/map/clif.c"
void clif_produceeffect(struct map_session_data* sd,int flag,int nameid)
{
 int view,fd;

 do { if (((void)(sd), 
# 6759 "../../../server-code/src/map/clif.c" 3 4
0
# 6759 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 clif->solved_charname(fd, sd->status.char_id, sd->status.name);
 WFIFOHEAD(fd,packet_db[0x18f].len);
 WFIFOW(fd,0)=0x18f;
 WFIFOW(fd,2)=flag;
 if((view = (itemdb->search(nameid)->view_id)) > 0)
  WFIFOW(fd,4)=view;
 else
  WFIFOW(fd,4)=nameid;
 WFIFOSET(fd,packet_db[0x18f].len);
}



void clif_catch_process(struct map_session_data *sd)
{
 int fd;

 do { if (((void)(sd), 
# 6779 "../../../server-code/src/map/clif.c" 3 4
0
# 6779 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x19e].len);
 WFIFOW(fd,0)=0x19e;
 WFIFOSET(fd,packet_db[0x19e].len);
}





void clif_pet_roulette(struct map_session_data *sd,int data)
{
 int fd;

 do { if (((void)(sd), 
# 6795 "../../../server-code/src/map/clif.c" 3 4
0
# 6795 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x1a0].len);
 WFIFOW(fd,0)=0x1a0;
 WFIFOB(fd,2)=data;
 WFIFOSET(fd,packet_db[0x1a0].len);
}



void clif_sendegg(struct map_session_data *sd) {
 int i, n, fd;

 do { if (((void)(sd), 
# 6809 "../../../server-code/src/map/clif.c" 3 4
0
# 6809 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 if (battle_config.pet_no_gvg && (map->list[sd->bl.m].flag.gvg || map->list[sd->bl.m].flag.gvg_castle)) {
  clif->message(fd, atcommand->msgsd((sd),(866)));
  return;
 }

 WFIFOHEAD(fd, 100 * 2 + 4);
 WFIFOW(fd,0) = 0x1a6;
 for (i = n = 0; i < 100; i++) {
  if (sd->status.inventory[i].nameid <= 0 || sd->inventory_data[i] == 
# 6820 "../../../server-code/src/map/clif.c" 3 4
                                                                     ((void *)0) 
# 6820 "../../../server-code/src/map/clif.c"
                                                                          || sd->inventory_data[i]->type!=IT_PETEGG || sd->status.inventory[i].amount <= 0)
   continue;
  WFIFOW(fd,n * 2 + 4) = i + 2;
  n++;
 }

 if (!n) return;

 WFIFOW(fd,2) = 4 + n * 2;
 WFIFOSET(fd, WFIFOW(fd,2));

 sd->menuskill_id = SA_TAMINGMONSTER;
 sd->menuskill_val = -1;
}
# 6846 "../../../server-code/src/map/clif.c"
void clif_send_petdata(struct map_session_data* sd, struct pet_data* pd, int type, int param)
{
 uint8 buf[16];
 do { if (((void)(pd), 
# 6849 "../../../server-code/src/map/clif.c" 3 4
0
# 6849 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0x1a4;
 WBUFB(buf,2) = type;
 WBUFL(buf,3) = pd->bl.id;
 WBUFL(buf,7) = param;
 if (sd)
  clif->send(buf, packet_db[0x1a4].len, &sd->bl, SELF);
 else
  clif->send(buf, packet_db[0x1a4].len, &pd->bl, AREA);
}



void clif_send_petstatus(struct map_session_data *sd)
{
 int fd;
 struct s_pet *p;

 do { if (((void)(sd), 
# 6868 "../../../server-code/src/map/clif.c" 3 4
0
# 6868 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(sd->pd), 
# 6869 "../../../server-code/src/map/clif.c" 3 4
0
# 6869 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 p = &sd->pd->pet;
 WFIFOHEAD(fd,packet_db[0x1a2].len);
 WFIFOW(fd,0)=0x1a2;
 memcpy(WFIFOP(fd,2),p->name,(23 + 1));
 WFIFOB(fd,26)=battle_config.pet_rename?0:p->rename_flag;
 WFIFOW(fd,27)=p->level;
 WFIFOW(fd,29)=p->hungry;
 WFIFOW(fd,31)=p->intimate;
 WFIFOW(fd,33)=p->equip;

 WFIFOW(fd,35)=p->class_;

 WFIFOSET(fd,packet_db[0x1a2].len);
}





void clif_pet_emotion(struct pet_data *pd,int param)
{
 unsigned char buf[16];

 do { if (((void)(pd), 
# 6895 "../../../server-code/src/map/clif.c" 3 4
0
# 6895 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 memset(buf,0,packet_db[0x1aa].len);

 WBUFW(buf,0)=0x1aa;
 WBUFL(buf,2)=pd->bl.id;
 if(param >= 100 && pd->petDB->talk_convert_class) {
  if(pd->petDB->talk_convert_class < 0)
   return;
  else if(pd->petDB->talk_convert_class > 0) {

   param -= (pd->pet.class_ - 100)*100;
   param += (pd->petDB->talk_convert_class - 100)*100;
  }
 }
 WBUFL(buf,6)=param;

 clif->send(buf,packet_db[0x1aa].len,&pd->bl,AREA);
}






void clif_pet_food(struct map_session_data *sd,int foodid,int fail)
{
 int fd;

 do { if (((void)(sd), 
# 6924 "../../../server-code/src/map/clif.c" 3 4
0
# 6924 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x1a3].len);
 WFIFOW(fd,0)=0x1a3;
 WFIFOB(fd,2)=fail;
 WFIFOW(fd,3)=foodid;
 WFIFOSET(fd,packet_db[0x1a3].len);
}



void clif_autospell(struct map_session_data *sd,uint16 skill_lv)
{
 int fd;

 do { if (((void)(sd), 
# 6940 "../../../server-code/src/map/clif.c" 3 4
0
# 6940 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x1cd].len);
 WFIFOW(fd,0)=0x1cd;

 if(skill_lv>0 && pc->checkskill(sd,MG_NAPALMBEAT)>0)
  WFIFOL(fd,2)= MG_NAPALMBEAT;
 else
  WFIFOL(fd,2)= 0x00000000;
 if(skill_lv>1 && pc->checkskill(sd,MG_COLDBOLT)>0)
  WFIFOL(fd,6)= MG_COLDBOLT;
 else
  WFIFOL(fd,6)= 0x00000000;
 if(skill_lv>1 && pc->checkskill(sd,MG_FIREBOLT)>0)
  WFIFOL(fd,10)= MG_FIREBOLT;
 else
  WFIFOL(fd,10)= 0x00000000;
 if(skill_lv>1 && pc->checkskill(sd,MG_LIGHTNINGBOLT)>0)
  WFIFOL(fd,14)= MG_LIGHTNINGBOLT;
 else
  WFIFOL(fd,14)= 0x00000000;
 if(skill_lv>4 && pc->checkskill(sd,MG_SOULSTRIKE)>0)
  WFIFOL(fd,18)= MG_SOULSTRIKE;
 else
  WFIFOL(fd,18)= 0x00000000;
 if(skill_lv>7 && pc->checkskill(sd,MG_FIREBALL)>0)
  WFIFOL(fd,22)= MG_FIREBALL;
 else
  WFIFOL(fd,22)= 0x00000000;
 if(skill_lv>9 && pc->checkskill(sd,MG_FROSTDIVER)>0)
  WFIFOL(fd,26)= MG_FROSTDIVER;
 else
  WFIFOL(fd,26)= 0x00000000;

 WFIFOSET(fd,packet_db[0x1cd].len);
 sd->menuskill_id = SA_AUTOSPELL;
 sd->menuskill_val = skill_lv;
}



void clif_devotion(struct block_list *src, struct map_session_data *tsd)
{
 unsigned char buf[56];

 do { if (((void)(src), 
# 6986 "../../../server-code/src/map/clif.c" 3 4
0
# 6986 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 memset(buf,0,packet_db[0x1cf].len);

 WBUFW(buf,0) = 0x1cf;
 WBUFL(buf,2) = src->id;
 if( src->type == BL_MER )
 {
  struct mercenary_data *md = ( ((src) == (struct block_list *)
# 6993 "../../../server-code/src/map/clif.c" 3 4
                             ((void *)0) 
# 6993 "../../../server-code/src/map/clif.c"
                             || (src)->type != (BL_MER)) ? (TBL_MER *)
# 6993 "../../../server-code/src/map/clif.c" 3 4
                             ((void *)0) 
# 6993 "../../../server-code/src/map/clif.c"
                             : (TBL_MER *)(src) );
  if( md && md->master && md->devotion_flag )
   WBUFL(buf,6) = md->master->bl.id;

  WBUFW(buf,26) = skill->get_range2(src, ML_DEVOTION, mercenary->checkskill(md, ML_DEVOTION));
 }
 else
 {
  int i;
  struct map_session_data *sd = ( ((src) == (struct block_list *)
# 7002 "../../../server-code/src/map/clif.c" 3 4
                               ((void *)0) 
# 7002 "../../../server-code/src/map/clif.c"
                               || (src)->type != (BL_PC)) ? (TBL_PC *)
# 7002 "../../../server-code/src/map/clif.c" 3 4
                               ((void *)0) 
# 7002 "../../../server-code/src/map/clif.c"
                               : (TBL_PC *)(src) );
  if( sd == 
# 7003 "../../../server-code/src/map/clif.c" 3 4
           ((void *)0) 
# 7003 "../../../server-code/src/map/clif.c"
                )
   return;

  for( i = 0; i < 5; i++ )
   WBUFL(buf,6+4*i) = sd->devotion[i];
  WBUFW(buf,26) = skill->get_range2(src, CR_DEVOTION, pc->checkskill(sd, CR_DEVOTION));
 }

 if( tsd )
  clif->send(buf, packet_db[0x1cf].len, &tsd->bl, SELF);
 else
  clif->send(buf, packet_db[0x1cf].len, src, AREA);
}







void clif_spiritball(struct block_list *bl) {
 unsigned char buf[16];
 struct map_session_data *sd = ( ((bl) == (struct block_list *)
# 7025 "../../../server-code/src/map/clif.c" 3 4
                              ((void *)0) 
# 7025 "../../../server-code/src/map/clif.c"
                              || (bl)->type != (BL_PC)) ? (TBL_PC *)
# 7025 "../../../server-code/src/map/clif.c" 3 4
                              ((void *)0) 
# 7025 "../../../server-code/src/map/clif.c"
                              : (TBL_PC *)(bl) );
 struct homun_data *hd = ( ((bl) == (struct block_list *)
# 7026 "../../../server-code/src/map/clif.c" 3 4
                        ((void *)0) 
# 7026 "../../../server-code/src/map/clif.c"
                        || (bl)->type != (BL_HOM)) ? (TBL_HOM *)
# 7026 "../../../server-code/src/map/clif.c" 3 4
                        ((void *)0) 
# 7026 "../../../server-code/src/map/clif.c"
                        : (TBL_HOM *)(bl) );

 do { if (((void)(bl), 
# 7028 "../../../server-code/src/map/clif.c" 3 4
0
# 7028 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0x1d0;
 WBUFL(buf, 2) = bl->id;
 WBUFW(buf,6) = 0;
 switch(bl->type){
  case BL_PC: WBUFW(buf,6) = sd->spiritball; break;
  case BL_HOM: WBUFW(buf,6) = hd->homunculus.spiritball; break;
 }
 clif->send(buf, packet_db[0x1d0].len, bl, AREA);
}



void clif_combo_delay(struct block_list *bl,int wait)
{
 unsigned char buf[32];

 do { if (((void)(bl), 
# 7046 "../../../server-code/src/map/clif.c" 3 4
0
# 7046 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0)=0x1d2;
 WBUFL(buf,2)=bl->id;
 WBUFL(buf,6)=wait;
 clif->send(buf,packet_db[0x1d2].len,bl,AREA);
}






void clif_bladestop(struct block_list *src, int dst_id, int active)
{
 unsigned char buf[32];

 do { if (((void)(src), 
# 7063 "../../../server-code/src/map/clif.c" 3 4
0
# 7063 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0)=0x1d1;
 WBUFL(buf,2)=src->id;
 WBUFL(buf,6)=dst_id;
 WBUFL(buf,10)=active;

 clif->send(buf,packet_db[0x1d1].len,src,AREA);
}



void clif_mvp_effect(struct map_session_data *sd)
{
 unsigned char buf[16];

 do { if (((void)(sd), 
# 7079 "../../../server-code/src/map/clif.c" 3 4
0
# 7079 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0)=0x10c;
 WBUFL(buf,2)=sd->bl.id;
 clif->send(buf,packet_db[0x10c].len,&sd->bl,AREA);
}



void clif_mvp_item(struct map_session_data *sd,int nameid)
{
 int view,fd;

 do { if (((void)(sd), 
# 7092 "../../../server-code/src/map/clif.c" 3 4
0
# 7092 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x10a].len);
 WFIFOW(fd,0)=0x10a;
 if((view = (itemdb->search(nameid)->view_id)) > 0)
  WFIFOW(fd,2)=view;
 else
  WFIFOW(fd,2)=nameid;
 WFIFOSET(fd,packet_db[0x10a].len);
}



void clif_mvp_exp(struct map_session_data *sd, unsigned int exp)
{
 int fd;

 do { if (((void)(sd), 
# 7110 "../../../server-code/src/map/clif.c" 3 4
0
# 7110 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x10b].len);
 WFIFOW(fd,0)=0x10b;
 WFIFOL(fd,2)=(((exp) >= (
# 7115 "../../../server-code/src/map/clif.c" 3 4
             (2147483647)
# 7115 "../../../server-code/src/map/clif.c"
             )) ? (
# 7115 "../../../server-code/src/map/clif.c" 3 4
             (2147483647)
# 7115 "../../../server-code/src/map/clif.c"
             ) : ((exp) <= (0)) ? (0) : (exp));
 WFIFOSET(fd,packet_db[0x10b].len);
}






void clif_mvp_noitem(struct map_session_data* sd)
{
 int fd = sd->fd;

 WFIFOHEAD(fd,packet_db[0x10d].len);
 WFIFOW(fd,0) = 0x10d;
 WFIFOSET(fd,packet_db[0x10d].len);
}
# 7140 "../../../server-code/src/map/clif.c"
void clif_guild_created(struct map_session_data *sd,int flag)
{
 int fd;

 do { if (((void)(sd), 
# 7144 "../../../server-code/src/map/clif.c" 3 4
0
# 7144 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x167].len);
 WFIFOW(fd,0)=0x167;
 WFIFOB(fd,2)=flag;
 WFIFOSET(fd,packet_db[0x167].len);
}




void clif_guild_belonginfo(struct map_session_data *sd, struct guild *g)
{
 int ps,fd;
 do { if (((void)(sd), 
# 7159 "../../../server-code/src/map/clif.c" 3 4
0
# 7159 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(g), 
# 7160 "../../../server-code/src/map/clif.c" 3 4
0
# 7160 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 ps=guild->getposition(g,sd);
 WFIFOHEAD(fd,packet_db[0x16c].len);
 WFIFOW(fd,0)=0x16c;
 WFIFOL(fd,2)=g->guild_id;
 WFIFOL(fd,6)=g->emblem_id;
 WFIFOL(fd,10)=g->position[ps].mode;
 WFIFOB(fd,14)=(
# 7169 "../../../server-code/src/map/clif.c" 3 4
               _Bool
# 7169 "../../../server-code/src/map/clif.c"
                   )(sd->state.gmaster_flag == 1);
 WFIFOL(fd,15)=0;
 memcpy(WFIFOP(fd,19),g->name,(23 + 1));
 WFIFOSET(fd,packet_db[0x16c].len);
}







void clif_guild_memberlogin_notice(struct guild *g,int idx,int flag)
{
 unsigned char buf[64];
 struct map_session_data* sd;

 do { if (((void)(g), 
# 7186 "../../../server-code/src/map/clif.c" 3 4
0
# 7186 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0)=0x1f2;
 WBUFL(buf, 2)=g->member[idx].account_id;
 WBUFL(buf, 6)=g->member[idx].char_id;
 WBUFL(buf,10)=flag;

 if( ( sd = g->member[idx].sd ) != 
# 7193 "../../../server-code/src/map/clif.c" 3 4
                                  ((void *)0) 
# 7193 "../../../server-code/src/map/clif.c"
                                       )
 {
  WBUFW(buf,14) = sd->status.sex;
  WBUFW(buf,16) = sd->status.hair;
  WBUFW(buf,18) = sd->status.hair_color;
  clif->send(buf,packet_db[0x1f2].len,&sd->bl,GUILD_WOS);
 }
 else if( ( sd = guild->getavailablesd(g) ) != 
# 7200 "../../../server-code/src/map/clif.c" 3 4
                                              ((void *)0) 
# 7200 "../../../server-code/src/map/clif.c"
                                                   )
 {
  WBUFW(buf,14) = 0;
  WBUFW(buf,16) = 0;
  WBUFW(buf,18) = 0;
  clif->send(buf,packet_db[0x1f2].len,&sd->bl,GUILD);
 }
}
# 7218 "../../../server-code/src/map/clif.c"
void clif_guild_send_onlineinfo(struct map_session_data *sd)
{
 struct guild *g;
 unsigned char buf[14*128];
 int i, count=0, p_len;

 do { if (((void)(sd), 
# 7224 "../../../server-code/src/map/clif.c" 3 4
0
# 7224 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 p_len = packet_db[0x16d].len;

 if(!(g = sd->guild))
  return;

 for(i=0; i<g->max_member; i++) {

  if(g->member[i].account_id > 0 &&
   g->member[i].account_id != sd->status.account_id) {

   WBUFW(buf,count*p_len) = 0x16d;
   WBUFL(buf,count*p_len+2) = g->member[i].account_id;
   WBUFL(buf,count*p_len+6) = g->member[i].char_id;
   WBUFL(buf,count*p_len+10) = g->member[i].online;
   count++;
  }
 }

 clif->send(buf, p_len*count, &sd->bl, SELF);
}
# 7257 "../../../server-code/src/map/clif.c"
void clif_guild_masterormember(struct map_session_data *sd)
{
 int fd;

 do { if (((void)(sd), 
# 7261 "../../../server-code/src/map/clif.c" 3 4
0
# 7261 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x14e].len);
 WFIFOW(fd,0) = 0x14e;
 WFIFOL(fd,2) = (sd->state.gmaster_flag) ? 0xd7 : 0x57;
 WFIFOSET(fd,packet_db[0x14e].len);
}




void clif_guild_basicinfo(struct map_session_data *sd) {
 int fd;
 struct guild *g;

 do { if (((void)(sd), 
# 7277 "../../../server-code/src/map/clif.c" 3 4
0
# 7277 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;

 if( (g = sd->guild) == 
# 7280 "../../../server-code/src/map/clif.c" 3 4
                       ((void *)0) 
# 7280 "../../../server-code/src/map/clif.c"
                            )
  return;

 WFIFOHEAD(fd,packet_db[0x1b6].len);
 WFIFOW(fd,0)=0x1b6;
 WFIFOL(fd, 2)=g->guild_id;
 WFIFOL(fd, 6)=g->guild_lv;
 WFIFOL(fd,10)=g->connect_member;
 WFIFOL(fd,14)=g->max_member;
 WFIFOL(fd,18)=g->average_lv;
 WFIFOL(fd,22)=(uint32)(((g->exp) >= (
# 7290 "../../../server-code/src/map/clif.c" 3 4
                      (2147483647)
# 7290 "../../../server-code/src/map/clif.c"
                      )) ? (
# 7290 "../../../server-code/src/map/clif.c" 3 4
                      (2147483647)
# 7290 "../../../server-code/src/map/clif.c"
                      ) : ((g->exp) <= (0)) ? (0) : (g->exp));
 WFIFOL(fd,26)=g->next_exp;
 WFIFOL(fd,30)=0;
 WFIFOL(fd,34)=0;
 WFIFOL(fd,38)=0;
 WFIFOL(fd,42)=g->emblem_id;
 memcpy(WFIFOP(fd,46),g->name, (23 + 1));
 memcpy(WFIFOP(fd,70),g->master, (23 + 1));

 (strlib->safestrncpy_((WFIFOP(fd,94)),(atcommand->msgsd((sd),(300+guild->checkcastles(g)))),(16)));
 WFIFOL(fd,110) = 0;

 WFIFOSET(fd,packet_db[0x1b6].len);
}



void clif_guild_allianceinfo(struct map_session_data *sd)
{
 int fd,i,c;
 struct guild *g;

 do { if (((void)(sd), 
# 7312 "../../../server-code/src/map/clif.c" 3 4
0
# 7312 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if( (g = sd->guild) == 
# 7313 "../../../server-code/src/map/clif.c" 3 4
                       ((void *)0) 
# 7313 "../../../server-code/src/map/clif.c"
                            )
  return;

 fd = sd->fd;
 WFIFOHEAD(fd, 16 * 32 + 4);
 WFIFOW(fd,0)=0x14c;
 for(i=c=0;i<16;i++){
  struct guild_alliance *a=&g->alliance[i];
  if(a->guild_id>0){
   WFIFOL(fd,c*32+4)=a->opposition;
   WFIFOL(fd,c*32+8)=a->guild_id;
   memcpy(WFIFOP(fd,c*32+12),a->name,(23 + 1));
   c++;
  }
 }
 WFIFOW(fd,2)=c*32+4;
 WFIFOSET(fd,WFIFOW(fd,2));
}
# 7339 "../../../server-code/src/map/clif.c"
void clif_guild_memberlist(struct map_session_data *sd)
{
 int fd;
 int i,c;
 struct guild *g;
 do { if (((void)(sd), 
# 7344 "../../../server-code/src/map/clif.c" 3 4
0
# 7344 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if( (fd = sd->fd) == 0 )
  return;
 if( (g = sd->guild) == 
# 7348 "../../../server-code/src/map/clif.c" 3 4
                       ((void *)0) 
# 7348 "../../../server-code/src/map/clif.c"
                            )
  return;

 WFIFOHEAD(fd, g->max_member * 104 + 4);
 WFIFOW(fd,0)=0x154;
 for(i=0,c=0;i<g->max_member;i++){
  struct guild_member *m=&g->member[i];
  if(m->account_id==0)
   continue;
  WFIFOL(fd,c*104+ 4)=m->account_id;
  WFIFOL(fd,c*104+ 8)=m->char_id;
  WFIFOW(fd,c*104+12)=m->hair;
  WFIFOW(fd,c*104+14)=m->hair_color;
  WFIFOW(fd,c*104+16)=m->gender;
  WFIFOW(fd,c*104+18)=m->class_;
  WFIFOW(fd,c*104+20)=m->lv;
  WFIFOL(fd,c*104+22)=(int)(((m->exp) >= (
# 7364 "../../../server-code/src/map/clif.c" 3 4
                          (2147483647)
# 7364 "../../../server-code/src/map/clif.c"
                          )) ? (
# 7364 "../../../server-code/src/map/clif.c" 3 4
                          (2147483647)
# 7364 "../../../server-code/src/map/clif.c"
                          ) : ((m->exp) <= (0)) ? (0) : (m->exp));
  WFIFOL(fd,c*104+26)=m->online;
  WFIFOL(fd,c*104+30)=m->position;
  memset(WFIFOP(fd,c*104+34),0,50);
  memcpy(WFIFOP(fd,c*104+84),m->name,(23 + 1));
  c++;
 }
 WFIFOW(fd,2)=c*104+4;
 WFIFOSET(fd,WFIFOW(fd,2));
}



void clif_guild_positionnamelist(struct map_session_data *sd) {
 int i,fd;
 struct guild *g;

 do { if (((void)(sd), 
# 7381 "../../../server-code/src/map/clif.c" 3 4
0
# 7381 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if( (g = sd->guild) == 
# 7382 "../../../server-code/src/map/clif.c" 3 4
                       ((void *)0) 
# 7382 "../../../server-code/src/map/clif.c"
                            )
  return;

 fd = sd->fd;
 WFIFOHEAD(fd, 20 * 28 + 4);
 WFIFOW(fd,0)=0x166;
 for(i=0;i<20;i++){
  WFIFOL(fd,i*28+4)=i;
  memcpy(WFIFOP(fd,i*28+8),g->position[i].name,(23 + 1));
 }
 WFIFOW(fd,2)=i*28+4;
 WFIFOSET(fd,WFIFOW(fd,2));
}






void clif_guild_positioninfolist(struct map_session_data *sd) {
 int i,fd;
 struct guild *g;

 do { if (((void)(sd), 
# 7405 "../../../server-code/src/map/clif.c" 3 4
0
# 7405 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if( (g = sd->guild) == 
# 7406 "../../../server-code/src/map/clif.c" 3 4
                       ((void *)0) 
# 7406 "../../../server-code/src/map/clif.c"
                            )
  return;

 fd = sd->fd;
 WFIFOHEAD(fd, 20 * 16 + 4);
 WFIFOW(fd,0)=0x160;
 for(i=0;i<20;i++){
  struct guild_position *p=&g->position[i];
  WFIFOL(fd,i*16+ 4)=i;
  WFIFOL(fd,i*16+ 8)=p->mode;
  WFIFOL(fd,i*16+12)=i;
  WFIFOL(fd,i*16+16)=p->exp_mode;
 }
 WFIFOW(fd,2)=i*16+4;
 WFIFOSET(fd,WFIFOW(fd,2));
}






void clif_guild_positionchanged(struct guild *g,int idx)
{



 struct map_session_data *sd;
 unsigned char buf[128];

 do { if (((void)(g), 
# 7436 "../../../server-code/src/map/clif.c" 3 4
0
# 7436 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0)=0x174;
 WBUFW(buf,2)=44;

 WBUFL(buf, 4)=idx;
 WBUFL(buf, 8)=g->position[idx].mode;
 WBUFL(buf,12)=idx;
 WBUFL(buf,16)=g->position[idx].exp_mode;
 memcpy(WBUFP(buf,20),g->position[idx].name,(23 + 1));

 if( (sd=guild->getavailablesd(g))!=
# 7447 "../../../server-code/src/map/clif.c" 3 4
                                   ((void *)0) 
# 7447 "../../../server-code/src/map/clif.c"
                                        )
  clif->send(buf,WBUFW(buf,2),&sd->bl,GUILD);
}



void clif_guild_memberpositionchanged(struct guild *g,int idx)
{



 struct map_session_data *sd;
 unsigned char buf[64];

 do { if (((void)(g), 
# 7461 "../../../server-code/src/map/clif.c" 3 4
0
# 7461 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0)=0x156;
 WBUFW(buf,2)=16;

 WBUFL(buf, 4)=g->member[idx].account_id;
 WBUFL(buf, 8)=g->member[idx].char_id;
 WBUFL(buf,12)=g->member[idx].position;

 if( (sd=guild->getavailablesd(g))!=
# 7470 "../../../server-code/src/map/clif.c" 3 4
                                   ((void *)0) 
# 7470 "../../../server-code/src/map/clif.c"
                                        )
  clif->send(buf,WBUFW(buf,2),&sd->bl,GUILD);
}



void clif_guild_emblem(struct map_session_data *sd,struct guild *g)
{
 int fd;
 do { if (((void)(sd), 
# 7479 "../../../server-code/src/map/clif.c" 3 4
0
# 7479 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(g), 
# 7480 "../../../server-code/src/map/clif.c" 3 4
0
# 7480 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 if( g->emblem_len <= 0 )
  return;

 WFIFOHEAD(fd,g->emblem_len+12);
 WFIFOW(fd,0)=0x152;
 WFIFOW(fd,2)=g->emblem_len+12;
 WFIFOL(fd,4)=g->guild_id;
 WFIFOL(fd,8)=g->emblem_id;
 memcpy(WFIFOP(fd,12),g->emblem_data,g->emblem_len);
 WFIFOSET(fd,WFIFOW(fd,2));
}



void clif_guild_emblem_area(struct block_list* bl)
{
 uint8 buf[12];

 do { if (((void)(bl), 
# 7501 "../../../server-code/src/map/clif.c" 3 4
0
# 7501 "../../../server-code/src/map/clif.c"
)) return; } while(0);



 WBUFW(buf,0) = 0x1b4;
 WBUFL(buf,2) = bl->id;
 WBUFL(buf,6) = status->get_guild_id(bl);
 WBUFW(buf,10) = status->get_emblem_id(bl);
 clif->send(buf, 12, bl, AREA_WOS);
}



void clif_guild_skillinfo(struct map_session_data* sd)
{
 int fd;
 struct guild* g;
 int i,c;

 do { if (((void)(sd), 
# 7520 "../../../server-code/src/map/clif.c" 3 4
0
# 7520 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if( (g = sd->guild) == 
# 7521 "../../../server-code/src/map/clif.c" 3 4
                       ((void *)0) 
# 7521 "../../../server-code/src/map/clif.c"
                            )
  return;

 fd = sd->fd;
 WFIFOHEAD(fd, 6 + 15*37);
 WFIFOW(fd,0) = 0x0162;
 WFIFOW(fd,4) = g->skill_point;
 for(i = 0, c = 0; i < 15; i++) {
  if(g->skill[i].id > 0 && guild->check_skill_require(g, g->skill[i].id)) {
   int id = g->skill[i].id;
   int p = 6 + c*37;
   WFIFOW(fd,p+0) = id;
   WFIFOL(fd,p+2) = skill->get_inf(id);
   WFIFOW(fd,p+6) = g->skill[i].lv;
   if ( g->skill[i].lv ) {
    WFIFOW(fd,p + 8) = skill->get_sp(id, g->skill[i].lv);
    WFIFOW(fd,p + 10) = skill->get_range(id, g->skill[i].lv);
   } else {
    WFIFOW(fd,p + 8) = 0;
    WFIFOW(fd,p + 10) = 0;
   }
   (strlib->safestrncpy_((WFIFOP(fd,p+12)),(skill->get_name(id)),((23 + 1))));
   WFIFOB(fd,p+36)= (g->skill[i].lv < guild->skill_get_max(id) && sd == g->member[0].sd) ? 1 : 0;
   c++;
  }
 }
 WFIFOW(fd,2) = 6 + c*37;
 WFIFOSET(fd,WFIFOW(fd,2));
}



void clif_guild_notice(struct map_session_data* sd, struct guild* g)
{
 int fd;

 do { if (((void)(sd), 
# 7557 "../../../server-code/src/map/clif.c" 3 4
0
# 7557 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(g), 
# 7558 "../../../server-code/src/map/clif.c" 3 4
0
# 7558 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;

 if (!sockt->session_is_active(fd))
  return;

 if(g->mes1[0] == '\0' && g->mes2[0] == '\0')
  return;

 WFIFOHEAD(fd,packet_db[0x16f].len);
 WFIFOW(fd,0) = 0x16f;
 memcpy(WFIFOP(fd,2), g->mes1, 60);
 memcpy(WFIFOP(fd,62), g->mes2, 120);
 WFIFOSET(fd,packet_db[0x16f].len);
}



void clif_guild_invite(struct map_session_data *sd,struct guild *g)
{
 int fd;

 do { if (((void)(sd), 
# 7581 "../../../server-code/src/map/clif.c" 3 4
0
# 7581 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(g), 
# 7582 "../../../server-code/src/map/clif.c" 3 4
0
# 7582 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x16a].len);
 WFIFOW(fd,0)=0x16a;
 WFIFOL(fd,2)=g->guild_id;
 memcpy(WFIFOP(fd,6),g->name,(23 + 1));
 WFIFOSET(fd,packet_db[0x16a].len);
}
# 7599 "../../../server-code/src/map/clif.c"
void clif_guild_inviteack(struct map_session_data *sd,int flag)
{
 int fd;

 do { if (((void)(sd), 
# 7603 "../../../server-code/src/map/clif.c" 3 4
0
# 7603 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x169].len);
 WFIFOW(fd,0)=0x169;
 WFIFOB(fd,2)=flag;
 WFIFOSET(fd,packet_db[0x169].len);
}



void clif_guild_leave(struct map_session_data *sd,const char *name,const char *mes)
{
 unsigned char buf[128];

 do { if (((void)(sd), 
# 7618 "../../../server-code/src/map/clif.c" 3 4
0
# 7618 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0)=0x15a;
 memcpy(WBUFP(buf, 2),name,(23 + 1));
 memcpy(WBUFP(buf,26),mes,40);
 clif->send(buf,packet_db[0x15a].len,&sd->bl,GUILD_NOBG);
}




void clif_guild_expulsion(struct map_session_data* sd, const char* name, const char* mes, int account_id)
{
 unsigned char buf[128];



 const unsigned short cmd = 0x839;


 do { if (((void)(sd), 
# 7638 "../../../server-code/src/map/clif.c" 3 4
0
# 7638 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(name), 
# 7639 "../../../server-code/src/map/clif.c" 3 4
0
# 7639 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(mes), 
# 7640 "../../../server-code/src/map/clif.c" 3 4
0
# 7640 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = cmd;
 (strlib->safestrncpy_((WBUFP(buf,2)),(name),((23 + 1))));
 (strlib->safestrncpy_((WBUFP(buf,26)),(mes),(40)));



 clif->send(buf, packet_db[cmd].len, &sd->bl, GUILD_NOBG);
}




void clif_guild_expulsionlist(struct map_session_data* sd) {



 const int offset = (23 + 1)+40;

 int fd, i, c = 0;
 struct guild* g;

 do { if (((void)(sd), 
# 7663 "../../../server-code/src/map/clif.c" 3 4
0
# 7663 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if( (g = sd->guild) == 
# 7665 "../../../server-code/src/map/clif.c" 3 4
                       ((void *)0) 
# 7665 "../../../server-code/src/map/clif.c"
                            )
  return;

 fd = sd->fd;

 WFIFOHEAD(fd,4 + 32 * offset);
 WFIFOW(fd,0) = 0x163;

 for( i = 0; i < 32; i++ )
 {
  struct guild_expulsion* e = &g->expulsion[i];

  if( e->account_id > 0 )
  {
   memcpy(WFIFOP(fd,4 + c*offset), e->name, (23 + 1));




   memcpy(WFIFOP(fd,4 + c*offset+24), e->mes, 40);

   c++;
  }
 }
 WFIFOW(fd,2) = 4 + c*offset;
 WFIFOSET(fd,WFIFOW(fd,2));
}



void clif_guild_message(struct guild *g,int account_id,const char *mes,int len)
{
 struct map_session_data *sd;
 uint8 buf[256];

 do { if (((void)(mes), 
# 7700 "../../../server-code/src/map/clif.c" 3 4
0
# 7700 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if (len == 0)
  return;

 if (len > sizeof(buf)-5) {
  (showmsg->showWarning(("clif_guild_message: Truncated message '%s' (len=%d, max=%""z" "u"", guild_id=%d).\n"), mes, len, sizeof(buf)-5, g->guild_id));
  len = sizeof(buf)-5;
 }

 WBUFW(buf,0) = 0x17f;
 WBUFW(buf,2) = len + 5;
 (strlib->safestrncpy_((WBUFP(buf,4)),(mes),(len+1)));

 if ((sd = guild->getavailablesd(g)) != 
# 7713 "../../../server-code/src/map/clif.c" 3 4
                                       ((void *)0)
# 7713 "../../../server-code/src/map/clif.c"
                                           )
  clif->send(buf, WBUFW(buf,2), &sd->bl, GUILD_NOBG);
}



void clif_guild_reqalliance(struct map_session_data *sd,int account_id,const char *name)
{
 int fd;

 do { if (((void)(sd), 
# 7723 "../../../server-code/src/map/clif.c" 3 4
0
# 7723 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(name), 
# 7724 "../../../server-code/src/map/clif.c" 3 4
0
# 7724 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x171].len);
 WFIFOW(fd,0)=0x171;
 WFIFOL(fd,2)=account_id;
 memcpy(WFIFOP(fd,6),name,(23 + 1));
 WFIFOSET(fd,packet_db[0x171].len);
}
# 7743 "../../../server-code/src/map/clif.c"
void clif_guild_allianceack(struct map_session_data *sd,int flag)
{
 int fd;

 do { if (((void)(sd), 
# 7747 "../../../server-code/src/map/clif.c" 3 4
0
# 7747 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x173].len);
 WFIFOW(fd,0)=0x173;
 WFIFOL(fd,2)=flag;
 WFIFOSET(fd,packet_db[0x173].len);
}






void clif_guild_delalliance(struct map_session_data *sd,int guild_id,int flag)
{
 int fd;

 do { if (((void)(sd), 
# 7765 "../../../server-code/src/map/clif.c" 3 4
0
# 7765 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 if (fd <= 0)
  return;
 WFIFOHEAD(fd,packet_db[0x184].len);
 WFIFOW(fd,0)=0x184;
 WFIFOL(fd,2)=guild_id;
 WFIFOL(fd,6)=flag;
 WFIFOSET(fd,packet_db[0x184].len);
}
# 7784 "../../../server-code/src/map/clif.c"
void clif_guild_oppositionack(struct map_session_data *sd,int flag)
{
 int fd;

 do { if (((void)(sd), 
# 7788 "../../../server-code/src/map/clif.c" 3 4
0
# 7788 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x181].len);
 WFIFOW(fd,0)=0x181;
 WFIFOB(fd,2)=flag;
 WFIFOSET(fd,packet_db[0x181].len);
}
# 7816 "../../../server-code/src/map/clif.c"
void clif_guild_broken(struct map_session_data *sd,int flag)
{
 int fd;

 do { if (((void)(sd), 
# 7820 "../../../server-code/src/map/clif.c" 3 4
0
# 7820 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x15e].len);
 WFIFOW(fd,0)=0x15e;
 WFIFOL(fd,2)=flag;
 WFIFOSET(fd,packet_db[0x15e].len);
}





void clif_emotion(struct block_list *bl,int type)
{
 unsigned char buf[8];

 do { if (((void)(bl), 
# 7837 "../../../server-code/src/map/clif.c" 3 4
0
# 7837 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0)=0xc0;
 WBUFL(buf,2)=bl->id;
 WBUFB(buf,6)=type;
 clif->send(buf,packet_db[0xc0].len,bl,AREA);
}



void clif_talkiebox(struct block_list* bl, const char* talkie)
{
 unsigned char buf[(79 + 1)+6];
 do { if (((void)(bl), 
# 7850 "../../../server-code/src/map/clif.c" 3 4
0
# 7850 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(talkie), 
# 7851 "../../../server-code/src/map/clif.c" 3 4
0
# 7851 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0x191;
 WBUFL(buf,2) = bl->id;
 (strlib->safestrncpy_((WBUFP(buf,6)),(talkie),((79 + 1))));
 clif->send(buf,packet_db[0x191].len,bl,AREA);
}



void clif_wedding_effect(struct block_list *bl)
{
 unsigned char buf[6];

 do { if (((void)(bl), 
# 7865 "../../../server-code/src/map/clif.c" 3 4
0
# 7865 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0x1ea;
 WBUFL(buf,2) = bl->id;
 clif->send(buf, packet_db[0x1ea].len, bl, AREA);
}



void clif_callpartner(struct map_session_data *sd) {
 unsigned char buf[26];

 do { if (((void)(sd), 
# 7877 "../../../server-code/src/map/clif.c" 3 4
0
# 7877 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0x1e6;

 if( sd->status.partner_id ) {
  const char *p;
  if( ( p = map->charid2nick(sd->status.partner_id) ) != 
# 7883 "../../../server-code/src/map/clif.c" 3 4
                                                        ((void *)0) 
# 7883 "../../../server-code/src/map/clif.c"
                                                             ) {
   memcpy(WBUFP(buf,2), p, (23 + 1));
  } else {
   WBUFB(buf,2) = 0;
  }
 } else {

  WBUFB(buf,2) = 0;
 }

 clif->send(buf, packet_db[0x1e6].len, &sd->bl, AREA);
}
# 7914 "../../../server-code/src/map/clif.c"
void clif_divorced(struct map_session_data* sd, const char* name)
{
 int fd;
 do { if (((void)(sd), 
# 7917 "../../../server-code/src/map/clif.c" 3 4
0
# 7917 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0x205].len);
 WFIFOW(fd,0)=0x205;
 memcpy(WFIFOP(fd,2), name, (23 + 1));
 WFIFOSET(fd, packet_db[0x205].len);
}
# 7946 "../../../server-code/src/map/clif.c"
void clif_disp_message(struct block_list* src, const char* mes, size_t len, enum send_target target)
{
 unsigned char buf[256];

 if (len == 0)
  return;

 do { if (((void)(src), 
# 7953 "../../../server-code/src/map/clif.c" 3 4
0
# 7953 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(mes), 
# 7954 "../../../server-code/src/map/clif.c" 3 4
0
# 7954 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if (len > sizeof(buf)-5) {
  (showmsg->showWarning(("clif_disp_message: Truncated message '%s' (len=%""z" "u"", max=%""z" "u"", aid=%d).\n"), mes, len, sizeof(buf)-5, src->id));
  len = sizeof(buf)-5;
 }

 WBUFW(buf,0) = 0x17f;
 WBUFW(buf,2) = len + 5;
 (strlib->safestrncpy_((WBUFP(buf,4)),(mes),(len+1)));
 clif->send(buf, WBUFW(buf,2), src, target);
}







void clif_GM_kickack(struct map_session_data *sd, int result)
{
 int fd;

 do { if (((void)(sd), 
# 7977 "../../../server-code/src/map/clif.c" 3 4
0
# 7977 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0xcd].len);
 WFIFOW(fd,0) = 0xcd;
 WFIFOB(fd,2) = result;
 WFIFOSET(fd, packet_db[0xcd].len);
}

void clif_GM_kick(struct map_session_data *sd,struct map_session_data *tsd) {
 int fd;

 do { if (((void)(tsd), 
# 7989 "../../../server-code/src/map/clif.c" 3 4
0
# 7989 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = tsd->fd;

 if (fd > 0)
  clif->authfail_fd(fd, 15);
 else
  map->quit(tsd);

 if (sd)
  clif->GM_kickack(sd, 1);
}
# 8010 "../../../server-code/src/map/clif.c"
void clif_manner_message(struct map_session_data* sd, uint32 type)
{
 int fd;
 do { if (((void)(sd), 
# 8013 "../../../server-code/src/map/clif.c" 3 4
0
# 8013 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x14a].len);
 WFIFOW(fd,0) = 0x14a;
 WFIFOL(fd,2) = type;
 WFIFOSET(fd, packet_db[0x14a].len);
}






void clif_GM_silence(struct map_session_data* sd, struct map_session_data* tsd, uint8 type)
{
 int fd;
 do { if (((void)(sd), 
# 8030 "../../../server-code/src/map/clif.c" 3 4
0
# 8030 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(tsd), 
# 8031 "../../../server-code/src/map/clif.c" 3 4
0
# 8031 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = tsd->fd;
 WFIFOHEAD(fd,packet_db[0x14b].len);
 WFIFOW(fd,0) = 0x14b;
 WFIFOB(fd,2) = type;
 (strlib->safestrncpy_((WFIFOP(fd,3)),(sd->status.name),((23 + 1))));
 WFIFOSET(fd, packet_db[0x14b].len);
}
# 8050 "../../../server-code/src/map/clif.c"
void clif_wisexin(struct map_session_data *sd,int type,int flag) {
 int fd;

 do { if (((void)(sd), 
# 8053 "../../../server-code/src/map/clif.c" 3 4
0
# 8053 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0xd1].len);
 WFIFOW(fd,0)=0xd1;
 WFIFOB(fd,2)=type;
 WFIFOB(fd,3)=flag;
 WFIFOSET(fd,packet_db[0xd1].len);
}
# 8071 "../../../server-code/src/map/clif.c"
void clif_wisall(struct map_session_data *sd,int type,int flag) {
 int fd;

 do { if (((void)(sd), 
# 8074 "../../../server-code/src/map/clif.c" 3 4
0
# 8074 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd=sd->fd;
 WFIFOHEAD(fd,packet_db[0xd2].len);
 WFIFOW(fd,0)=0xd2;
 WFIFOB(fd,2)=type;
 WFIFOB(fd,3)=flag;
 WFIFOSET(fd,packet_db[0xd2].len);
}



void clif_playBGM(struct map_session_data* sd, const char* name)
{
 int fd;

 do { if (((void)(sd), 
# 8090 "../../../server-code/src/map/clif.c" 3 4
0
# 8090 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x7fe].len);
 WFIFOW(fd,0) = 0x7fe;
 (strlib->safestrncpy_((WFIFOP(fd,2)),(name),((23 + 1))));
 WFIFOSET(fd,packet_db[0x7fe].len);
}
# 8112 "../../../server-code/src/map/clif.c"
void clif_soundeffect(struct map_session_data* sd, struct block_list* bl, const char* name, int type)
{
 int fd;

 do { if (((void)(sd), 
# 8116 "../../../server-code/src/map/clif.c" 3 4
0
# 8116 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(bl), 
# 8117 "../../../server-code/src/map/clif.c" 3 4
0
# 8117 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(name), 
# 8118 "../../../server-code/src/map/clif.c" 3 4
0
# 8118 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x1d3].len);
 WFIFOW(fd,0) = 0x1d3;
 (strlib->safestrncpy_((WFIFOP(fd,2)),(name),((23 + 1))));
 WFIFOB(fd,26) = type;
 WFIFOL(fd,27) = 0;
 WFIFOL(fd,31) = bl->id;
 WFIFOSET(fd,packet_db[0x1d3].len);
}

void clif_soundeffectall(struct block_list* bl, const char* name, int type, enum send_target coverage)
{
 unsigned char buf[40];

 do { if (((void)(bl), 
# 8134 "../../../server-code/src/map/clif.c" 3 4
0
# 8134 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(name), 
# 8135 "../../../server-code/src/map/clif.c" 3 4
0
# 8135 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0x1d3;
 (strlib->safestrncpy_((WBUFP(buf,2)),(name),((23 + 1))));
 WBUFB(buf,26) = type;
 WBUFL(buf,27) = 0;
 WBUFL(buf,31) = bl->id;
 clif->send(buf, packet_db[0x1d3].len, bl, coverage);
}





void clif_specialeffect(struct block_list* bl, int type, enum send_target target)
{
 unsigned char buf[24];

 do { if (((void)(bl), 
# 8153 "../../../server-code/src/map/clif.c" 3 4
0
# 8153 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 memset(buf, 0, packet_db[0x1f3].len);

 WBUFW(buf,0) = 0x1f3;
 WBUFL(buf,2) = bl->id;
 WBUFL(buf,6) = type;

 clif->send(buf, packet_db[0x1f3].len, bl, target);

 if (disguised(bl)) {
  WBUFL(buf,2) = -bl->id;
  clif->send(buf, packet_db[0x1f3].len, bl, SELF);
 }
}

void clif_specialeffect_single(struct block_list* bl, int type, int fd) {
 do { if (((void)(bl), 
# 8170 "../../../server-code/src/map/clif.c" 3 4
0
# 8170 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 WFIFOHEAD(fd,10);
 WFIFOW(fd,0) = 0x1f3;
 WFIFOL(fd,2) = bl->id;
 WFIFOL(fd,6) = type;
 WFIFOSET(fd,10);
}







void clif_specialeffect_value(struct block_list* bl, int effect_id, int num, send_target target)
{
 uint8 buf[14];

 WBUFW(buf,0) = 0x284;
 WBUFL(buf,2) = bl->id;
 WBUFL(buf,6) = effect_id;
 WBUFL(buf,10) = num;

 clif->send(buf, packet_db[0x284].len, bl, target);

 if( disguised(bl) )
 {
  WBUFL(buf,2) = -bl->id;
  clif->send(buf, packet_db[0x284].len, bl, SELF);
 }
}
# 8210 "../../../server-code/src/map/clif.c"
void clif_messagecolor_self(int fd, uint32 color, const char *msg)
{
 size_t msg_len;

 do { if (((void)(msg), 
# 8214 "../../../server-code/src/map/clif.c" 3 4
0
# 8214 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 msg_len = strlen(msg) + 1;

 WFIFOHEAD(fd,msg_len + 12);
 WFIFOW(fd,0) = 0x2C1;
 WFIFOW(fd,2) = msg_len + 12;
 WFIFOL(fd,4) = 0;
 WFIFOL(fd,8) = (((color) & 0x0000FF) << 16 | ((color) & 0x00FF00) | ((color) & 0xFF0000) >> 16);
 (strlib->safestrncpy_((WFIFOP(fd,12)),(msg),(msg_len)));
 WFIFOSET(fd, msg_len + 12);
}
# 8235 "../../../server-code/src/map/clif.c"
void clif_messagecolor(struct block_list* bl, uint32 color, const char *msg)
{
 size_t msg_len = strlen(msg) + 1;
 uint8 buf[256];

 do { if (((void)(bl), 
# 8240 "../../../server-code/src/map/clif.c" 3 4
0
# 8240 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(msg), 
# 8241 "../../../server-code/src/map/clif.c" 3 4
0
# 8241 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if (msg_len > sizeof(buf)-12) {
  (showmsg->showWarning(("clif_messagecolor: Truncating too long message '%s' (len=%""z" "u"").\n"), msg, msg_len));
  msg_len = sizeof(buf)-12;
 }

 WBUFW(buf,0) = 0x2C1;
 WBUFW(buf,2) = msg_len + 12;
 WBUFL(buf,4) = bl->id;
 WBUFL(buf,8) = (((color) & 0x0000FF) << 16 | ((color) & 0x00FF00) | ((color) & 0xFF0000) >> 16);
 memcpy(WBUFP(buf,12), msg, msg_len);

 clif->send(buf, WBUFW(buf,2), bl, AREA_CHAT_WOC);
}







void clif_refresh_storagewindow(struct map_session_data *sd)
{
 do { if (((void)(sd), 
# 8265 "../../../server-code/src/map/clif.c" 3 4
0
# 8265 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if (sd->state.storage_flag == STORAGE_FLAG_NORMAL) {
  storage->sortitem(sd->status.storage.items, ( (int)(sizeof(sd->status.storage.items)/sizeof((sd->status.storage.items)[0])) ));
  clif->storagelist(sd, sd->status.storage.items, ( (int)(sizeof(sd->status.storage.items)/sizeof((sd->status.storage.items)[0])) ));
  clif->updatestorageamount(sd, sd->status.storage.storage_amount, 600);
 }


 if (sd->state.storage_flag == STORAGE_FLAG_GUILD) {
  struct guild_storage *gstor;
  if( (gstor = ( DB->data2ptr((gstorage->db)->get((gstorage->db),DB->i2key(sd->status.guild_id))) )) == 
# 8276 "../../../server-code/src/map/clif.c" 3 4
                                                            ((void *)0)
# 8276 "../../../server-code/src/map/clif.c"
                                                                ) {

   intif->request_guild_storage(sd->status.account_id,sd->status.guild_id);
  } else {
   storage->sortitem(gstor->items, ( (int)(sizeof(gstor->items)/sizeof((gstor->items)[0])) ));
   clif->storagelist(sd, gstor->items, ( (int)(sizeof(gstor->items)/sizeof((gstor->items)[0])) ));
   clif->updatestorageamount(sd, gstor->storage_amount, 600);
  }
 }
}


void clif_refresh(struct map_session_data *sd)
{
 do { if (((void)(sd), 
# 8290 "../../../server-code/src/map/clif.c" 3 4
0
# 8290 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 clif->changemap(sd,sd->bl.m,sd->bl.x,sd->bl.y);
 clif->inventorylist(sd);
 if(( (sd)->sc.data[SC_PUSH_CART] )) {
  clif->cartlist(sd);
  clif->updatestatus(sd,SP_CARTINFO);
 }
 clif->updatestatus(sd,SP_WEIGHT);
 clif->updatestatus(sd,SP_MAXWEIGHT);
 clif->updatestatus(sd,SP_STR);
 clif->updatestatus(sd,SP_AGI);
 clif->updatestatus(sd,SP_VIT);
 clif->updatestatus(sd,SP_INT);
 clif->updatestatus(sd,SP_DEX);
 clif->updatestatus(sd,SP_LUK);
 if (sd->spiritball)
  clif->spiritball_single(sd->fd, sd);
 if (sd->charm_type != CHARM_TYPE_NONE && sd->charm_count > 0)
  clif->charm_single(sd->fd, sd);

 if (sd->vd.cloth_color)
  clif->refreshlook(&sd->bl,sd->bl.id,LOOK_CLOTHES_COLOR,sd->vd.cloth_color,SELF);
 if (sd->vd.body_style)
  clif->refreshlook(&sd->bl,sd->bl.id,LOOK_BODY2,sd->vd.body_style,SELF);
 if(((sd->hd) && (sd->hd)->homunculus.vaporize == HOM_ST_ACTIVE && (sd->hd)->battle_status.hp > 0))
  clif->send_homdata(sd,SP_ACK,0);
 if( sd->md ) {
  clif->mercenary_info(sd);
  clif->mercenary_skillblock(sd);
 }
 if( sd->ed )
  clif->elemental_info(sd);
 map->foreachinrange(clif->getareachar,&sd->bl,(battle->bc->area_size),BL_ALL,sd);
 clif->weather_check(sd);
 if( sd->chatID )
  chat->leave(sd, 
# 8326 "../../../server-code/src/map/clif.c" 3 4
                 0
# 8326 "../../../server-code/src/map/clif.c"
                      );
 if( sd->state.vending )
  clif->openvending(sd, sd->bl.id, sd->vending);
 if( ( (sd)->vd.dead_sit == 2 ) )
  clif->sitting(&sd->bl);
 if( ( (sd)->state.dead_sit == 1 ) )
  clif->clearunit_single(sd->bl.id,CLR_DEAD,sd->fd);
 else
  clif->changed_dir(&sd->bl, SELF);


 buyingstore->close(sd);

 mail->clear(sd);

 if( disguised(&sd->bl) ) {
  short disguise = sd->disguise;
  pc->disguise(sd, -1);
  pc->disguise(sd, disguise);
 }

 clif->refresh_storagewindow(sd);
}




void clif_charnameack (int fd, struct block_list *bl)
{
 unsigned char buf[103];
 int cmd = 0x95;

 do { if (((void)(bl), 
# 8358 "../../../server-code/src/map/clif.c" 3 4
0
# 8358 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = cmd;
 WBUFL(buf,2) = bl->id;

 switch( bl->type ) {
  case BL_PC:
  {
   const struct map_session_data *ssd = ((const TBL_PC *)BL_UCCAST_(bl));
   const struct party_data *p = 
# 8367 "../../../server-code/src/map/clif.c" 3 4
                               ((void *)0)
# 8367 "../../../server-code/src/map/clif.c"
                                   ;
   const struct guild *g = 
# 8368 "../../../server-code/src/map/clif.c" 3 4
                          ((void *)0)
# 8368 "../../../server-code/src/map/clif.c"
                              ;
   int ps = -1;


   if (ssd->fd == fd && ssd->disguise != -1)
    WBUFL(buf,2) = -bl->id;

   if (ssd->fakename[0] != '\0') {
    WBUFW(buf,0) = cmd = 0x195;
    memcpy(WBUFP(buf,6), ssd->fakename, (23 + 1));
    WBUFB(buf,30) = WBUFB(buf,54) = WBUFB(buf,78) = 0;
    break;
   }
   memcpy(WBUFP(buf,6), ssd->status.name, (23 + 1));

   if (ssd->status.party_id != 0) {
    p = party->search(ssd->status.party_id);
   }
   if (ssd->status.guild_id != 0) {
    if ((g = ssd->guild) != 
# 8387 "../../../server-code/src/map/clif.c" 3 4
                           ((void *)0)
# 8387 "../../../server-code/src/map/clif.c"
                               ) {
     int i;
     do { for ((i) = (0); (i) < (g->max_member); ++(i)) if (g->member[i].account_id == ssd->status.account_id && g->member[i].char_id == ssd->status.char_id) break; } while(
# 8389 "../../../server-code/src/map/clif.c" 3 4
    0
# 8389 "../../../server-code/src/map/clif.c"
    );
     if (i < g->max_member)
      ps = g->member[i].position;
    }
   }

   if (!battle_config.display_party_name && g == 
# 8395 "../../../server-code/src/map/clif.c" 3 4
                                                ((void *)0)
# 8395 "../../../server-code/src/map/clif.c"
                                                    ) {

    p = 
# 8397 "../../../server-code/src/map/clif.c" 3 4
       ((void *)0)
# 8397 "../../../server-code/src/map/clif.c"
           ;
   }

   if (p == 
# 8400 "../../../server-code/src/map/clif.c" 3 4
           ((void *)0) 
# 8400 "../../../server-code/src/map/clif.c"
                && g == 
# 8400 "../../../server-code/src/map/clif.c" 3 4
                        ((void *)0)
# 8400 "../../../server-code/src/map/clif.c"
                            )
    break;

   WBUFW(buf,0) = cmd = 0x195;
   if (p != 
# 8404 "../../../server-code/src/map/clif.c" 3 4
           ((void *)0)
# 8404 "../../../server-code/src/map/clif.c"
               )
    memcpy(WBUFP(buf,30), p->party.name, (23 + 1));
   else
    WBUFB(buf,30) = 0;

   if (g != 
# 8409 "../../../server-code/src/map/clif.c" 3 4
           ((void *)0) 
# 8409 "../../../server-code/src/map/clif.c"
                && ps >= 0 && ps < 20) {
    memcpy(WBUFP(buf,54), g->name,(23 + 1));
    memcpy(WBUFP(buf,78), g->position[ps].name, (23 + 1));
   } else {
    WBUFB(buf,54) = 0;
    WBUFB(buf,78) = 0;
   }
  }
   break;

  case BL_HOM:
   memcpy(WBUFP(buf,6), ((const TBL_HOM *)BL_UCCAST_(bl))->homunculus.name, (23 + 1));
   break;
  case BL_MER:
   memcpy(WBUFP(buf,6), ((const TBL_MER *)BL_UCCAST_(bl))->db->name, (23 + 1));
   break;
  case BL_PET:
   memcpy(WBUFP(buf,6), ((const TBL_PET *)BL_UCCAST_(bl))->pet.name, (23 + 1));
   break;
  case BL_NPC:
   memcpy(WBUFP(buf,6), ((const TBL_NPC *)BL_UCCAST_(bl))->name, (23 + 1));
   break;
  case BL_MOB:
  {
   const struct mob_data *md = ((const TBL_MOB *)BL_UCCAST_(bl));

   memcpy(WBUFP(buf,6), md->name, (23 + 1));
   if (md->guardian_data && md->guardian_data->g) {
    WBUFW(buf,0) = cmd = 0x195;
    WBUFB(buf,30) = 0;
    memcpy(WBUFP(buf,54), md->guardian_data->g->name, (23 + 1));
    memcpy(WBUFP(buf,78), md->guardian_data->castle->castle_name, (23 + 1));
   } else if (battle_config.show_mob_info) {
    char mobhp[50], *str_p = mobhp;
    WBUFW(buf,0) = cmd = 0x195;
    if (battle_config.show_mob_info&4)
     str_p += sprintf(str_p, "Lv. %d | ", md->level);
    if (battle_config.show_mob_info&1)
     str_p += sprintf(str_p, "HP: %u/%u | ", md->status.hp, md->status.max_hp);
    if (battle_config.show_mob_info&2)
     str_p += sprintf(str_p, "HP: %u%% | ", get_percentage(md->status.hp, md->status.max_hp));


    if (str_p != mobhp) {
     *(str_p-3) = '\0';
     memcpy(WBUFP(buf,30), mobhp, (23 + 1));
     WBUFB(buf,54) = 0;
     WBUFB(buf,78) = 0;
    }
   }
  }
   break;
  case BL_CHAT:




   return;
  case BL_ELEM:
   memcpy(WBUFP(buf,6), ((const TBL_ELEM *)BL_UCCAST_(bl))->db->name, (23 + 1));
   break;
  default:
   (showmsg->showError(("clif_charnameack: bad type %u(%d)\n"), bl->type, bl->id));
   return;
 }


 if (fd == 0) {
  clif->send(buf, packet_db[cmd].len, bl, AREA);
 } else {
  WFIFOHEAD(fd, packet_db[cmd].len);
  memcpy(WFIFOP(fd, 0), buf, packet_db[cmd].len);
  WFIFOSET(fd, packet_db[cmd].len);
 }
}



void clif_charnameupdate (struct map_session_data *ssd)
{
 unsigned char buf[103];
 int cmd = 0x195, ps = -1;
 struct party_data *p = 
# 8491 "../../../server-code/src/map/clif.c" 3 4
                       ((void *)0)
# 8491 "../../../server-code/src/map/clif.c"
                           ;
 struct guild *g = 
# 8492 "../../../server-code/src/map/clif.c" 3 4
                  ((void *)0)
# 8492 "../../../server-code/src/map/clif.c"
                      ;

 do { if (((void)(ssd), 
# 8494 "../../../server-code/src/map/clif.c" 3 4
0
# 8494 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if( ssd->fakename[0] )
  return;

 WBUFW(buf,0) = cmd;
 WBUFL(buf,2) = ssd->bl.id;

 memcpy(WBUFP(buf,6), ssd->status.name, (23 + 1));

 if (!battle_config.display_party_name) {
  if (ssd->status.party_id > 0 && ssd->status.guild_id > 0 && (g = ssd->guild) != 
# 8505 "../../../server-code/src/map/clif.c" 3 4
                                                                                 ((void *)0)
# 8505 "../../../server-code/src/map/clif.c"
                                                                                     )
   p = party->search(ssd->status.party_id);
 }else{
  if (ssd->status.party_id > 0)
   p = party->search(ssd->status.party_id);
 }

 if( ssd->status.guild_id > 0 && (g = ssd->guild) != 
# 8512 "../../../server-code/src/map/clif.c" 3 4
                                                    ((void *)0) 
# 8512 "../../../server-code/src/map/clif.c"
                                                         )
 {
  int i;
  do { for ((i) = (0); (i) < (g->max_member); ++(i)) if (g->member[i].account_id == ssd->status.account_id && g->member[i].char_id == ssd->status.char_id) break; } while(
# 8515 "../../../server-code/src/map/clif.c" 3 4
 0
# 8515 "../../../server-code/src/map/clif.c"
 );
  if( i < g->max_member ) ps = g->member[i].position;
 }

 if( p )
  memcpy(WBUFP(buf,30), p->party.name, (23 + 1));
 else
  WBUFB(buf,30) = 0;

 if( g && ps >= 0 && ps < 20 )
 {
  memcpy(WBUFP(buf,54), g->name,(23 + 1));
  memcpy(WBUFP(buf,78), g->position[ps].name, (23 + 1));
 }
 else
 {
  WBUFB(buf,54) = 0;
  WBUFB(buf,78) = 0;
 }


 clif->send(buf, packet_db[cmd].len, &ssd->bl, AREA);
}







void clif_slide(struct block_list *bl, int x, int y)
{
 unsigned char buf[10];
 do { if (((void)(bl), 
# 8548 "../../../server-code/src/map/clif.c" 3 4
0
# 8548 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0x01ff;
 WBUFL(buf, 2) = bl->id;
 WBUFW(buf,6) = x;
 WBUFW(buf,8) = y;
 clif->send(buf, packet_db[0x1ff].len, bl, AREA);

 if( disguised(bl) )
 {
  WBUFL(buf,2) = -bl->id;
  clif->send(buf, packet_db[0x1ff].len, bl, SELF);
 }
}



void clif_disp_overhead(struct block_list *bl, const char* mes)
{
 unsigned char buf[256];
 size_t len_mes;

 do { if (((void)(bl), 
# 8570 "../../../server-code/src/map/clif.c" 3 4
0
# 8570 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(mes), 
# 8571 "../../../server-code/src/map/clif.c" 3 4
0
# 8571 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 len_mes = strlen(mes)+1;

 if (len_mes > sizeof(buf)-8) {
  (showmsg->showError(("clif_disp_overhead: Message too long (length %""z" "u"")\n"), len_mes));
  len_mes = sizeof(buf)-8;
 }

 WBUFW(buf,0) = 0x8d;
 WBUFW(buf,2) = len_mes + 8;
 WBUFL(buf,4) = bl->id;
 (strlib->safestrncpy_((WBUFP(buf,8)),(mes),(len_mes)));
 clif->send(buf, WBUFW(buf,2), bl, AREA_CHAT_WOC);


 if( bl->type == BL_PC ) {
  WBUFW(buf,0) = 0x8e;
  WBUFW(buf,2) = len_mes + 4;
  (strlib->safestrncpy_((WBUFP(buf,4)),(mes),(len_mes)));
  clif->send(buf, WBUFW(buf,2), bl, SELF);
 }

}





void clif_party_xy_remove(struct map_session_data *sd)
{
 unsigned char buf[16];
 do { if (((void)(sd), 
# 8602 "../../../server-code/src/map/clif.c" 3 4
0
# 8602 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 WBUFW(buf,0)=0x107;
 WBUFL(buf,2)=sd->status.account_id;
 WBUFW(buf,6)=-1;
 WBUFW(buf,8)=-1;
 clif->send(buf,packet_db[0x107].len,&sd->bl,PARTY_SAMEMAP_WOS);
}
# 8625 "../../../server-code/src/map/clif.c"
void clif_gospel_info(struct map_session_data *sd, int type)
{
 int fd;

 do { if (((void)(sd), 
# 8629 "../../../server-code/src/map/clif.c" 3 4
0
# 8629 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x215].len);
 WFIFOW(fd,0)=0x215;
 WFIFOL(fd,2)=type;
 WFIFOSET(fd, packet_db[0x215].len);

}
# 8666 "../../../server-code/src/map/clif.c"
void clif_starskill(struct map_session_data* sd, const char* mapname, int monster_id, unsigned char star, unsigned char result)
{
 int fd;

 do { if (((void)(sd), 
# 8670 "../../../server-code/src/map/clif.c" 3 4
0
# 8670 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(mapname), 
# 8671 "../../../server-code/src/map/clif.c" 3 4
0
# 8671 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;

 WFIFOHEAD(fd,packet_db[0x20e].len);
 WFIFOW(fd,0) = 0x20e;
 (strlib->safestrncpy_((WFIFOP(fd,2)),(mapname),((23 + 1))));
 WFIFOL(fd,26) = monster_id;
 WFIFOB(fd,30) = star;
 WFIFOB(fd,31) = result;
 WFIFOSET(fd,packet_db[0x20e].len);
}





void clif_feel_info(struct map_session_data* sd, unsigned char feel_level, unsigned char type)
{
 char mapname[((11 + 1) + 4)];

 do { if (((void)(sd), 
# 8691 "../../../server-code/src/map/clif.c" 3 4
0
# 8691 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (( (feel_level < 3) ? 
# 8692 "../../../server-code/src/map/clif.c" 3 4
0 
# 8692 "../../../server-code/src/map/clif.c"
: (nullpo->assert_report("../../../server-code/src/map/clif.c", 8692, __func__, "feel_level < 3", "failed assertion"), 
# 8692 "../../../server-code/src/map/clif.c" 3 4
1
# 8692 "../../../server-code/src/map/clif.c"
) )) return; } while(0);
 mapindex->getmapname_ext(mapindex->id2name((sd->feel_map[feel_level].index),"../../../server-code/src/map/clif.c", 8693, __func__), mapname);
 clif->starskill(sd, mapname, 0, feel_level, type ? 1 : 0);
}





void clif_hate_info(struct map_session_data *sd, unsigned char hate_level,int class_, unsigned char type)
{
 if( pc->db_checkid(class_) ) {
  clif->starskill(sd, pc->job_name(class_), class_, hate_level, type ? 10 : 11);
 } else if( mob->db_checkid(class_) ) {
  clif->starskill(sd, mob->db(class_)->jname, class_, hate_level, type ? 10 : 11);
 } else {
  (showmsg->showWarning(("clif_hate_info: Received invalid class %d for this packet (char_id=%d, hate_level=%u, type=%u).\n"), class_, sd->status.char_id, (unsigned int)hate_level, (unsigned int)type));
 }
}




void clif_mission_info(struct map_session_data *sd, int mob_id, unsigned char progress)
{
 clif->starskill(sd, mob->db(mob_id)->jname, mob_id, progress, 20);
}




void clif_feel_hate_reset(struct map_session_data *sd)
{
 clif->starskill(sd, "", 0, 0, 30);
}
# 8735 "../../../server-code/src/map/clif.c"
void clif_equiptickack(struct map_session_data* sd, int flag)
{
 int fd;
 do { if (((void)(sd), 
# 8738 "../../../server-code/src/map/clif.c" 3 4
0
# 8738 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;

 WFIFOHEAD(fd, packet_db[0x2d9].len);
 WFIFOW(fd,0) = 0x2d9;
 WFIFOL(fd, 2) = 0;
 WFIFOL(fd, 6) = flag;
 WFIFOSET(fd, packet_db[0x2d9].len);
}






void clif_equpcheckbox(struct map_session_data* sd)
{
 int fd;
 do { if (((void)(sd), 
# 8756 "../../../server-code/src/map/clif.c" 3 4
0
# 8756 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;

 WFIFOHEAD(fd, packet_db[0x2da].len);
 WFIFOW(fd,0) = 0x2da;
 WFIFOB(fd, 2) = (sd->status.show_equip ? 1 : 0);
 WFIFOSET(fd, packet_db[0x2da].len);
}






void clif_viewequip_ack(struct map_session_data* sd, struct map_session_data* tsd) {
 int i, equip = 0;

 do { if (((void)(sd), 
# 8773 "../../../server-code/src/map/clif.c" 3 4
0
# 8773 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(tsd), 
# 8774 "../../../server-code/src/map/clif.c" 3 4
0
# 8774 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 for (i = 0; i < EQI_MAX; i++) {
  int k = tsd->equip_index[i];
  if (k >= 0) {
   if (tsd->status.inventory[k].nameid <= 0 || tsd->inventory_data[k] == 
# 8779 "../../../server-code/src/map/clif.c" 3 4
                                                                        ((void *)0)
# 8779 "../../../server-code/src/map/clif.c"
                                                                            )
    continue;

   clif->item_equip(k+2,&viewequip_list.list[equip++],&tsd->status.inventory[k],tsd->inventory_data[k],pc->equippoint(tsd,k));
  }
 }

 viewequip_list.PacketType = viewequipackType;
 viewequip_list.PacketLength = ( sizeof( viewequip_list ) - sizeof( viewequip_list.list ) ) + ( sizeof(struct EQUIPITEM_INFO) * equip );

 (strlib->safestrncpy_((viewequip_list.characterName),(tsd->status.name),((23 + 1))));

 viewequip_list.job = tsd->status.class_;
 viewequip_list.head = tsd->vd.hair_style;
 viewequip_list.accessory = tsd->vd.head_bottom;
 viewequip_list.accessory2 = tsd->vd.head_mid;
 viewequip_list.accessory3 = tsd->vd.head_top;

 viewequip_list.robe = tsd->vd.robe;

 viewequip_list.headpalette = tsd->vd.hair_color;
 viewequip_list.bodypalette = tsd->vd.cloth_color;
 viewequip_list.sex = tsd->vd.sex;

 clif->send(&viewequip_list, viewequip_list.PacketLength, &sd->bl, SELF);
}
# 8814 "../../../server-code/src/map/clif.c"
void clif_msgtable(struct map_session_data* sd, unsigned short msg_id)
{
 int fd;
 do { if (((void)(sd), 
# 8817 "../../../server-code/src/map/clif.c" 3 4
0
# 8817 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;

 WFIFOHEAD(fd, packet_db[0x291].len);
 WFIFOW(fd,0) = 0x291;
 WFIFOW(fd,2) = msg_id;
 WFIFOSET(fd, packet_db[0x291].len);
}
# 8835 "../../../server-code/src/map/clif.c"
void clif_msgtable_num(struct map_session_data *sd, unsigned short msg_id, int value)
{

 int fd;
 do { if (((void)(sd), 
# 8839 "../../../server-code/src/map/clif.c" 3 4
0
# 8839 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;

 WFIFOHEAD(fd, packet_db[0x7e2].len);
 WFIFOW(fd,0) = 0x7e2;
 WFIFOW(fd,2) = msg_id;
 WFIFOL(fd, 4) = value;
 WFIFOSET(fd, packet_db[0x7e2].len);

}
# 8862 "../../../server-code/src/map/clif.c"
void clif_msgtable_skill(struct map_session_data* sd, uint16 skill_id, int msg_id)
{
 int fd;

 do { if (((void)(sd), 
# 8866 "../../../server-code/src/map/clif.c" 3 4
0
# 8866 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;

 WFIFOHEAD(fd, packet_db[0x7e6].len);
 WFIFOW(fd,0) = 0x7e6;
 WFIFOW(fd,2) = skill_id;
 WFIFOL(fd,4) = msg_id;
 WFIFOSET(fd, packet_db[0x7e6].len);
}






# 8880 "../../../server-code/src/map/clif.c" 3 4
_Bool 
# 8880 "../../../server-code/src/map/clif.c"
    clif_process_message(struct map_session_data *sd, int format, const char **name_, size_t *namelen_, const char **message_, size_t *messagelen_)
{
 const char *text, *name, *message;
 unsigned int packetlen, textlen;
 size_t namelen, messagelen;
 int fd = sd->fd;

 do { if (((void)(sd), 
# 8887 "../../../server-code/src/map/clif.c" 3 4
0
# 8887 "../../../server-code/src/map/clif.c"
)) return(
# 8887 "../../../server-code/src/map/clif.c" 3 4
0
# 8887 "../../../server-code/src/map/clif.c"
); } while(0);
 do { if (((void)(name_), 
# 8888 "../../../server-code/src/map/clif.c" 3 4
0
# 8888 "../../../server-code/src/map/clif.c"
)) return(
# 8888 "../../../server-code/src/map/clif.c" 3 4
0
# 8888 "../../../server-code/src/map/clif.c"
); } while(0);
 do { if (((void)(namelen_), 
# 8889 "../../../server-code/src/map/clif.c" 3 4
0
# 8889 "../../../server-code/src/map/clif.c"
)) return(
# 8889 "../../../server-code/src/map/clif.c" 3 4
0
# 8889 "../../../server-code/src/map/clif.c"
); } while(0);
 do { if (((void)(message_), 
# 8890 "../../../server-code/src/map/clif.c" 3 4
0
# 8890 "../../../server-code/src/map/clif.c"
)) return(
# 8890 "../../../server-code/src/map/clif.c" 3 4
0
# 8890 "../../../server-code/src/map/clif.c"
); } while(0);
 do { if (((void)(messagelen_), 
# 8891 "../../../server-code/src/map/clif.c" 3 4
0
# 8891 "../../../server-code/src/map/clif.c"
)) return(
# 8891 "../../../server-code/src/map/clif.c" 3 4
0
# 8891 "../../../server-code/src/map/clif.c"
); } while(0);

 *name_ = 
# 8893 "../../../server-code/src/map/clif.c" 3 4
         ((void *)0)
# 8893 "../../../server-code/src/map/clif.c"
             ;
 *namelen_ = 0;
 *message_ = 
# 8895 "../../../server-code/src/map/clif.c" 3 4
            ((void *)0)
# 8895 "../../../server-code/src/map/clif.c"
                ;
 *messagelen_ = 0;

 packetlen = RFIFOW(fd,2);

 if (packetlen < 4 + 1) {

  (showmsg->showWarning(("clif_process_message: Received malformed packet from player '%s' (no message data)!\n"), sd->status.name));
  return 
# 8903 "../../../server-code/src/map/clif.c" 3 4
        0
# 8903 "../../../server-code/src/map/clif.c"
             ;
 }

 text = RFIFOP(fd,4);
 textlen = packetlen - 4;


 if( format == 0 )
 {

  name = text;
  namelen = (strlib->strnlen_((sd->status.name),((23 + 1)-1)));

  if( strncmp(name, sd->status.name, namelen) ||
   name[namelen] != ' ' || name[namelen+1] != ':' || name[namelen+2] != ' ' )
  {

   (showmsg->showWarning(("clif_process_message: Player '%s' sent a message using an incorrect name! Forcing a relog...\n"), sd->status.name));
   sockt->eof(fd);
   return 
# 8922 "../../../server-code/src/map/clif.c" 3 4
         0
# 8922 "../../../server-code/src/map/clif.c"
              ;
  }

  message = name + namelen + 3;
  messagelen = textlen - namelen - 3;
 }
 else
 {
  if( textlen < (23 + 1) + 1 )
  {
   (showmsg->showWarning(("clif_process_message: Received malformed packet from player '%s' (packet length is incorrect)!\n"), sd->status.name));
   return 
# 8933 "../../../server-code/src/map/clif.c" 3 4
         0
# 8933 "../../../server-code/src/map/clif.c"
              ;
  }


  name = text;
  namelen = (strlib->strnlen_((name),((23 + 1)-1)));

  if (name[namelen] != '\0') {

   (showmsg->showWarning(("clif_process_message: Player '%s' sent an unterminated name!\n"), sd->status.name));
   return 
# 8943 "../../../server-code/src/map/clif.c" 3 4
         0
# 8943 "../../../server-code/src/map/clif.c"
              ;
  }

  message = name + (23 + 1);
  messagelen = textlen - (23 + 1);
 }

 if (messagelen != (strlib->strnlen_((message),(messagelen)))+1) {

  (showmsg->showWarning(("clif_process_message: Received malformed packet from player '%s' (length is incorrect)!\n"), sd->status.name));
  return 
# 8953 "../../../server-code/src/map/clif.c" 3 4
        0
# 8953 "../../../server-code/src/map/clif.c"
             ;
 }

 if (message[messagelen-1] != '\0') {

  (showmsg->showWarning(("clif_process_message: Player '%s' sent an unterminated message string!\n"), sd->status.name));
  return 
# 8959 "../../../server-code/src/map/clif.c" 3 4
        0
# 8959 "../../../server-code/src/map/clif.c"
             ;
 }
 if (messagelen > (255 + 1)-1) {





  (showmsg->showWarning(("clif_process_message: Player '%s' sent a message too long ('%.*s')!\n"), sd->status.name, (255 + 1)-1, message));
  return 
# 8968 "../../../server-code/src/map/clif.c" 3 4
        0
# 8968 "../../../server-code/src/map/clif.c"
             ;
 }

 *name_ = name;
 *namelen_ = namelen;
 *message_ = message;
 *messagelen_ = messagelen;
 return 
# 8975 "../../../server-code/src/map/clif.c" 3 4
       1
# 8975 "../../../server-code/src/map/clif.c"
           ;
}

void clif_channel_msg(struct channel_data *chan, struct map_session_data *sd, char *msg)
{
 struct DBIterator *iter;
 struct map_session_data *user;
 unsigned short msg_len;
 uint32 color;

 do { if (((void)(chan), 
# 8985 "../../../server-code/src/map/clif.c" 3 4
0
# 8985 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(sd), 
# 8986 "../../../server-code/src/map/clif.c" 3 4
0
# 8986 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(msg), 
# 8987 "../../../server-code/src/map/clif.c" 3 4
0
# 8987 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 iter = ( (chan->users)->iterator(chan->users) );
 msg_len = strlen(msg) + 1;
 color = channel->config->colors[chan->color];

 WFIFOHEAD(sd->fd,msg_len + 12);
 WFIFOW(sd->fd,0) = 0x2C1;
 WFIFOW(sd->fd,2) = msg_len + 12;
 WFIFOL(sd->fd,4) = 0;
 WFIFOL(sd->fd,8) = (((color) & 0x0000FF) << 16 | ((color) & 0x00FF00) | ((color) & 0xFF0000) >> 16);
 (strlib->safestrncpy_((WFIFOP(sd->fd,12)),(msg),(msg_len)));

 for (user = ( DB->data2ptr((iter)->first((iter),
# 8999 "../../../server-code/src/map/clif.c" 3 4
            ((void *)0)
# 8999 "../../../server-code/src/map/clif.c"
            )) ); ( (iter)->exists(iter) ); user = ( DB->data2ptr((iter)->next((iter),
# 8999 "../../../server-code/src/map/clif.c" 3 4
                                                      ((void *)0)
# 8999 "../../../server-code/src/map/clif.c"
                                                      )) )) {
  if( user->fd == sd->fd )
   continue;
  WFIFOHEAD(user->fd,msg_len + 12);
  memcpy(WFIFOP(user->fd,0), WFIFOP(sd->fd,0), msg_len + 12);
  WFIFOSET(user->fd, msg_len + 12);
 }

 WFIFOSET(sd->fd, msg_len + 12);

 ( (iter)->destroy(iter) );
}

void clif_channel_msg2(struct channel_data *chan, char *msg)
{
 struct DBIterator *iter;
 struct map_session_data *user;
 unsigned char buf[210];
 unsigned short msg_len;
 uint32 color;

 do { if (((void)(chan), 
# 9020 "../../../server-code/src/map/clif.c" 3 4
0
# 9020 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(msg), 
# 9021 "../../../server-code/src/map/clif.c" 3 4
0
# 9021 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 iter = ( (chan->users)->iterator(chan->users) );
 msg_len = strlen(msg) + 1;
 color = channel->config->colors[chan->color];

 WBUFW(buf,0) = 0x2C1;
 WBUFW(buf,2) = msg_len + 12;
 WBUFL(buf,4) = 0;
 WBUFL(buf,8) = (((color) & 0x0000FF) << 16 | ((color) & 0x00FF00) | ((color) & 0xFF0000) >> 16);
 (strlib->safestrncpy_((WBUFP(buf,12)),(msg),(msg_len)));

 for (user = ( DB->data2ptr((iter)->first((iter),
# 9032 "../../../server-code/src/map/clif.c" 3 4
            ((void *)0)
# 9032 "../../../server-code/src/map/clif.c"
            )) ); ( (iter)->exists(iter) ); user = ( DB->data2ptr((iter)->next((iter),
# 9032 "../../../server-code/src/map/clif.c" 3 4
                                                      ((void *)0)
# 9032 "../../../server-code/src/map/clif.c"
                                                      )) )) {
  WFIFOHEAD(user->fd,msg_len + 12);
  memcpy(WFIFOP(user->fd,0), WBUFP(buf,0), msg_len + 12);
  WFIFOSET(user->fd, msg_len + 12);
 }

 ( (iter)->destroy(iter) );
}
# 9050 "../../../server-code/src/map/clif.c"
void clif_parse_WantToConnection(int fd, struct map_session_data* sd) {
 struct block_list* bl;
 struct auth_node* node;
 int cmd, account_id, char_id, login_id1, sex;
 unsigned int client_tick;

 if (sd) {
  (showmsg->showError(("clif_parse_WantToConnection : invalid request (character already logged in)\n")));
  return;
 }



 cmd = RFIFOW(fd,0);
 account_id = RFIFOL(fd, packet_db[cmd].pos[0]);
 char_id = RFIFOL(fd, packet_db[cmd].pos[1]);
 login_id1 = RFIFOL(fd, packet_db[cmd].pos[2]);
 client_tick = RFIFOL(fd, packet_db[cmd].pos[3]);
 sex = RFIFOB(fd, packet_db[cmd].pos[4]);

 if( core->runflag != MAPSERVER_ST_RUNNING ) {
  clif->authfail_fd(fd,1);
  return;
 }


 bl = map->id2bl(account_id);
 if(bl && bl->type != BL_PC) {
  (showmsg->showError(("clif_parse_WantToConnection: a non-player object already has id %d, please increase the starting account number\n"), account_id));
  WFIFOHEAD(fd,packet_db[0x6a].len);
  WFIFOW(fd,0) = 0x6a;
  WFIFOB(fd,2) = 3;
  WFIFOSET(fd,packet_db[0x6a].len);
  sockt->eof(fd);

  return;
 }

 if (bl ||
  ((node=chrif->search(account_id)) &&
   !(node->account_id == account_id && node->char_id == char_id && node->state == ST_LOGIN)))
 {
  clif->authfail_fd(fd, 8);
  return;
 }

 ((sd) = (struct map_session_data *) (iMalloc->calloc(((1)),(sizeof(struct map_session_data)),"../../../server-code/src/map/clif.c", 9096, __func__)));
 sd->fd = fd;

 sd->cryptKey = (( ((( clif->cryptKey[0] * clif->cryptKey[1] ) + clif->cryptKey[2]) & 0xFFFFFFFF)
      * clif->cryptKey[1] ) + clif->cryptKey[2]) & 0xFFFFFFFF;
 sd->parse_cmd_func = clif->parse_cmd;

 sockt->session[fd]->session_data = sd;

 pc->setnewpc(sd, account_id, char_id, login_id1, client_tick, sex, fd);






 WFIFOHEAD(fd,packet_db[0x283].len);
 WFIFOW(fd,0) = 0x283;
 WFIFOL(fd,2) = sd->bl.id;
 WFIFOSET(fd,packet_db[0x283].len);


 chrif->authreq(sd,
# 9118 "../../../server-code/src/map/clif.c" 3 4
                  0
# 9118 "../../../server-code/src/map/clif.c"
                       );
}

void clif_parse_LoadEndAck(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_LoadEndAck(int fd, struct map_session_data *sd) {
 
# 9125 "../../../server-code/src/map/clif.c" 3 4
_Bool 
# 9125 "../../../server-code/src/map/clif.c"
     first_time = 
# 9125 "../../../server-code/src/map/clif.c" 3 4
                  0
# 9125 "../../../server-code/src/map/clif.c"
                       ;

 if(sd->bl.prev != 
# 9127 "../../../server-code/src/map/clif.c" 3 4
                  ((void *)0)
# 9127 "../../../server-code/src/map/clif.c"
                      )
  return;

 if (!sd->state.active) {

  sd->state.connect_new = 0;
  return;
 }

 if (sd->state.rewarp) {
  sd->state.rewarp = 0;
  clif->changemap(sd, sd->bl.m, sd->bl.x, sd->bl.y);
  return;
 }

 sd->state.warping = 0;
 sd->state.dialog = 0;






 clif->changelook(&sd->bl,LOOK_WEAPON,0);


 if(sd->vd.cloth_color)
  clif->refreshlook(&sd->bl,sd->bl.id,LOOK_CLOTHES_COLOR,sd->vd.cloth_color,SELF);
 if (sd->vd.body_style)
  clif->refreshlook(&sd->bl,sd->bl.id,LOOK_BODY2,sd->vd.body_style,SELF);

 clif->inventorylist(sd);
 pc->checkitem(sd);


 if(( (sd)->sc.data[SC_PUSH_CART] )) {
  clif->cartlist(sd);
  clif->updatestatus(sd,SP_CARTINFO);
 }


 clif->updatestatus(sd,SP_WEIGHT);
 clif->updatestatus(sd,SP_MAXWEIGHT);



 if(sd->status.guild_id)
  guild->send_memberinfoshort(sd,1);

 if(battle_config.pc_invincible_time > 0) {
  pc->setinvincibletimer(sd,battle_config.pc_invincible_time);
 }

 if( map->list[sd->bl.m].users++ == 0 && battle_config.dynamic_mobs )
  map->spawnmobs(sd->bl.m);

 if( map->list[sd->bl.m].instance_id >= 0 ) {
  instance->list[map->list[sd->bl.m].instance_id].users++;
  instance->check_idle(map->list[sd->bl.m].instance_id);
 }

 if( ( ((sd)->extra_temp_permissions&(PC_PERM_VIEW_HPMETER)) != 0 || ((sd)->group->e_permissions&(PC_PERM_VIEW_HPMETER)) != 0 ) ) {
  map->list[sd->bl.m].hpmeter_visible++;
  sd->state.hpmeter_visible = 1;
 }

 if (!( (sd)->sc.option&OPTION_INVISIBLE )) {
  map->list[sd->bl.m].users_pvp++;
 }

 sd->state.debug_remove_map = 0;


 sd->state.callshop = 0;

 map->addblock(&sd->bl);
 clif->spawn(&sd->bl);



 if(sd->status.party_id) {
  party->send_movemap(sd);
  clif->party_hp(sd);
 }

 if( sd->bg_id ) clif->bg_hp(sd);

 if (map->list[sd->bl.m].flag.pvp && !( (sd)->sc.option&OPTION_INVISIBLE )) {
  if(!battle_config.pk_mode) {
   if (!map->list[sd->bl.m].flag.pvp_nocalcrank)
    sd->pvp_timer = timer->add(timer->gettick()+200, pc->calc_pvprank_timer, sd->bl.id, 0);
   sd->pvp_rank = 0;
   sd->pvp_lastusers = 0;
   sd->pvp_point = 5;
   sd->pvp_won = 0;
   sd->pvp_lost = 0;
  }
  clif->map_property(sd, MAPPROPERTY_FREEPVPZONE);
 } else

 if(sd->duel_group)
  clif->map_property(sd, MAPPROPERTY_FREEPVPZONE);

 if (map->list[sd->bl.m].flag.gvg_dungeon)
  clif->map_property(sd, MAPPROPERTY_FREEPVPZONE);

 if( (map->list[sd->bl.m].flag.gvg || map->list[sd->bl.m].flag.gvg_castle) )
  clif->map_property(sd, MAPPROPERTY_AGITZONE);



 map->foreachinarea(clif->getareachar, sd->bl.m, sd->bl.x-(battle->bc->area_size), sd->bl.y-(battle->bc->area_size), sd->bl.x+(battle->bc->area_size), sd->bl.y+(battle->bc->area_size), BL_ALL, sd);


 if( sd->pd ) {
  if( battle_config.pet_no_gvg && (map->list[sd->bl.m].flag.gvg || map->list[sd->bl.m].flag.gvg_castle) ) {
   clif->message(sd->fd, atcommand->msgsd((sd),(866)));
   pet->menu(sd, 3);
  } else {
   map->addblock(&sd->pd->bl);
   clif->spawn(&sd->pd->bl);
   clif->send_petdata(sd,sd->pd,0,0);
   clif->send_petstatus(sd);

  }
 }


 if( ((sd->hd) && (sd->hd)->homunculus.vaporize == HOM_ST_ACTIVE && (sd->hd)->battle_status.hp > 0) ) {
  map->addblock(&sd->hd->bl);
  clif->spawn(&sd->hd->bl);
  clif->send_homdata(sd,SP_ACK,0);
  clif->hominfo(sd,sd->hd,1);
  clif->hominfo(sd,sd->hd,0);
  clif->homskillinfoblock(sd);
  if( battle_config.hom_setting&0x8 )
   (status->calc_bl_((&sd->hd->bl), (enum scb_flag)(SCB_SPEED), SCO_NONE));
  if( !(battle_config.hom_setting&0x2) )
   skill->unit_move(&sd->hd->bl,timer->gettick(),1);
 }

 if( sd->md ) {
  map->addblock(&sd->md->bl);
  clif->spawn(&sd->md->bl);
  clif->mercenary_info(sd);
  clif->mercenary_skillblock(sd);
  (status->calc_bl_((&sd->md->bl), (enum scb_flag)(SCB_SPEED), SCO_NONE));
 }

 if( sd->ed ) {
  map->addblock(&sd->ed->bl);
  clif->spawn(&sd->ed->bl);
  clif->elemental_info(sd);
  clif->elemental_updatestatus(sd,SP_HP);
  clif->hpmeter_single(sd->fd,sd->ed->bl.id,sd->ed->battle_status.hp,sd->ed->battle_status.max_hp);
  clif->elemental_updatestatus(sd,SP_SP);
  (status->calc_bl_((&sd->ed->bl), (enum scb_flag)(SCB_SPEED), SCO_NONE));
 }

 if(sd->state.connect_new) {
  int lv;
  first_time = 
# 9288 "../../../server-code/src/map/clif.c" 3 4
              1
# 9288 "../../../server-code/src/map/clif.c"
                  ;
  sd->state.connect_new = 0;
  clif->skillinfoblock(sd);
  clif->hotkeys(sd);
  clif->updatestatus(sd,SP_BASEEXP);
  clif->updatestatus(sd,SP_NEXTBASEEXP);
  clif->updatestatus(sd,SP_JOBEXP);
  clif->updatestatus(sd,SP_NEXTJOBEXP);
  clif->updatestatus(sd,SP_SKILLPOINT);
  clif->initialstatus(sd);

  if (( (sd)->sc.option&OPTION_FALCON ))
   clif->status_change(&sd->bl, SI_FALCON, 1, 0, 0, 0, 0);
  if (( (sd)->sc.option&(OPTION_RIDING) ) || ( (sd)->sc.option&OPTION_DRAGON ))
   clif->status_change(&sd->bl, SI_RIDING, 1, 0, 0, 0, 0);
  else if (( (sd)->sc.option&OPTION_WUGRIDER ))
   clif->status_change(&sd->bl, SI_WUGRIDER, 1, 0, 0, 0, 0);

  if(sd->status.manner < 0)
   (status->change_start((
# 9307 "../../../server-code/src/map/clif.c" 3 4
  ((void *)0)
# 9307 "../../../server-code/src/map/clif.c"
  ),(&sd->bl),(SC_NOCHAT),100*(100),(0),0,0,0,(0),SCFLAG_NONE));


  if ((lv = pc->checkskill(sd,SG_KNOWLEDGE)) > 0) {
   int i;
   for (i = 0; i < 3; i++) {
    if (sd->bl.m == sd->feel_map[i].m) {
     (status->change_start((
# 9314 "../../../server-code/src/map/clif.c" 3 4
    ((void *)0)
# 9314 "../../../server-code/src/map/clif.c"
    ),(&sd->bl),(SC_KNOWLEDGE),100*(100),(lv),0,0,0,(skill->get_time(SG_KNOWLEDGE, lv)),SCFLAG_NONE));
     break;
    }
   }
  }

  if(sd->pd && sd->pd->pet.intimate > 900)
   clif->pet_emotion(sd->pd,(sd->pd->pet.class_ - 100)*100 + 50 + pet->hungry_val(sd->pd));

  if(((sd->hd) && (sd->hd)->homunculus.vaporize == HOM_ST_ACTIVE && (sd->hd)->battle_status.hp > 0))
   homun->init_timers(sd->hd);

  if (map->night_flag && map->list[sd->bl.m].flag.nightenabled) {
   sd->state.night = 1;
   clif->status_change(&sd->bl, SI_SKE, 1, 0, 0, 0, 0);
  }


  map->foreachpc(clif->friendslist_toggle_sub, sd->status.account_id, sd->status.char_id, 1);


  npc->script_event(sd, NPCE_LOGIN);
 } else {

  clif->updatestatus(sd,SP_STR);
  clif->updatestatus(sd,SP_AGI);
  clif->updatestatus(sd,SP_VIT);
  clif->updatestatus(sd,SP_INT);
  clif->updatestatus(sd,SP_DEX);
  clif->updatestatus(sd,SP_LUK);

  if (sd->state.warp_clean) {

   sd->state.using_fake_npc = 0;
   sd->state.menu_or_input = 0;
   sd->npc_menu = 0;
   if(sd->npc_id)
    npc->event_dequeue(sd);
  } else {
   sd->state.warp_clean = 1;
  }
  if( sd->guild && ( battle_config.guild_notice_changemap == 2 || ( battle_config.guild_notice_changemap == 1 && sd->state.changemap ) ) )
   clif->guild_notice(sd,sd->guild);
 }

 if( sd->state.changemap ) {

  clif->partyinvitationstate(sd);
  clif->equpcheckbox(sd);

  if( (battle_config.bg_flee_penalty != 100 || battle_config.gvg_flee_penalty != 100)
   && ((map->list[sd->state.pmap].flag.gvg || map->list[sd->state.pmap].flag.gvg_castle) || (map->list[sd->bl.m].flag.gvg || map->list[sd->bl.m].flag.gvg_castle)
    || map->list[sd->state.pmap].flag.battleground || map->list[sd->bl.m].flag.battleground) )
   (status->calc_bl_((&sd->bl), (enum scb_flag)(SCB_FLEE), SCO_NONE));

  if( map->night_flag && map->list[sd->bl.m].flag.nightenabled ) {

   if( !sd->state.night ) {
    sd->state.night = 1;
    clif->status_change(&sd->bl, SI_SKE, 1, 0, 0, 0, 0);
   }
  } else if( sd->state.night ) {
   sd->state.night = 0;
   clif->sc_end(&sd->bl, sd->bl.id, SELF, SI_SKE);
  }

  if( map->list[sd->bl.m].flag.battleground ) {
   clif->map_type(sd, MAPTYPE_BATTLEFIELD);
   if( map->list[sd->bl.m].flag.battleground == 2 )
    clif->bg_updatescore_single(sd);
  }

  if( map->list[sd->bl.m].flag.allowks && !(map->list[sd->bl.m].flag.town || map->list[sd->bl.m].flag.pvp || map->list[sd->bl.m].flag.gvg || map->list[sd->bl.m].flag.battleground) ) {
   char output[128];
   sprintf(output, "[ Kill Steal Protection Disabled. KS is allowed in this map ]");
   clif->broadcast(&sd->bl, output, strlen(output) + 1, BC_BLUE, SELF);
  }

  map->iwall_get(sd);
  (status->calc_bl_(&(sd)->bl, SCB_ALL, (SCO_NONE)));
  sd->state.changemap = 
# 9394 "../../../server-code/src/map/clif.c" 3 4
                       0
# 9394 "../../../server-code/src/map/clif.c"
                            ;

  if (channel->config->local && channel->config->local_autojoin) {
   channel->map_join(sd);
  }
  if (channel->config->irc && channel->config->irc_autojoin) {
   channel->irc_join(sd);
  }
 }

 mail->clear(sd);

 clif->maptypeproperty2(&sd->bl,SELF);


 if( sd->state.gmaster_flag ) {
  guild->aura_refresh(sd,GD_LEADERSHIP,guild->checkskill(sd->guild,GD_LEADERSHIP));
  guild->aura_refresh(sd,GD_GLORYWOUNDS,guild->checkskill(sd->guild,GD_GLORYWOUNDS));
  guild->aura_refresh(sd,GD_SOULCOLD,guild->checkskill(sd->guild,GD_SOULCOLD));
  guild->aura_refresh(sd,GD_HAWKEYES,guild->checkskill(sd->guild,GD_HAWKEYES));
 }

 if( sd->state.vending ) {
  clif->openvending(sd,sd->bl.id,sd->vending);
  clif->showvendingboard(&sd->bl,sd->message,0);
 }

 if(map->list[sd->bl.m].flag.loadevent)
  npc->script_event(sd, NPCE_LOADMAP);

 if (pc->checkskill(sd, SG_DEVIL) && !pc->nextjobexp(sd))
  clif->sc_end(&sd->bl, sd->bl.id, SELF, SI_DEVIL1);

 if (sd->sc.opt2)
  clif->changeoption(&sd->bl);

 if( sd->sc.data[SC_MONSTER_TRANSFORM] && battle_config.mon_trans_disable_in_gvg && (map->list[sd->bl.m].flag.gvg || map->list[sd->bl.m].flag.gvg_castle) ){
  (status->change_end_((&sd->bl),(SC_MONSTER_TRANSFORM),((-1)),"../../../server-code/src/map/clif.c",9431));
  clif->message(sd->fd, atcommand->msgsd((sd),(1488)));
 }

 clif->weather_check(sd);


 if( sd->guild && first_time )
  clif->guild_notice(sd, sd->guild);


 if (map->getcell(sd->bl.m, &sd->bl, sd->bl.x, sd->bl.y, CELL_CHKNPC))
  npc->touch_areanpc(sd,sd->bl.m,sd->bl.x,sd->bl.y);
 else
  npc->untouch_areanpc(sd, sd->bl.m, sd->bl.x, sd->bl.y);


 if( !sd->status.hp && !( (sd)->state.dead_sit == 1 ) && status->isdead(&sd->bl) )
  ( (sd)->state.dead_sit = (sd)->vd.dead_sit = 1 );


 if(( (sd)->state.dead_sit == 1 ))
  clif->clearunit_area(&sd->bl, CLR_DEAD);
 else {
  skill->usave_trigger(sd);
  sd->ud.dir = 0;
 }


 if(!battle_config.pc_invincible_time)
  skill->unit_move(&sd->bl,timer->gettick(),1);



 {
  int i;
  for(i = 0; i < map->list[sd->bl.m].qi_count; i++) {
   struct questinfo *qi = &map->list[sd->bl.m].qi_data[i];
   if( quest->check(sd, qi->quest_id, HAVEQUEST) == -1 ) {
    if( qi->hasJob ) {
     if( sd->class_ == qi->job )
      clif->quest_show_event(sd, &qi->nd->bl, qi->icon, qi->color);
    } else {
     clif->quest_show_event(sd, &qi->nd->bl, qi->icon, qi->color);
    }
   }
  }
 }

}



void clif_notify_time(struct map_session_data* sd, int64 time) {
 int fd;

 do { if (((void)(sd), 
# 9487 "../../../server-code/src/map/clif.c" 3 4
0
# 9487 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;

 WFIFOHEAD(fd,packet_db[0x7f].len);
 WFIFOW(fd,0) = 0x7f;
 WFIFOL(fd,2) = (uint32)time;
 WFIFOSET(fd,packet_db[0x7f].len);
}

void clif_parse_TickSend(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));




void clif_parse_TickSend(int fd, struct map_session_data *sd)
{
 sd->client_tick = RFIFOL(fd,packet_db[RFIFOW(fd,0)].pos[0]);

 clif->notify_time(sd, timer->gettick());
}






void clif_hotkeys_send(struct map_session_data *sd) {

 struct packet_hotkey p;
 int i;
 do { if (((void)(sd), 
# 9517 "../../../server-code/src/map/clif.c" 3 4
0
# 9517 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 p.PacketType = hotkeyType;

 p.Rotate = sd->status.hotkey_rowshift;

 for(i = 0; i < ( (int)(sizeof(p.hotkey)/sizeof((p.hotkey)[0])) ); i++) {
  p.hotkey[i].isSkill = sd->status.hotkeys[i].type;
  p.hotkey[i].ID = sd->status.hotkeys[i].id;
  p.hotkey[i].count = sd->status.hotkeys[i].lv;
 }
 clif->send(&p, sizeof(p), &sd->bl, SELF);

}

void clif_parse_HotkeyRowShift(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));
void clif_parse_HotkeyRowShift(int fd, struct map_session_data *sd)
{
 int cmd = RFIFOW(fd, 0);
 sd->status.hotkey_rowshift = RFIFOB(fd, packet_db[cmd].pos[0]);
}

void clif_parse_Hotkey(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_Hotkey(int fd, struct map_session_data *sd) {

 unsigned short idx;
 int cmd;

 cmd = RFIFOW(fd, 0);
 idx = RFIFOW(fd, packet_db[cmd].pos[0]);
 if (idx >= 38) return;

 sd->status.hotkeys[idx].type = RFIFOB(fd, packet_db[cmd].pos[1]);
 sd->status.hotkeys[idx].id = RFIFOL(fd, packet_db[cmd].pos[2]);
 sd->status.hotkeys[idx].lv = RFIFOW(fd, packet_db[cmd].pos[3]);

}




void clif_progressbar(struct map_session_data * sd, unsigned int color, unsigned int second)
{
 int fd;

 do { if (((void)(sd), 
# 9563 "../../../server-code/src/map/clif.c" 3 4
0
# 9563 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;

 WFIFOHEAD(fd,packet_db[0x2f0].len);
 WFIFOW(fd,0) = 0x2f0;
 WFIFOL(fd,2) = color;
 WFIFOL(fd,6) = second;
 WFIFOSET(fd,packet_db[0x2f0].len);
}



void clif_progressbar_abort(struct map_session_data * sd)
{
 int fd;

 do { if (((void)(sd), 
# 9579 "../../../server-code/src/map/clif.c" 3 4
0
# 9579 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;

 WFIFOHEAD(fd,packet_db[0x2f2].len);
 WFIFOW(fd,0) = 0x2f2;
 WFIFOSET(fd,packet_db[0x2f2].len);
}

void clif_parse_progressbar(int fd, struct map_session_data * sd) __attribute__((nonnull (2)));


void clif_parse_progressbar(int fd, struct map_session_data * sd)
{
 int npc_id = sd->progressbar.npc_id;

 if( timer->gettick() < sd->progressbar.timeout && sd->st )
  sd->st->state = END;

 sd->progressbar.timeout = sd->state.workinprogress = sd->progressbar.npc_id = 0;
 npc->scriptcont(sd, npc_id, 
# 9598 "../../../server-code/src/map/clif.c" 3 4
                            0
# 9598 "../../../server-code/src/map/clif.c"
                                 );
}

void clif_parse_WalkToXY(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));




void clif_parse_WalkToXY(int fd, struct map_session_data *sd)
{
 short x, y;

 if (( (sd)->state.dead_sit == 1 )) {
  clif->clearunit_area(&sd->bl, CLR_DEAD);
  return;
 }

 if (sd->sc.opt1 && ( sd->sc.opt1 == OPT1_STONEWAIT || sd->sc.opt1 == OPT1_BURNING ))
  ;


 else if (( (sd)->npc_id || (sd)->state.vending || (sd)->state.buyingstore || (sd)->chatID || ((sd)->sc.opt1 && (sd)->sc.opt1 != OPT1_BURNING) || (sd)->state.trading || (sd)->state.storage_flag || (sd)->state.prevend ))
  return;

 if(sd->sc.data[SC_RUN] || sd->sc.data[SC_WUGDASH])
  return;

 pc->delinvincibletimer(sd);

 RFIFOPOS(fd, packet_db[RFIFOW(fd,0)].pos[0], &x, &y, 
# 9627 "../../../server-code/src/map/clif.c" 3 4
                                                     ((void *)0)
# 9627 "../../../server-code/src/map/clif.c"
                                                         );


 pc->update_idle_time(sd, BCIDLE_WALK);

 unit->walktoxy(&sd->bl, x, y, 4);
}







void clif_disconnect_ack(struct map_session_data* sd, short result)
{
 int fd;

 do { if (((void)(sd), 
# 9645 "../../../server-code/src/map/clif.c" 3 4
0
# 9645 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;

 WFIFOHEAD(fd,packet_db[0x18b].len);
 WFIFOW(fd,0) = 0x18b;
 WFIFOW(fd,2) = result;
 WFIFOSET(fd,packet_db[0x18b].len);
}

void clif_parse_QuitGame(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));




void clif_parse_QuitGame(int fd, struct map_session_data *sd)
{

 if( !sd->sc.data[SC_CLOAKING] && !sd->sc.data[SC_HIDING] && !sd->sc.data[SC_CHASEWALK] && !sd->sc.data[SC_CLOAKINGEXCEED] && !sd->sc.data[SC__INVISIBILITY] &&
  (!battle_config.prevent_logout || ((timer->gettick())-(sd->canlog_tick)) > battle_config.prevent_logout) )
 {
  sockt->eof(fd);

  clif->disconnect_ack(sd, 0);
 } else {
  clif->disconnect_ack(sd, 1);
 }
}

void clif_parse_GetCharNameRequest(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));




void clif_parse_GetCharNameRequest(int fd, struct map_session_data *sd) {
 int id = RFIFOL(fd,packet_db[RFIFOW(fd,0)].pos[0]);
 struct block_list* bl;


 if( id < 0 && -id == sd->bl.id )
  id = sd->bl.id;

 bl = map->id2bl(id);
 if( bl == 
# 9687 "../../../server-code/src/map/clif.c" 3 4
          ((void *)0) 
# 9687 "../../../server-code/src/map/clif.c"
               )
  return;

 if( sd->bl.m != bl->m || !(path->check_distance((&sd->bl)->x - (bl)->x, (&sd->bl)->y - (bl)->y, (battle->bc->area_size))) )
  return;
# 9709 "../../../server-code/src/map/clif.c"
 clif->charnameack(fd, bl);
}
int clif_undisguise_timer(int tid, int64 tick, int id, intptr_t data) {
 struct map_session_data * sd;
 if( (sd = map->id2sd(id)) ) {
  sd->fontcolor_tid = (-1);
  if( sd->fontcolor && sd->disguise == sd->status.class_ )
   pc->disguise(sd,-1);
 }
 return 0;
}

void clif_parse_GlobalMessage(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));



void clif_parse_GlobalMessage(int fd, struct map_session_data* sd)
{
 const char *text = RFIFOP(fd,4);
 size_t textlen = RFIFOW(fd,2) - 4;

 const char *name = 
# 9730 "../../../server-code/src/map/clif.c" 3 4
                   ((void *)0)
# 9730 "../../../server-code/src/map/clif.c"
                       , *message = 
# 9730 "../../../server-code/src/map/clif.c" 3 4
                                    ((void *)0)
# 9730 "../../../server-code/src/map/clif.c"
                                        ;
 char *fakename = 
# 9731 "../../../server-code/src/map/clif.c" 3 4
                 ((void *)0)
# 9731 "../../../server-code/src/map/clif.c"
                     ;
 size_t namelen, messagelen;

 
# 9734 "../../../server-code/src/map/clif.c" 3 4
_Bool 
# 9734 "../../../server-code/src/map/clif.c"
     is_fake;


 if( !clif->process_message(sd, 0, &name, &namelen, &message, &messagelen) )
  return;

 if( atcommand->exec(fd, sd, message, 
# 9740 "../../../server-code/src/map/clif.c" 3 4
                                     1
# 9740 "../../../server-code/src/map/clif.c"
                                         ) )
  return;

 if( !pc->can_talk(sd) )
  return;

 if( battle_config.min_chat_delay ) {
  if (((sd->cantalk_tick)-(timer->gettick())) > 0)
   return;
  sd->cantalk_tick = timer->gettick() + battle_config.min_chat_delay;
 }

 if( (sd->class_&0x0fff) == MAPID_SUPER_NOVICE ) {
  unsigned int next = pc->nextbaseexp(sd);
  if( next == 0 ) next = pc->thisbaseexp(sd);
  if( next ) {
   int percent = (int)( ( (float)sd->status.base_exp/(float)next )*1000. );
   if( (battle_config.snovice_call_type || percent) && ( percent%100 ) == 0 ) {
    switch (sd->state.snovice_call_flag) {
     case 0:
      if( strstr(message, atcommand->msg(1479)) )
       sd->state.snovice_call_flag = 1;
      break;
     case 1: {
      char buf[256];
      snprintf(buf, 256, atcommand->msg(1480), sd->status.name);
      if( strstr(message, buf) )
       sd->state.snovice_call_flag = 2;
     }
      break;
     case 2:
      if( strstr(message, atcommand->msg(1481)) )
       sd->state.snovice_call_flag = 3;
      break;
     case 3:
      (status->change_start((
# 9775 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0)
# 9775 "../../../server-code/src/map/clif.c"
     ),(&sd->bl),(status->skill2sc(MO_EXPLOSIONSPIRITS)),100*(100),(17),0,0,0,(skill->get_time(MO_EXPLOSIONSPIRITS, 5)),SCFLAG_NONE));
      clif->skill_nodamage(&sd->bl, &sd->bl, MO_EXPLOSIONSPIRITS, 5, 1);
      sd->state.snovice_call_flag = 0;
      break;
    }
   }
  }
 }

 pc->update_idle_time(sd, BCIDLE_CHAT);

 if( sd->gcbind ) {
  channel->send(sd->gcbind,sd,message);
  return;
 } else if ( sd->fontcolor && !sd->chatID ) {
  char mout[200];
  unsigned char mylen = 1;
  uint32 color = 0;

  if( sd->disguise == -1 ) {
   sd->fontcolor_tid = timer->add(timer->gettick()+5000, clif->undisguise_timer, sd->bl.id, 0);
   pc->disguise(sd,sd->status.class_);
   if( ( (sd)->state.dead_sit == 1 ) )
    clif->clearunit_single(-sd->bl.id, CLR_DEAD, sd->fd);
   if( unit->is_walking(&sd->bl) )
    clif->move(&sd->ud);
  } else if ( sd->disguise == sd->status.class_ && sd->fontcolor_tid != (-1) ) {
   const struct TimerData *td;
   if( (td = timer->get(sd->fontcolor_tid)) ) {
    timer->settick(sd->fontcolor_tid, td->tick+5000);
   }
  }

  mylen += snprintf(mout, 200, "%s : %s",sd->fakename[0]?sd->fakename:sd->status.name,message);

  color = channel->config->colors[sd->fontcolor - 1];
  WFIFOHEAD(fd,mylen + 12);
  WFIFOW(fd,0) = 0x2C1;
  WFIFOW(fd,2) = mylen + 12;
  WFIFOL(fd,4) = sd->bl.id;
  WFIFOL(fd,8) = (((color) & 0x0000FF) << 16 | ((color) & 0x00FF00) | ((color) & 0xFF0000) >> 16);
  (strlib->safestrncpy_((WFIFOP(fd,12)),(mout),(mylen)));
  clif->send(WFIFOP(fd,0), WFIFOW(fd,2), &sd->bl, AREA_WOS);
  WFIFOL(fd,4) = -sd->bl.id;
  WFIFOSET(fd, mylen + 12);
  return;
 }




 if( ( is_fake = ( sd->fakename[0] ) ) ) {
  fakename = (char*) (iMalloc->malloc((strlen(sd->fakename)+messagelen+3),"../../../server-code/src/map/clif.c", 9827, __func__));
  strcpy(fakename, sd->fakename);
  strcat(fakename, " : ");
  strcat(fakename, message);
  textlen = strlen(fakename) + 1;
 }

 WFIFOHEAD(fd, 8 + textlen);
 WFIFOW(fd,0) = 0x8d;
 WFIFOW(fd,2) = 8 + textlen;
 WFIFOL(fd,4) = sd->bl.id;
 (strlib->safestrncpy_((WFIFOP(fd,8)),(is_fake ? fakename : text),(textlen)));

 clif->send(WFIFOP(fd,0), WFIFOW(fd,2), &sd->bl, sd->chatID ? CHAT_WOS : AREA_CHAT_WOC);


 if( is_fake ) {
  WFIFOW(fd,0) = 0x8e;
  WFIFOW(fd,2) = textlen + 4;
  (strlib->safestrncpy_((WFIFOP(fd,4)),(fakename),(textlen)));
  (iMalloc->free((fakename),"../../../server-code/src/map/clif.c", 9847, __func__));
 } else {
  memcpy(WFIFOP(fd,0), RFIFOP(fd,0), RFIFOW(fd,2));
  WFIFOW(fd,0) = 0x8e;
 }
 WFIFOSET(fd, WFIFOW(fd,2));


 logs->chat(LOG_CHAT_GLOBAL, 0, sd->status.char_id, sd->status.account_id, mapindex->id2name((sd->mapindex),"../../../server-code/src/map/clif.c", 9855, __func__), sd->bl.x, sd->bl.y, 
# 9855 "../../../server-code/src/map/clif.c" 3 4
                                                                                                                              ((void *)0)
# 9855 "../../../server-code/src/map/clif.c"
                                                                                                                                  , message);


 map->foreachinrange(npc_chat->sub, &sd->bl, (battle->bc->area_size), BL_NPC, text, textlen, &sd->bl);
}

void clif_parse_MapMove(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));



void clif_parse_MapMove(int fd, struct map_session_data *sd)
{
 char command[((11 + 1) + 4)+25];
 char map_name[((11 + 1) + 4)];

 (strlib->safestrncpy_((map_name),(RFIFOP(fd,2)),(((11 + 1) + 4))));
 sprintf(command, "%cmapmove %s %d %d", atcommand->at_symbol, map_name, RFIFOW(fd,18), RFIFOW(fd,20));
 atcommand->exec(fd, sd, command, 
# 9872 "../../../server-code/src/map/clif.c" 3 4
                                 1
# 9872 "../../../server-code/src/map/clif.c"
                                     );
}
# 9890 "../../../server-code/src/map/clif.c"
void clif_changed_dir(struct block_list *bl, enum send_target target)
{
 unsigned char buf[64];

 do { if (((void)(bl), 
# 9894 "../../../server-code/src/map/clif.c" 3 4
0
# 9894 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 WBUFW(buf,0) = 0x9c;
 WBUFL(buf,2) = bl->id;
 WBUFW(buf,6) = bl->type == BL_PC ? ((const TBL_PC *)BL_UCCAST_(bl))->head_dir : 0;
 WBUFB(buf,8) = unit->getdir(bl);

 clif->send(buf, packet_db[0x9c].len, bl, target);

 if (disguised(bl)) {
  WBUFL(buf,2) = -bl->id;
  WBUFW(buf,6) = 0;
  clif->send(buf, packet_db[0x9c].len, bl, SELF);
 }
}

void clif_parse_ChangeDir(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));




void clif_parse_ChangeDir(int fd, struct map_session_data *sd)
{
 unsigned char headdir, dir;

 headdir = RFIFOB(fd,packet_db[RFIFOW(fd,0)].pos[0]);
 dir = RFIFOB(fd,packet_db[RFIFOW(fd,0)].pos[1]);
 ( (sd)->ud.dir = (dir) ,(sd)->head_dir = (headdir) );

 clif->changed_dir(&sd->bl, AREA_WOS);
}

void clif_parse_Emotion(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));




void clif_parse_Emotion(int fd, struct map_session_data *sd)
{
 int emoticon = RFIFOB(fd,packet_db[RFIFOW(fd,0)].pos[0]);

 if (battle_config.basic_skill_check == 0 || pc->checkskill(sd, NV_BASIC) >= 2) {
  if (emoticon == E_MUTE) {
   clif->skill_fail(sd, 1, USESKILL_FAIL_LEVEL, 1);
   return;
  }

  if (sd->emotionlasttime + 1 >= time(
# 9940 "../../../server-code/src/map/clif.c" 3 4
                                     ((void *)0)
# 9940 "../../../server-code/src/map/clif.c"
                                         )) {
   sd->emotionlasttime = time(
# 9941 "../../../server-code/src/map/clif.c" 3 4
                             ((void *)0)
# 9941 "../../../server-code/src/map/clif.c"
                                 );
   clif->skill_fail(sd, 1, USESKILL_FAIL_LEVEL, 1);
   return;
  }
  sd->emotionlasttime = time(
# 9945 "../../../server-code/src/map/clif.c" 3 4
                            ((void *)0)
# 9945 "../../../server-code/src/map/clif.c"
                                );

  pc->update_idle_time(sd, BCIDLE_EMOTION);

  if(battle_config.client_reshuffle_dice && emoticon>=E_DICE1 && emoticon<=E_DICE6) {
   emoticon = rnd()%6+E_DICE1;
  }

  clif->emotion(&sd->bl, emoticon);
 } else
  clif->skill_fail(sd, 1, USESKILL_FAIL_LEVEL, 1);
}



void clif_user_count(struct map_session_data* sd, int count) {
 int fd;

 do { if (((void)(sd), 
# 9963 "../../../server-code/src/map/clif.c" 3 4
0
# 9963 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;

 WFIFOHEAD(fd,packet_db[0xc2].len);
 WFIFOW(fd,0) = 0xc2;
 WFIFOL(fd,2) = count;
 WFIFOSET(fd,packet_db[0xc2].len);
}

void clif_parse_HowManyConnections(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));



void clif_parse_HowManyConnections(int fd, struct map_session_data *sd) {
 clif->user_count(sd, map->getusers());
}

void clif_parse_ActionRequest_sub(struct map_session_data *sd, int action_type, int target_id, int64 tick)
{
 do { if (((void)(sd), 
# 9982 "../../../server-code/src/map/clif.c" 3 4
0
# 9982 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if (( (sd)->state.dead_sit == 1 )) {
  clif->clearunit_area(&sd->bl, CLR_DEAD);
  return;
 }



 if( sd->sc.count && (
   sd->sc.data[SC_TRICKDEAD] ||
   (sd->sc.data[SC_AUTOCOUNTER] && action_type != 0x07) ||
    sd->sc.data[SC_BLADESTOP] ||
    sd->sc.data[SC_DEEP_SLEEP] )
    )
  return;

 if(action_type != 0x00 && action_type != 0x07)
  (unit->stop_walking(&(sd)->bl, (STOPWALKING_FLAG_FIXPOS)));
 (unit->stop_attack(&(sd)->bl));

 if(target_id<0 && -target_id == sd->bl.id)
  target_id = sd->bl.id;

 switch(action_type) {
  case 0x00:
  case 0x07:
  {
   struct npc_data *nd = map->id2nd(target_id);
   if (nd != 
# 10010 "../../../server-code/src/map/clif.c" 3 4
            ((void *)0)
# 10010 "../../../server-code/src/map/clif.c"
                ) {
    npc->click(sd, nd);
    return;
   }

   if( ( (sd)->npc_id || (sd)->state.vending || (sd)->state.buyingstore || (sd)->chatID || ((sd)->sc.opt1 && (sd)->sc.opt1 != OPT1_BURNING) || (sd)->state.trading || (sd)->state.storage_flag || (sd)->state.prevend ) || ( (sd)->vd.dead_sit == 2 ) || sd->sc.option&OPTION_HIDE )
    return;

   if( sd->sc.option&OPTION_COSTUME )
    return;

   if (!battle_config.sdelay_attack_enable && pc->checkskill(sd, SA_FREECAST) <= 0) {
    if (((tick)-(sd->ud.canact_tick)) < 0) {
     clif->skill_fail(sd, 1, USESKILL_FAIL_SKILLINTERVAL, 0);
     return;
    }
   }

   pc->delinvincibletimer(sd);
   pc->update_idle_time(sd, BCIDLE_ATTACK);
   unit->attack(&sd->bl, target_id, action_type != 0);
  }
  break;
  case 0x02:
   if (battle_config.basic_skill_check && pc->checkskill(sd, NV_BASIC) < 3) {
    clif->skill_fail(sd, 1, USESKILL_FAIL_LEVEL, 2);
    break;
   }

   if (sd->sc.data[SC_SITDOWN_FORCE] || sd->sc.data[SC_BANANA_BOMB_SITDOWN_POSTDELAY])
    return;

   if(( (sd)->vd.dead_sit == 2 )) {

    clif->sitting(&sd->bl);
    return;
   }

   if (sd->ud.skilltimer != (-1) || (sd->sc.opt1 && sd->sc.opt1 != OPT1_BURNING ))
    break;

   if (sd->sc.count && (
    sd->sc.data[SC_DANCING] ||
    sd->sc.data[SC_ANKLESNARE] ||
    (sd->sc.data[SC_GRAVITATION] && sd->sc.data[SC_GRAVITATION]->val3 == BCT_SELF)
   ))
    break;

   pc->update_idle_time(sd, BCIDLE_SIT);

   ( (sd)->state.dead_sit = (sd)->vd.dead_sit = 2 );
   skill->sit(sd,1);
   clif->sitting(&sd->bl);
  break;
  case 0x03:

   if (sd->sc.data[SC_SITDOWN_FORCE] || sd->sc.data[SC_BANANA_BOMB_SITDOWN_POSTDELAY])
    return;

   if (!( (sd)->vd.dead_sit == 2 )) {

    clif->standing(&sd->bl);
    return;
   }

   pc->update_idle_time(sd, BCIDLE_SIT);

   pc->setstand(sd);
   skill->sit(sd,0);
   clif->standing(&sd->bl);
  break;
 }
}

void clif_parse_ActionRequest(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));
# 10096 "../../../server-code/src/map/clif.c"
void clif_parse_ActionRequest(int fd, struct map_session_data *sd)
{
 clif->pActionRequest_sub(sd,
  RFIFOB(fd,packet_db[RFIFOW(fd,0)].pos[1]),
  RFIFOL(fd,packet_db[RFIFOW(fd,0)].pos[0]),
  timer->gettick()
 );
}

void clif_parse_Restart(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));





void clif_parse_Restart(int fd, struct map_session_data *sd) {
 switch(RFIFOB(fd,2)) {
  case 0x00:
   pc->respawn(sd,CLR_OUTSIGHT);
   break;
  case 0x01:

   if (!sd->sc.data[SC_CLOAKING] && !sd->sc.data[SC_HIDING] && !sd->sc.data[SC_CHASEWALK]
    && !sd->sc.data[SC_CLOAKINGEXCEED] && !sd->sc.data[SC__INVISIBILITY]
    && (!battle_config.prevent_logout || ((timer->gettick())-(sd->canlog_tick)) > battle_config.prevent_logout)
   ) {

    chrif->charselectreq(sd, sockt->session[fd]->client_addr);
   } else {
    clif->disconnect_ack(sd, 1);
   }
   break;
 }
}

void clif_parse_WisMessage(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_WisMessage(int fd, struct map_session_data* sd)
{
 struct map_session_data* dstsd;
 int i;

 const char *target, *message;
 size_t namelen, messagelen;


 if( !clif->process_message(sd, 1, &target, &namelen, &message, &messagelen) )
  return;

 if ( atcommand->exec(fd, sd, message, 
# 10146 "../../../server-code/src/map/clif.c" 3 4
                                      1
# 10146 "../../../server-code/src/map/clif.c"
                                          ) )
  return;


 if( !pc->can_talk(sd) )
  return;

 if (battle_config.min_chat_delay) {
  if (((sd->cantalk_tick)-(timer->gettick())) > 0) {
   return;
  }
  sd->cantalk_tick = timer->gettick() + battle_config.min_chat_delay;
 }

 pc->update_idle_time(sd, BCIDLE_CHAT);


 logs->chat(LOG_CHAT_WHISPER, 0, sd->status.char_id, sd->status.account_id, mapindex->id2name((sd->mapindex),"../../../server-code/src/map/clif.c", 10163, __func__), sd->bl.x, sd->bl.y, target, message);




 if (target[0] && (strncasecmp(target,"NPC:",4) == 0) && (strlen(target) > 4)) {
  const char *str = target+4;
  struct npc_data *nd;
  if ((nd = npc->name2id(str))) {
   char split_data[10][(255 + 1)];
   char *split;
   char output[256];

   str = message;

   if( str[0] == '|' && strlen(str) >= 4 )
    str += 3;
   for( i = 0; i < 10; ++i ) {
    split = strchr(str,'#');
    if( split == 
# 10182 "../../../server-code/src/map/clif.c" 3 4
                ((void *)0) 
# 10182 "../../../server-code/src/map/clif.c"
                     ) {
     (strlib->safestrncpy_((split_data[i]),(str),(( (int)(sizeof(split_data[i])/sizeof((split_data[i])[0])) ))));
     for( ++i; i < 10; ++i )
      split_data[i][0] = '\0';
     break;
    }
    *split = '\0';
    (strlib->safestrncpy_((split_data[i]),(str),(( (int)(sizeof(split_data[i])/sizeof((split_data[i])[0])) ))));
    str = split+1;
   }

   for( i = 0; i < 10; ++i ) {
    sprintf(output, "@whispervar%d$", i);
    script->set_var(sd,output,(char *) split_data[i]);
   }

   sprintf(output, "%s::OnWhisperGlobal", nd->exname);
   npc->event(sd,output,0);

   return;
  }
 } else if( target[0] == '#' ) {
  const char *chname = target;
  struct channel_data *chan = channel->search(chname, sd);

  if (chan) {
   int k;
   do { for ((k) = (0); (k) < (sd->channel_count); ++(k)) if (sd->channels[k] == chan) break; } while(
# 10209 "../../../server-code/src/map/clif.c" 3 4
  0
# 10209 "../../../server-code/src/map/clif.c"
  );
   if (k < sd->channel_count || channel->join(chan, sd, "", 
# 10210 "../../../server-code/src/map/clif.c" 3 4
                                                           1
# 10210 "../../../server-code/src/map/clif.c"
                                                               ) == HCS_STATUS_OK) {
    channel->send(chan,sd,message);
   } else {
    clif->message(fd, atcommand->msgfd((fd),(1402)));
   }
   return;
  } else if (strcasecmp(&chname[1], channel->config->ally_name) == 0) {
   clif->message(fd, atcommand->msgfd((fd),(1294)));
   return;
  }
 }


 dstsd = map->nick2sd(target);

 if (dstsd == 
# 10225 "../../../server-code/src/map/clif.c" 3 4
             ((void *)0) 
# 10225 "../../../server-code/src/map/clif.c"
                  || strcmp(dstsd->status.name, target) != 0) {





  intif->wis_message(sd, target, message, messagelen);
  return;
 }


 if (dstsd->state.ignoreAll && ( (sd)->group->level ) <= ( (dstsd)->group->level )) {
  if (( (dstsd)->sc.option&OPTION_INVISIBLE ) && ( (sd)->group->level ) < ( (dstsd)->group->level ))
   clif->wis_end(fd, 1);
  else
   clif->wis_end(fd, 3);
  return;
 }


 if( dstsd->state.autotrade ) {
  char output[256];
  sprintf(output, "%s is in autotrade mode and cannot receive whispered messages.", dstsd->status.name);
  clif->wis_message(fd, map->wisp_server_name, output, strlen(output) + 1);
  return;
 }

 if( ( (sd)->group->level ) <= ( (dstsd)->group->level ) ) {

  do { for ((i) = (0); (i) < (20); ++(i)) if (dstsd->ignore[i].name[0] == '\0' || strcmp(dstsd->ignore[i].name, sd->status.name) == 0) break; } while(
# 10254 "../../../server-code/src/map/clif.c" 3 4
 0
# 10254 "../../../server-code/src/map/clif.c"
 );
  if(i < 20 && dstsd->ignore[i].name[0] != '\0') {
   clif->wis_end(fd, 2);
   return;
  }
 }


 clif->wis_end(fd, 0);


 clif->wis_message(dstsd->fd, sd->status.name, message, messagelen);
}

void clif_parse_Broadcast(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));



void clif_parse_Broadcast(int fd, struct map_session_data *sd)
{
 const char commandname[] = "kami";
 char command[sizeof commandname + 2 + (255 + 1)] = "";
 int len = (int)RFIFOW(fd,2) - 4;

 if (len < 0)
  return;

 sprintf(command, "%c%s ", atcommand->at_symbol, commandname);


 if (len >= (int)(sizeof command - strlen(command)))
  len = (int)(sizeof command - strlen(command)) - 1;

 strncat(command, RFIFOP(fd,4), len);
 atcommand->exec(fd, sd, command, 
# 10288 "../../../server-code/src/map/clif.c" 3 4
                                 1
# 10288 "../../../server-code/src/map/clif.c"
                                     );
}

void clif_parse_TakeItem(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));




void clif_parse_TakeItem(int fd, struct map_session_data *sd)
{
 int map_object_id = RFIFOL(fd,packet_db[RFIFOW(fd,0)].pos[0]);
 struct flooritem_data *fitem = map->id2fi(map_object_id);

 do {
  if (( (sd)->state.dead_sit == 1 )) {
   clif->clearunit_area(&sd->bl, CLR_DEAD);
   break;
  }

  if (fitem == 
# 10307 "../../../server-code/src/map/clif.c" 3 4
              ((void *)0) 
# 10307 "../../../server-code/src/map/clif.c"
                   || fitem->bl.m != sd->bl.m)
   break;

  if( sd->sc.count && (
     sd->sc.data[SC_HIDING] ||
     sd->sc.data[SC_CLOAKING] ||
     sd->sc.data[SC_TRICKDEAD] ||
     sd->sc.data[SC_BLADESTOP] ||
     sd->sc.data[SC_CLOAKINGEXCEED] ||
     ( (&sd->sc)->data[SC_NOCHAT] && (&sd->sc)->data[SC_NOCHAT]->val1&(MANNER_NOITEM) )
   ) )
   break;

  if (( (sd)->npc_id || (sd)->state.vending || (sd)->state.buyingstore || (sd)->chatID || ((sd)->sc.opt1 && (sd)->sc.opt1 != OPT1_BURNING) || (sd)->state.trading || (sd)->state.storage_flag || (sd)->state.prevend ))
   break;

  if (!pc->takeitem(sd, fitem))
   break;

  return;
 } while (0);

 clif->additem(sd,0,0,6);
}

void clif_parse_DropItem(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));




void clif_parse_DropItem(int fd, struct map_session_data *sd)
{
 int item_index = RFIFOW(fd,packet_db[RFIFOW(fd,0)].pos[0])-2;
 int item_amount = RFIFOW(fd,packet_db[RFIFOW(fd,0)].pos[1]);

 for(;;) {
  if (( (sd)->state.dead_sit == 1 ))
   break;

  if ( ( (sd)->npc_id || (sd)->state.buyingstore || ((sd)->sc.opt1 && (sd)->sc.opt1 != OPT1_BURNING) || (sd)->state.trading || (sd)->state.storage_flag || (sd)->state.prevend ) || sd->state.vending )
   break;

  if (sd->sc.count && (
   sd->sc.data[SC_AUTOCOUNTER] ||
   sd->sc.data[SC_BLADESTOP] ||
   ( (&sd->sc)->data[SC_NOCHAT] && (&sd->sc)->data[SC_NOCHAT]->val1&(MANNER_NOITEM) )
  ))
   break;

  if (!pc->dropitem(sd, item_index, item_amount))
   break;

  pc->update_idle_time(sd, BCIDLE_DROPITEM);

  return;
 }


 clif->dropitem(sd, item_index, 0);
}

void clif_parse_UseItem(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));




void clif_parse_UseItem(int fd, struct map_session_data *sd)
{
 int n;

 if (( (sd)->state.dead_sit == 1 )) {
  clif->clearunit_area(&sd->bl, CLR_DEAD);
  return;
 }

 if ( (!sd->npc_id && ( (sd)->npc_id || (sd)->state.vending || (sd)->state.buyingstore || (sd)->state.trading )) || sd->chatID )
  return;


 pc->update_idle_time(sd, BCIDLE_USEITEM);
 n = RFIFOW(fd,packet_db[RFIFOW(fd,0)].pos[0])-2;

 if (n < 0 || n >= 100)
  return;
 if (!pc->useitem(sd,n))
  clif->useitemack(sd,n,0,
# 10392 "../../../server-code/src/map/clif.c" 3 4
                         0
# 10392 "../../../server-code/src/map/clif.c"
                              );
}

void clif_parse_EquipItem(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));



void clif_parse_EquipItem(int fd,struct map_session_data *sd)
{
 const struct packet_equip_item *p = RP2PTR(fd);
 int index = 0;

 if(( (sd)->state.dead_sit == 1 )) {
  clif->clearunit_area(&sd->bl,CLR_DEAD);
  return;
 }

 index = p->index - 2;
 if (index >= 100)
  return;

 if( sd->npc_id ) {
  if ( !sd->npc_item_flag )
   return;
 } else if (sd->state.storage_flag != STORAGE_FLAG_CLOSED || sd->sc.opt1)
  ;
 else if ( ( (sd)->npc_id || (sd)->state.buyingstore || ((sd)->sc.opt1 && (sd)->sc.opt1 != OPT1_BURNING) || (sd)->state.trading || (sd)->state.storage_flag || (sd)->state.prevend ) || sd->state.prerefining )
  return;

 if(!sd->status.inventory[index].identify) {
  clif->equipitemack(sd, index, 0, EIA_FAIL);
  return;
 }

 if(!sd->inventory_data[index])
  return;

 if(sd->inventory_data[index]->type == IT_PETARMOR){
  pet->equipitem(sd, index);
  return;
 }

 pc->update_idle_time(sd, BCIDLE_USEITEM);


 if(sd->inventory_data[index]->type == IT_AMMO)
  pc->equipitem(sd, index, EQP_AMMO);
 else
  pc->equipitem(sd, index, p->wearLocation);
}

void clif_parse_UnequipItem(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_UnequipItem(int fd,struct map_session_data *sd)
{
 int index;

 if(( (sd)->state.dead_sit == 1 )) {
  clif->clearunit_area(&sd->bl,CLR_DEAD);
  return;
 }

 if( sd->npc_id ) {
  if ( !sd->npc_item_flag )
   return;
 } else if (sd->state.storage_flag != STORAGE_FLAG_CLOSED || sd->sc.opt1)
  ;
 else if ( ( (sd)->npc_id || (sd)->state.buyingstore || ((sd)->sc.opt1 && (sd)->sc.opt1 != OPT1_BURNING) || (sd)->state.trading || (sd)->state.storage_flag || (sd)->state.prevend ) || sd->state.prerefining )
  return;

 index = RFIFOW(fd,2)-2;

 pc->update_idle_time(sd, BCIDLE_USEITEM);

 pc->unequipitem(sd,index, PCUNEQUIPITEM_RECALC);
}

void clif_parse_NpcClicked(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));




void clif_parse_NpcClicked(int fd,struct map_session_data *sd)
{
 struct block_list *bl;

 if( ( (sd)->state.dead_sit == 1 ) ) {
  clif->clearunit_area(&sd->bl,CLR_DEAD);
  return;
 }
 if( sd->npc_id || sd->state.workinprogress&2 ){

  clif->msgtable(sd, MSG_NPC_WORK_IN_PROGRESS);

  return;
 }
 if ( ( (sd)->npc_id || (sd)->state.buyingstore || ((sd)->sc.opt1 && (sd)->sc.opt1 != OPT1_BURNING) || (sd)->state.trading || (sd)->state.storage_flag || (sd)->state.prevend ) || !(bl = map->id2bl(RFIFOL(fd,2))) || sd->state.vending )
  return;

 switch (bl->type) {
  case BL_MOB:
  case BL_PC:
   clif->pActionRequest_sub(sd, 0x07, bl->id, timer->gettick());
   break;
  case BL_NPC:
   if( sd->ud.skill_id < RK_ENCHANTBLADE && sd->ud.skilltimer != (-1) ) {

    clif->msgtable(sd, MSG_NPC_WORK_IN_PROGRESS);

    break;
   }
   if( bl->m != -1 )
    npc->click(sd, ((TBL_NPC *)BL_UCAST_(bl)));
   break;
 }
}

void clif_parse_NpcBuySellSelected(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));





void clif_parse_NpcBuySellSelected(int fd, struct map_session_data *sd)
{
 if (sd->state.trading)
  return;
 npc->buysellsel(sd, RFIFOL(fd,2), RFIFOB(fd,6));
}
# 10530 "../../../server-code/src/map/clif.c"
void clif_npc_buy_result(struct map_session_data* sd, unsigned char result) {
 int fd;

 do { if (((void)(sd), 
# 10533 "../../../server-code/src/map/clif.c" 3 4
0
# 10533 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0xca].len);
 WFIFOW(fd,0) = 0xca;
 WFIFOB(fd,2) = result;
 WFIFOSET(fd,packet_db[0xca].len);
}

void clif_parse_NpcBuyListSend(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_NpcBuyListSend(int fd, struct map_session_data* sd)
{
 int n = ((int)RFIFOW(fd,2)-4) / 4;
 int result;

 do { if (( (n >= 0) ? 
# 10549 "../../../server-code/src/map/clif.c" 3 4
0 
# 10549 "../../../server-code/src/map/clif.c"
: (nullpo->assert_report("../../../server-code/src/map/clif.c", 10549, __func__, "n >= 0", "failed assertion"), 
# 10549 "../../../server-code/src/map/clif.c" 3 4
1
# 10549 "../../../server-code/src/map/clif.c"
) )) return; } while(0);

 if( sd->state.trading || !sd->npc_shopid || ( ((sd)->extra_temp_permissions&(PC_PERM_DISABLE_STORE)) != 0 || ((sd)->group->e_permissions&(PC_PERM_DISABLE_STORE)) != 0 ) ) {
  result = 1;
 } else {
  struct itemlist item_list = { 0 };
  int i;

  memset(&(item_list), 0, sizeof(item_list));
  do { int _empty_ = ( (item_list)._max_ )-( (item_list)._len_ ); if ((n) > _empty_) { while ((n) > _empty_) _empty_ += (1); do { if ((_empty_+( (item_list)._len_ )) > ( (item_list)._max_ )) { if (( (item_list)._max_ ) == 0) ( (item_list)._data_ ) = (iMalloc->malloc(((_empty_+( (item_list)._len_ ))*sizeof(( ( ( (item_list)._data_ )[0] ) ))),"../../../server-code/src/map/clif.c", 10558, __func__)); else ( (item_list)._data_ ) = (iMalloc->realloc((( (item_list)._data_ )),((_empty_+( (item_list)._len_ ))*sizeof(( ( ( (item_list)._data_ )[0] ) ))),"../../../server-code/src/map/clif.c", 10558, __func__)); memset(( (item_list)._data_ )+( (item_list)._len_ ), 0, (( (item_list)._max_ )-( (item_list)._len_ ))*sizeof(( ( ( (item_list)._data_ )[0] ) ))); ( (item_list)._max_ ) = (_empty_+( (item_list)._len_ )); } else if ((_empty_+( (item_list)._len_ )) == 0 && ( (item_list)._max_ ) > 0) { (iMalloc->free((( (item_list)._data_ )),"../../../server-code/src/map/clif.c", 10558, __func__)); ( (item_list)._data_ ) = 
# 10558 "../../../server-code/src/map/clif.c" 3 4
 ((void *)0)
# 10558 "../../../server-code/src/map/clif.c"
 ; ( (item_list)._max_ ) = 0; ( (item_list)._len_ ) = 0; } else if ((_empty_+( (item_list)._len_ )) < ( (item_list)._max_ )) { ( (item_list)._data_ ) = (iMalloc->realloc((( (item_list)._data_ )),((_empty_+( (item_list)._len_ ))*sizeof(( ( ( (item_list)._data_ )[0] ) ))),"../../../server-code/src/map/clif.c", 10558, __func__)); ( (item_list)._max_ ) = (_empty_+( (item_list)._len_ )); if ((_empty_+( (item_list)._len_ )) - ( (item_list)._len_ ) > 0) ( (item_list)._len_ ) = (_empty_+( (item_list)._len_ )); } } while(
# 10558 "../../../server-code/src/map/clif.c" 3 4
 0
# 10558 "../../../server-code/src/map/clif.c"
 ); } } while(
# 10558 "../../../server-code/src/map/clif.c" 3 4
 0
# 10558 "../../../server-code/src/map/clif.c"
 );
  for (i = 0; i < n; i++) {
   struct itemlist_entry entry = { 0 };

   entry.amount = RFIFOW(fd, 4 + 4 * i);
   entry.id = RFIFOW(fd, 4 + 4 * i + 2);

   do { ( ( (item_list)._data_ )[( (item_list)._len_ )] ) = (entry); ++( (item_list)._len_ ); }while(
# 10565 "../../../server-code/src/map/clif.c" 3 4
  0
# 10565 "../../../server-code/src/map/clif.c"
  );
  }
  result = npc->buylist(sd, &item_list);
  do { if (( (item_list)._max_ ) > 0) { (iMalloc->free((( (item_list)._data_ )),"../../../server-code/src/map/clif.c", 10568, __func__)); ( (item_list)._data_ ) = 
# 10568 "../../../server-code/src/map/clif.c" 3 4
 ((void *)0)
# 10568 "../../../server-code/src/map/clif.c"
 ; ( (item_list)._max_ ) = 0; ( (item_list)._len_ ) = 0; } } while(
# 10568 "../../../server-code/src/map/clif.c" 3 4
 0
# 10568 "../../../server-code/src/map/clif.c"
 );
 }

 sd->npc_shopid = 0;

 clif->npc_buy_result(sd, result);
}






void clif_npc_sell_result(struct map_session_data* sd, unsigned char result) {
 int fd;

 do { if (((void)(sd), 
# 10584 "../../../server-code/src/map/clif.c" 3 4
0
# 10584 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0xcb].len);
 WFIFOW(fd,0) = 0xcb;
 WFIFOB(fd,2) = result;
 WFIFOSET(fd,packet_db[0xcb].len);
}

void clif_parse_NpcSellListSend(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_NpcSellListSend(int fd,struct map_session_data *sd)
{
 int fail=0,n;

 n = ((int)RFIFOW(fd,2)-4) /4;

 do { if (( (n >= 0) ? 
# 10601 "../../../server-code/src/map/clif.c" 3 4
0 
# 10601 "../../../server-code/src/map/clif.c"
: (nullpo->assert_report("../../../server-code/src/map/clif.c", 10601, __func__, "n >= 0", "failed assertion"), 
# 10601 "../../../server-code/src/map/clif.c" 3 4
1
# 10601 "../../../server-code/src/map/clif.c"
) )) return; } while(0);

 if (sd->state.trading || !sd->npc_shopid) {
  fail = 1;
 } else {
  struct itemlist item_list = { 0 };
  int i;

  memset(&(item_list), 0, sizeof(item_list));
  do { int _empty_ = ( (item_list)._max_ )-( (item_list)._len_ ); if ((n) > _empty_) { while ((n) > _empty_) _empty_ += (1); do { if ((_empty_+( (item_list)._len_ )) > ( (item_list)._max_ )) { if (( (item_list)._max_ ) == 0) ( (item_list)._data_ ) = (iMalloc->malloc(((_empty_+( (item_list)._len_ ))*sizeof(( ( ( (item_list)._data_ )[0] ) ))),"../../../server-code/src/map/clif.c", 10610, __func__)); else ( (item_list)._data_ ) = (iMalloc->realloc((( (item_list)._data_ )),((_empty_+( (item_list)._len_ ))*sizeof(( ( ( (item_list)._data_ )[0] ) ))),"../../../server-code/src/map/clif.c", 10610, __func__)); memset(( (item_list)._data_ )+( (item_list)._len_ ), 0, (( (item_list)._max_ )-( (item_list)._len_ ))*sizeof(( ( ( (item_list)._data_ )[0] ) ))); ( (item_list)._max_ ) = (_empty_+( (item_list)._len_ )); } else if ((_empty_+( (item_list)._len_ )) == 0 && ( (item_list)._max_ ) > 0) { (iMalloc->free((( (item_list)._data_ )),"../../../server-code/src/map/clif.c", 10610, __func__)); ( (item_list)._data_ ) = 
# 10610 "../../../server-code/src/map/clif.c" 3 4
 ((void *)0)
# 10610 "../../../server-code/src/map/clif.c"
 ; ( (item_list)._max_ ) = 0; ( (item_list)._len_ ) = 0; } else if ((_empty_+( (item_list)._len_ )) < ( (item_list)._max_ )) { ( (item_list)._data_ ) = (iMalloc->realloc((( (item_list)._data_ )),((_empty_+( (item_list)._len_ ))*sizeof(( ( ( (item_list)._data_ )[0] ) ))),"../../../server-code/src/map/clif.c", 10610, __func__)); ( (item_list)._max_ ) = (_empty_+( (item_list)._len_ )); if ((_empty_+( (item_list)._len_ )) - ( (item_list)._len_ ) > 0) ( (item_list)._len_ ) = (_empty_+( (item_list)._len_ )); } } while(
# 10610 "../../../server-code/src/map/clif.c" 3 4
 0
# 10610 "../../../server-code/src/map/clif.c"
 ); } } while(
# 10610 "../../../server-code/src/map/clif.c" 3 4
 0
# 10610 "../../../server-code/src/map/clif.c"
 );

  for (i = 0; i < n; i++) {
   struct itemlist_entry entry = { 0 };

   entry.id = (int)RFIFOW(fd, 4 + 4 * i) - 2;
   entry.amount = RFIFOW(fd, 4 + 4 * i + 2);

   do { ( ( (item_list)._data_ )[( (item_list)._len_ )] ) = (entry); ++( (item_list)._len_ ); }while(
# 10618 "../../../server-code/src/map/clif.c" 3 4
  0
# 10618 "../../../server-code/src/map/clif.c"
  );
  }
  fail = npc->selllist(sd, &item_list);

  do { if (( (item_list)._max_ ) > 0) { (iMalloc->free((( (item_list)._data_ )),"../../../server-code/src/map/clif.c", 10622, __func__)); ( (item_list)._data_ ) = 
# 10622 "../../../server-code/src/map/clif.c" 3 4
 ((void *)0)
# 10622 "../../../server-code/src/map/clif.c"
 ; ( (item_list)._max_ ) = 0; ( (item_list)._len_ ) = 0; } } while(
# 10622 "../../../server-code/src/map/clif.c" 3 4
 0
# 10622 "../../../server-code/src/map/clif.c"
 );
 }

 sd->npc_shopid = 0;

 clif->npc_sell_result(sd, fail);
}

void clif_parse_CreateChatRoom(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));





void clif_parse_CreateChatRoom(int fd, struct map_session_data* sd)
{
 int len = RFIFOW(fd,2)-15;
 int limit = RFIFOW(fd,4);
 
# 10640 "../../../server-code/src/map/clif.c" 3 4
_Bool 
# 10640 "../../../server-code/src/map/clif.c"
     pub = (RFIFOB(fd,6) != 0);
 const char *password = RFIFOP(fd,7);
 const char *title = RFIFOP(fd,15);
 char s_password[(8 + 1)];
 char s_title[(36 + 1)];

 if (( (&sd->sc)->data[SC_NOCHAT] && (&sd->sc)->data[SC_NOCHAT]->val1&(MANNER_NOROOM) ))
  return;
 if(battle_config.basic_skill_check && pc->checkskill(sd,NV_BASIC) < 4) {
  clif->skill_fail(sd,1,USESKILL_FAIL_LEVEL,3);
  return;
 }
 if( npc->isnear(&sd->bl) ) {




  clif->skill_fail(sd,1,USESKILL_FAIL_THERE_ARE_NPC_AROUND,0);
  return;
 }

 if( len <= 0 )
  return;

 (strlib->safestrncpy_((s_password),(password),((8 + 1))));
 (strlib->safestrncpy_((s_title),(title),((((len+1) < ((36 + 1))) ? (len+1) : ((36 + 1))))));

 chat->create_pc_chat(sd, s_title, s_password, limit, pub);
}

void clif_parse_ChatAddMember(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_ChatAddMember(int fd, struct map_session_data* sd)
{
 int chatid = RFIFOL(fd,2);
 const char *password = RFIFOP(fd,6);

 chat->join(sd,chatid,password);
}

void clif_parse_ChatRoomStatusChange(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));





void clif_parse_ChatRoomStatusChange(int fd, struct map_session_data* sd)
{
 int len = RFIFOW(fd,2)-15;
 int limit = RFIFOW(fd,4);
 
# 10691 "../../../server-code/src/map/clif.c" 3 4
_Bool 
# 10691 "../../../server-code/src/map/clif.c"
     pub = (RFIFOB(fd,6) != 0);
 const char *password = RFIFOP(fd,7);
 const char *title = RFIFOP(fd,15);
 char s_password[(8 + 1)];
 char s_title[(36 + 1)];

 if( len <= 0 )
  return;

 (strlib->safestrncpy_((s_password),(password),((8 + 1))));
 (strlib->safestrncpy_((s_title),(title),((((len+1) < ((36 + 1))) ? (len+1) : ((36 + 1))))));

 chat->change_status(sd, s_title, s_password, limit, pub);
}

void clif_parse_ChangeChatOwner(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));





void clif_parse_ChangeChatOwner(int fd, struct map_session_data* sd)
{
 chat->change_owner(sd, RFIFOP(fd,6));
}

void clif_parse_KickFromChat(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_KickFromChat(int fd,struct map_session_data *sd)
{
 chat->kick(sd, RFIFOP(fd,2));
}

void clif_parse_ChatLeave(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_ChatLeave(int fd, struct map_session_data* sd)
{
 chat->leave(sd, 
# 10730 "../../../server-code/src/map/clif.c" 3 4
                0
# 10730 "../../../server-code/src/map/clif.c"
                     );
}




void clif_noask_sub(struct map_session_data *src, struct map_session_data *target, int type) {
 const char* msg;
 char output[256];
 do { if (((void)(src), 
# 10739 "../../../server-code/src/map/clif.c" 3 4
0
# 10739 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 msg = atcommand->msgsd((src),(392));
 clif->disp_message( &(src)->bl, (msg), (strlen(msg)), SELF );

 snprintf(output, 256, atcommand->msgsd((target),(393+type)), src->status.name, 256);
 clif->disp_message( &(target)->bl, (output), (strlen(output)), SELF );
}

void clif_parse_TradeRequest(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_TradeRequest(int fd,struct map_session_data *sd) {
 struct map_session_data *t_sd;

 t_sd = map->id2sd(RFIFOL(fd,2));

 if(!sd->chatID && ( (sd)->npc_id || (sd)->state.vending || (sd)->state.buyingstore || (sd)->chatID || ((sd)->sc.opt1 && (sd)->sc.opt1 != OPT1_BURNING) || (sd)->state.trading || (sd)->state.storage_flag || (sd)->state.prevend ))
  return;


 if(t_sd && t_sd->state.noask) {
  clif->noask_sub(sd, t_sd, 0);
  return;
 }

 if( battle_config.basic_skill_check && pc->checkskill(sd,NV_BASIC) < 1) {
  clif->skill_fail(sd,1,USESKILL_FAIL_LEVEL,0);
  return;
 }

 trade->request(sd,t_sd);
}

void clif_parse_TradeAck(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));





void clif_parse_TradeAck(int fd,struct map_session_data *sd)
{
 trade->ack(sd,RFIFOB(fd,2));
}

void clif_parse_TradeAddItem(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_TradeAddItem(int fd,struct map_session_data *sd)
{
 short index = RFIFOW(fd,2);
 int amount = RFIFOL(fd,4);

 if( index == 0 )
  trade->addzeny(sd, amount);
 else
  trade->additem(sd, index, (short)amount);
}

void clif_parse_TradeOk(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_TradeOk(int fd,struct map_session_data *sd)
{
 trade->ok(sd);
}

void clif_parse_TradeCancel(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_TradeCancel(int fd,struct map_session_data *sd)
{
 trade->cancel(sd);
}

void clif_parse_TradeCommit(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_TradeCommit(int fd,struct map_session_data *sd)
{
 trade->commit(sd);
}

void clif_parse_StopAttack(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_StopAttack(int fd,struct map_session_data *sd)
{
 (unit->stop_attack(&(sd)->bl));
}

void clif_parse_PutItemToCart(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_PutItemToCart(int fd,struct map_session_data *sd) {
 int flag = 0;
 if (( (sd)->npc_id || (sd)->state.vending || (sd)->state.buyingstore || (sd)->state.trading ))
  return;
 if (!( (sd)->sc.data[SC_PUSH_CART] ))
  return;
 if ( (flag = pc->putitemtocart(sd,RFIFOW(fd,2)-2,RFIFOL(fd,4))) ) {
  clif->dropitem(sd, RFIFOW(fd,2)-2,0);
  clif->cart_additem_ack(sd,flag == 1?0x0:0x1);
 }
}

void clif_parse_GetItemFromCart(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_GetItemFromCart(int fd,struct map_session_data *sd)
{
 if (!( (sd)->sc.data[SC_PUSH_CART] ))
  return;
 pc->getitemfromcart(sd,RFIFOW(fd,2)-2,RFIFOL(fd,4));
}

void clif_parse_RemoveOption(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_RemoveOption(int fd,struct map_session_data *sd)
{
 if (( (sd)->sc.option&(OPTION_RIDING) ) || ( (sd)->sc.option&OPTION_FALCON ) || ( (sd)->sc.option&OPTION_DRAGON ) || ( (sd)->sc.option&OPTION_MADOGEAR )) {

  pc->setoption(sd,sd->sc.option&~(OPTION_RIDING|OPTION_FALCON|OPTION_DRAGON|OPTION_MADOGEAR));
 } else {

  if (sd->sc.data[SC_PUSH_CART])
   pc->setcart(sd,0);



 }
}

void clif_parse_ChangeCart(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_ChangeCart(int fd,struct map_session_data *sd)
{
 int type;

 if( pc->checkskill(sd, MC_CHANGECART) < 1 )
  return;


 if( sd->npc_id || sd->state.workinprogress&1 ){
  clif->msgtable(sd, MSG_NPC_WORK_IN_PROGRESS);
  return;
 }


 type = RFIFOW(fd,2);

 if( (type == 9 && sd->status.base_level > 131) ||
  (type == 8 && sd->status.base_level > 121) ||
  (type == 7 && sd->status.base_level > 111) ||
  (type == 6 && sd->status.base_level > 101) ||
  (type == 5 && sd->status.base_level > 90) ||
  (type == 4 && sd->status.base_level > 80) ||
  (type == 3 && sd->status.base_level > 65) ||
  (type == 2 && sd->status.base_level > 40) ||
  (type == 1))







  pc->setcart(sd,type);
}



void clif_parse_SelectCart(int fd, struct map_session_data *sd)
{
# 10928 "../../../server-code/src/map/clif.c"
}

void clif_parse_StatusUp(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));







void clif_parse_StatusUp(int fd,struct map_session_data *sd) {
 int increase_amount;

 increase_amount = RFIFOB(fd,4);
 if( increase_amount < 0 )
 {
  (showmsg->showDebug(("clif_parse_StatusUp: Negative 'increase' value sent by client! (fd: %d, value: %d)\n"), fd, increase_amount))
                       ;
 }
 pc->statusup(sd, RFIFOW(fd,2), increase_amount);
}

void clif_parse_SkillUp(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_SkillUp(int fd,struct map_session_data *sd)
{
 pc->skillup(sd,RFIFOW(fd,2));
}

void clif_parse_UseSkillToId_homun(struct homun_data *hd, struct map_session_data *sd, int64 tick, uint16 skill_id, uint16 skill_lv, int target_id) {
 int lv;

 do { if (((void)(sd), 
# 10961 "../../../server-code/src/map/clif.c" 3 4
0
# 10961 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if( !hd )
  return;
 if (skill->not_ok_hom(skill_id, hd)){
  clif->emotion(&hd->bl, E_DOTS);
  return;
 }
 if (hd->bl.id != target_id && skill->get_inf(skill_id)&INF_SELF_SKILL)
  target_id = hd->bl.id;
 if (hd->ud.skilltimer != (-1)) {
  if (skill_id != SA_CASTCANCEL && skill_id != SO_SPELLFIST) return;
 }
 else if (((tick)-(hd->ud.canact_tick)) < 0){
  clif->emotion(&hd->bl, E_DOTS);
  if (hd->master)
   clif->skill_fail(hd->master, skill_id, USESKILL_FAIL_SKILLINTERVAL, 0);
  return;

 }

 lv = homun->checkskill(hd, skill_id);
 if( skill_lv > lv )
  skill_lv = lv;
 if( skill_lv )
  unit->skilluse_id(&hd->bl, target_id, skill_id, skill_lv);
}

void clif_parse_UseSkillToPos_homun(struct homun_data *hd, struct map_session_data *sd, int64 tick, uint16 skill_id, uint16 skill_lv, short x, short y, int skillmoreinfo) {
 int lv;
 do { if (((void)(sd), 
# 10990 "../../../server-code/src/map/clif.c" 3 4
0
# 10990 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if( !hd )
  return;
 if (skill->not_ok_hom(skill_id, hd)){
  clif->emotion(&hd->bl, E_DOTS);
  return;
 }
 if ( hd->ud.skilltimer != (-1) ) {
  if ( skill_id != SA_CASTCANCEL && skill_id != SO_SPELLFIST ) return;

 } else if ( ((tick)-(hd->ud.canact_tick)) < 0 ) {
  clif->emotion(&hd->bl, E_DOTS);
  if ( hd->master )
   clif->skill_fail(hd->master, skill_id, USESKILL_FAIL_SKILLINTERVAL, 0);
  return;
 }

 if( hd->sc.data[SC_BASILICA] )
  return;
 lv = homun->checkskill(hd, skill_id);
 if( skill_lv > lv )
  skill_lv = lv;
 if( skill_lv )
  unit->skilluse_pos(&hd->bl, x, y, skill_id, skill_lv);
}

void clif_parse_UseSkillToId_mercenary(struct mercenary_data *md, struct map_session_data *sd, int64 tick, uint16 skill_id, uint16 skill_lv, int target_id) {
 int lv;

 do { if (((void)(sd), 
# 11019 "../../../server-code/src/map/clif.c" 3 4
0
# 11019 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if( !md )
  return;
 if( skill->not_ok_mercenary(skill_id, md) )
  return;
 if( md->bl.id != target_id && skill->get_inf(skill_id)&INF_SELF_SKILL )
  target_id = md->bl.id;
 if( md->ud.skilltimer != (-1) ) {
  if( skill_id != SA_CASTCANCEL && skill_id != SO_SPELLFIST ) return;
 } else if( ((tick)-(md->ud.canact_tick)) < 0 )
  return;

 lv = mercenary->checkskill(md, skill_id);
 if( skill_lv > lv )
  skill_lv = lv;
 if( skill_lv )
  unit->skilluse_id(&md->bl, target_id, skill_id, skill_lv);
}

void clif_parse_UseSkillToPos_mercenary(struct mercenary_data *md, struct map_session_data *sd, int64 tick, uint16 skill_id, uint16 skill_lv, short x, short y, int skillmoreinfo) {
 int lv;
 do { if (((void)(sd), 
# 11040 "../../../server-code/src/map/clif.c" 3 4
0
# 11040 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if( !md )
  return;
 if( skill->not_ok_mercenary(skill_id, md) )
  return;
 if( md->ud.skilltimer != (-1) )
  return;
 if( ((tick)-(md->ud.canact_tick)) < 0 ) {
  clif->skill_fail(md->master, skill_id, USESKILL_FAIL_SKILLINTERVAL, 0);
  return;
 }

 if( md->sc.data[SC_BASILICA] )
  return;
 lv = mercenary->checkskill(md, skill_id);
 if( skill_lv > lv )
  skill_lv = lv;
 if( skill_lv )
  unit->skilluse_pos(&md->bl, x, y, skill_id, skill_lv);
}

void clif_parse_UseSkillToId(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));




void clif_parse_UseSkillToId(int fd, struct map_session_data *sd)
{
 uint16 skill_id, skill_lv;
 int tmp, target_id;
 int64 tick = timer->gettick();

 skill_lv = RFIFOW(fd,packet_db[RFIFOW(fd,0)].pos[0]);
 skill_id = RFIFOW(fd,packet_db[RFIFOW(fd,0)].pos[1]);
 target_id = RFIFOL(fd,packet_db[RFIFOW(fd,0)].pos[2]);

 if( skill_lv < 1 ) skill_lv = 1;

 tmp = skill->get_inf(skill_id);
 if (tmp&INF_GROUND_SKILL || !tmp)
  return;

 if( skill_id >= 8001 && skill_id < 8001 + 43 ) {
  clif->pUseSkillToId_homun(sd->hd, sd, tick, skill_id, skill_lv, target_id);
  return;
 }

 if( skill_id >= 8201 && skill_id < 8201 + 40 ) {
  clif->pUseSkillToId_mercenary(sd->md, sd, tick, skill_id, skill_lv, target_id);
  return;
 }


 pc->update_idle_time(sd, BCIDLE_USESKILLTOID);

 if( sd->npc_id || sd->state.workinprogress&1 ){

  clif->msgtable(sd, MSG_NPC_WORK_IN_PROGRESS);

  return;
 }

 if( ( (sd)->npc_id || (sd)->state.vending || (sd)->state.buyingstore || (sd)->chatID || ((sd)->sc.opt1 && (sd)->sc.opt1 != OPT1_BURNING) || (sd)->state.trading || (sd)->state.storage_flag || (sd)->state.prevend )
 && skill_id != RK_REFRESH
 && !(skill_id == SR_GENTLETOUCH_CURE && (sd->sc.opt1 == OPT1_STONE || sd->sc.opt1 == OPT1_FREEZE || sd->sc.opt1 == OPT1_STUN))
 && (sd->state.storage_flag != STORAGE_FLAG_CLOSED && !(tmp&INF_SELF_SKILL))
 )
  return;

 if( ( (sd)->vd.dead_sit == 2 ) )
  return;

 if( skill->not_ok(skill_id, sd) )
  return;

 if( sd->bl.id != target_id && tmp&INF_SELF_SKILL )
  target_id = sd->bl.id;

 if( target_id < 0 && -target_id == sd->bl.id )
  target_id = sd->bl.id;

 if( sd->ud.skilltimer != (-1) ) {
  if( skill_id != SA_CASTCANCEL && skill_id != SO_SPELLFIST )
   return;
 } else if( ((tick)-(sd->ud.canact_tick)) < 0 ) {
  if( sd->skillitem != skill_id ) {
   clif->skill_fail(sd, skill_id, USESKILL_FAIL_SKILLINTERVAL, 0);
   return;
  }
 }

 if( sd->sc.option&OPTION_COSTUME )
  return;

 if( sd->sc.data[SC_BASILICA] && (skill_id != HP_BASILICA || sd->sc.data[SC_BASILICA]->val4 != sd->bl.id) )
  return;

 if( sd->menuskill_id ) {
  if( sd->menuskill_id == SA_TAMINGMONSTER ) {
   ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
  } else if( sd->menuskill_id != SA_AUTOSPELL )
   return;
 }
 if( sd->skillitem == skill_id ) {
  if( skill_lv != sd->skillitemlv )
   skill_lv = sd->skillitemlv;
  if( !(tmp&INF_SELF_SKILL) )
   pc->delinvincibletimer(sd);
  unit->skilluse_id(&sd->bl, target_id, skill_id, skill_lv);
  return;
 }

 sd->skillitem = sd->skillitemlv = 0;

 if( skill_id >= GD_SKILLBASE ) {
  if( sd->state.gmaster_flag )
   skill_lv = guild->checkskill(sd->guild, skill_id);
  else
   skill_lv = 0;
 } else {
  tmp = pc->checkskill(sd, skill_id);
  if( skill_lv > tmp )
   skill_lv = tmp;
 }

 pc->delinvincibletimer(sd);

 if( skill_lv )
  unit->skilluse_id(&sd->bl, target_id, skill_id, skill_lv);
}




void clif_parse_UseSkillToPosSub(int fd, struct map_session_data *sd, uint16 skill_lv, uint16 skill_id, short x, short y, int skillmoreinfo)
{
 int64 tick = timer->gettick();

 do { if (((void)(sd), 
# 11178 "../../../server-code/src/map/clif.c" 3 4
0
# 11178 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if( !(skill->get_inf(skill_id)&INF_GROUND_SKILL) )
  return;

 if( skill_id >= 8001 && skill_id < 8001 + 43 ) {
  clif->pUseSkillToPos_homun(sd->hd, sd, tick, skill_id, skill_lv, x, y, skillmoreinfo);
  return;
 }

 if( skill_id >= 8201 && skill_id < 8201 + 40 ) {
  clif->pUseSkillToPos_mercenary(sd->md, sd, tick, skill_id, skill_lv, x, y, skillmoreinfo);
  return;
 }


 if( sd->state.workinprogress&1 ){
  clif->msgtable(sd, MSG_NPC_WORK_IN_PROGRESS);
  return;
 }



 pc->update_idle_time(sd, BCIDLE_USESKILLTOPOS);

 if( skill->not_ok(skill_id, sd) )
  return;
 if( skillmoreinfo != -1 ) {
  if( ( (sd)->vd.dead_sit == 2 ) ) {
   clif->skill_fail(sd, skill_id, USESKILL_FAIL_LEVEL, 0);
   return;
  }

  (strlib->safestrncpy_((sd->message),(RFIFOP(fd,skillmoreinfo)),((79 + 1))));
 }

 if( sd->ud.skilltimer != (-1) )
  return;

 if( ((tick)-(sd->ud.canact_tick)) < 0 ) {
  if( sd->skillitem != skill_id ) {
   clif->skill_fail(sd, skill_id, USESKILL_FAIL_SKILLINTERVAL, 0);
   return;
  }
 }

 if( sd->sc.option&OPTION_COSTUME )
  return;

 if( sd->sc.data[SC_BASILICA] && (skill_id != HP_BASILICA || sd->sc.data[SC_BASILICA]->val4 != sd->bl.id) )
  return;

 if( sd->menuskill_id ) {
  if( sd->menuskill_id == SA_TAMINGMONSTER ) {
   ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
  } else if( sd->menuskill_id != SA_AUTOSPELL )
   return;
 }

 pc->delinvincibletimer(sd);

 if( sd->skillitem == skill_id ) {
  if( skill_lv != sd->skillitemlv )
   skill_lv = sd->skillitemlv;
  unit->skilluse_pos(&sd->bl, x, y, skill_id, skill_lv);
 } else {
  int lv;
  sd->skillitem = sd->skillitemlv = 0;
  if( (lv = pc->checkskill(sd, skill_id)) > 0 ) {
   if( skill_lv > lv )
    skill_lv = lv;
   unit->skilluse_pos(&sd->bl, x, y, skill_id,skill_lv);
  }
 }
}

void clif_parse_UseSkillToPos(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));




void clif_parse_UseSkillToPos(int fd, struct map_session_data *sd)
{
 if (( (sd)->npc_id || (sd)->state.vending || (sd)->state.buyingstore || (sd)->chatID || ((sd)->sc.opt1 && (sd)->sc.opt1 != OPT1_BURNING) || (sd)->state.trading || (sd)->state.storage_flag || (sd)->state.prevend ))
  return;
 if (( (sd)->vd.dead_sit == 2 ))
  return;

 clif->pUseSkillToPosSub(fd, sd,
  RFIFOW(fd,packet_db[RFIFOW(fd,0)].pos[0]),
  RFIFOW(fd,packet_db[RFIFOW(fd,0)].pos[1]),
  RFIFOW(fd,packet_db[RFIFOW(fd,0)].pos[2]),
  RFIFOW(fd,packet_db[RFIFOW(fd,0)].pos[3]),
  -1
 );
}

void clif_parse_UseSkillToPosMoreInfo(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));




void clif_parse_UseSkillToPosMoreInfo(int fd, struct map_session_data *sd)
{
 if (( (sd)->npc_id || (sd)->state.vending || (sd)->state.buyingstore || (sd)->chatID || ((sd)->sc.opt1 && (sd)->sc.opt1 != OPT1_BURNING) || (sd)->state.trading || (sd)->state.storage_flag || (sd)->state.prevend ))
  return;
 if (( (sd)->vd.dead_sit == 2 ))
  return;

 clif->pUseSkillToPosSub(fd, sd,
  RFIFOW(fd,packet_db[RFIFOW(fd,0)].pos[0]),
  RFIFOW(fd,packet_db[RFIFOW(fd,0)].pos[1]),
  RFIFOW(fd,packet_db[RFIFOW(fd,0)].pos[2]),
  RFIFOW(fd,packet_db[RFIFOW(fd,0)].pos[3]),
  packet_db[RFIFOW(fd,0)].pos[4]
 );
}

void clif_parse_UseSkillMap(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_UseSkillMap(int fd, struct map_session_data* sd)
{
 uint16 skill_id = RFIFOW(fd,2);
 char map_name[(11 + 1)];

 mapindex->getmapname(RFIFOP(fd,4), map_name);
 sd->state.workinprogress = 0;

 if(skill_id != sd->menuskill_id)
  return;


 if (( (sd)->npc_id || (sd)->state.vending || (sd)->state.buyingstore || (sd)->chatID || ((sd)->sc.opt1 && (sd)->sc.opt1 != OPT1_BURNING) || (sd)->state.trading || (sd)->state.storage_flag || (sd)->state.prevend ) && (sd->state.storage_flag == STORAGE_FLAG_CLOSED && skill_id != AL_TELEPORT)) {
  ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
  return;
 }

 pc->delinvincibletimer(sd);
 skill->castend_map(sd,skill_id,map_name);
}

void clif_parse_RequestMemo(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_RequestMemo(int fd,struct map_session_data *sd)
{
 if (!( (sd)->state.dead_sit == 1 ))
  pc->memo(sd,-1);
}

void clif_parse_ProduceMix(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_ProduceMix(int fd,struct map_session_data *sd)
{
 switch( sd->menuskill_id ) {
  case -1:
  case AM_PHARMACY:
  case RK_RUNEMASTERY:
  case GC_RESEARCHNEWPOISON:
   break;
  default:
   return;
 }
 if (( (sd)->npc_id || (sd)->state.vending || (sd)->state.buyingstore || (sd)->state.trading )) {

  clif->skill_fail(sd,sd->ud.skill_id,USESKILL_FAIL_LEVEL,0);
  ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
  return;
 }
 if( skill->can_produce_mix(sd,RFIFOW(fd,2),sd->menuskill_val, 1) )
  skill->produce_mix(sd,0,RFIFOW(fd,2),RFIFOW(fd,4),RFIFOW(fd,6),RFIFOW(fd,8), 1);
 ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
}

void clif_parse_Cooking(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));
# 11363 "../../../server-code/src/map/clif.c"
void clif_parse_Cooking(int fd,struct map_session_data *sd) {
 int type = RFIFOW(fd,2);
 int nameid = RFIFOW(fd,4);
 int amount = sd->menuskill_val2?sd->menuskill_val2:1;
 if( type == 6 && sd->menuskill_id != GN_MIX_COOKING && sd->menuskill_id != GN_S_PHARMACY )
  return;

 if (( (sd)->npc_id || (sd)->state.vending || (sd)->state.buyingstore || (sd)->state.trading )) {

  clif->skill_fail(sd,sd->ud.skill_id,USESKILL_FAIL_LEVEL,0);
  ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
  return;
 }
 if( skill->can_produce_mix(sd,nameid,sd->menuskill_val, amount) )
  skill->produce_mix(sd,(type>1?sd->menuskill_id:0),nameid,0,0,0,amount);
 ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
}

void clif_parse_RepairItem(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_RepairItem(int fd, struct map_session_data *sd)
{
 if (sd->menuskill_id != BS_REPAIRWEAPON)
  return;
 if (( (sd)->npc_id || (sd)->state.vending || (sd)->state.buyingstore || (sd)->state.trading )) {

  clif->skill_fail(sd,sd->ud.skill_id,USESKILL_FAIL_LEVEL,0);
  ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
  return;
 }
 skill->repairweapon(sd,RFIFOW(fd,2));
 ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
}

void clif_parse_WeaponRefine(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_WeaponRefine(int fd, struct map_session_data *sd)
{
 int idx;

 sd->state.prerefining = 0;

 if (sd->menuskill_id != WS_WEAPONREFINE)
  return;
 if (( (sd)->npc_id || (sd)->state.vending || (sd)->state.buyingstore || (sd)->state.trading )) {

  clif->skill_fail(sd,sd->ud.skill_id,USESKILL_FAIL_LEVEL,0);
  ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
  return;
 }
 idx = RFIFOL(fd,packet_db[RFIFOW(fd,0)].pos[0]);
 skill->weaponrefine(sd, idx-2);
 ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
}

void clif_parse_NpcSelectMenu(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));







void clif_parse_NpcSelectMenu(int fd,struct map_session_data *sd)
{
 int npc_id = RFIFOL(fd,2);
 uint8 select = RFIFOB(fd,6);

 if( (select > sd->npc_menu && select != 0xff) || select == 0 ) {



   struct npc_data *nd = map->id2nd(npc_id);
   (showmsg->showWarning(("Invalid menu selection on npc %d:'%s' - got %d, valid range is [%d..%d] (player AID:%d, CID:%d, name:'%s')!\n"), npc_id, (nd)?nd->name:"invalid npc id", select, 1, sd->npc_menu, sd->bl.id, sd->status.char_id, sd->status.name));
   clif->GM_kick(
# 11439 "../../../server-code/src/map/clif.c" 3 4
                ((void *)0)
# 11439 "../../../server-code/src/map/clif.c"
                    ,sd);



  return;
 }

 sd->npc_menu = select;
 npc->scriptcont(sd,npc_id, 
# 11447 "../../../server-code/src/map/clif.c" 3 4
                           0
# 11447 "../../../server-code/src/map/clif.c"
                                );
}

void clif_parse_NpcNextClicked(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_NpcNextClicked(int fd,struct map_session_data *sd)
{
 npc->scriptcont(sd,RFIFOL(fd,2), 
# 11455 "../../../server-code/src/map/clif.c" 3 4
                                 0
# 11455 "../../../server-code/src/map/clif.c"
                                      );
}

void clif_parse_NpcAmountInput(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_NpcAmountInput(int fd,struct map_session_data *sd)
{
 int npcid = RFIFOL(fd,2);
 int amount = RFIFOL(fd,6);

 if (amount >= 0)
  sd->npc_amount = amount;
 else
  sd->npc_amount = 0;
 npc->scriptcont(sd, npcid, 
# 11470 "../../../server-code/src/map/clif.c" 3 4
                           0
# 11470 "../../../server-code/src/map/clif.c"
                                );
}

void clif_parse_NpcStringInput(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_NpcStringInput(int fd, struct map_session_data* sd)
{
 int message_len = RFIFOW(fd,2)-8;
 int npcid = RFIFOL(fd,4);
 const char *message = RFIFOP(fd,8);

 if( message_len <= 0 )
  return;

 (strlib->safestrncpy_((sd->npc_str),(message),((((message_len) < ((70 + 1))) ? (message_len) : ((70 + 1))))));
 npc->scriptcont(sd, npcid, 
# 11486 "../../../server-code/src/map/clif.c" 3 4
                           0
# 11486 "../../../server-code/src/map/clif.c"
                                );
}

void clif_parse_NpcCloseClicked(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_NpcCloseClicked(int fd,struct map_session_data *sd)
{
 if (!sd->npc_id)
  return;
 sd->state.dialog = 0;
 npc->scriptcont(sd, RFIFOL(fd,2), 
# 11497 "../../../server-code/src/map/clif.c" 3 4
                                  1
# 11497 "../../../server-code/src/map/clif.c"
                                      );
}

void clif_parse_ItemIdentify(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));




void clif_parse_ItemIdentify(int fd,struct map_session_data *sd)
{
 short idx = RFIFOW(fd,2);

 if (sd->menuskill_id != MC_IDENTIFY)
  return;
 if( idx == -1 ) {
  sd->state.workinprogress = 0;
  clif->item_identified(sd,idx-2,1);
  ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
  return;
 }
 skill->identify(sd,idx-2);
 ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
}



void clif_parse_OneClick_ItemIdentify(int fd, struct map_session_data *sd)
{
 int cmd = RFIFOW(fd,0);
 short idx = RFIFOW(fd, packet_db[cmd].pos[0]) - 2;
 int n;

 if (idx < 0 || idx >= 100 || sd->inventory_data[idx] == 
# 11529 "../../../server-code/src/map/clif.c" 3 4
                                                                  ((void *)0) 
# 11529 "../../../server-code/src/map/clif.c"
                                                                       || sd->status.inventory[idx].nameid <= 0)
  return;

 if ((n = pc->have_magnifier(sd) ) != (-1) &&
  pc->delitem(sd, n, 1, 0, DELITEM_NORMAL, LOG_TYPE_CONSUME) == 0)
  skill->identify(sd, idx);
}

void clif_parse_SelectArrow(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_SelectArrow(int fd,struct map_session_data *sd)
{
 if (( (sd)->npc_id || (sd)->state.vending || (sd)->state.buyingstore || (sd)->state.trading )) {

  clif->skill_fail(sd,sd->ud.skill_id,USESKILL_FAIL_LEVEL,0);
  ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
  return;
 }
 switch( sd->menuskill_id ) {
  case AC_MAKINGARROW:
   skill->arrow_create(sd,RFIFOW(fd,2));
   break;
  case SA_CREATECON:
   skill->produce_mix(sd,SA_CREATECON,RFIFOW(fd,2),0,0,0, 1);
   break;
  case WL_READING_SB:
   skill->spellbook(sd,RFIFOW(fd,2));
   break;
  case GC_POISONINGWEAPON:
   skill->poisoningweapon(sd,RFIFOW(fd,2));
   break;
  case NC_MAGICDECOY:
   skill->magicdecoy(sd,RFIFOW(fd,2));
   break;
 }

 ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
}

void clif_parse_AutoSpell(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_AutoSpell(int fd,struct map_session_data *sd)
{
 uint16 skill_id = RFIFOL(fd,2);

 sd->state.workinprogress = 0;

 if( sd->menuskill_id != SA_AUTOSPELL )
  return;

 if( !skill_id )
  return;

 skill->autospell(sd, skill_id);
 ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
}

void clif_parse_UseCard(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_UseCard(int fd,struct map_session_data *sd)
{
 clif->use_card(sd,RFIFOW(fd,2)-2);
}

void clif_parse_InsertCard(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_InsertCard(int fd,struct map_session_data *sd)
{
 pc->insert_card(sd,RFIFOW(fd,2)-2,RFIFOW(fd,4)-2);
}

void clif_parse_SolveCharName(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));




void clif_parse_SolveCharName(int fd, struct map_session_data *sd) {
 int charid;

 charid = RFIFOL(fd,packet_db[RFIFOW(fd,0)].pos[0]);
 map->reqnickdb(sd, charid);
}

void clif_parse_ResetChar(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));






void clif_parse_ResetChar(int fd, struct map_session_data *sd) {
 char cmd[15];

 if( RFIFOW(fd,2) )
  sprintf(cmd,"%cskreset",atcommand->at_symbol);
 else
  sprintf(cmd,"%cstreset",atcommand->at_symbol);

 atcommand->exec(fd, sd, cmd, 
# 11631 "../../../server-code/src/map/clif.c" 3 4
                             1
# 11631 "../../../server-code/src/map/clif.c"
                                 );
}

void clif_parse_LocalBroadcast(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));



void clif_parse_LocalBroadcast(int fd, struct map_session_data *sd)
{
 const char commandname[] = "lkami";
 char command[sizeof commandname + 2 + (255 + 1)] = "";
 int len = (int)RFIFOW(fd,2) - 4;

 if (len < 0)
  return;

 sprintf(command, "%c%s ", atcommand->at_symbol, commandname);


 if (len >= (int)(sizeof command - strlen(command)))
  len = (int)(sizeof command - strlen(command)) - 1;

 strncat(command, RFIFOP(fd,4), len);
 atcommand->exec(fd, sd, command, 
# 11654 "../../../server-code/src/map/clif.c" 3 4
                                 1
# 11654 "../../../server-code/src/map/clif.c"
                                     );
}

void clif_parse_MoveToKafra(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));




void clif_parse_MoveToKafra(int fd, struct map_session_data *sd)
{
 int item_index, item_amount;

 if (( (sd)->npc_id || (sd)->state.vending || (sd)->state.buyingstore || (sd)->state.trading ))
  return;

 item_index = RFIFOW(fd,packet_db[RFIFOW(fd,0)].pos[0])-2;
 item_amount = RFIFOL(fd,packet_db[RFIFOW(fd,0)].pos[1]);
 if (item_index < 0 || item_index >= 100 || item_amount < 1)
  return;

 if (sd->state.storage_flag == STORAGE_FLAG_NORMAL)
  storage->add(sd, item_index, item_amount);
 else if (sd->state.storage_flag == STORAGE_FLAG_GUILD)
  gstorage->add(sd, item_index, item_amount);
}

void clif_parse_MoveFromKafra(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));




void clif_parse_MoveFromKafra(int fd,struct map_session_data *sd)
{
 int item_index, item_amount;

 item_index = RFIFOW(fd,packet_db[RFIFOW(fd,0)].pos[0])-1;
 item_amount = RFIFOL(fd,packet_db[RFIFOW(fd,0)].pos[1]);

 if (sd->state.storage_flag == STORAGE_FLAG_NORMAL)
  storage->get(sd, item_index, item_amount);
 else if(sd->state.storage_flag == STORAGE_FLAG_GUILD)
  gstorage->get(sd, item_index, item_amount);
}

void clif_parse_MoveToKafraFromCart(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_MoveToKafraFromCart(int fd, struct map_session_data *sd)
{
 if( sd->state.vending )
  return;
 if (!( (sd)->sc.data[SC_PUSH_CART] ))
  return;

 if (sd->state.storage_flag == STORAGE_FLAG_NORMAL)
  storage->addfromcart(sd, RFIFOW(fd,2) - 2, RFIFOL(fd,4));
 else if (sd->state.storage_flag == STORAGE_FLAG_GUILD)
  gstorage->addfromcart(sd, RFIFOW(fd,2) - 2, RFIFOL(fd,4));
}

void clif_parse_MoveFromKafraToCart(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_MoveFromKafraToCart(int fd, struct map_session_data *sd)
{
 if( sd->state.vending )
  return;
 if (!( (sd)->sc.data[SC_PUSH_CART] ))
  return;

 if (sd->state.storage_flag == STORAGE_FLAG_NORMAL)
  storage->gettocart(sd, RFIFOW(fd,2)-1, RFIFOL(fd,4));
 else if (sd->state.storage_flag == STORAGE_FLAG_GUILD)
  gstorage->gettocart(sd, RFIFOW(fd,2)-1, RFIFOL(fd,4));
}

void clif_parse_CloseKafra(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_CloseKafra(int fd, struct map_session_data *sd)
{
 if( sd->state.storage_flag == STORAGE_FLAG_NORMAL )
  storage->close(sd);
 else if( sd->state.storage_flag == STORAGE_FLAG_GUILD )
  gstorage->close(sd);
}
# 11749 "../../../server-code/src/map/clif.c"
void clif_storagepassword(struct map_session_data* sd, short info)
{
 int fd;

 do { if (((void)(sd), 
# 11753 "../../../server-code/src/map/clif.c" 3 4
0
# 11753 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x23a].len);
 WFIFOW(fd,0) = 0x23a;
 WFIFOW(fd,2) = info;
 WFIFOSET(fd,packet_db[0x23a].len);
}

void clif_parse_StoragePassword(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));






void clif_parse_StoragePassword(int fd, struct map_session_data *sd)
{

}
# 11783 "../../../server-code/src/map/clif.c"
void clif_storagepassword_result(struct map_session_data* sd, short result, short error_count)
{
 int fd;

 do { if (((void)(sd), 
# 11787 "../../../server-code/src/map/clif.c" 3 4
0
# 11787 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x23c].len);
 WFIFOW(fd,0) = 0x23c;
 WFIFOW(fd,2) = result;
 WFIFOW(fd,4) = error_count;
 WFIFOSET(fd,packet_db[0x23c].len);
}

void clif_parse_CreateParty(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));



void clif_parse_CreateParty(int fd, struct map_session_data *sd)
{
 char name[(23 + 1)];

 (strlib->safestrncpy_((name),(RFIFOP(fd,2)),((23 + 1))));

 if( map->list[sd->bl.m].flag.partylock ) {

  clif->message(fd, atcommand->msgfd((fd),(227)));
  return;
 }
 if( battle_config.basic_skill_check && pc->checkskill(sd,NV_BASIC) < 7 ) {
  clif->skill_fail(sd,1,USESKILL_FAIL_LEVEL,4);
  return;
 }

 party->create(sd,name,0,0);
}

void clif_parse_CreateParty2(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));
void clif_parse_CreateParty2(int fd, struct map_session_data *sd)
{
 char name[(23 + 1)];
 int item1 = RFIFOB(fd,26);
 int item2 = RFIFOB(fd,27);

 (strlib->safestrncpy_((name),(RFIFOP(fd,2)),((23 + 1))));

 if( map->list[sd->bl.m].flag.partylock ) {

  clif->message(fd, atcommand->msgfd((fd),(227)));
  return;
 }
 if( battle_config.basic_skill_check && pc->checkskill(sd,NV_BASIC) < 7 ) {
  clif->skill_fail(sd,1,USESKILL_FAIL_LEVEL,4);
  return;
 }

 party->create(sd,name,item1,item2);
}

void clif_parse_PartyInvite(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));



void clif_parse_PartyInvite(int fd, struct map_session_data *sd) {
 struct map_session_data *t_sd;

 if(map->list[sd->bl.m].flag.partylock) {

  clif->message(fd, atcommand->msgfd((fd),(227)));
  return;
 }

 t_sd = map->id2sd(RFIFOL(fd,2));

 if(t_sd && t_sd->state.noask) {
  clif->noask_sub(sd, t_sd, 1);
  return;
 }

 party->invite(sd, t_sd);
}

void clif_parse_PartyInvite2(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));
void clif_parse_PartyInvite2(int fd, struct map_session_data *sd)
{
 struct map_session_data *t_sd;
 char name[(23 + 1)];

 (strlib->safestrncpy_((name),(RFIFOP(fd,2)),((23 + 1))));

 if(map->list[sd->bl.m].flag.partylock) {

  clif->message(fd, atcommand->msgfd((fd),(227)));
  return;
 }

 t_sd = map->nick2sd(name);

 if(t_sd && t_sd->state.noask) {
  clif->noask_sub(sd, t_sd, 1);
  return;
 }

 party->invite(sd, t_sd);
}

void clif_parse_ReplyPartyInvite(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));






void clif_parse_ReplyPartyInvite(int fd,struct map_session_data *sd)
{
 party->reply_invite(sd,RFIFOL(fd,2),RFIFOL(fd,6));
}

void clif_parse_ReplyPartyInvite2(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));
void clif_parse_ReplyPartyInvite2(int fd,struct map_session_data *sd)
{
 party->reply_invite(sd,RFIFOL(fd,2),RFIFOB(fd,6));
}

void clif_parse_LeaveParty(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_LeaveParty(int fd, struct map_session_data *sd) {
 if(map->list[sd->bl.m].flag.partylock) {

  clif->message(fd, atcommand->msgfd((fd),(227)));
  return;
 }
 party->leave(sd);
}

void clif_parse_RemovePartyMember(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_RemovePartyMember(int fd, struct map_session_data *sd) {
 if(map->list[sd->bl.m].flag.partylock) {

  clif->message(fd, atcommand->msgfd((fd),(227)));
  return;
 }
 party->removemember(sd, RFIFOL(fd,2), RFIFOP(fd,6));
}

void clif_parse_PartyChangeOption(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));



void clif_parse_PartyChangeOption(int fd, struct map_session_data *sd)
{
 struct party_data *p;
 int i;

 if( !sd->status.party_id )
  return;

 p = party->search(sd->status.party_id);
 if( p == 
# 11943 "../../../server-code/src/map/clif.c" 3 4
         ((void *)0) 
# 11943 "../../../server-code/src/map/clif.c"
              )
  return;

 do { for ((i) = (0); (i) < (12); ++(i)) if (p->data[i].sd == sd) break; } while(
# 11946 "../../../server-code/src/map/clif.c" 3 4
0
# 11946 "../../../server-code/src/map/clif.c"
);
 if( i == 12 )
  return;

 if( !p->party.member[i].leader )
  return;





 party->changeoption(sd, RFIFOL(fd,2), ((RFIFOB(fd,6)?1:0)|(RFIFOB(fd,7)?2:0)));

}

void clif_parse_PartyMessage(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_PartyMessage(int fd, struct map_session_data* sd)
{
 const char *text = RFIFOP(fd,4);
 int textlen = RFIFOW(fd,2) - 4;

 const char *name, *message;
 size_t namelen, messagelen;


 if( !clif->process_message(sd, 0, &name, &namelen, &message, &messagelen) )
  return;

 if( atcommand->exec(fd, sd, message, 
# 11976 "../../../server-code/src/map/clif.c" 3 4
                                     1
# 11976 "../../../server-code/src/map/clif.c"
                                         ) )
  return;

 if( !pc->can_talk(sd) )
  return;

 if (battle_config.min_chat_delay) {
  if (((sd->cantalk_tick)-(timer->gettick())) > 0)
   return;
  sd->cantalk_tick = timer->gettick() + battle_config.min_chat_delay;
 }

 pc->update_idle_time(sd, BCIDLE_CHAT);

 party->send_message(sd, text, textlen);
}

void clif_parse_PartyChangeLeader(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_PartyChangeLeader(int fd, struct map_session_data* sd) {
 party->changeleader(sd, map->id2sd(RFIFOL(fd,2)));
}

void clif_parse_PartyBookingRegisterReq(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));





void clif_parse_PartyBookingRegisterReq(int fd, struct map_session_data* sd)
{

 short level = RFIFOW(fd,2);
 short mapid = RFIFOW(fd,4);
 short job[6];
 int i;

 for(i=0; i<6; i++)
  job[i] = RFIFOB(fd,6+i*2);

 party->booking_register(sd, level, mapid, job);



}







void clif_PartyBookingRegisterAck(struct map_session_data *sd, int flag)
{

 int fd;

 do { if (((void)(sd), 
# 12034 "../../../server-code/src/map/clif.c" 3 4
0
# 12034 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x803].len);
 WFIFOW(fd,0) = 0x803;
 WFIFOW(fd,2) = flag;
 WFIFOSET(fd,packet_db[0x803].len);



}

void clif_parse_PartyBookingSearchReq(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_PartyBookingSearchReq(int fd, struct map_session_data* sd)
{

 short level = RFIFOW(fd,2);
 short mapid = RFIFOW(fd,4);
 short job = RFIFOW(fd,6);
 unsigned long lastindex = RFIFOL(fd,8);
 short resultcount = RFIFOW(fd,12);

 party->booking_search(sd, level, mapid, job, lastindex, resultcount);



}






void clif_PartyBookingSearchAck(int fd, struct party_booking_ad_info** results, int count, 
# 12068 "../../../server-code/src/map/clif.c" 3 4
                                                                                          _Bool 
# 12068 "../../../server-code/src/map/clif.c"
                                                                                               more_result)
{

 int i, j;
 int size = sizeof(struct party_booking_ad_info);
 struct party_booking_ad_info *pb_ad;
 do { if (((void)(results), 
# 12074 "../../../server-code/src/map/clif.c" 3 4
0
# 12074 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 WFIFOHEAD(fd,size*count + 5);
 WFIFOW(fd,0) = 0x805;
 WFIFOW(fd,2) = size*count + 5;
 WFIFOB(fd,4) = more_result;
 for(i=0; i<count; i++)
 {
  pb_ad = results[i];
  WFIFOL(fd,i*size+5) = pb_ad->index;
  memcpy(WFIFOP(fd,i*size+9),pb_ad->charname,(23 + 1));
  WFIFOL(fd,i*size+33) = pb_ad->expiretime;
  WFIFOW(fd,i*size+37) = pb_ad->p_detail.level;
  WFIFOW(fd,i*size+39) = pb_ad->p_detail.mapid;
  for(j=0; j<6; j++)
   WFIFOW(fd,i*size+41+j*2) = pb_ad->p_detail.job[j];
 }
 WFIFOSET(fd,WFIFOW(fd,2));



}

void clif_parse_PartyBookingDeleteReq(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_PartyBookingDeleteReq(int fd, struct map_session_data* sd)
{

 if(party->booking_delete(sd))
  clif->PartyBookingDeleteAck(sd, 0);



}
# 12116 "../../../server-code/src/map/clif.c"
void clif_PartyBookingDeleteAck(struct map_session_data* sd, int flag)
{

 int fd;

 do { if (((void)(sd), 
# 12121 "../../../server-code/src/map/clif.c" 3 4
0
# 12121 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x807].len);
 WFIFOW(fd,0) = 0x807;
 WFIFOW(fd,2) = flag;
 WFIFOSET(fd,packet_db[0x807].len);



}

void clif_parse_PartyBookingUpdateReq(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_PartyBookingUpdateReq(int fd, struct map_session_data* sd)
{

 short job[6];
 int i;

 for(i=0; i<6; i++)
  job[i] = RFIFOW(fd,2+i*2);

 party->booking_update(sd, job);



}



void clif_PartyBookingInsertNotify(struct map_session_data* sd, struct party_booking_ad_info* pb_ad)
{

 int i;
 uint8 buf[38+6*2];

 do { if (((void)(sd), 
# 12158 "../../../server-code/src/map/clif.c" 3 4
0
# 12158 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if(pb_ad == 
# 12159 "../../../server-code/src/map/clif.c" 3 4
            ((void *)0)
# 12159 "../../../server-code/src/map/clif.c"
                ) return;

 WBUFW(buf,0) = 0x809;
 WBUFL(buf,2) = pb_ad->index;
 memcpy(WBUFP(buf,6),pb_ad->charname,(23 + 1));
 WBUFL(buf,30) = pb_ad->expiretime;
 WBUFW(buf,34) = pb_ad->p_detail.level;
 WBUFW(buf,36) = pb_ad->p_detail.mapid;
 for(i=0; i<6; i++)
  WBUFW(buf,38+i*2) = pb_ad->p_detail.job[i];

 clif->send(buf, packet_db[0x809].len, &sd->bl, ALL_CLIENT);



}



void clif_PartyBookingUpdateNotify(struct map_session_data* sd, struct party_booking_ad_info* pb_ad)
{

 int i;
 uint8 buf[6+6*2];

 do { if (((void)(sd), 
# 12184 "../../../server-code/src/map/clif.c" 3 4
0
# 12184 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if(pb_ad == 
# 12185 "../../../server-code/src/map/clif.c" 3 4
            ((void *)0)
# 12185 "../../../server-code/src/map/clif.c"
                ) return;

 WBUFW(buf,0) = 0x80a;
 WBUFL(buf,2) = pb_ad->index;
 for(i=0; i<6; i++)
  WBUFW(buf,6+i*2) = pb_ad->p_detail.job[i];
 clif->send(buf,packet_db[0x80a].len,&sd->bl,ALL_CLIENT);



}



void clif_PartyBookingDeleteNotify(struct map_session_data* sd, int index)
{

 uint8 buf[6];

 do { if (((void)(sd), 
# 12204 "../../../server-code/src/map/clif.c" 3 4
0
# 12204 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 WBUFW(buf,0) = 0x80b;
 WBUFL(buf,2) = index;

 clif->send(buf, packet_db[0x80b].len, &sd->bl, ALL_CLIENT);



}

void clif_parse_PartyRecruitRegisterReq(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));





void clif_parse_PartyRecruitRegisterReq(int fd, struct map_session_data* sd)
{






 return;

}






void clif_PartyRecruitSearchAck(int fd, struct party_booking_ad_info** results, int count, 
# 12237 "../../../server-code/src/map/clif.c" 3 4
                                                                                          _Bool 
# 12237 "../../../server-code/src/map/clif.c"
                                                                                               more_result)
{
# 12262 "../../../server-code/src/map/clif.c"
 return;

}







void clif_PartyRecruitRegisterAck(struct map_session_data *sd, int flag)
{
# 12284 "../../../server-code/src/map/clif.c"
 return;

}

void clif_parse_PartyRecruitSearchReq(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_PartyRecruitSearchReq(int fd, struct map_session_data* sd)
{
# 12301 "../../../server-code/src/map/clif.c"
 return;

}

void clif_parse_PartyRecruitDeleteReq(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_PartyRecruitDeleteReq(int fd, struct map_session_data* sd)
{




 return;

}
# 12325 "../../../server-code/src/map/clif.c"
void clif_PartyRecruitDeleteAck(struct map_session_data* sd, int flag)
{
# 12337 "../../../server-code/src/map/clif.c"
 return;

}

void clif_parse_PartyRecruitUpdateReq(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_PartyRecruitUpdateReq(int fd, struct map_session_data *sd)
{





 return;

}



void clif_PartyRecruitInsertNotify(struct map_session_data* sd, struct party_booking_ad_info* pb_ad)
{
# 12374 "../../../server-code/src/map/clif.c"
 return;

}



void clif_PartyRecruitUpdateNotify(struct map_session_data *sd, struct party_booking_ad_info* pb_ad)
{
# 12393 "../../../server-code/src/map/clif.c"
 return;

}



void clif_PartyRecruitDeleteNotify(struct map_session_data* sd, int index)
{
# 12410 "../../../server-code/src/map/clif.c"
 return;

}

void clif_parse_PartyBookingAddFilteringList(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_PartyBookingAddFilteringList(int fd, struct map_session_data *sd)
{





 return;

}

void clif_parse_PartyBookingSubFilteringList(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_PartyBookingSubFilteringList(int fd, struct map_session_data *sd)
{





 return;

}

void clif_parse_PartyBookingReqVolunteer(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_PartyBookingReqVolunteer(int fd, struct map_session_data *sd)
{





 return;

}



void clif_PartyBookingVolunteerInfo(int index, struct map_session_data *sd)
{
# 12472 "../../../server-code/src/map/clif.c"
 return;

}
# 12519 "../../../server-code/src/map/clif.c"
void clif_parse_PartyBookingRefuseVolunteer(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));

void clif_parse_PartyBookingRefuseVolunteer(int fd, struct map_session_data *sd)
{





 return;

}

void clif_PartyBookingRefuseVolunteer(unsigned int aid, struct map_session_data *sd) __attribute__((nonnull (2)));

void clif_PartyBookingRefuseVolunteer(unsigned int aid, struct map_session_data *sd)
{
# 12544 "../../../server-code/src/map/clif.c"
 return;

}

void clif_parse_PartyBookingCancelVolunteer(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));

void clif_parse_PartyBookingCancelVolunteer(int fd, struct map_session_data *sd)
{





 return;

}


void clif_PartyBookingCancelVolunteer(int index, struct map_session_data *sd)
{
# 12573 "../../../server-code/src/map/clif.c"
 return;

}


void clif_PartyBookingAddFilteringList(int index, struct map_session_data *sd)
{
# 12590 "../../../server-code/src/map/clif.c"
 return;

}


void clif_PartyBookingSubFilteringList(int gid, struct map_session_data *sd)
{
# 12607 "../../../server-code/src/map/clif.c"
 return;

}
# 12623 "../../../server-code/src/map/clif.c"
void clif_parse_CloseVending(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_CloseVending(int fd, struct map_session_data* sd)
{
 vending->close(sd);
}

void clif_parse_VendingListReq(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_VendingListReq(int fd, struct map_session_data* sd)
{
 if( sd->npc_id ) {
  return;
 }
 vending->list(sd,RFIFOL(fd,2));
}

void clif_parse_PurchaseReq(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_PurchaseReq(int fd, struct map_session_data* sd)
{
 int len = (int)RFIFOW(fd,2) - 8;
 int id = RFIFOL(fd,4);
 const uint8 *data = RFIFOP(fd,8);

 vending->purchase(sd, id, sd->vended_id, data, len/4);


 sd->vended_id = 0;
}

void clif_parse_PurchaseReq2(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_PurchaseReq2(int fd, struct map_session_data* sd)
{
 int len = (int)RFIFOW(fd,2) - 12;
 int aid = RFIFOL(fd,4);
 int uid = RFIFOL(fd,8);
 const uint8 *data = RFIFOP(fd,12);

 vending->purchase(sd, aid, uid, data, len/4);


 sd->vended_id = 0;
}

void clif_parse_OpenVending(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));






void clif_parse_OpenVending(int fd, struct map_session_data* sd) {
 short len = (short)RFIFOW(fd,2) - 85;
 const char *message = RFIFOP(fd,4);
 
# 12683 "../../../server-code/src/map/clif.c" 3 4
_Bool 
# 12683 "../../../server-code/src/map/clif.c"
     flag = (RFIFOB(fd,84) != 0) ? 
# 12683 "../../../server-code/src/map/clif.c" 3 4
                                   1 
# 12683 "../../../server-code/src/map/clif.c"
                                        : 
# 12683 "../../../server-code/src/map/clif.c" 3 4
                                          0
# 12683 "../../../server-code/src/map/clif.c"
                                               ;
 const uint8 *data = RFIFOP(fd,85);

 if( !flag )
  sd->state.prevend = sd->state.workinprogress = 0;

 if(( (&sd->sc)->data[SC_NOCHAT] && (&sd->sc)->data[SC_NOCHAT]->val1&(MANNER_NOROOM) ))
  return;
 if( map->list[sd->bl.m].flag.novending ) {
  clif->message (sd->fd, atcommand->msgsd((sd),(276)));
  return;
 }
 if (map->getcell(sd->bl.m, &sd->bl, sd->bl.x, sd->bl.y, CELL_CHKNOVENDING)) {
  clif->message (sd->fd, atcommand->msgsd((sd),(204)));
  return;
 }

 if( message[0] == '\0' )
  return;

 vending->open(sd, message, data, len/8);
}

void clif_parse_CreateGuild(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_CreateGuild(int fd,struct map_session_data *sd)
{
 char name[(23 + 1)];
 (strlib->safestrncpy_((name),(RFIFOP(fd,6)),((23 + 1))));

 if(map->list[sd->bl.m].flag.guildlock) {

  clif->message(fd, atcommand->msgfd((fd),(228)));
  return;
 }

 guild->create(sd, name);
}

void clif_parse_GuildCheckMaster(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_GuildCheckMaster(int fd, struct map_session_data *sd)
{
 clif->guild_masterormember(sd);
}

void clif_parse_GuildRequestInfo(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));
# 12742 "../../../server-code/src/map/clif.c"
void clif_parse_GuildRequestInfo(int fd, struct map_session_data *sd)
{
 if( !sd->status.guild_id && !sd->bg_id )
  return;

 switch( RFIFOL(fd,2) ) {
  case 0:
   clif->guild_basicinfo(sd);
   clif->guild_allianceinfo(sd);
   break;
  case 1:
   clif->guild_positionnamelist(sd);
   clif->guild_memberlist(sd);
   break;
  case 2:
   clif->guild_positionnamelist(sd);
   clif->guild_positioninfolist(sd);
   break;
  case 3:
   clif->guild_skillinfo(sd);
   break;
  case 4:
   clif->guild_expulsionlist(sd);
   break;
  default:
   (showmsg->showError(("clif: guild request info: unknown type %u\n"), RFIFOL(fd,2)));
   break;
 }
}

void clif_parse_GuildChangePositionInfo(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_GuildChangePositionInfo(int fd, struct map_session_data *sd)
{
 int i;

 if(!sd->state.gmaster_flag)
  return;

 for(i = 4; i < RFIFOW(fd,2); i += 40 ){
  guild->change_position(sd->status.guild_id, RFIFOL(fd,i), RFIFOL(fd,i+4), RFIFOL(fd,i+12), RFIFOP(fd,i+16));
 }
}

void clif_parse_GuildChangeMemberPosition(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_GuildChangeMemberPosition(int fd, struct map_session_data *sd)
{
 int i;

 if(!sd->state.gmaster_flag)
  return;

 for(i=4;i<RFIFOW(fd,2);i+=12){
  guild->change_memberposition(sd->status.guild_id,
   RFIFOL(fd,i),RFIFOL(fd,i+4),RFIFOL(fd,i+8));
 }
}

void clif_parse_GuildRequestEmblem(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_GuildRequestEmblem(int fd,struct map_session_data *sd)
{
 struct guild* g;
 int guild_id = RFIFOL(fd,2);

 if( (g = guild->search(guild_id)) != 
# 12811 "../../../server-code/src/map/clif.c" 3 4
                                     ((void *)0) 
# 12811 "../../../server-code/src/map/clif.c"
                                          )
  clif->guild_emblem(sd,g);
}



# 12816 "../../../server-code/src/map/clif.c" 3 4
_Bool 
# 12816 "../../../server-code/src/map/clif.c"
    clif_validate_emblem(const uint8 *emblem, unsigned long emblem_len) {
 enum e_bitmapconst {
  RGBTRIPLE_SIZE = 3,
  RGBQUAD_SIZE = 4,
  BITMAPFILEHEADER_SIZE = 14,
  BITMAPINFOHEADER_SIZE = 40,
  BITMAP_WIDTH = 24,
  BITMAP_HEIGHT = 24,
 };

#pragma pack(push, 1)

 struct s_bitmaptripple {



  unsigned int rgb:24;
 } __attribute__((packed));

#pragma pack(pop)

 uint8 buf[1800];
 unsigned long buf_len = sizeof(buf);
 int header = 0, bitmap = 0, offbits = 0, palettesize = 0;

 do { if (((void)(emblem), 
# 12841 "../../../server-code/src/map/clif.c" 3 4
0
# 12841 "../../../server-code/src/map/clif.c"
)) return(
# 12841 "../../../server-code/src/map/clif.c" 3 4
0
# 12841 "../../../server-code/src/map/clif.c"
); } while(0);
 if( decode_zip(buf, &buf_len, emblem, emblem_len) != 0 || buf_len < BITMAPFILEHEADER_SIZE + BITMAPINFOHEADER_SIZE
  || RBUFW(buf,0) != 0x4d42
  || RBUFL(buf,2) != buf_len
  || RBUFL(buf,14) != BITMAPINFOHEADER_SIZE
  || RBUFL(buf,18) != BITMAP_WIDTH
  || RBUFL(buf,22) != BITMAP_HEIGHT
  || RBUFL(buf,30) != 0
  ) {

  return 
# 12851 "../../../server-code/src/map/clif.c" 3 4
        0
# 12851 "../../../server-code/src/map/clif.c"
             ;
 }

 offbits = RBUFL(buf,10);

 switch( RBUFW(buf,28) ) {
  case 8:
   palettesize = RBUFL(buf,46);
   if( palettesize == 0 )
    palettesize = 256;
   else if( palettesize > 256 )
    return 
# 12862 "../../../server-code/src/map/clif.c" 3 4
          0
# 12862 "../../../server-code/src/map/clif.c"
               ;
   header = BITMAPFILEHEADER_SIZE + BITMAPINFOHEADER_SIZE + RGBQUAD_SIZE * palettesize;
   bitmap = BITMAP_WIDTH * BITMAP_HEIGHT;
   break;
  case 24:
   header = BITMAPFILEHEADER_SIZE + BITMAPINFOHEADER_SIZE;
   bitmap = BITMAP_WIDTH * BITMAP_HEIGHT * RGBTRIPLE_SIZE;
   break;
  default:
   return 
# 12871 "../../../server-code/src/map/clif.c" 3 4
         0
# 12871 "../../../server-code/src/map/clif.c"
              ;
 }






 if( offbits < header || buf_len <= bitmap || offbits > buf_len - bitmap ) {
  return 
# 12880 "../../../server-code/src/map/clif.c" 3 4
        0
# 12880 "../../../server-code/src/map/clif.c"
             ;
 }

 if( battle_config.client_emblem_max_blank_percent < 100 ) {
  int required_pixels = BITMAP_WIDTH * BITMAP_HEIGHT * (100 - battle_config.client_emblem_max_blank_percent) / 100;
  int found_pixels = 0;
  int i;
# 12895 "../../../server-code/src/map/clif.c"
  switch( RBUFW(buf,28) ) {
   case 8:
   {
    const uint8 *indexes = RBUFP(buf,offbits);
    const uint32 *palette = RBUFP(buf,BITMAPFILEHEADER_SIZE + BITMAPINFOHEADER_SIZE);

    for (i = 0; i < BITMAP_WIDTH * BITMAP_HEIGHT; i++) {
     if( indexes[i] >= palettesize )
      return 
# 12903 "../../../server-code/src/map/clif.c" 3 4
            0
# 12903 "../../../server-code/src/map/clif.c"
                 ;


     if( ( palette[indexes[i]]&0x00F8F8F8 ) != 0x00F800F8 ) {
      if( ++found_pixels >= required_pixels ) {

       return 
# 12909 "../../../server-code/src/map/clif.c" 3 4
             1
# 12909 "../../../server-code/src/map/clif.c"
                 ;
      }
     }
    }
    break;
   }
   case 24:
   {
    const struct s_bitmaptripple *pixels = RBUFP(buf,offbits);

    for (i = 0; i < BITMAP_WIDTH * BITMAP_HEIGHT; i++) {

     if( ( pixels[i].rgb&0xF8F8F8 ) != 0xF800F8 ) {
      if( ++found_pixels >= required_pixels ) {

       return 
# 12924 "../../../server-code/src/map/clif.c" 3 4
             1
# 12924 "../../../server-code/src/map/clif.c"
                 ;
      }
     }
    }
    break;
   }
  }


  return 
# 12933 "../../../server-code/src/map/clif.c" 3 4
        0
# 12933 "../../../server-code/src/map/clif.c"
             ;
 }

 return 
# 12936 "../../../server-code/src/map/clif.c" 3 4
       1
# 12936 "../../../server-code/src/map/clif.c"
           ;
}

void clif_parse_GuildChangeEmblem(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_GuildChangeEmblem(int fd,struct map_session_data *sd)
{
 unsigned int emblem_len = RFIFOW(fd,2)-4;
 const uint8* emblem = RFIFOP(fd,4);

 if( !emblem_len || !sd->state.gmaster_flag )
  return;

 if (!clif->validate_emblem(emblem, emblem_len)) {
  (showmsg->showWarning(("clif_parse_GuildChangeEmblem: Rejected malformed guild emblem (size=%u, accound_id=%d, char_id=%d, guild_id=%d).\n"), emblem_len, sd->status.account_id, sd->status.char_id, sd->status.guild_id))
                                                                                         ;
  return;
 }

 guild->change_emblem(sd, emblem_len, (const char*)emblem);
}

void clif_parse_GuildChangeNotice(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_GuildChangeNotice(int fd, struct map_session_data* sd)
{
 int guild_id = RFIFOL(fd,2);
 char *msg1 = 
# 12965 "../../../server-code/src/map/clif.c" 3 4
             ((void *)0)
# 12965 "../../../server-code/src/map/clif.c"
                 , *msg2 = 
# 12965 "../../../server-code/src/map/clif.c" 3 4
                           ((void *)0)
# 12965 "../../../server-code/src/map/clif.c"
                               ;

 if (!sd->state.gmaster_flag)
  return;

 msg1 = (iMalloc->astrndup((RFIFOP(fd,6)),(60 -1),"../../../server-code/src/map/clif.c", 12970, __func__));
 msg2 = (iMalloc->astrndup((RFIFOP(fd,66)),(120 -1),"../../../server-code/src/map/clif.c", 12971, __func__));


 if (msg1[0] == '|' && msg1[3] == '|') msg1+= 3;
 if (msg2[0] == '|' && msg2[3] == '|') msg2+= 3;
 if (msg2[0] == '|') msg2[(strlib->strnlen_((msg2),(120)))-1] = '\0';

 guild->change_notice(sd, guild_id, msg1, msg2);
 (iMalloc->free((msg1),"../../../server-code/src/map/clif.c", 12979, __func__));
 (iMalloc->free((msg2),"../../../server-code/src/map/clif.c", 12980, __func__));
}



# 12984 "../../../server-code/src/map/clif.c" 3 4
_Bool 
# 12984 "../../../server-code/src/map/clif.c"
    clif_sub_guild_invite(int fd, struct map_session_data *sd, struct map_session_data *t_sd) {
 if ( t_sd == 
# 12985 "../../../server-code/src/map/clif.c" 3 4
             ((void *)0) 
# 12985 "../../../server-code/src/map/clif.c"
                  )
  return 
# 12986 "../../../server-code/src/map/clif.c" 3 4
        0
# 12986 "../../../server-code/src/map/clif.c"
             ;

 do { if (((void)(sd), 
# 12988 "../../../server-code/src/map/clif.c" 3 4
0
# 12988 "../../../server-code/src/map/clif.c"
)) return(
# 12988 "../../../server-code/src/map/clif.c" 3 4
0
# 12988 "../../../server-code/src/map/clif.c"
); } while(0);
 do { if (((void)(t_sd), 
# 12989 "../../../server-code/src/map/clif.c" 3 4
0
# 12989 "../../../server-code/src/map/clif.c"
)) return(
# 12989 "../../../server-code/src/map/clif.c" 3 4
0
# 12989 "../../../server-code/src/map/clif.c"
); } while(0);
 if ( map->list[sd->bl.m].flag.guildlock ) {

  clif->message(fd, atcommand->msgfd((fd),(228)));
  return 
# 12993 "../../../server-code/src/map/clif.c" 3 4
        0
# 12993 "../../../server-code/src/map/clif.c"
             ;
 }

 if (t_sd->state.noask) {
  clif->noask_sub(sd, t_sd, 2);
  return 
# 12998 "../../../server-code/src/map/clif.c" 3 4
        0
# 12998 "../../../server-code/src/map/clif.c"
             ;
 }

 guild->invite(sd,t_sd);
 return 
# 13002 "../../../server-code/src/map/clif.c" 3 4
       1
# 13002 "../../../server-code/src/map/clif.c"
           ;
}

void clif_parse_GuildInvite(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_GuildInvite(int fd,struct map_session_data *sd) {
 struct map_session_data *t_sd = map->id2sd(RFIFOL(fd,2));

 if (!clif_sub_guild_invite(fd, sd, t_sd))
  return;
}

void clif_parse_GuildInvite2(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_GuildInvite2(int fd, struct map_session_data *sd)
{
 char nick[(23 + 1)];
 struct map_session_data *t_sd = 
# 13021 "../../../server-code/src/map/clif.c" 3 4
                                ((void *)0)
# 13021 "../../../server-code/src/map/clif.c"
                                    ;

 (strlib->safestrncpy_((nick),(RFIFOP(fd, 2)),((23 + 1))));
 t_sd = map->nick2sd(nick);

 clif_sub_guild_invite(fd, sd, t_sd);
}

void clif_parse_GuildReplyInvite(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));





void clif_parse_GuildReplyInvite(int fd,struct map_session_data *sd)
{
 guild->reply_invite(sd,RFIFOL(fd,2),RFIFOL(fd,6));
}

void clif_parse_GuildLeave(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_GuildLeave(int fd,struct map_session_data *sd) {
 if(map->list[sd->bl.m].flag.guildlock) {

  clif->message(fd, atcommand->msgfd((fd),(228)));
  return;
 }
 if( sd->bg_id ) {
  clif->message(fd, atcommand->msgfd((fd),(870)));
  return;
 }

 guild->leave(sd,RFIFOL(fd,2), RFIFOL(fd,6), RFIFOL(fd,10), RFIFOP(fd,14));
}

void clif_parse_GuildExpulsion(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_GuildExpulsion(int fd,struct map_session_data *sd) {
 if( map->list[sd->bl.m].flag.guildlock || sd->bg_id ) {

  clif->message(fd, atcommand->msgfd((fd),(228)));
  return;
 }
 guild->expulsion(sd, RFIFOL(fd,2), RFIFOL(fd,6), RFIFOL(fd,10), RFIFOP(fd,14));
}

void clif_parse_GuildMessage(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_GuildMessage(int fd, struct map_session_data* sd)
{
 const char *text = RFIFOP(fd,4);
 int textlen = RFIFOW(fd,2) - 4;

 const char *name, *message;
 size_t namelen, messagelen;


 if( !clif->process_message(sd, 0, &name, &namelen, &message, &messagelen) )
  return;

 if( atcommand->exec(fd, sd, message, 
# 13084 "../../../server-code/src/map/clif.c" 3 4
                                     1
# 13084 "../../../server-code/src/map/clif.c"
                                         ) )
  return;

 if( !pc->can_talk(sd) )
  return;

 if (battle_config.min_chat_delay) {
  if (((sd->cantalk_tick)-(timer->gettick())) > 0)
   return;
  sd->cantalk_tick = timer->gettick() + battle_config.min_chat_delay;
 }

 pc->update_idle_time(sd, BCIDLE_CHAT);

 if( sd->bg_id )
  bg->send_message(sd, text, textlen);
 else
  guild->send_message(sd, text, textlen);
}

void clif_parse_GuildRequestAlliance(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_GuildRequestAlliance(int fd, struct map_session_data *sd) {
 struct map_session_data *t_sd;

 if(!sd->state.gmaster_flag)
  return;

 if(map->list[sd->bl.m].flag.guildlock) {

  clif->message(fd, atcommand->msgfd((fd),(228)));
  return;
 }

 t_sd = map->id2sd(RFIFOL(fd,2));


 if(t_sd && t_sd->state.noask) {
  clif->noask_sub(sd, t_sd, 3);
  return;
 }

 guild->reqalliance(sd,t_sd);
}

void clif_parse_GuildReplyAlliance(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));





void clif_parse_GuildReplyAlliance(int fd, struct map_session_data *sd)
{
 guild->reply_reqalliance(sd,RFIFOL(fd,2),RFIFOL(fd,6));
}

void clif_parse_GuildDelAlliance(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));





void clif_parse_GuildDelAlliance(int fd, struct map_session_data *sd) {
 if(!sd->state.gmaster_flag)
  return;

 if(map->list[sd->bl.m].flag.guildlock) {

  clif->message(fd, atcommand->msgfd((fd),(228)));
  return;
 }
 guild->delalliance(sd,RFIFOL(fd,2),RFIFOL(fd,6));
}

void clif_parse_GuildOpposition(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_GuildOpposition(int fd, struct map_session_data *sd) {
 struct map_session_data *t_sd;

 if(!sd->state.gmaster_flag)
  return;

 if(map->list[sd->bl.m].flag.guildlock) {

  clif->message(fd, atcommand->msgfd((fd),(228)));
  return;
 }

 t_sd = map->id2sd(RFIFOL(fd,2));


 if(t_sd && t_sd->state.noask) {
  clif->noask_sub(sd, t_sd, 4);
  return;
 }

 guild->opposition(sd,t_sd);
}

void clif_parse_GuildBreak(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));





void clif_parse_GuildBreak(int fd, struct map_session_data *sd) {
 if( map->list[sd->bl.m].flag.guildlock ) {

  clif->message(fd, atcommand->msgfd((fd),(228)));
  return;
 }
 guild->dobreak(sd, RFIFOP(fd,2));
}




void clif_parse_PetMenu(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));
# 13212 "../../../server-code/src/map/clif.c"
void clif_parse_PetMenu(int fd, struct map_session_data *sd)
{
 pet->menu(sd,RFIFOB(fd,2));
}

void clif_parse_CatchPet(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_CatchPet(int fd, struct map_session_data *sd)
{
 pet->catch_process2(sd,RFIFOL(fd,2));
}

void clif_parse_SelectEgg(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_SelectEgg(int fd, struct map_session_data *sd)
{
 if (sd->menuskill_id != SA_TAMINGMONSTER || sd->menuskill_val != -1) {
  return;
 }
 pet->select_egg(sd,RFIFOW(fd,2)-2);
 ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
}

void clif_parse_SendEmotion(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));
# 13262 "../../../server-code/src/map/clif.c"
void clif_parse_SendEmotion(int fd, struct map_session_data *sd)
{
 if(sd->pd)
  clif->pet_emotion(sd->pd,RFIFOL(fd,2));
}

void clif_parse_ChangePetName(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_ChangePetName(int fd, struct map_session_data *sd)
{
 pet->change_name(sd, RFIFOP(fd,2));
}

void clif_parse_GMKick(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));




void clif_parse_GMKick(int fd, struct map_session_data *sd) {
 struct block_list *target;
 int tid;

 tid = RFIFOL(fd,2);
 target = map->id2bl(tid);
 if (!target) {
  clif->GM_kickack(sd, 0);
  return;
 }

 switch (target->type) {
  case BL_PC:
  {
   char command[(23 + 1)+6];
   sprintf(command, "%ckick %s", atcommand->at_symbol, clif->get_bl_name(target));
   atcommand->exec(fd, sd, command, 
# 13297 "../../../server-code/src/map/clif.c" 3 4
                                   1
# 13297 "../../../server-code/src/map/clif.c"
                                       );
  }
  break;




  case BL_MOB:
  {
   char command[100];
   if( !pc->can_use_command(sd, "@killmonster")) {
    clif->GM_kickack(sd, 0);
    return;
   }
   sprintf(command, "/kick %s (%d)", clif->get_bl_name(target), status->get_class(target));
   logs->atcommand(sd, command);
   (status->percent_change((&sd->bl), (target), (100), (0), (
# 13313 "../../../server-code/src/map/clif.c" 3 4
  1
# 13313 "../../../server-code/src/map/clif.c"
  )?1:2));
  }
  break;

  case BL_NPC:
  {
   struct npc_data *nd = ((TBL_NPC *)BL_UCAST_(target));
   if( !pc->can_use_command(sd, "@unloadnpc")) {
    clif->GM_kickack(sd, 0);
    return;
   }
   npc->unload_duplicates(nd);
   npc->unload(nd,
# 13325 "../../../server-code/src/map/clif.c" 3 4
                 1
# 13325 "../../../server-code/src/map/clif.c"
                     );
   npc->read_event_script();
  }
  break;

  default:
   clif->GM_kickack(sd, 0);
 }
}

void clif_parse_GMKickAll(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));



void clif_parse_GMKickAll(int fd, struct map_session_data* sd) {
 char cmd[15];
 sprintf(cmd,"%ckickall",atcommand->at_symbol);
 atcommand->exec(fd, sd, cmd, 
# 13342 "../../../server-code/src/map/clif.c" 3 4
                             1
# 13342 "../../../server-code/src/map/clif.c"
                                 );
}

void clif_parse_GMShift(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));







void clif_parse_GMShift(int fd, struct map_session_data *sd)
{

 char player_name[(23 + 1)];
 char command[(23 + 1)+8];

 (strlib->safestrncpy_((player_name),(RFIFOP(fd,2)),((23 + 1))));

 sprintf(command, "%cjumpto %s", atcommand->at_symbol, player_name);
 atcommand->exec(fd, sd, command, 
# 13362 "../../../server-code/src/map/clif.c" 3 4
                                 1
# 13362 "../../../server-code/src/map/clif.c"
                                     );
}

void clif_parse_GMRemove2(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));



void clif_parse_GMRemove2(int fd, struct map_session_data* sd) {
 int account_id;
 struct map_session_data* pl_sd;

 account_id = RFIFOL(fd,packet_db[RFIFOW(fd,0)].pos[0]);
 if( (pl_sd = map->id2sd(account_id)) != 
# 13374 "../../../server-code/src/map/clif.c" 3 4
                                        ((void *)0) 
# 13374 "../../../server-code/src/map/clif.c"
                                             ) {
  char command[(23 + 1)+8];
  sprintf(command, "%cjumpto %s", atcommand->at_symbol, pl_sd->status.name);
  atcommand->exec(fd, sd, command, 
# 13377 "../../../server-code/src/map/clif.c" 3 4
                                  1
# 13377 "../../../server-code/src/map/clif.c"
                                      );
 }
}

void clif_parse_GMRecall(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));







void clif_parse_GMRecall(int fd, struct map_session_data *sd)
{

 char player_name[(23 + 1)];
 char command[(23 + 1)+8];

 (strlib->safestrncpy_((player_name),(RFIFOP(fd,2)),((23 + 1))));

 sprintf(command, "%crecall %s", atcommand->at_symbol, player_name);
 atcommand->exec(fd, sd, command, 
# 13398 "../../../server-code/src/map/clif.c" 3 4
                                 1
# 13398 "../../../server-code/src/map/clif.c"
                                     );
}

void clif_parse_GMRecall2(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));



void clif_parse_GMRecall2(int fd, struct map_session_data* sd) {
 int account_id;
 struct map_session_data* pl_sd;

 account_id = RFIFOL(fd,packet_db[RFIFOW(fd,0)].pos[0]);
 if( (pl_sd = map->id2sd(account_id)) != 
# 13410 "../../../server-code/src/map/clif.c" 3 4
                                        ((void *)0) 
# 13410 "../../../server-code/src/map/clif.c"
                                             ) {
  char command[(23 + 1)+8];
  sprintf(command, "%crecall %s", atcommand->at_symbol, pl_sd->status.name);
  atcommand->exec(fd, sd, command, 
# 13413 "../../../server-code/src/map/clif.c" 3 4
                                  1
# 13413 "../../../server-code/src/map/clif.c"
                                      );
 }
}

void clif_parse_GM_Monster_Item(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));
# 13431 "../../../server-code/src/map/clif.c"
void clif_parse_GM_Monster_Item(int fd, struct map_session_data *sd)
{
 const struct packet_gm_monster_item *p = RP2PTR(fd);
 int i, count;
 char item_monster_name[sizeof p->str];
 struct item_data *item_array[10];
 struct mob_db *mob_array[10];
 char command[256];

 (strlib->safestrncpy_((item_monster_name),(p->str),(sizeof(item_monster_name))));

 if ( (count=itemdb->search_name_array(item_array, 10, item_monster_name, 1)) > 0 ) {
  for(i = 0; i < count; i++) {
   if( !item_array[i] )
    continue;

   if( battle_config.case_sensitive_aegisnames && strcmp(item_array[i]->name, item_monster_name) == 0 )
    break;
   if( !battle_config.case_sensitive_aegisnames && strcasecmp(item_array[i]->name, item_monster_name) == 0 )
    break;
  }

  if( i < count ) {
   if( item_array[i]->type == IT_WEAPON || item_array[i]->type == IT_ARMOR )
    snprintf(command, sizeof(command)-1, "%citem2 %d 1 0 0 0 0 0 0 0", atcommand->at_symbol, item_array[i]->nameid);
   else
    snprintf(command, sizeof(command)-1, "%citem %d 20", atcommand->at_symbol, item_array[i]->nameid);
   atcommand->exec(fd, sd, command, 
# 13458 "../../../server-code/src/map/clif.c" 3 4
                                   1
# 13458 "../../../server-code/src/map/clif.c"
                                       );
   return;
  }
 }

 if( strcmp("money", item_monster_name) == 0 ){
  snprintf(command, sizeof(command)-1, "%czeny %d", atcommand->at_symbol, 0x7fffffff);
  atcommand->exec(fd, sd, command, 
# 13465 "../../../server-code/src/map/clif.c" 3 4
                                  1
# 13465 "../../../server-code/src/map/clif.c"
                                      );
  return;
 }

 if( (count=mob->db_searchname_array(mob_array, 10, item_monster_name, 1)) > 0) {
  for(i = 0; i < count; i++) {
   if( !mob_array[i] )
    continue;

   if( battle_config.case_sensitive_aegisnames && strcmp(mob_array[i]->sprite, item_monster_name) == 0 )
    break;
   if( !battle_config.case_sensitive_aegisnames && strcasecmp(mob_array[i]->sprite, item_monster_name) == 0 )
    break;
  }

  if( i < count ){
   snprintf(command, sizeof(command)-1, "%cmonster %s", atcommand->at_symbol, mob_array[i]->sprite);
   atcommand->exec(fd, sd, command, 
# 13482 "../../../server-code/src/map/clif.c" 3 4
                                   1
# 13482 "../../../server-code/src/map/clif.c"
                                       );
  }
 }
}

void clif_parse_GMHide(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));




void clif_parse_GMHide(int fd, struct map_session_data *sd) {
 char cmd[6];

 sprintf(cmd,"%chide",atcommand->at_symbol);

 atcommand->exec(fd, sd, cmd, 
# 13497 "../../../server-code/src/map/clif.c" 3 4
                             1
# 13497 "../../../server-code/src/map/clif.c"
                                 );
}

void clif_parse_GMReqNoChat(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));






void clif_parse_GMReqNoChat(int fd,struct map_session_data *sd) {
 int id, type, value;
 struct map_session_data *dstsd;
 char command[(23 + 1)+15];

 id = RFIFOL(fd,2);
 type = RFIFOB(fd,6);
 value = RFIFOW(fd,7);

 if( type == 0 )
  value = -value;

 if (type == 2) {
  if (!battle_config.client_accept_chatdori)
   return;
  if (( (sd)->group->level ) > 0 || sd->bl.id != id)
   return;

  value = battle_config.client_accept_chatdori;
  dstsd = sd;
 } else {
  dstsd = map->id2sd(id);
  if( dstsd == 
# 13529 "../../../server-code/src/map/clif.c" 3 4
              ((void *)0) 
# 13529 "../../../server-code/src/map/clif.c"
                   )
   return;
 }

 if (type == 2 || ( (( (sd)->group->level )) > ( (dstsd)->group->level ) && !pc->can_use_command(sd, "@mute"))) {
  clif->manner_message(sd, 0);
  clif->manner_message(dstsd, 5);

  if (dstsd->status.manner < value) {
   dstsd->status.manner -= value;
   (status->change_start((
# 13539 "../../../server-code/src/map/clif.c" 3 4
  ((void *)0)
# 13539 "../../../server-code/src/map/clif.c"
  ),(&dstsd->bl),(SC_NOCHAT),100*(100),(0),0,0,0,(0),SCFLAG_NONE));

  } else {
   dstsd->status.manner = 0;
   (status->change_end_((&dstsd->bl),(SC_NOCHAT),((-1)),"../../../server-code/src/map/clif.c",13543));
  }

  if( type != 2 )
   clif->GM_silence(sd, dstsd, type);
 }

 sprintf(command, "%cmute %d %s", atcommand->at_symbol, value, dstsd->status.name);
 atcommand->exec(fd, sd, command, 
# 13551 "../../../server-code/src/map/clif.c" 3 4
                                 1
# 13551 "../../../server-code/src/map/clif.c"
                                     );
}

void clif_parse_GMRc(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));



void clif_parse_GMRc(int fd, struct map_session_data* sd)
{
 char command[(23 + 1)+15];
 char name[(23 + 1)];

 (strlib->safestrncpy_((name),(RFIFOP(fd,2)),((23 + 1))));

 sprintf(command, "%cmute %d %s", atcommand->at_symbol, 60, name);
 atcommand->exec(fd, sd, command, 
# 13566 "../../../server-code/src/map/clif.c" 3 4
                                 1
# 13566 "../../../server-code/src/map/clif.c"
                                     );
}



void clif_account_name(struct map_session_data* sd, int account_id, const char* accname) {
 int fd;

 do { if (((void)(sd), 
# 13574 "../../../server-code/src/map/clif.c" 3 4
0
# 13574 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x1e0].len);
 WFIFOW(fd,0) = 0x1e0;
 WFIFOL(fd,2) = account_id;
 (strlib->safestrncpy_((WFIFOP(fd,6)),(accname),((23 + 1))));
 WFIFOSET(fd,packet_db[0x1e0].len);
}

void clif_parse_GMReqAccountName(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_GMReqAccountName(int fd, struct map_session_data *sd)
{
 int account_id = RFIFOL(fd,2);


 clif->account_name(sd, account_id, "");
}

void clif_parse_GMChangeMapType(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));






void clif_parse_GMChangeMapType(int fd, struct map_session_data *sd) {
 int x,y,type;

 if (!( ((sd)->extra_temp_permissions&(PC_PERM_USE_CHANGEMAPTYPE)) != 0 || ((sd)->group->e_permissions&(PC_PERM_USE_CHANGEMAPTYPE)) != 0 ))
  return;

 x = RFIFOW(fd,2);
 y = RFIFOW(fd,4);
 type = RFIFOW(fd,6);

 map->setgatcell(sd->bl.m,x,y,type);
 clif->changemapcell(0,sd->bl.m,x,y,type,ALL_SAMEMAP);

}

void clif_parse_PMIgnore(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));






void clif_parse_PMIgnore(int fd, struct map_session_data* sd)
{
 char nick[(23 + 1)];
 uint8 type;
 int i;

 (strlib->safestrncpy_((nick),(RFIFOP(fd,2)),((23 + 1))));

 type = RFIFOB(fd,26);

 if( type == 0 ) {
  if (strcmp(map->wisp_server_name, nick) == 0) {
   clif->wisexin(sd, type, 1);
   return;
  }


  do { for ((i) = (0); (i) < (20); ++(i)) if (sd->ignore[i].name[0] == '\0' || strcmp(sd->ignore[i].name, nick) == 0) break; } while(
# 13640 "../../../server-code/src/map/clif.c" 3 4
 0
# 13640 "../../../server-code/src/map/clif.c"
 );
  if( i == 20 ) {
   clif->wisexin(sd, type, 2);
   return;
  }
  if( sd->ignore[i].name[0] != '\0' ) {
   clif->wisexin(sd, type, 0);
   return;
  }


  (strlib->safestrncpy_((sd->ignore[i].name),(nick),((23 + 1))));
 } else {


  do { for ((i) = (0); (i) < (20); ++(i)) if (sd->ignore[i].name[0] == '\0' || strcmp(sd->ignore[i].name, nick) == 0) break; } while(
# 13655 "../../../server-code/src/map/clif.c" 3 4
 0
# 13655 "../../../server-code/src/map/clif.c"
 );
  if( i == 20 || sd->ignore[i].name[i] == '\0' ) {
   clif->wisexin(sd, type, 1);
   return;
  }

  if( i != 20 - 1 )
   memmove(&sd->ignore[i], &sd->ignore[i+1], (20 -i-1)*sizeof(sd->ignore[0]));

  memset(sd->ignore[20 -1].name, 0, sizeof(sd->ignore[0].name));
 }

 clif->wisexin(sd, type, 0);
}

void clif_parse_PMIgnoreAll(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));






void clif_parse_PMIgnoreAll(int fd, struct map_session_data *sd)
{
 int type = RFIFOB(fd,2), flag;

 if( type == 0 ) {
  if( sd->state.ignoreAll ) {
   flag = 1;
  } else {
   sd->state.ignoreAll = 1;
   flag = 0;
  }
 } else {
  if( sd->state.ignoreAll ) {
   sd->state.ignoreAll = 0;
   flag = 0;
  } else {
   if (sd->ignore[0].name[0] != '\0')
   {
    memset(sd->ignore, 0, sizeof(sd->ignore));
    flag = 0;
   } else {
    flag = 1;
   }
  }
 }

 clif->wisall(sd, type, flag);
}



void clif_PMIgnoreList(struct map_session_data* sd) {
 int i, fd;

 do { if (((void)(sd), 
# 13711 "../../../server-code/src/map/clif.c" 3 4
0
# 13711 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,4+( (int)(sizeof(sd->ignore)/sizeof((sd->ignore)[0])) )*(23 + 1));
 WFIFOW(fd,0) = 0xd4;

 for( i = 0; i < ( (int)(sizeof(sd->ignore)/sizeof((sd->ignore)[0])) ) && sd->ignore[i].name[0]; i++ ) {
  memcpy(WFIFOP(fd,4+i*(23 + 1)), sd->ignore[i].name, (23 + 1));
 }

 WFIFOW(fd,2) = 4+i*(23 + 1);
 WFIFOSET(fd,WFIFOW(fd,2));
}

void clif_parse_PMIgnoreList(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_PMIgnoreList(int fd,struct map_session_data *sd)
{
 clif->PMIgnoreList(sd);
}

void clif_parse_NoviceDoriDori(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_NoviceDoriDori(int fd, struct map_session_data *sd)
{
 if (sd->state.doridori) return;

 switch (sd->class_&0x0fff) {
  case MAPID_SOUL_LINKER:
  case MAPID_STAR_GLADIATOR:
  case MAPID_TAEKWON:
   if (!sd->state.rest)
    break;
  case MAPID_SUPER_NOVICE:
   sd->state.doridori=1;
   break;
 }
}

void clif_parse_NoviceExplosionSpirits(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));
# 13760 "../../../server-code/src/map/clif.c"
void clif_parse_NoviceExplosionSpirits(int fd, struct map_session_data *sd)
{




 if( ( sd->class_&0x0fff ) == MAPID_SUPER_NOVICE ) {
  unsigned int next = pc->nextbaseexp(sd);
  if( next == 0 ) next = pc->thisbaseexp(sd);
  if( next ) {
   int percent = (int)( ( (float)sd->status.base_exp/(float)next )*1000. );

   if( percent && ( percent%100 ) == 0 ) {
    (status->change_start((
# 13773 "../../../server-code/src/map/clif.c" 3 4
   ((void *)0)
# 13773 "../../../server-code/src/map/clif.c"
   ),(&sd->bl),(status->skill2sc(MO_EXPLOSIONSPIRITS)),100*(100),(17),0,0,0,(skill->get_time(MO_EXPLOSIONSPIRITS, 5)),SCFLAG_NONE));
    clif->skill_nodamage(&sd->bl, &sd->bl, MO_EXPLOSIONSPIRITS, 5, 1);
   }
  }
 }
}
# 13788 "../../../server-code/src/map/clif.c"
void clif_friendslist_toggle(struct map_session_data *sd,int account_id, int char_id, int online) {
 int i, fd;

 do { if (((void)(sd), 
# 13791 "../../../server-code/src/map/clif.c" 3 4
0
# 13791 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;

 for (i = 0; i < 40 && sd->status.friends[i].char_id &&
  (sd->status.friends[i].char_id != char_id || sd->status.friends[i].account_id != account_id); i++);

 if(i == 40 || sd->status.friends[i].char_id == 0)
  return;

 WFIFOHEAD(fd,packet_db[0x206].len);
 WFIFOW(fd,0) = 0x206;
 WFIFOL(fd, 2) = sd->status.friends[i].account_id;
 WFIFOL(fd, 6) = sd->status.friends[i].char_id;
 WFIFOB(fd,10) = !online;
 WFIFOSET(fd, packet_db[0x206].len);
}


int clif_friendslist_toggle_sub(struct map_session_data *sd,va_list ap)
{
 int account_id, char_id, online;
 account_id = 
# 13812 "../../../server-code/src/map/clif.c" 3 4
             __builtin_va_arg(
# 13812 "../../../server-code/src/map/clif.c"
             ap
# 13812 "../../../server-code/src/map/clif.c" 3 4
             ,
# 13812 "../../../server-code/src/map/clif.c"
             int
# 13812 "../../../server-code/src/map/clif.c" 3 4
             )
# 13812 "../../../server-code/src/map/clif.c"
                            ;
 char_id = 
# 13813 "../../../server-code/src/map/clif.c" 3 4
          __builtin_va_arg(
# 13813 "../../../server-code/src/map/clif.c"
          ap
# 13813 "../../../server-code/src/map/clif.c" 3 4
          ,
# 13813 "../../../server-code/src/map/clif.c"
          int
# 13813 "../../../server-code/src/map/clif.c" 3 4
          )
# 13813 "../../../server-code/src/map/clif.c"
                         ;
 online = 
# 13814 "../../../server-code/src/map/clif.c" 3 4
         __builtin_va_arg(
# 13814 "../../../server-code/src/map/clif.c"
         ap
# 13814 "../../../server-code/src/map/clif.c" 3 4
         ,
# 13814 "../../../server-code/src/map/clif.c"
         int
# 13814 "../../../server-code/src/map/clif.c" 3 4
         )
# 13814 "../../../server-code/src/map/clif.c"
                        ;
 clif->friendslist_toggle(sd, account_id, char_id, online);
 return 0;
}



void clif_friendslist_send(struct map_session_data *sd)
{
 int i = 0, n, fd = sd->fd;

 do { if (((void)(sd), 
# 13825 "../../../server-code/src/map/clif.c" 3 4
0
# 13825 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WFIFOHEAD(fd, 40 * 32 + 4);
 WFIFOW(fd,0) = 0x201;
 for(i = 0; i < 40 && sd->status.friends[i].char_id; i++) {
  WFIFOL(fd, 4 + 32 * i + 0) = sd->status.friends[i].account_id;
  WFIFOL(fd, 4 + 32 * i + 4) = sd->status.friends[i].char_id;
  memcpy(WFIFOP(fd, 4 + 32 * i + 8), &sd->status.friends[i].name, (23 + 1));
 }

 if (i) {
  WFIFOW(fd,2) = 4 + 32 * i;
  WFIFOSET(fd, WFIFOW(fd,2));
 }

 for (n = 0; n < i; n++) {
  if (map->charid2sd(sd->status.friends[n].char_id))
   clif->friendslist_toggle(sd, sd->status.friends[n].account_id, sd->status.friends[n].char_id, 1);
 }
}
# 13853 "../../../server-code/src/map/clif.c"
void clif_friendslist_reqack(struct map_session_data *sd, struct map_session_data *f_sd, int type)
{
 int fd;
 do { if (((void)(sd), 
# 13856 "../../../server-code/src/map/clif.c" 3 4
0
# 13856 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x209].len);
 WFIFOW(fd,0) = 0x209;
 WFIFOW(fd,2) = type;
 if (f_sd) {
  WFIFOL(fd,4) = f_sd->status.account_id;
  WFIFOL(fd,8) = f_sd->status.char_id;
  memcpy(WFIFOP(fd, 12), f_sd->status.name,(23 + 1));
 }
 WFIFOSET(fd, packet_db[0x209].len);
}



void clif_friendlist_req(struct map_session_data* sd, int account_id, int char_id, const char* name) {
 int fd;

 do { if (((void)(sd), 
# 13875 "../../../server-code/src/map/clif.c" 3 4
0
# 13875 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x207].len);
 WFIFOW(fd,0) = 0x207;
 WFIFOL(fd,2) = account_id;
 WFIFOL(fd,6) = char_id;
 memcpy(WFIFOP(fd,10), name, (23 + 1));
 WFIFOSET(fd,packet_db[0x207].len);
}

void clif_parse_FriendsListAdd(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_FriendsListAdd(int fd, struct map_session_data *sd)
{
 struct map_session_data *f_sd;
 int i;
 char nick[(23 + 1)];

 (strlib->safestrncpy_((nick),(RFIFOP(fd,2)),((23 + 1))));

 f_sd = map->nick2sd(nick);


 do { for ((i) = (0); (i) < (40); ++(i)) if (sd->status.friends[i].char_id == 0) break; } while(
# 13899 "../../../server-code/src/map/clif.c" 3 4
0
# 13899 "../../../server-code/src/map/clif.c"
);

 if( i == 40 ) {
  clif->friendslist_reqack(sd, f_sd, 2);
  return;
 }


 if (f_sd == 
# 13907 "../../../server-code/src/map/clif.c" 3 4
            ((void *)0)
# 13907 "../../../server-code/src/map/clif.c"
                ) {
  clif->message(fd, atcommand->msgfd((fd),(3)));
  return;
 }

 if( sd->bl.id == f_sd->bl.id ) {
  return;
 }


 if(f_sd->state.noask) {
  clif->noask_sub(sd, f_sd, 5);
  return;
 }


 for (i = 0; i < 40 && sd->status.friends[i].char_id != 0; i++) {
  if (sd->status.friends[i].char_id == f_sd->status.char_id) {
   clif->message(fd, atcommand->msgfd((fd),(871)));
   return;
  }
 }

 f_sd->friend_req = sd->status.char_id;
 sd->friend_req = f_sd->status.char_id;

 clif->friendlist_req(f_sd, sd->status.account_id, sd->status.char_id, sd->status.name);
}

void clif_parse_FriendsListReply(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));






void clif_parse_FriendsListReply(int fd, struct map_session_data *sd)
{
 struct map_session_data *f_sd;
 int account_id;
 char reply;

 account_id = RFIFOL(fd,2);




 reply = RFIFOL(fd,10);


 if( sd->bl.id == account_id ) {
  return;
 }

 f_sd = map->id2sd(account_id);
 if (f_sd == 
# 13962 "../../../server-code/src/map/clif.c" 3 4
            ((void *)0)
# 13962 "../../../server-code/src/map/clif.c"
                )
  return;

 if (reply == 0 || !( sd->friend_req == f_sd->status.char_id && f_sd->friend_req == sd->status.char_id ) )
  clif->friendslist_reqack(f_sd, sd, 1);
 else {
  int i;

  for (i = 0; i < 40; i++)
   if (f_sd->status.friends[i].char_id == 0)
    break;
  if (i == 40) {
   clif->friendslist_reqack(f_sd, sd, 2);
   return;
  }

  f_sd->status.friends[i].account_id = sd->status.account_id;
  f_sd->status.friends[i].char_id = sd->status.char_id;
  memcpy(f_sd->status.friends[i].name, sd->status.name, (23 + 1));
  clif->friendslist_reqack(f_sd, sd, 0);

  if (battle_config.friend_auto_add) {

   for (i = 0; i < 40; i++) {
    if (sd->status.friends[i].char_id == f_sd->status.char_id)
     return;
    if (sd->status.friends[i].char_id == 0)
     break;
   }
   if (i == 40) {
    clif->friendslist_reqack(sd, f_sd, 2);
    return;
   }

   sd->status.friends[i].account_id = f_sd->status.account_id;
   sd->status.friends[i].char_id = f_sd->status.char_id;
   memcpy(sd->status.friends[i].name, f_sd->status.name, (23 + 1));
   clif->friendslist_reqack(sd, f_sd, 0);
  }
 }
}

void clif_parse_FriendsListRemove(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_FriendsListRemove(int fd, struct map_session_data *sd)
{
 struct map_session_data *f_sd = 
# 14009 "../../../server-code/src/map/clif.c" 3 4
                                ((void *)0)
# 14009 "../../../server-code/src/map/clif.c"
                                    ;
 int account_id, char_id;
 int i, j;

 account_id = RFIFOL(fd,2);
 char_id = RFIFOL(fd,6);


 for (i = 0; i < 40 &&
  (sd->status.friends[i].char_id != char_id || sd->status.friends[i].account_id != account_id); i++);

 if (i == 40) {
  clif->message(fd, atcommand->msgfd((fd),(872)));
  return;
 }


 if( (f_sd = map->id2sd(account_id)) && f_sd->status.char_id == char_id) {
  for (i = 0; i < 40 &&
   (f_sd->status.friends[i].char_id != sd->status.char_id || f_sd->status.friends[i].account_id != sd->status.account_id); i++);

  if (i != 40) {

   for(j = i + 1; j < 40; j++)
    memcpy(&f_sd->status.friends[j-1], &f_sd->status.friends[j], sizeof(f_sd->status.friends[0]));

   memset(&f_sd->status.friends[40 -1], 0, sizeof(f_sd->status.friends[40 -1]));

   WFIFOHEAD(f_sd->fd,packet_db[0x20a].len);
   WFIFOW(f_sd->fd,0) = 0x20a;
   WFIFOL(f_sd->fd,2) = sd->status.account_id;
   WFIFOL(f_sd->fd,6) = sd->status.char_id;
   WFIFOSET(f_sd->fd, packet_db[0x20a].len);
  }

 } else {
  if(!chrif->removefriend(char_id,sd->status.char_id)) {
   clif->message(fd, atcommand->msgfd((fd),(873)));
   return;
  }
 }


 for (i = 0; i < 40 &&
  (sd->status.friends[i].char_id != char_id || sd->status.friends[i].account_id != account_id); i++);

 for(j = i + 1; j < 40; j++)
  memcpy(&sd->status.friends[j-1], &sd->status.friends[j], sizeof(sd->status.friends[0]));

 memset(&sd->status.friends[40 -1], 0, sizeof(sd->status.friends[40 -1]));
 clif->message(fd, atcommand->msgfd((fd),(874)));

 WFIFOHEAD(fd,packet_db[0x20a].len);
 WFIFOW(fd,0) = 0x20a;
 WFIFOL(fd,2) = account_id;
 WFIFOL(fd,6) = char_id;
 WFIFOSET(fd, packet_db[0x20a].len);
}



void clif_PVPInfo(struct map_session_data* sd) {
 int fd;

 do { if (((void)(sd), 
# 14073 "../../../server-code/src/map/clif.c" 3 4
0
# 14073 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x210].len);
 WFIFOW(fd,0) = 0x210;
 WFIFOL(fd,2) = sd->status.char_id;
 WFIFOL(fd,6) = sd->status.account_id;
 WFIFOL(fd,10) = sd->pvp_won;
 WFIFOL(fd,14) = sd->pvp_lost;
 WFIFOL(fd,18) = sd->pvp_point;
 WFIFOSET(fd, packet_db[0x210].len);
}

void clif_parse_PVPInfo(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_PVPInfo(int fd,struct map_session_data *sd)
{

 clif->PVPInfo(sd);
}




void clif_ranklist_sub(unsigned char *buf, enum fame_list_type type) {
 const char* name;
 struct fame_list* list;
 int i;

 do { if (((void)(buf), 
# 14102 "../../../server-code/src/map/clif.c" 3 4
0
# 14102 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 switch( type ) {
  case RANKTYPE_BLACKSMITH: list = pc->smith_fame_list; break;
  case RANKTYPE_ALCHEMIST: list = pc->chemist_fame_list; break;
  case RANKTYPE_TAEKWON: list = pc->taekwon_fame_list; break;
  default: return;
 }


 for( i = 0; i < 10 && i < 10; i++ ) {
  if( list[i].id > 0 ) {
   if( strcmp(list[i].name, "-") == 0 && (name = map->charid2nick(list[i].id)) != 
# 14113 "../../../server-code/src/map/clif.c" 3 4
                                                                                 ((void *)0) 
# 14113 "../../../server-code/src/map/clif.c"
                                                                                      ) {
    strncpy(WBUFP(buf, 24 * i), name, (23 + 1));
   } else {
    strncpy(WBUFP(buf, 24 * i), list[i].name, (23 + 1));
   }
  } else {
   strncpy(WBUFP(buf, 24 * i), "None", 5);
  }
  WBUFL(buf, 24 * 10 + i * 4) = list[i].fame;
 }
 for( ;i < 10; i++ ) {
  strncpy(WBUFP(buf, 24 * i), "Unavailable", 12);
  WBUFL(buf, 24 * 10 + i * 4) = 0;
 }
}


void clif_ranklist(struct map_session_data *sd, enum fame_list_type type) {
 int fd;
 int mypoint = 0;
 int upperMask;

 do { if (((void)(sd), 
# 14135 "../../../server-code/src/map/clif.c" 3 4
0
# 14135 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 upperMask = sd->class_&0x0fff;
 WFIFOHEAD(fd, 288);
 WFIFOW(fd,0) = 0x97d;
 WFIFOW(fd,2) = type;
 clif_ranklist_sub(WFIFOP(fd,4), type);

 if( (upperMask == MAPID_BLACKSMITH && type == RANKTYPE_BLACKSMITH)
  || (upperMask == MAPID_ALCHEMIST && type == RANKTYPE_ALCHEMIST)
  || (upperMask == MAPID_TAEKWON && type == RANKTYPE_TAEKWON)
 ) {
  mypoint = sd->status.fame;
 } else {
  mypoint = 0;
 }

 WFIFOL(fd, 284) = mypoint;
 WFIFOSET(fd, 288);
}

void clif_parse_ranklist(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));



void clif_parse_ranklist(int fd, struct map_session_data *sd) {
 int16 type = RFIFOW(fd, 2);

 switch( type ) {
  case RANKTYPE_BLACKSMITH:
  case RANKTYPE_ALCHEMIST:
  case RANKTYPE_TAEKWON:
   clif->ranklist(sd, type);
   break;
 }
}


void clif_update_rankingpoint(struct map_session_data *sd, enum fame_list_type type, int points) {
# 14182 "../../../server-code/src/map/clif.c"
 int fd;

 do { if (((void)(sd), 
# 14184 "../../../server-code/src/map/clif.c" 3 4
0
# 14184 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd, 12);
 WFIFOW(fd,0) = 0x97e;
 WFIFOW(fd,2) = type;
 WFIFOL(fd, 4) = points;
 WFIFOL(fd, 8) = sd->status.fame;
 WFIFOSET(fd, 12);

}



void clif_blacksmith(struct map_session_data* sd) {
 int fd;

 do { if (((void)(sd), 
# 14200 "../../../server-code/src/map/clif.c" 3 4
0
# 14200 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x219].len);
 WFIFOW(fd,0) = 0x219;
 clif_ranklist_sub(WFIFOP(fd, 2), RANKTYPE_BLACKSMITH);
 WFIFOSET(fd, packet_db[0x219].len);
}

void clif_parse_Blacksmith(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_Blacksmith(int fd,struct map_session_data *sd) {
 clif->blacksmith(sd);
}



void clif_fame_blacksmith(struct map_session_data *sd, int points) {
 int fd;

 do { if (((void)(sd), 
# 14220 "../../../server-code/src/map/clif.c" 3 4
0
# 14220 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x21b].len);
 WFIFOW(fd,0) = 0x21b;
 WFIFOL(fd,2) = points;
 WFIFOL(fd,6) = sd->status.fame;
 WFIFOSET(fd, packet_db[0x21b].len);
}



void clif_alchemist(struct map_session_data* sd) {
 int fd;

 do { if (((void)(sd), 
# 14234 "../../../server-code/src/map/clif.c" 3 4
0
# 14234 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x21a].len);
 WFIFOW(fd,0) = 0x21a;
 clif_ranklist_sub(WFIFOP(fd,2), RANKTYPE_ALCHEMIST);
 WFIFOSET(fd, packet_db[0x21a].len);
}

void clif_parse_Alchemist(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_Alchemist(int fd,struct map_session_data *sd) {
 clif->alchemist(sd);
}



void clif_fame_alchemist(struct map_session_data *sd, int points) {
 int fd;

 do { if (((void)(sd), 
# 14254 "../../../server-code/src/map/clif.c" 3 4
0
# 14254 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x21c].len);
 WFIFOW(fd,0) = 0x21c;
 WFIFOL(fd,2) = points;
 WFIFOL(fd,6) = sd->status.fame;
 WFIFOSET(fd, packet_db[0x21c].len);
}



void clif_taekwon(struct map_session_data* sd) {
 int fd;

 do { if (((void)(sd), 
# 14268 "../../../server-code/src/map/clif.c" 3 4
0
# 14268 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x226].len);
 WFIFOW(fd,0) = 0x226;
 clif_ranklist_sub(WFIFOP(fd,2), RANKTYPE_TAEKWON);
 WFIFOSET(fd, packet_db[0x226].len);
}

void clif_parse_Taekwon(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_Taekwon(int fd,struct map_session_data *sd) {
 clif->taekwon(sd);
}



void clif_fame_taekwon(struct map_session_data *sd, int points) {
 int fd;

 do { if (((void)(sd), 
# 14288 "../../../server-code/src/map/clif.c" 3 4
0
# 14288 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x224].len);
 WFIFOW(fd,0) = 0x224;
 WFIFOL(fd,2) = points;
 WFIFOL(fd,6) = sd->status.fame;
 WFIFOSET(fd, packet_db[0x224].len);
}



void clif_ranking_pk(struct map_session_data* sd) {
 int i, fd;

 do { if (((void)(sd), 
# 14302 "../../../server-code/src/map/clif.c" 3 4
0
# 14302 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x238].len);
 WFIFOW(fd,0) = 0x238;
 for (i = 0; i < 10;i ++) {
  strncpy(WFIFOP(fd, i * 24 + 2), "Unknown", (23 + 1));
  WFIFOL(fd,i*4+242) = 0;
 }
 WFIFOSET(fd, packet_db[0x238].len);
}

void clif_parse_RankingPk(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_RankingPk(int fd,struct map_session_data *sd) {
 clif->ranking_pk(sd);
}

void clif_parse_FeelSaveOk(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));






void clif_parse_FeelSaveOk(int fd,struct map_session_data *sd)
{
 int i;
 if (sd->menuskill_id != SG_FEEL)
  return;
 i = sd->menuskill_val-1;
 if (i<0 || i >= 3) return;

 sd->feel_map[i].index = (map->list[(sd->bl.m)].index);
 sd->feel_map[i].m = sd->bl.m;
 (pc->setregistry((sd),(script->add_str(pc->sg_info[i].feel_var)),(sd->feel_map[i].index)));





 clif->feel_info(sd, i, 0);
 ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
}







void clif_feel_req(int fd, struct map_session_data *sd, uint16 skill_lv)
{
 do { if (((void)(sd), 
# 14355 "../../../server-code/src/map/clif.c" 3 4
0
# 14355 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 WFIFOHEAD(fd,packet_db[0x253].len);
 WFIFOW(fd,0)=0x253;
 WFIFOB(fd,2)=TOB(skill_lv-1);
 WFIFOSET(fd, packet_db[0x253].len);
 sd->menuskill_id = SG_FEEL;
 sd->menuskill_val = skill_lv;
}

void clif_parse_ChangeHomunculusName(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_ChangeHomunculusName(int fd, struct map_session_data *sd)
{
 homun->change_name(sd, RFIFOP(fd,2));
}

void clif_parse_HomMoveToMaster(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_HomMoveToMaster(int fd, struct map_session_data *sd)
{
 int id = RFIFOL(fd,2);
 struct block_list *bl = 
# 14378 "../../../server-code/src/map/clif.c" 3 4
                        ((void *)0)
# 14378 "../../../server-code/src/map/clif.c"
                            ;
 struct unit_data *ud = 
# 14379 "../../../server-code/src/map/clif.c" 3 4
                       ((void *)0)
# 14379 "../../../server-code/src/map/clif.c"
                           ;

 if (sd->md && sd->md->bl.id == id)
  bl = &sd->md->bl;
 else if (((sd->hd) && (sd->hd)->homunculus.vaporize == HOM_ST_ACTIVE && (sd->hd)->battle_status.hp > 0) && sd->hd->bl.id == id)
  bl = &sd->hd->bl;
 else
  return;

 unit->calc_pos(bl, sd->bl.x, sd->bl.y, sd->ud.dir);
 ud = unit->bl2ud(bl);
 unit->walktoxy(bl, ud->to_x, ud->to_y, 4);
}

void clif_parse_HomMoveTo(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_HomMoveTo(int fd, struct map_session_data *sd)
{
 int id = RFIFOL(fd,2);
 struct block_list *bl = 
# 14399 "../../../server-code/src/map/clif.c" 3 4
                        ((void *)0)
# 14399 "../../../server-code/src/map/clif.c"
                            ;
 short x, y;

 RFIFOPOS(fd, packet_db[RFIFOW(fd,0)].pos[1], &x, &y, 
# 14402 "../../../server-code/src/map/clif.c" 3 4
                                                     ((void *)0)
# 14402 "../../../server-code/src/map/clif.c"
                                                         );

 if( sd->md && sd->md->bl.id == id )
  bl = &sd->md->bl;
 else if( ((sd->hd) && (sd->hd)->homunculus.vaporize == HOM_ST_ACTIVE && (sd->hd)->battle_status.hp > 0) && sd->hd->bl.id == id )
  bl = &sd->hd->bl;
 else
  return;

 unit->walktoxy(bl, x, y, 4);
}

void clif_parse_HomAttack(int fd,struct map_session_data *sd) __attribute__((nonnull (2)));




void clif_parse_HomAttack(int fd,struct map_session_data *sd)
{
 struct block_list *bl = 
# 14421 "../../../server-code/src/map/clif.c" 3 4
                        ((void *)0)
# 14421 "../../../server-code/src/map/clif.c"
                            ;
 int id = RFIFOL(fd,2),
  target_id = RFIFOL(fd,6),
  action_type = RFIFOB(fd,10);

 if( ((sd->hd) && (sd->hd)->homunculus.vaporize == HOM_ST_ACTIVE && (sd->hd)->battle_status.hp > 0) && sd->hd->bl.id == id )
  bl = &sd->hd->bl;
 else if( sd->md && sd->md->bl.id == id )
  bl = &sd->md->bl;
 else return;

 unit->stop_attack(bl);
 unit->attack(bl, target_id, action_type != 0);
}

void clif_parse_HomMenu(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));
# 14445 "../../../server-code/src/map/clif.c"
void clif_parse_HomMenu(int fd, struct map_session_data *sd) {
 int cmd;

 cmd = RFIFOW(fd,0);

 if(!((sd->hd) && (sd->hd)->homunculus.vaporize == HOM_ST_ACTIVE && (sd->hd)->battle_status.hp > 0))
  return;

 homun->menu(sd,RFIFOB(fd,packet_db[cmd].pos[1]));
}

void clif_parse_AutoRevive(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_AutoRevive(int fd, struct map_session_data *sd) {
 int item_position = pc->search_inventory(sd, ITEMID_TOKEN_OF_SIEGFRIED);
 int hpsp = 100;

 if (item_position == (-1)) {
  if (sd->sc.data[SC_LIGHT_OF_REGENE])
   hpsp = 20 * sd->sc.data[SC_LIGHT_OF_REGENE]->val1;
  else
   return;
 }

 if (sd->sc.data[SC_HELLPOWER])
  return;

 if (!status->revive(&sd->bl, hpsp, hpsp))
  return;

 if (item_position == (-1))
  (status->change_end_((&sd->bl),(SC_LIGHT_OF_REGENE),((-1)),"../../../server-code/src/map/clif.c",14477));
 else
  pc->delitem(sd, item_position, 1, 0, DELITEM_SKILLUSE, LOG_TYPE_CONSUME);

 clif->skill_nodamage(&sd->bl,&sd->bl,ALL_RESURRECTION,4,1);
}
# 14491 "../../../server-code/src/map/clif.c"
void clif_check(int fd, struct map_session_data* pl_sd) {
 do { if (((void)(pl_sd), 
# 14492 "../../../server-code/src/map/clif.c" 3 4
0
# 14492 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 WFIFOHEAD(fd,packet_db[0x214].len);
 WFIFOW(fd,0) = 0x214;
 WFIFOB(fd, 2) = (((pl_sd->status.str) < (((uint8) 0xFF))) ? (pl_sd->status.str) : (((uint8) 0xFF)));
 WFIFOB(fd, 3) = pc->need_status_point(pl_sd, SP_STR, 1);
 WFIFOB(fd, 4) = (((pl_sd->status.agi) < (((uint8) 0xFF))) ? (pl_sd->status.agi) : (((uint8) 0xFF)));
 WFIFOB(fd, 5) = pc->need_status_point(pl_sd, SP_AGI, 1);
 WFIFOB(fd, 6) = (((pl_sd->status.vit) < (((uint8) 0xFF))) ? (pl_sd->status.vit) : (((uint8) 0xFF)));
 WFIFOB(fd, 7) = pc->need_status_point(pl_sd, SP_VIT, 1);
 WFIFOB(fd, 8) = (((pl_sd->status.int_) < (((uint8) 0xFF))) ? (pl_sd->status.int_) : (((uint8) 0xFF)));
 WFIFOB(fd, 9) = pc->need_status_point(pl_sd, SP_INT, 1);
 WFIFOB(fd,10) = (((pl_sd->status.dex) < (((uint8) 0xFF))) ? (pl_sd->status.dex) : (((uint8) 0xFF)));
 WFIFOB(fd,11) = pc->need_status_point(pl_sd, SP_DEX, 1);
 WFIFOB(fd,12) = (((pl_sd->status.luk) < (((uint8) 0xFF))) ? (pl_sd->status.luk) : (((uint8) 0xFF)));
 WFIFOB(fd,13) = pc->need_status_point(pl_sd, SP_LUK, 1);
 WFIFOW(fd,14) = pl_sd->battle_status.batk+pl_sd->battle_status.rhw.atk+pl_sd->battle_status.lhw.atk;
 WFIFOW(fd,16) = pl_sd->battle_status.rhw.atk2+pl_sd->battle_status.lhw.atk2;
 WFIFOW(fd,18) = pl_sd->battle_status.matk_max;
 WFIFOW(fd,20) = pl_sd->battle_status.matk_min;
 WFIFOW(fd,22) = pl_sd->battle_status.def;
 WFIFOW(fd,24) = pl_sd->battle_status.def2;
 WFIFOW(fd,26) = pl_sd->battle_status.mdef;
 WFIFOW(fd,28) = pl_sd->battle_status.mdef2;
 WFIFOW(fd,30) = pl_sd->battle_status.hit;
 WFIFOW(fd,32) = pl_sd->battle_status.flee;
 WFIFOW(fd,34) = pl_sd->battle_status.flee2/10;
 WFIFOW(fd,36) = pl_sd->battle_status.cri/10;
 WFIFOW(fd,38) = (2000-pl_sd->battle_status.amotion)/10;
 WFIFOW(fd,40) = 0;
 WFIFOSET(fd,packet_db[0x214].len);
}

void clif_parse_Check(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));



void clif_parse_Check(int fd, struct map_session_data *sd)
{
 char charname[(23 + 1)];
 struct map_session_data* pl_sd;

 if(!( ((sd)->extra_temp_permissions&(PC_PERM_USE_CHECK)) != 0 || ((sd)->group->e_permissions&(PC_PERM_USE_CHECK)) != 0 ))
  return;

 (strlib->safestrncpy_((charname),(RFIFOP(fd,packet_db[RFIFOW(fd,0)].pos[0])),(sizeof(charname))));

 if( ( pl_sd = map->nick2sd(charname) ) == 
# 14538 "../../../server-code/src/map/clif.c" 3 4
                                          ((void *)0) 
# 14538 "../../../server-code/src/map/clif.c"
                                               || ( (sd)->group->level ) < ( (pl_sd)->group->level ) ) {
  return;
 }

 clif->check(fd, pl_sd);
}
# 14554 "../../../server-code/src/map/clif.c"
void clif_Mail_setattachment(int fd, int index, uint8 flag)
{
 WFIFOHEAD(fd,packet_db[0x255].len);
 WFIFOW(fd,0) = 0x255;
 WFIFOW(fd,2) = index;
 WFIFOB(fd,4) = flag;
 WFIFOSET(fd,packet_db[0x255].len);
}







void clif_Mail_getattachment(int fd, uint8 flag)
{
 WFIFOHEAD(fd,packet_db[0x245].len);
 WFIFOW(fd,0) = 0x245;
 WFIFOB(fd,2) = flag;
 WFIFOSET(fd,packet_db[0x245].len);
}






void clif_Mail_send(int fd, 
# 14582 "../../../server-code/src/map/clif.c" 3 4
                           _Bool 
# 14582 "../../../server-code/src/map/clif.c"
                                fail)
{
 WFIFOHEAD(fd,packet_db[0x249].len);
 WFIFOW(fd,0) = 0x249;
 WFIFOB(fd,2) = fail;
 WFIFOSET(fd,packet_db[0x249].len);
}






void clif_Mail_delete(int fd, int mail_id, short fail)
{
 WFIFOHEAD(fd, packet_db[0x257].len);
 WFIFOW(fd,0) = 0x257;
 WFIFOL(fd,2) = mail_id;
 WFIFOW(fd,6) = fail;
 WFIFOSET(fd, packet_db[0x257].len);
}






void clif_Mail_return(int fd, int mail_id, short fail)
{
 WFIFOHEAD(fd,packet_db[0x274].len);
 WFIFOW(fd,0) = 0x274;
 WFIFOL(fd,2) = mail_id;
 WFIFOW(fd,6) = fail;
 WFIFOSET(fd,packet_db[0x274].len);
}



void clif_Mail_new(int fd, int mail_id, const char *sender, const char *title)
{
 do { if (((void)(sender), 
# 14622 "../../../server-code/src/map/clif.c" 3 4
0
# 14622 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(title), 
# 14623 "../../../server-code/src/map/clif.c" 3 4
0
# 14623 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 WFIFOHEAD(fd,packet_db[0x24a].len);
 WFIFOW(fd,0) = 0x24a;
 WFIFOL(fd,2) = mail_id;
 (strlib->safestrncpy_((WFIFOP(fd,6)),(title),(40)));
 (strlib->safestrncpy_((WFIFOP(fd,46)),(sender),((23 + 1))));
 WFIFOSET(fd,packet_db[0x24a].len);
}






void clif_Mail_window(int fd, int flag)
{
 WFIFOHEAD(fd,packet_db[0x260].len);
 WFIFOW(fd,0) = 0x260;
 WFIFOL(fd,2) = flag;
 WFIFOSET(fd,packet_db[0x260].len);
}






void clif_Mail_refreshinbox(struct map_session_data *sd)
{
 int fd = sd->fd;
 struct mail_data *md;
 struct mail_message *msg;
 int len, i, j;

 do { if (((void)(sd), 
# 14657 "../../../server-code/src/map/clif.c" 3 4
0
# 14657 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 md = &sd->mail.inbox;
 len = 8 + (73 * md->amount);

 WFIFOHEAD(fd,len);
 WFIFOW(fd,0) = 0x240;
 WFIFOW(fd,2) = len;
 WFIFOL(fd,4) = md->amount;
 for( i = j = 0; i < 30 && j < md->amount; i++ )
 {
  msg = &md->msg[i];
  if (msg->id < 1)
   continue;

  WFIFOL(fd,8+73*j) = msg->id;
  memcpy(WFIFOP(fd,12+73*j), msg->title, 40);
  WFIFOB(fd,52+73*j) = (msg->status != MAIL_UNREAD);
  memcpy(WFIFOP(fd,53+73*j), msg->send_name, (23 + 1));
  WFIFOL(fd,77+73*j) = (uint32)msg->timestamp;
  j++;
 }
 WFIFOSET(fd,len);

 if( md->full ) {
  char output[100];
  sprintf(output, "Inbox is full (Max %d). Delete some mails.", 30);
  clif->disp_message( &(sd)->bl, (output), (strlen(output)), SELF );
 }
}

void clif_parse_Mail_refreshinbox(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_Mail_refreshinbox(int fd, struct map_session_data *sd)
{
 struct mail_data* md = &sd->mail.inbox;

 if( md->amount < 30 && (md->full || sd->mail.changed) )
  intif->Mail_requestinbox(sd->status.char_id, 1);
 else
  clif->mail_refreshinbox(sd);

 mail->removeitem(sd, 0);
 mail->removezeny(sd, 0);
}





void clif_Mail_read(struct map_session_data *sd, int mail_id)
{
 int i, fd = sd->fd;

 do { if (((void)(sd), 
# 14711 "../../../server-code/src/map/clif.c" 3 4
0
# 14711 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { for ((i) = (0); (i) < (30); ++(i)) if (sd->mail.inbox.msg[i].id == mail_id) break; } while(
# 14712 "../../../server-code/src/map/clif.c" 3 4
0
# 14712 "../../../server-code/src/map/clif.c"
);
 if( i == 30 ) {
  clif->mail_return(sd->fd, mail_id, 1);
  (showmsg->showWarning(("clif_parse_Mail_read: char '%s' trying to read a message not the inbox.\n"), sd->status.name));
  return;
 } else {
  struct mail_message *msg = &sd->mail.inbox.msg[i];
  struct item *item = &msg->item;
  struct item_data *data;
  size_t msg_len = strlen(msg->body), len;

  if( msg_len == 0 ) {
   strcpy(msg->body, "(no message)");
   msg_len = strlen(msg->body);
  }

  len = 101 + msg_len;

  WFIFOHEAD(fd,len);
  WFIFOW(fd,0) = 0x242;
  WFIFOW(fd,2) = len;
  WFIFOL(fd,4) = msg->id;
  (strlib->safestrncpy_((WFIFOP(fd,8)),(msg->title),(40 + 1)));
  (strlib->safestrncpy_((WFIFOP(fd,48)),(msg->send_name),((23 + 1) + 1)));
  WFIFOL(fd,72) = 0;
  WFIFOL(fd,76) = msg->zeny;

  if( item->nameid && (data = itemdb->exists(item->nameid)) != 
# 14739 "../../../server-code/src/map/clif.c" 3 4
                                                              ((void *)0) 
# 14739 "../../../server-code/src/map/clif.c"
                                                                   ) {
   WFIFOL(fd,80) = item->amount;
   WFIFOW(fd,84) = (data->view_id)?data->view_id:item->nameid;
   WFIFOW(fd,86) = data->type;
   WFIFOB(fd,88) = item->identify;
   WFIFOB(fd,89) = item->attribute;
   WFIFOB(fd,90) = item->refine;
   WFIFOW(fd,91) = item->card[0];
   WFIFOW(fd,93) = item->card[1];
   WFIFOW(fd,95) = item->card[2];
   WFIFOW(fd,97) = item->card[3];
  } else
   memset(WFIFOP(fd,80), 0x00, 19);

  WFIFOB(fd,99) = (unsigned char)msg_len;
  (strlib->safestrncpy_((WFIFOP(fd,100)),(msg->body),(msg_len + 1)));
  WFIFOSET(fd,len);

  if (msg->status == MAIL_UNREAD) {
   msg->status = MAIL_READ;
   intif->Mail_read(mail_id);
   clif->pMail_refreshinbox(fd, sd);
  }
 }
}

void clif_parse_Mail_read(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_Mail_read(int fd, struct map_session_data *sd)
{
 int mail_id = RFIFOL(fd,2);

 if( mail_id <= 0 )
  return;
 if( mail->invalid_operation(sd) )
  return;

 clif->mail_read(sd, RFIFOL(fd,2));
}

void clif_parse_Mail_getattach(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_Mail_getattach(int fd, struct map_session_data *sd)
{
 int mail_id = RFIFOL(fd,2);
 int i;
 
# 14787 "../../../server-code/src/map/clif.c" 3 4
_Bool 
# 14787 "../../../server-code/src/map/clif.c"
     fail = 
# 14787 "../../../server-code/src/map/clif.c" 3 4
            0
# 14787 "../../../server-code/src/map/clif.c"
                 ;

 if( !chrif->isconnected() )
  return;
 if( mail_id <= 0 )
  return;
 if( mail->invalid_operation(sd) )
  return;

 do { for ((i) = (0); (i) < (30); ++(i)) if (sd->mail.inbox.msg[i].id == mail_id) break; } while(
# 14796 "../../../server-code/src/map/clif.c" 3 4
0
# 14796 "../../../server-code/src/map/clif.c"
);
 if( i == 30 )
  return;

 if( sd->mail.inbox.msg[i].zeny < 1 && (sd->mail.inbox.msg[i].item.nameid < 1 || sd->mail.inbox.msg[i].item.amount < 1) )
  return;

 if( sd->mail.inbox.msg[i].zeny + sd->status.zeny > 0x7fffffff ) {
  clif->mail_getattachment(fd, 1);
  return;
 }

 if( sd->mail.inbox.msg[i].item.nameid > 0 ) {
  struct item_data *data;
  unsigned int weight;

  if ((data = itemdb->exists(sd->mail.inbox.msg[i].item.nameid)) == 
# 14812 "../../../server-code/src/map/clif.c" 3 4
                                                                   ((void *)0)
# 14812 "../../../server-code/src/map/clif.c"
                                                                       )
   return;

  if( ( (sd)->weight*10 >= (sd)->max_weight*9 ) ) {
   clif->mail_getattachment(fd, 2);
   return;
  }

  switch( pc->checkadditem(sd, data->nameid, sd->mail.inbox.msg[i].item.amount) ) {
   case ADDITEM_NEW:
    fail = ( pc->inventoryblank(sd) == 0 );
    break;
   case ADDITEM_OVERAMOUNT:
    fail = 
# 14825 "../../../server-code/src/map/clif.c" 3 4
          1
# 14825 "../../../server-code/src/map/clif.c"
              ;
  }

  if( fail ) {
   clif->mail_getattachment(fd, 1);
   return;
  }

  weight = data->weight * sd->mail.inbox.msg[i].item.amount;
  if( sd->weight + weight > sd->max_weight ) {
   clif->mail_getattachment(fd, 2);
   return;
  }
 }

 sd->mail.inbox.msg[i].zeny = 0;
 memset(&sd->mail.inbox.msg[i].item, 0, sizeof(struct item));
 mail->clear(sd);

 clif->mail_read(sd, mail_id);
 intif->Mail_getattach(sd->status.char_id, mail_id);
}

void clif_parse_Mail_delete(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_Mail_delete(int fd, struct map_session_data *sd)
{
 int mail_id = RFIFOL(fd,2);
 int i;

 if( !chrif->isconnected() )
  return;
 if( mail_id <= 0 )
  return;
 if( mail->invalid_operation(sd) )
  return;

 do { for ((i) = (0); (i) < (30); ++(i)) if (sd->mail.inbox.msg[i].id == mail_id) break; } while(
# 14863 "../../../server-code/src/map/clif.c" 3 4
0
# 14863 "../../../server-code/src/map/clif.c"
);
 if (i < 30) {
  struct mail_message *msg = &sd->mail.inbox.msg[i];

  if( (msg->item.nameid > 0 && msg->item.amount > 0) || msg->zeny > 0 ) {
   clif->mail_delete(sd->fd, mail_id, 1);
   return;
  }

  sd->mail.inbox.msg[i].zeny = 0;
  memset(&sd->mail.inbox.msg[i].item, 0, sizeof(struct item));
  mail->clear(sd);
  intif->Mail_delete(sd->status.char_id, mail_id);
 }
}

void clif_parse_Mail_return(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_Mail_return(int fd, struct map_session_data *sd)
{
 int mail_id = RFIFOL(fd,2);
 int i;

 if( mail_id <= 0 )
  return;
 if( mail->invalid_operation(sd) )
  return;

 do { for ((i) = (0); (i) < (30); ++(i)) if (sd->mail.inbox.msg[i].id == mail_id) break; } while(
# 14892 "../../../server-code/src/map/clif.c" 3 4
0
# 14892 "../../../server-code/src/map/clif.c"
);
 if (i < 30 && sd->mail.inbox.msg[i].send_id != 0) {
  sd->mail.inbox.msg[i].zeny = 0;
  memset(&sd->mail.inbox.msg[i].item, 0, sizeof(struct item));
  mail->clear(sd);
  intif->Mail_return(sd->status.char_id, mail_id);
 } else {
  clif->mail_return(sd->fd, mail_id, 1);
 }
}

void clif_parse_Mail_setattach(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_Mail_setattach(int fd, struct map_session_data *sd)
{
 int idx = RFIFOW(fd,2);
 int amount = RFIFOL(fd,4);
 unsigned char flag;

 if( !chrif->isconnected() )
  return;
 if (idx < 0 || amount < 0)
  return;

 flag = mail->setitem(sd, idx, amount);
 clif->mail_setattachment(fd,idx,flag);
}

void clif_parse_Mail_winopen(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));






void clif_parse_Mail_winopen(int fd, struct map_session_data *sd)
{
 int flag = RFIFOW(fd,2);

 if (flag == 0 || flag == 1)
  mail->removeitem(sd, 0);
 if (flag == 0 || flag == 2)
  mail->removezeny(sd, 0);
}

void clif_parse_Mail_send(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_Mail_send(int fd, struct map_session_data *sd)
{
 struct mail_message msg;
 int body_len;

 if( !chrif->isconnected() )
  return;
 if( sd->state.trading )
  return;

 if( RFIFOW(fd,2) < 69 ) {
  (showmsg->showWarning(("Invalid Msg Len from account %d.\n"), sd->status.account_id));
  return;
 }

 if( ((sd->cansendmail_tick)-(timer->gettick())) > 0 ) {
  clif->message(sd->fd,atcommand->msgsd((sd),(875)));
  clif->mail_send(fd, 
# 14958 "../../../server-code/src/map/clif.c" 3 4
                     1
# 14958 "../../../server-code/src/map/clif.c"
                         );
  return;
 }

 body_len = RFIFOB(fd,68);

 if (body_len > 200)
  body_len = 200;

 memset(&msg, 0, sizeof(msg));
 if (!mail->setattachment(sd, &msg)) {
  clif->mail_send(sd->fd, 
# 14969 "../../../server-code/src/map/clif.c" 3 4
                         1
# 14969 "../../../server-code/src/map/clif.c"
                             );
  mail->removeitem(sd,0);
  mail->removezeny(sd,0);
  return;
 }

 msg.id = 0;
 msg.send_id = sd->status.char_id;
 msg.dest_id = 0;
 (strlib->safestrncpy_((msg.send_name),(sd->status.name),((23 + 1))));
 (strlib->safestrncpy_((msg.dest_name),(RFIFOP(fd,4)),((23 + 1))));
 (strlib->safestrncpy_((msg.title),(RFIFOP(fd,28)),(40)));

 if (msg.title[0] == '\0') {
  return;
 }

 if (body_len)
  (strlib->safestrncpy_((msg.body),(RFIFOP(fd,69)),(body_len + 1)));
 else
  memset(msg.body, 0x00, 200);

 msg.timestamp = time(
# 14991 "../../../server-code/src/map/clif.c" 3 4
                     ((void *)0)
# 14991 "../../../server-code/src/map/clif.c"
                         );
 if( !intif->Mail_send(sd->status.account_id, &msg) )
  mail->deliveryfail(sd, &msg);

 sd->cansendmail_tick = timer->gettick() + 1000;
}
# 15007 "../../../server-code/src/map/clif.c"
void clif_Auction_openwindow(struct map_session_data *sd)
{
 int fd;

 do { if (((void)(sd), 
# 15011 "../../../server-code/src/map/clif.c" 3 4
0
# 15011 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 if (sd->state.storage_flag != STORAGE_FLAG_CLOSED || sd->state.vending || sd->state.buyingstore || sd->state.trading)
  return;

 if( !battle_config.feature_auction )
  return;

 WFIFOHEAD(fd,packet_db[0x25f].len);
 WFIFOW(fd,0) = 0x25f;
 WFIFOL(fd,2) = 0;
 WFIFOSET(fd,packet_db[0x25f].len);
}



void clif_Auction_results(struct map_session_data *sd, short count, short pages, const uint8 *buf)
{
 int i, fd, len = sizeof(struct auction_data);
 struct auction_data auction;
 struct item_data *item;

 do { if (((void)(sd), 
# 15033 "../../../server-code/src/map/clif.c" 3 4
0
# 15033 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,12 + (count * 83));
 WFIFOW(fd,0) = 0x252;
 WFIFOW(fd,2) = 12 + (count * 83);
 WFIFOL(fd,4) = pages;
 WFIFOL(fd,8) = count;

 for( i = 0; i < count; i++ ) {
  int k = 12 + (i * 83);
  memcpy(&auction, RBUFP(buf,i * len), len);

  WFIFOL(fd,k) = auction.auction_id;
  (strlib->safestrncpy_((WFIFOP(fd,4+k)),(auction.seller_name),((23 + 1))));

  if( (item = itemdb->exists(auction.item.nameid)) != 
# 15048 "../../../server-code/src/map/clif.c" 3 4
                                                     ((void *)0) 
# 15048 "../../../server-code/src/map/clif.c"
                                                          && item->view_id > 0 )
   WFIFOW(fd,28+k) = item->view_id;
  else
   WFIFOW(fd,28+k) = auction.item.nameid;

  WFIFOL(fd,30+k) = auction.type;
  WFIFOW(fd,34+k) = auction.item.amount;
  WFIFOB(fd,36+k) = auction.item.identify;
  WFIFOB(fd,37+k) = auction.item.attribute;
  WFIFOB(fd,38+k) = auction.item.refine;
  WFIFOW(fd,39+k) = auction.item.card[0];
  WFIFOW(fd,41+k) = auction.item.card[1];
  WFIFOW(fd,43+k) = auction.item.card[2];
  WFIFOW(fd,45+k) = auction.item.card[3];
  WFIFOL(fd,47+k) = auction.price;
  WFIFOL(fd,51+k) = auction.buynow;
  (strlib->safestrncpy_((WFIFOP(fd,55+k)),(auction.buyer_name),((23 + 1))));
  WFIFOL(fd,79+k) = (uint32)auction.timestamp;
 }
 WFIFOSET(fd,WFIFOW(fd,2));
}






void clif_Auction_setitem(int fd, int index, 
# 15075 "../../../server-code/src/map/clif.c" 3 4
                                            _Bool 
# 15075 "../../../server-code/src/map/clif.c"
                                                 fail) {
 WFIFOHEAD(fd,packet_db[0x256].len);
 WFIFOW(fd,0) = 0x256;
 WFIFOW(fd,2) = index;
 WFIFOB(fd,4) = fail;
 WFIFOSET(fd,packet_db[0x256].len);
}

void clif_parse_Auction_cancelreg(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));






void clif_parse_Auction_cancelreg(int fd, struct map_session_data *sd)
{
 if( sd->auction.amount > 0 )
  clif->additem(sd, sd->auction.index, sd->auction.amount, 0);

 sd->auction.amount = 0;
}

void clif_parse_Auction_setitem(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_Auction_setitem(int fd, struct map_session_data *sd)
{
 int idx = RFIFOW(fd,2) - 2;
 int amount = RFIFOL(fd,4);
 struct item_data *item;

 if( !battle_config.feature_auction )
  return;

 if( sd->auction.amount > 0 )
  sd->auction.amount = 0;

 if( idx < 0 || idx >= 100 ) {
  (showmsg->showWarning(("Character %s trying to set invalid item index in auctions.\n"), sd->status.name));
  return;
 }

 if( amount != 1 || amount > sd->status.inventory[idx].amount ) {
  (showmsg->showWarning(("Character %s trying to set invalid amount in auctions.\n"), sd->status.name));
  return;
 }

 if( (item = itemdb->exists(sd->status.inventory[idx].nameid)) != 
# 15123 "../../../server-code/src/map/clif.c" 3 4
                                                                 ((void *)0) 
# 15123 "../../../server-code/src/map/clif.c"
                                                                      && !(item->type == IT_ARMOR || item->type == IT_PETARMOR || item->type == IT_WEAPON || item->type == IT_CARD || item->type == IT_ETC) )
 {
  clif->auction_setitem(sd->fd, idx, 
# 15125 "../../../server-code/src/map/clif.c" 3 4
                                    1
# 15125 "../../../server-code/src/map/clif.c"
                                        );
  return;
 }

 if( !( ( (((sd))->extra_temp_permissions&(PC_PERM_TRADE)) != 0 || (((sd))->group->e_permissions&(PC_PERM_TRADE)) != 0 ) ) || sd->status.inventory[idx].expire_time ||
   !sd->status.inventory[idx].identify ||
    !(itemdb->isrestricted((&sd->status.inventory[idx]), (( (sd)->group->level )), 0, itemdb->canauction_sub)) ||
     (sd->status.inventory[idx].bound && !( ( (((sd))->extra_temp_permissions&(PC_PERM_TRADE_BOUND)) != 0 || (((sd))->group->e_permissions&(PC_PERM_TRADE_BOUND)) != 0 ) )) ) {
  clif->auction_setitem(sd->fd, idx, 
# 15133 "../../../server-code/src/map/clif.c" 3 4
                                    1
# 15133 "../../../server-code/src/map/clif.c"
                                        );
  return;
 }

 sd->auction.index = idx;
 sd->auction.amount = amount;
 clif->auction_setitem(fd, idx + 2, 
# 15139 "../../../server-code/src/map/clif.c" 3 4
                                   0
# 15139 "../../../server-code/src/map/clif.c"
                                        );
}
# 15155 "../../../server-code/src/map/clif.c"
void clif_Auction_message(int fd, unsigned char flag)
{
 WFIFOHEAD(fd,packet_db[0x250].len);
 WFIFOW(fd,0) = 0x250;
 WFIFOB(fd,2) = flag;
 WFIFOSET(fd,packet_db[0x250].len);
}







void clif_Auction_close(int fd, unsigned char flag)
{
 WFIFOHEAD(fd,packet_db[0x25e].len);
 WFIFOW(fd,0) = 0x25d;
 WFIFOW(fd,2) = flag;
 WFIFOSET(fd,packet_db[0x25e].len);
}

void clif_parse_Auction_register(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_Auction_register(int fd, struct map_session_data *sd)
{
 struct auction_data auction;
 struct item_data *item;

 if (!battle_config.feature_auction)
  return;

 do { if (( (sd->auction.index >= 0 && sd->auction.index < 100) ? 
# 15188 "../../../server-code/src/map/clif.c" 3 4
0 
# 15188 "../../../server-code/src/map/clif.c"
: (nullpo->assert_report("../../../server-code/src/map/clif.c", 15188, __func__, "sd->auction.index >= 0 && sd->auction.index < 100", "failed assertion"), 
# 15188 "../../../server-code/src/map/clif.c" 3 4
1
# 15188 "../../../server-code/src/map/clif.c"
) )) return; } while(0);

 memset(&auction, 0, sizeof(auction));
 auction.price = RFIFOL(fd,2);
 auction.buynow = RFIFOL(fd,6);
 auction.hours = RFIFOW(fd,10);


 if (auction.price <= 0 || auction.buynow <= 0) {
  (showmsg->showWarning(("Character %s trying to register auction wit wrong price.\n"), sd->status.name));
  return;
 }

 if( sd->auction.amount < 1 ) {
  (showmsg->showWarning(("Character %s trying to register auction without item.\n"), sd->status.name));
  return;
 }

 if( auction.price >= auction.buynow ) {
  (showmsg->showWarning(("Character %s trying to alter auction prices.\n"), sd->status.name));
  return;
 }

 if( auction.hours < 1 || auction.hours > 48 ) {
  (showmsg->showWarning(("Character %s trying to enter an invalid time for auction.\n"), sd->status.name));
  return;
 }

 if( sd->status.zeny < (auction.hours * battle_config.auction_feeperhour) ) {
  clif_Auction_message(fd, 5);
  return;
 }

 if( auction.buynow > battle_config.auction_maximumprice )
 {
  auction.buynow = battle_config.auction_maximumprice;
  if( auction.price >= auction.buynow )
   auction.price = auction.buynow - 1;
 }

 auction.auction_id = 0;
 auction.seller_id = sd->status.char_id;
 (strlib->safestrncpy_((auction.seller_name),(sd->status.name),(sizeof(auction.seller_name))));
 auction.buyer_id = 0;
 memset(auction.buyer_name, '\0', sizeof(auction.buyer_name));

 if( sd->status.inventory[sd->auction.index].nameid == 0 || sd->status.inventory[sd->auction.index].amount < sd->auction.amount )
 {
  clif->auction_message(fd, 2);
  return;
 }

 if( (item = itemdb->exists(sd->status.inventory[sd->auction.index].nameid)) == 
# 15240 "../../../server-code/src/map/clif.c" 3 4
                                                                               ((void *)0) 
# 15240 "../../../server-code/src/map/clif.c"
                                                                                    )
 {
  clif->auction_message(fd, 2);
  return;
 }


 if( sd->status.inventory[sd->auction.index].bound && !( ( (((sd))->extra_temp_permissions&(PC_PERM_TRADE_BOUND)) != 0 || (((sd))->group->e_permissions&(PC_PERM_TRADE_BOUND)) != 0 ) ) ) {
  clif->message(sd->fd, atcommand->msgsd((sd),(293)));
  clif->auction_message(fd, 2);
  return;
 }

 (strlib->safestrncpy_((auction.item_name),(item->jname),(sizeof(auction.item_name))));
 auction.type = item->type;
 memcpy(&auction.item, &sd->status.inventory[sd->auction.index], sizeof(struct item));
 auction.item.amount = 1;
 auction.timestamp = 0;

 if( !intif->Auction_register(&auction) )
  clif->auction_message(fd, 4);
 else
 {
  int zeny = auction.hours*battle_config.auction_feeperhour;

  pc->delitem(sd, sd->auction.index, sd->auction.amount, 1, DELITEM_SOLD, LOG_TYPE_AUCTION);
  sd->auction.amount = 0;

  pc->payzeny(sd, zeny, LOG_TYPE_AUCTION, 
# 15268 "../../../server-code/src/map/clif.c" 3 4
                                         ((void *)0)
# 15268 "../../../server-code/src/map/clif.c"
                                             );
 }
}

void clif_parse_Auction_cancel(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_Auction_cancel(int fd, struct map_session_data *sd)
{
 unsigned int auction_id = RFIFOL(fd,2);

 intif->Auction_cancel(sd->status.char_id, auction_id);
}

void clif_parse_Auction_close(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_Auction_close(int fd, struct map_session_data *sd)
{
 unsigned int auction_id = RFIFOL(fd,2);

 intif->Auction_close(sd->status.char_id, auction_id);
}

void clif_parse_Auction_bid(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_Auction_bid(int fd, struct map_session_data *sd)
{
 unsigned int auction_id = RFIFOL(fd,2);
 int bid = RFIFOL(fd,6);

 if( !( ( (((sd))->extra_temp_permissions&(PC_PERM_TRADE)) != 0 || (((sd))->group->e_permissions&(PC_PERM_TRADE)) != 0 ) ) ) {
  clif->message(sd->fd, atcommand->msgsd((sd),(246)));
  return;
 }

 if( bid <= 0 )
  clif->auction_message(fd, 0);
 else if( bid > sd->status.zeny )
  clif->auction_message(fd, 8);
 else if ( intif->CheckForCharServer() )
  clif->auction_message(fd, 0);
 else {
  pc->payzeny(sd, bid, LOG_TYPE_AUCTION, 
# 15312 "../../../server-code/src/map/clif.c" 3 4
                                        ((void *)0)
# 15312 "../../../server-code/src/map/clif.c"
                                            );
  intif->Auction_bid(sd->status.char_id, sd->status.name, auction_id, bid);
 }
}

void clif_parse_Auction_search(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));
# 15327 "../../../server-code/src/map/clif.c"
void clif_parse_Auction_search(int fd, struct map_session_data* sd)
{
 char search_text[(23 + 1)];
 short type = RFIFOW(fd,2), page = RFIFOW(fd,32);
 int price = RFIFOL(fd,4);

 if( !battle_config.feature_auction )
  return;

 clif->pAuction_cancelreg(fd, sd);

 (strlib->safestrncpy_((search_text),(RFIFOP(fd,8)),(sizeof(search_text))));
 intif->Auction_requestlist(sd->status.char_id, type, price, search_text, page);
}

void clif_parse_Auction_buysell(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));





void clif_parse_Auction_buysell(int fd, struct map_session_data* sd)
{
 short type = RFIFOW(fd,2) + 6;

 if( !battle_config.feature_auction )
  return;

 clif->pAuction_cancelreg(fd, sd);

 intif->Auction_requestlist(sd->status.char_id, type, 0, "", 1);
}







void clif_cashshop_show(struct map_session_data *sd, struct npc_data *nd) {
 struct npc_item_list *shop = 
# 15367 "../../../server-code/src/map/clif.c" 3 4
                             ((void *)0)
# 15367 "../../../server-code/src/map/clif.c"
                                 ;
 unsigned short shop_size = 0;
 int fd,i, c = 0;
 int currency[2] = { 0,0 };



 const int offset = 12;


 do { if (((void)(sd), 
# 15377 "../../../server-code/src/map/clif.c" 3 4
0
# 15377 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(nd), 
# 15378 "../../../server-code/src/map/clif.c" 3 4
0
# 15378 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if( nd->subtype == SCRIPT ) {
  shop = nd->u.scr.shop->item;
  shop_size = nd->u.scr.shop->items;

  npc->trader_count_funds(nd, sd);

  currency[0] = npc->trader_funds[0];
  currency[1] = npc->trader_funds[1];
 } else {
  shop = nd->u.shop.shop_item;
  shop_size = nd->u.shop.count;

  currency[0] = sd->cashPoints;
  currency[1] = sd->kafraPoints;
 }

 fd = sd->fd;
 sd->npc_shopid = nd->bl.id;
 WFIFOHEAD(fd,offset+shop_size*11);
 WFIFOW(fd,0) = 0x287;

 WFIFOL(fd,4) = currency[0];

 WFIFOL(fd,8) = currency[1];


 for( i = 0; i < shop_size; i++ ) {
  if( shop[i].nameid ) {
   struct item_data* id = itemdb->search(shop[i].nameid);
   WFIFOL(fd,offset+0+i*11) = shop[i].value;
   WFIFOL(fd,offset+4+i*11) = shop[i].value;
   WFIFOB(fd,offset+8+i*11) = itemtype(id->type);
   WFIFOW(fd,offset+9+i*11) = ( id->view_id > 0 ) ? id->view_id : id->nameid;
   c++;
  }
 }
 WFIFOW(fd,2) = offset+c*11;
 WFIFOSET(fd,WFIFOW(fd,2));
}





void clif_cashshop_ack(struct map_session_data* sd, int error) {
 struct npc_data *nd;
 int fd;
 int currency[2] = { 0,0 };

 do { if (((void)(sd), 
# 15429 "../../../server-code/src/map/clif.c" 3 4
0
# 15429 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 if( (nd = map->id2nd(sd->npc_shopid)) && nd->subtype == SCRIPT ) {
  npc->trader_count_funds(nd,sd);
  currency[0] = npc->trader_funds[0];
  currency[1] = npc->trader_funds[1];
 } else {
  currency[0] = sd->cashPoints;
  currency[1] = sd->kafraPoints;
 }

 WFIFOHEAD(fd, packet_db[0x289].len);
 WFIFOW(fd,0) = 0x289;
 WFIFOL(fd,2) = currency[0];



 WFIFOL(fd,6) = currency[1];
 WFIFOW(fd,10) = TOW(error);

 WFIFOSET(fd, packet_db[0x289].len);
}

void clif_parse_cashshop_buy(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));




void clif_parse_cashshop_buy(int fd, struct map_session_data *sd)
{
 int fail = 0;

 if( sd->state.trading || !sd->npc_shopid || ( ((sd)->extra_temp_permissions&(PC_PERM_DISABLE_STORE)) != 0 || ((sd)->group->e_permissions&(PC_PERM_DISABLE_STORE)) != 0 ) )
  fail = 1;
 else {







  int len = RFIFOW(fd,2);
  int points = RFIFOL(fd,4);
  int count = RFIFOW(fd,8);
  struct itemlist item_list = { 0 };
  int i;

  if( len < 10 || len != 10 + count * 4) {
   (showmsg->showWarning(("Player %d sent incorrect cash shop buy packet (len %d:%d)!\n"), sd->status.char_id, len, 10 + count * 4));
   return;
  }
  memset(&(item_list), 0, sizeof(item_list));
  do { int _empty_ = ( (item_list)._max_ )-( (item_list)._len_ ); if ((count) > _empty_) { while ((count) > _empty_) _empty_ += (1); do { if ((_empty_+( (item_list)._len_ )) > ( (item_list)._max_ )) { if (( (item_list)._max_ ) == 0) ( (item_list)._data_ ) = (iMalloc->malloc(((_empty_+( (item_list)._len_ ))*sizeof(( ( ( (item_list)._data_ )[0] ) ))),"../../../server-code/src/map/clif.c", 15482, __func__)); else ( (item_list)._data_ ) = (iMalloc->realloc((( (item_list)._data_ )),((_empty_+( (item_list)._len_ ))*sizeof(( ( ( (item_list)._data_ )[0] ) ))),"../../../server-code/src/map/clif.c", 15482, __func__)); memset(( (item_list)._data_ )+( (item_list)._len_ ), 0, (( (item_list)._max_ )-( (item_list)._len_ ))*sizeof(( ( ( (item_list)._data_ )[0] ) ))); ( (item_list)._max_ ) = (_empty_+( (item_list)._len_ )); } else if ((_empty_+( (item_list)._len_ )) == 0 && ( (item_list)._max_ ) > 0) { (iMalloc->free((( (item_list)._data_ )),"../../../server-code/src/map/clif.c", 15482, __func__)); ( (item_list)._data_ ) = 
# 15482 "../../../server-code/src/map/clif.c" 3 4
 ((void *)0)
# 15482 "../../../server-code/src/map/clif.c"
 ; ( (item_list)._max_ ) = 0; ( (item_list)._len_ ) = 0; } else if ((_empty_+( (item_list)._len_ )) < ( (item_list)._max_ )) { ( (item_list)._data_ ) = (iMalloc->realloc((( (item_list)._data_ )),((_empty_+( (item_list)._len_ ))*sizeof(( ( ( (item_list)._data_ )[0] ) ))),"../../../server-code/src/map/clif.c", 15482, __func__)); ( (item_list)._max_ ) = (_empty_+( (item_list)._len_ )); if ((_empty_+( (item_list)._len_ )) - ( (item_list)._len_ ) > 0) ( (item_list)._len_ ) = (_empty_+( (item_list)._len_ )); } } while(
# 15482 "../../../server-code/src/map/clif.c" 3 4
 0
# 15482 "../../../server-code/src/map/clif.c"
 ); } } while(
# 15482 "../../../server-code/src/map/clif.c" 3 4
 0
# 15482 "../../../server-code/src/map/clif.c"
 );
  for (i = 0; i < count; i++) {
   struct itemlist_entry entry = { 0 };

   entry.amount = RFIFOW(fd, 10 + 4 * i);
   entry.id = RFIFOW(fd, 10 + 4 * i + 2);

   do { ( ( (item_list)._data_ )[( (item_list)._len_ )] ) = (entry); ++( (item_list)._len_ ); }while(
# 15489 "../../../server-code/src/map/clif.c" 3 4
  0
# 15489 "../../../server-code/src/map/clif.c"
  );
  }
  fail = npc->cashshop_buylist(sd, points, &item_list);
  do { if (( (item_list)._max_ ) > 0) { (iMalloc->free((( (item_list)._data_ )),"../../../server-code/src/map/clif.c", 15492, __func__)); ( (item_list)._data_ ) = 
# 15492 "../../../server-code/src/map/clif.c" 3 4
 ((void *)0)
# 15492 "../../../server-code/src/map/clif.c"
 ; ( (item_list)._max_ ) = 0; ( (item_list)._len_ ) = 0; } } while(
# 15492 "../../../server-code/src/map/clif.c" 3 4
 0
# 15492 "../../../server-code/src/map/clif.c"
 );

 }

 clif->cashshop_ack(sd,fail);
}
# 15508 "../../../server-code/src/map/clif.c"
void clif_Adopt_reply(struct map_session_data *sd, int type)
{
 int fd;

 do { if (((void)(sd), 
# 15512 "../../../server-code/src/map/clif.c" 3 4
0
# 15512 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,6);
 WFIFOW(fd,0) = 0x216;
 WFIFOL(fd,2) = type;
 WFIFOSET(fd,6);
}



void clif_Adopt_request(struct map_session_data *sd, struct map_session_data *src, int p_id) {
 int fd;

 do { if (((void)(sd), 
# 15525 "../../../server-code/src/map/clif.c" 3 4
0
# 15525 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(src), 
# 15526 "../../../server-code/src/map/clif.c" 3 4
0
# 15526 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,34);
 WFIFOW(fd,0) = 0x1f6;
 WFIFOL(fd,2) = src->status.account_id;
 WFIFOL(fd,6) = p_id;
 memcpy(WFIFOP(fd,10), src->status.name, (23 + 1));
 WFIFOSET(fd,34);
}

void clif_parse_Adopt_request(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_Adopt_request(int fd, struct map_session_data *sd) {
 struct map_session_data *tsd = map->id2sd(RFIFOL(fd,2)), *p_sd = map->charid2sd(sd->status.partner_id);

 if( pc->can_Adopt(sd, p_sd, tsd) ) {
  tsd->adopt_invite = sd->status.account_id;
  clif->adopt_request(tsd, sd, p_sd->status.account_id);
 }
}

void clif_parse_Adopt_reply(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));





void clif_parse_Adopt_reply(int fd, struct map_session_data *sd) {
 int p1_id = RFIFOL(fd,2);
 int p2_id = RFIFOL(fd,6);
 int result = RFIFOL(fd,10);
 struct map_session_data* p1_sd = map->id2sd(p1_id);
 struct map_session_data* p2_sd = map->id2sd(p2_id);

 int pid = sd->adopt_invite;
 sd->adopt_invite = 0;

 if( p1_sd == 
# 15564 "../../../server-code/src/map/clif.c" 3 4
             ((void *)0) 
# 15564 "../../../server-code/src/map/clif.c"
                  || p2_sd == 
# 15564 "../../../server-code/src/map/clif.c" 3 4
                              ((void *)0) 
# 15564 "../../../server-code/src/map/clif.c"
                                   )
  return;

 if( pid != p1_sd->status.account_id )
  return;

 if( result == 0 )
  return;

 pc->adoption(p1_sd, p2_sd, sd);
}
# 15583 "../../../server-code/src/map/clif.c"
void clif_bossmapinfo(int fd, struct mob_data *md, short flag)
{
 WFIFOHEAD(fd,70);
 memset(WFIFOP(fd,0),0,70);
 WFIFOW(fd,0) = 0x293;

 if( md != 
# 15589 "../../../server-code/src/map/clif.c" 3 4
          ((void *)0) 
# 15589 "../../../server-code/src/map/clif.c"
               ) {
  if( md->bl.prev != 
# 15590 "../../../server-code/src/map/clif.c" 3 4
                    ((void *)0) 
# 15590 "../../../server-code/src/map/clif.c"
                         ) {
   if( flag ) {
    WFIFOB(fd,2) = 1;
    WFIFOL(fd,3) = md->bl.x;
    WFIFOL(fd,7) = md->bl.y;
   } else
    WFIFOB(fd,2) = 2;
  } else if (md->spawn_timer != (-1)) {
   const struct TimerData * timer_data = timer->get(md->spawn_timer);
   unsigned int seconds;
   int hours, minutes;

   seconds = (unsigned int)(((timer_data->tick)-(timer->gettick())) / 1000 + 60);
   hours = seconds / (60 * 60);
   seconds = seconds - (60 * 60 * hours);
   minutes = seconds / 60;

   WFIFOB(fd,2) = 3;
   WFIFOW(fd,11) = hours;
   WFIFOW(fd,13) = minutes;
  }
  (strlib->safestrncpy_((WFIFOP(fd,19)),(md->db->jname),((23 + 1))));
 }

 WFIFOSET(fd,70);
}

void clif_parse_ViewPlayerEquip(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_ViewPlayerEquip(int fd, struct map_session_data* sd) {
 int charid = RFIFOL(fd, 2);
 struct map_session_data* tsd = map->id2sd(charid);

 if (!tsd)
  return;

 if( tsd->status.show_equip || ( ((sd)->extra_temp_permissions&(PC_PERM_VIEW_EQUIPMENT)) != 0 || ((sd)->group->e_permissions&(PC_PERM_VIEW_EQUIPMENT)) != 0 ) )
  clif->viewequip_ack(sd, tsd);
 else
  clif->msgtable(sd, MSG_EQUIP_NOT_PUBLIC);
}

void clif_parse_EquipTick(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));







void clif_parse_EquipTick(int fd, struct map_session_data* sd)
{
 
# 15643 "../../../server-code/src/map/clif.c" 3 4
_Bool 
# 15643 "../../../server-code/src/map/clif.c"
     flag = (RFIFOL(fd,6) != 0) ? 
# 15643 "../../../server-code/src/map/clif.c" 3 4
                                  1 
# 15643 "../../../server-code/src/map/clif.c"
                                       : 
# 15643 "../../../server-code/src/map/clif.c" 3 4
                                         0
# 15643 "../../../server-code/src/map/clif.c"
                                              ;
 sd->status.show_equip = flag;
 clif->equiptickack(sd, flag);
}

void clif_parse_PartyTick(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));




void clif_parse_PartyTick(int fd, struct map_session_data* sd)
{
 
# 15655 "../../../server-code/src/map/clif.c" 3 4
_Bool 
# 15655 "../../../server-code/src/map/clif.c"
     flag = RFIFOB(fd,6)?
# 15655 "../../../server-code/src/map/clif.c" 3 4
                         1
# 15655 "../../../server-code/src/map/clif.c"
                             :
# 15655 "../../../server-code/src/map/clif.c" 3 4
                              0
# 15655 "../../../server-code/src/map/clif.c"
                                   ;
 sd->status.allow_party = flag;
 clif->partytickack(sd, flag);
}







void clif_quest_send_list(struct map_session_data *sd)
{
 int i, len, real_len;
 uint8 *buf = 
# 15669 "../../../server-code/src/map/clif.c" 3 4
             ((void *)0)
# 15669 "../../../server-code/src/map/clif.c"
                 ;
 struct packet_quest_list_header *packet = 
# 15670 "../../../server-code/src/map/clif.c" 3 4
                                          ((void *)0)
# 15670 "../../../server-code/src/map/clif.c"
                                              ;
 do { if (((void)(sd), 
# 15671 "../../../server-code/src/map/clif.c" 3 4
0
# 15671 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 len = sizeof(struct packet_quest_list_header)
     + sd->avail_quests * (sizeof(struct packet_quest_list_info)
                          + 3 * sizeof(struct packet_mission_info_sub));
 buf = (iMalloc->malloc((len),"../../../server-code/src/map/clif.c", 15676, __func__));
 packet = WBUFP(buf, 0);
 real_len = sizeof(*packet);

 packet->PacketType = questListType;
 packet->questCount = sd->avail_quests;

 for (i = 0; i < sd->avail_quests; i++) {
  struct packet_quest_list_info *info = (struct packet_quest_list_info *)(buf+real_len);

  struct quest_db *qi = quest->db(sd->quest_log[i].quest_id);
  int j;

  real_len += sizeof(*info);

  info->questID = sd->quest_log[i].quest_id;
  info->active = sd->quest_log[i].state;

  info->quest_svrTime = sd->quest_log[i].time - qi->time;
  info->quest_endTime = sd->quest_log[i].time;
  info->hunting_count = qi->objectives_count;

  for (j = 0; j < qi->objectives_count; j++) {
   struct mob_db *mob_data;
   if (( (j < 3) ? 
# 15700 "../../../server-code/src/map/clif.c" 3 4
  0 
# 15700 "../../../server-code/src/map/clif.c"
  : (nullpo->assert_report("../../../server-code/src/map/clif.c", 15700, __func__, "j < 3", "failed assertion"), 
# 15700 "../../../server-code/src/map/clif.c" 3 4
  1
# 15700 "../../../server-code/src/map/clif.c"
  ) )) break; else (void)0;
   real_len += sizeof(info->objectives[j]);

   mob_data = mob->db(qi->objectives[j].mob);

   info->objectives[j].mob_id = qi->objectives[j].mob;
   info->objectives[j].huntCount = sd->quest_log[i].count[j];
   info->objectives[j].maxCount = qi->objectives[j].count;
   (strlib->safestrncpy_((info->objectives[j].mobName),(mob_data->jname),(sizeof(info->objectives[j].mobName))));
  }

 }
 packet->PacketLength = real_len;
 clif->send(buf, real_len, &sd->bl, SELF);
 (iMalloc->free((buf),"../../../server-code/src/map/clif.c", 15714, __func__));
}



void clif_quest_send_mission(struct map_session_data *sd)
{
 int fd = sd->fd;
 int i, j;
 int len;
 struct mob_db *monster;

 do { if (((void)(sd), 
# 15726 "../../../server-code/src/map/clif.c" 3 4
0
# 15726 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 len = sd->avail_quests*104+8;
 WFIFOHEAD(fd, len);
 WFIFOW(fd,0) = 0x2b2;
 WFIFOW(fd,2) = len;
 WFIFOL(fd, 4) = sd->avail_quests;

 for (i = 0; i < sd->avail_quests; i++) {
  struct quest_db *qi = quest->db(sd->quest_log[i].quest_id);
  WFIFOL(fd, i*104+8) = sd->quest_log[i].quest_id;
  WFIFOL(fd, i*104+12) = sd->quest_log[i].time - qi->time;
  WFIFOL(fd, i*104+16) = sd->quest_log[i].time;
  WFIFOW(fd,i*104+20) = qi->objectives_count;

  for (j = 0 ; j < qi->objectives_count; j++) {
   WFIFOL(fd, i*104+22+j*30) = qi->objectives[j].mob;
   WFIFOW(fd,i*104+26+j*30) = sd->quest_log[i].count[j];
   monster = mob->db(qi->objectives[j].mob);
   memcpy(WFIFOP(fd, i*104+28+j*30), monster->jname, (23 + 1));
  }
 }

 WFIFOSET(fd, len);
}



void clif_quest_add(struct map_session_data *sd, struct quest *qd)
{
 int fd;
 int i;
 struct quest_db *qi;

 do { if (((void)(sd), 
# 15759 "../../../server-code/src/map/clif.c" 3 4
0
# 15759 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(qd), 
# 15760 "../../../server-code/src/map/clif.c" 3 4
0
# 15760 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 qi = quest->db(qd->quest_id);
 WFIFOHEAD(fd, packet_db[0x2b3].len);
 WFIFOW(fd,0) = 0x2b3;
 WFIFOL(fd, 2) = qd->quest_id;
 WFIFOB(fd, 6) = qd->state;
 WFIFOB(fd, 7) = qd->time - qi->time;
 WFIFOL(fd, 11) = qd->time;
 WFIFOW(fd,15) = qi->objectives_count;

 for (i = 0; i < qi->objectives_count; i++) {
  struct mob_db *monster;
  WFIFOL(fd, i*30+17) = qi->objectives[i].mob;
  WFIFOW(fd,i*30+21) = qd->count[i];
  monster = mob->db(qi->objectives[i].mob);
  memcpy(WFIFOP(fd, i*30+23), monster->jname, (23 + 1));
 }

 WFIFOSET(fd, packet_db[0x2b3].len);
}



void clif_quest_delete(struct map_session_data *sd, int quest_id) {
 int fd;

 do { if (((void)(sd), 
# 15787 "../../../server-code/src/map/clif.c" 3 4
0
# 15787 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd, packet_db[0x2b4].len);
 WFIFOW(fd,0) = 0x2b4;
 WFIFOL(fd, 2) = quest_id;
 WFIFOSET(fd, packet_db[0x2b4].len);
}



void clif_quest_update_objective(struct map_session_data *sd, struct quest *qd)
{
 int fd;
 int i;
 struct quest_db *qi;
 int len;

 do { if (((void)(sd), 
# 15804 "../../../server-code/src/map/clif.c" 3 4
0
# 15804 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(qd), 
# 15805 "../../../server-code/src/map/clif.c" 3 4
0
# 15805 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 qi = quest->db(qd->quest_id);
 len = qi->objectives_count * 12 + 6;

 WFIFOHEAD(fd, len);
 WFIFOW(fd,0) = 0x2b5;
 WFIFOW(fd,2) = len;
 WFIFOW(fd,4) = qi->objectives_count;

 for (i = 0; i < qi->objectives_count; i++) {
  WFIFOL(fd, i*12+6) = qd->quest_id;
  WFIFOL(fd, i*12+10) = qi->objectives[i].mob;
  WFIFOW(fd,i*12+14) = qi->objectives[i].count;
  WFIFOW(fd,i*12+16) = qd->count[i];
 }

 WFIFOSET(fd, len);
}

void clif_parse_questStateAck(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));


void clif_parse_questStateAck(int fd, struct map_session_data *sd) {
 quest->update_status(sd, RFIFOL(fd,2), RFIFOB(fd,6)?Q_ACTIVE:Q_INACTIVE);
}



void clif_quest_update_status(struct map_session_data *sd, int quest_id, 
# 15834 "../../../server-code/src/map/clif.c" 3 4
                                                                        _Bool 
# 15834 "../../../server-code/src/map/clif.c"
                                                                             active) {
 int fd;

 do { if (((void)(sd), 
# 15837 "../../../server-code/src/map/clif.c" 3 4
0
# 15837 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd, packet_db[0x2b7].len);
 WFIFOW(fd,0) = 0x2b7;
 WFIFOL(fd, 2) = quest_id;
 WFIFOB(fd, 6) = active;
 WFIFOSET(fd, packet_db[0x2b7].len);
}
# 15857 "../../../server-code/src/map/clif.c"
void clif_quest_show_event(struct map_session_data *sd, struct block_list *bl, short state, short color)
{

 int fd;

 do { if (((void)(sd), 
# 15862 "../../../server-code/src/map/clif.c" 3 4
0
# 15862 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(bl), 
# 15863 "../../../server-code/src/map/clif.c" 3 4
0
# 15863 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd, packet_db[0x446].len);
 WFIFOW(fd,0) = 0x446;
 WFIFOL(fd, 2) = bl->id;
 WFIFOW(fd,6) = bl->x;
 WFIFOW(fd,8) = bl->y;
 WFIFOW(fd,10) = state;
 WFIFOW(fd,12) = color;
 WFIFOSET(fd, packet_db[0x446].len);

}






void clif_mercenary_updatestatus(struct map_session_data *sd, int type) {
 struct mercenary_data *md;
 struct status_data *mstatus;
 int fd;
 if( sd == 
# 15885 "../../../server-code/src/map/clif.c" 3 4
          ((void *)0) 
# 15885 "../../../server-code/src/map/clif.c"
               || (md = sd->md) == 
# 15885 "../../../server-code/src/map/clif.c" 3 4
                                   ((void *)0) 
# 15885 "../../../server-code/src/map/clif.c"
                                        )
  return;

 fd = sd->fd;
 mstatus = &md->battle_status;
 WFIFOHEAD(fd,packet_db[0x2a2].len);
 WFIFOW(fd,0) = 0x2a2;
 WFIFOW(fd,2) = type;
 switch( type ) {
  case SP_ATK1:
  {
   int atk = rnd()%(mstatus->rhw.atk2 - mstatus->rhw.atk + 1) + mstatus->rhw.atk;
   WFIFOL(fd,4) = (((atk) >= (
# 15897 "../../../server-code/src/map/clif.c" 3 4
                 (32767)
# 15897 "../../../server-code/src/map/clif.c"
                 )) ? (
# 15897 "../../../server-code/src/map/clif.c" 3 4
                 (32767)
# 15897 "../../../server-code/src/map/clif.c"
                 ) : ((atk) <= (0)) ? (0) : (atk));
  }
   break;
  case SP_MATK1:
   WFIFOL(fd,4) = (((mstatus->matk_max) >= (
# 15901 "../../../server-code/src/map/clif.c" 3 4
                 (32767)
# 15901 "../../../server-code/src/map/clif.c"
                 )) ? (
# 15901 "../../../server-code/src/map/clif.c" 3 4
                 (32767)
# 15901 "../../../server-code/src/map/clif.c"
                 ) : ((mstatus->matk_max) <= (0)) ? (0) : (mstatus->matk_max));
   break;
  case SP_HIT:
   WFIFOL(fd,4) = mstatus->hit;
   break;
  case SP_CRITICAL:
   WFIFOL(fd,4) = mstatus->cri/10;
   break;
  case SP_DEF1:
   WFIFOL(fd,4) = mstatus->def;
   break;
  case SP_MDEF1:
   WFIFOL(fd,4) = mstatus->mdef;
   break;
  case SP_MERCFLEE:
   WFIFOL(fd,4) = mstatus->flee;
   break;
  case SP_ASPD:
   WFIFOL(fd,4) = mstatus->amotion;
   break;
  case SP_HP:
   WFIFOL(fd,4) = mstatus->hp;
   break;
  case SP_MAXHP:
   WFIFOL(fd,4) = mstatus->max_hp;
   break;
  case SP_SP:
   WFIFOL(fd,4) = mstatus->sp;
   break;
  case SP_MAXSP:
   WFIFOL(fd,4) = mstatus->max_sp;
   break;
  case SP_MERCKILLS:
   WFIFOL(fd,4) = md->mercenary.kill_count;
   break;
  case SP_MERCFAITH:
   WFIFOL(fd,4) = mercenary->get_faith(md);
   break;
 }
 WFIFOSET(fd,packet_db[0x2a2].len);
}





void clif_mercenary_info(struct map_session_data *sd) {
 int fd;
 struct mercenary_data *md;
 struct status_data *mstatus;
 int atk;

 if( sd == 
# 15953 "../../../server-code/src/map/clif.c" 3 4
          ((void *)0) 
# 15953 "../../../server-code/src/map/clif.c"
               || (md = sd->md) == 
# 15953 "../../../server-code/src/map/clif.c" 3 4
                                   ((void *)0) 
# 15953 "../../../server-code/src/map/clif.c"
                                        )
  return;

 fd = sd->fd;
 mstatus = &md->battle_status;

 WFIFOHEAD(fd,packet_db[0x29b].len);
 WFIFOW(fd,0) = 0x29b;
 WFIFOL(fd,2) = md->bl.id;



 atk = status->get_weapon_atk(&md->bl, &mstatus->rhw, 0);



 WFIFOW(fd,6) = (((atk) >= (
# 15969 "../../../server-code/src/map/clif.c" 3 4
                (32767)
# 15969 "../../../server-code/src/map/clif.c"
                )) ? (
# 15969 "../../../server-code/src/map/clif.c" 3 4
                (32767)
# 15969 "../../../server-code/src/map/clif.c"
                ) : ((atk) <= (0)) ? (0) : (atk));

 atk = status->base_matk(&md->bl, mstatus, status->get_lv(&md->bl));
 WFIFOW(fd,8) = (((atk) >= (
# 15972 "../../../server-code/src/map/clif.c" 3 4
               (32767)
# 15972 "../../../server-code/src/map/clif.c"
               )) ? (
# 15972 "../../../server-code/src/map/clif.c" 3 4
               (32767)
# 15972 "../../../server-code/src/map/clif.c"
               ) : ((atk) <= (0)) ? (0) : (atk));



 WFIFOW(fd,10) = mstatus->hit;
 WFIFOW(fd,12) = mstatus->cri/10;

 WFIFOW(fd,14) = mstatus->def2;
 WFIFOW(fd,16) = mstatus->mdef2;




 WFIFOW(fd,18) = mstatus->flee;
 WFIFOW(fd,20) = mstatus->amotion;
 (strlib->safestrncpy_((WFIFOP(fd,22)),(md->db->name),((23 + 1))));
 WFIFOW(fd,46) = md->db->lv;
 WFIFOL(fd,48) = mstatus->hp;
 WFIFOL(fd,52) = mstatus->max_hp;
 WFIFOL(fd,56) = mstatus->sp;
 WFIFOL(fd,60) = mstatus->max_sp;
 WFIFOL(fd,64) = (int)time(
# 15993 "../../../server-code/src/map/clif.c" 3 4
                          ((void *)0)
# 15993 "../../../server-code/src/map/clif.c"
                              ) + (mercenary->get_lifetime(md) / 1000);
 WFIFOW(fd,68) = mercenary->get_faith(md);
 WFIFOL(fd,70) = mercenary->get_calls(md);
 WFIFOL(fd,74) = md->mercenary.kill_count;
 WFIFOW(fd,78) = md->battle_status.rhw.range;
 WFIFOSET(fd,packet_db[0x29b].len);
}



void clif_mercenary_skillblock(struct map_session_data *sd)
{
 struct mercenary_data *md;
 int fd, i, len = 4, j;

 if( sd == 
# 16008 "../../../server-code/src/map/clif.c" 3 4
          ((void *)0) 
# 16008 "../../../server-code/src/map/clif.c"
               || (md = sd->md) == 
# 16008 "../../../server-code/src/map/clif.c" 3 4
                                   ((void *)0) 
# 16008 "../../../server-code/src/map/clif.c"
                                        )
  return;

 fd = sd->fd;
 WFIFOHEAD(fd,4+37*40);
 WFIFOW(fd,0) = 0x29d;
 for (i = 0; i < 40; i++) {
  int id = md->db->skill[i].id;
  if (id == 0)
   continue;
  j = id - 8201;
  WFIFOW(fd,len) = id;
  WFIFOL(fd,len+2) = skill->get_inf(id);
  WFIFOW(fd,len+6) = md->db->skill[j].lv;
  if ( md->db->skill[j].lv ) {
   WFIFOW(fd,len + 8) = skill->get_sp(id, md->db->skill[j].lv);
   WFIFOW(fd,len + 10) = skill->get_range2(&md->bl, id, md->db->skill[j].lv);
  } else {
   WFIFOW(fd,len + 8) = 0;
   WFIFOW(fd,len + 10) = 0;
  }
  (strlib->safestrncpy_((WFIFOP(fd,len+12)),(skill->get_name(id)),((23 + 1))));
  WFIFOB(fd,len+36) = 0;
  len += 37;
 }

 WFIFOW(fd,2) = len;
 WFIFOSET(fd,len);
}

void clif_parse_mercenary_action(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));




void clif_parse_mercenary_action(int fd, struct map_session_data* sd)
{
 int option = RFIFOB(fd,2);
 if (sd->md == 
# 16046 "../../../server-code/src/map/clif.c" 3 4
              ((void *)0)
# 16046 "../../../server-code/src/map/clif.c"
                  )
  return;

 if (option == 2)
  mercenary->delete(sd->md, 2);
}







void clif_mercenary_message(struct map_session_data* sd, int message)
{
 clif->msgtable(sd, MSG_MERCENARY_EXPIRED + message);
}



void clif_rental_time(int fd, int nameid, int seconds)
{
 WFIFOHEAD(fd,packet_db[0x298].len);
 WFIFOW(fd,0) = 0x298;
 WFIFOW(fd,2) = nameid;
 WFIFOL(fd,4) = seconds;
 WFIFOSET(fd,packet_db[0x298].len);
}



void clif_rental_expired(int fd, int index, int nameid)
{
 WFIFOHEAD(fd,packet_db[0x299].len);
 WFIFOW(fd,0) = 0x299;
 WFIFOW(fd,2) = index+2;
 WFIFOW(fd,4) = nameid;
 WFIFOSET(fd,packet_db[0x299].len);
}



void clif_readbook(int fd, int book_id, int page)
{
 WFIFOHEAD(fd,packet_db[0x294].len);
 WFIFOW(fd,0) = 0x294;
 WFIFOL(fd,2) = book_id;
 WFIFOL(fd,6) = page;
 WFIFOSET(fd,packet_db[0x294].len);
}






void clif_bg_hp(struct map_session_data *sd)
{
 unsigned char buf[34];
 const int cmd = 0x2e0;
 do { if (((void)(sd), 
# 16106 "../../../server-code/src/map/clif.c" 3 4
0
# 16106 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = cmd;
 WBUFL(buf,2) = sd->status.account_id;
 memcpy(WBUFP(buf,6), sd->status.name, (23 + 1));

 if( sd->battle_status.max_hp > 
# 16112 "../../../server-code/src/map/clif.c" 3 4
                               (32767) 
# 16112 "../../../server-code/src/map/clif.c"
                                         )
 {
  WBUFW(buf,30) = sd->battle_status.hp/(sd->battle_status.max_hp/100);
  WBUFW(buf,32) = 100;
 }
 else
 {
  WBUFW(buf,30) = sd->battle_status.hp;
  WBUFW(buf,32) = sd->battle_status.max_hp;
 }

 clif->send(buf, packet_db[cmd].len, &sd->bl, BG_AREA_WOS);
}



void clif_bg_xy(struct map_session_data *sd)
{
 unsigned char buf[36];
 do { if (((void)(sd), 
# 16131 "../../../server-code/src/map/clif.c" 3 4
0
# 16131 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0)=0x2df;
 WBUFL(buf,2)=sd->status.account_id;
 memcpy(WBUFP(buf,6), sd->status.name, (23 + 1));
 WBUFW(buf,30)=sd->status.class_;
 WBUFW(buf,32)=sd->bl.x;
 WBUFW(buf,34)=sd->bl.y;

 clif->send(buf, packet_db[0x2df].len, &sd->bl, BG_SAMEMAP_WOS);
}

void clif_bg_xy_remove(struct map_session_data *sd)
{
 unsigned char buf[36];
 do { if (((void)(sd), 
# 16146 "../../../server-code/src/map/clif.c" 3 4
0
# 16146 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0)=0x2df;
 WBUFL(buf,2)=sd->status.account_id;
 memset(WBUFP(buf,6), 0, (23 + 1));
 WBUFW(buf,30)=0;
 WBUFW(buf,32)=-1;
 WBUFW(buf,34)=-1;

 clif->send(buf, packet_db[0x2df].len, &sd->bl, BG_SAMEMAP_WOS);
}



void clif_bg_message(struct battleground_data *bgd, int src_id, const char *name, const char *mes, size_t len)
{
 struct map_session_data *sd;
 unsigned char *buf;

 do { if (((void)(bgd), 
# 16165 "../../../server-code/src/map/clif.c" 3 4
0
# 16165 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(name), 
# 16166 "../../../server-code/src/map/clif.c" 3 4
0
# 16166 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(mes), 
# 16167 "../../../server-code/src/map/clif.c" 3 4
0
# 16167 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if( !bgd->count || (sd = bg->getavailablesd(bgd)) == 
# 16168 "../../../server-code/src/map/clif.c" 3 4
                                                     ((void *)0) 
# 16168 "../../../server-code/src/map/clif.c"
                                                          )
  return;

 buf = (unsigned char*)(iMalloc->malloc(((len + (23 + 1) + 8)*sizeof(unsigned char)),"../../../server-code/src/map/clif.c", 16171, __func__));

 WBUFW(buf,0) = 0x2dc;
 WBUFW(buf,2) = len + (23 + 1) + 8;
 WBUFL(buf,4) = src_id;
 memcpy(WBUFP(buf,8), name, (23 + 1));
 memcpy(WBUFP(buf,32), mes, len);
 clif->send(buf,WBUFW(buf,2), &sd->bl, BG);

 (iMalloc->free((buf),"../../../server-code/src/map/clif.c", 16180, __func__));
}

void clif_parse_BattleChat(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_BattleChat(int fd, struct map_session_data* sd)
{
 const char *text = RFIFOP(fd,4);
 int textlen = RFIFOW(fd,2) - 4;

 const char *name, *message;
 size_t namelen, messagelen;

 if( !clif->process_message(sd, 0, &name, &namelen, &message, &messagelen) )
  return;

 if( atcommand->exec(fd, sd, message, 
# 16197 "../../../server-code/src/map/clif.c" 3 4
                                     1
# 16197 "../../../server-code/src/map/clif.c"
                                         ) )
  return;

 if( !pc->can_talk(sd) )
  return;

 if( battle_config.min_chat_delay ) {
  if( ((sd->cantalk_tick)-(timer->gettick())) > 0 )
   return;
  sd->cantalk_tick = timer->gettick() + battle_config.min_chat_delay;
 }

 pc->update_idle_time(sd, BCIDLE_CHAT);

 bg->send_message(sd, text, textlen);
}



void clif_bg_updatescore(int16 m) {
 struct block_list bl;
 unsigned char buf[6];

 bl.id = 0;
 bl.type = BL_NUL;
 bl.m = m;

 WBUFW(buf,0) = 0x2de;
 WBUFW(buf,2) = map->list[m].bgscore_lion;
 WBUFW(buf,4) = map->list[m].bgscore_eagle;
 clif->send(buf,packet_db[0x2de].len,&bl,ALL_SAMEMAP);
}

void clif_bg_updatescore_single(struct map_session_data *sd) {
 int fd;
 do { if (((void)(sd), 
# 16232 "../../../server-code/src/map/clif.c" 3 4
0
# 16232 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;

 WFIFOHEAD(fd,packet_db[0x2de].len);
 WFIFOW(fd,0) = 0x2de;
 WFIFOW(fd,2) = map->list[sd->bl.m].bgscore_lion;
 WFIFOW(fd,4) = map->list[sd->bl.m].bgscore_eagle;
 WFIFOSET(fd,packet_db[0x2de].len);
}



void clif_sendbgemblem_area(struct map_session_data *sd)
{
 unsigned char buf[33];
 do { if (((void)(sd), 
# 16247 "../../../server-code/src/map/clif.c" 3 4
0
# 16247 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0x2dd;
 WBUFL(buf,2) = sd->bl.id;
 (strlib->safestrncpy_((WBUFP(buf,6)),(sd->status.name),((23 + 1))));
 WBUFW(buf,30) = sd->bg_id;
 clif->send(buf,packet_db[0x2dd].len, &sd->bl, AREA);
}

void clif_sendbgemblem_single(int fd, struct map_session_data *sd)
{
 do { if (((void)(sd), 
# 16258 "../../../server-code/src/map/clif.c" 3 4
0
# 16258 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 WFIFOHEAD(fd,32);
 WFIFOW(fd,0) = 0x2dd;
 WFIFOL(fd,2) = sd->bl.id;
 (strlib->safestrncpy_((WFIFOP(fd,6)),(sd->status.name),((23 + 1))));
 WFIFOW(fd,30) = sd->bg_id;
 WFIFOSET(fd,packet_db[0x2dd].len);
}



void clif_font(struct map_session_data *sd)
{

 unsigned char buf[8];
 do { if (((void)(sd), 
# 16273 "../../../server-code/src/map/clif.c" 3 4
0
# 16273 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 WBUFW(buf,0) = 0x2ef;
 WBUFL(buf,2) = sd->bl.id;
 WBUFW(buf,6) = sd->status.font;
 clif->send(buf, packet_db[0x2ef].len, &sd->bl, AREA);

}




int clif_instance(int instance_id, int type, int flag) {
 struct map_session_data *sd = 
# 16285 "../../../server-code/src/map/clif.c" 3 4
                              ((void *)0)
# 16285 "../../../server-code/src/map/clif.c"
                                  ;
 unsigned char buf[255];
 enum send_target target = PARTY;

 switch( instance->list[instance_id].owner_type ) {
  case IOT_NONE:
   return 0;
  case IOT_GUILD:
   target = GUILD;
   sd = guild->getavailablesd(guild->search(instance->list[instance_id].owner_id));
   break;
  case IOT_PARTY:

   sd = party->getavailablesd(party->search(instance->list[instance_id].owner_id));
   break;
  case IOT_CHAR:
   target = SELF;
   sd = map->id2sd(instance->list[instance_id].owner_id);
   break;
 }

 if( !sd )
  return 0;

 switch( type ) {
  case 1:



   WBUFW(buf,0) = 0x02CB;
   memcpy(WBUFP(buf,2),instance->list[instance_id].name,(60+1));
   WBUFW(buf,63) = flag;
   clif->send(buf,packet_db[0x02CB].len,&sd->bl,target);
   break;
  case 2:


   WBUFW(buf,0) = 0x02CC;
   WBUFW(buf,2) = flag;
   clif->send(buf,packet_db[0x02CC].len,&sd->bl,target);
   break;
  case 3:
  case 4:

   WBUFW(buf,0) = 0x02CD;
   memcpy(WBUFP(buf,2),instance->list[instance_id].name,61);
   if( type == 3 ) {
    WBUFL(buf,63) = instance->list[instance_id].progress_timeout;
    WBUFL(buf,67) = 0;
   } else {
    WBUFL(buf,63) = 0;
    WBUFL(buf,67) = instance->list[instance_id].idle_timeout;
   }
   clif->send(buf,packet_db[0x02CD].len,&sd->bl,target);
   break;
  case 5:






   WBUFW(buf,0) = 0x02CE;
   WBUFL(buf,2) = flag;

   clif->send(buf,packet_db[0x02CE].len,&sd->bl,target);
   break;
 }
 return 0;
}

void clif_instance_join(int fd, int instance_id)
{
 if( instance->list[instance_id].idle_timer != (-1) ) {
  WFIFOHEAD(fd,packet_db[0x02CD].len);
  WFIFOW(fd,0) = 0x02CD;
  memcpy(WFIFOP(fd,2),instance->list[instance_id].name,61);
  WFIFOL(fd,63) = 0;
  WFIFOL(fd,67) = instance->list[instance_id].idle_timeout;
  WFIFOSET(fd,packet_db[0x02CD].len);
 } else if( instance->list[instance_id].progress_timer != (-1) ) {
  WFIFOHEAD(fd,packet_db[0x02CD].len);
  WFIFOW(fd,0) = 0x02CD;
  memcpy(WFIFOP(fd,2),instance->list[instance_id].name,61);
  WFIFOL(fd,63) = instance->list[instance_id].progress_timeout;
  WFIFOL(fd,67) = 0;
  WFIFOSET(fd,packet_db[0x02CD].len);
 } else {
  WFIFOHEAD(fd,packet_db[0x02CB].len);
  WFIFOW(fd,0) = 0x02CB;
  memcpy(WFIFOP(fd,2),instance->list[instance_id].name,61);
  WFIFOW(fd,63) = 0;
  WFIFOSET(fd,packet_db[0x02CB].len);
 }
}

void clif_instance_leave(int fd)
{
 WFIFOHEAD(fd,packet_db[0x02CE].len);
 WFIFOW(fd,0) = 0x02ce;
 WFIFOL(fd,2) = 4;
 WFIFOSET(fd,packet_db[0x02CE].len);
}



void clif_party_show_picker(struct map_session_data * sd, struct item * item_data)
{

 unsigned char buf[22];
 struct item_data* id;

 do { if (((void)(sd), 
# 16397 "../../../server-code/src/map/clif.c" 3 4
0
# 16397 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(item_data), 
# 16398 "../../../server-code/src/map/clif.c" 3 4
0
# 16398 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 id = itemdb->search(item_data->nameid);
 WBUFW(buf,0) = 0x2b8;
 WBUFL(buf,2) = sd->status.account_id;
 WBUFW(buf,6) = item_data->nameid;
 WBUFB(buf,8) = item_data->identify;
 WBUFB(buf,9) = item_data->attribute;
 WBUFB(buf,10) = item_data->refine;
 clif->addcards(WBUFP(buf,11), item_data);
 WBUFW(buf,19) = id->equip;
 WBUFB(buf,21) = itemtype(id->type);
 clif->send(buf, packet_db[0x2b8].len, &sd->bl, PARTY_SAMEMAP_WOS);

}
# 16420 "../../../server-code/src/map/clif.c"
void clif_displayexp(struct map_session_data *sd, unsigned int exp, char type, 
# 16420 "../../../server-code/src/map/clif.c" 3 4
                                                                              _Bool 
# 16420 "../../../server-code/src/map/clif.c"
                                                                                   is_quest) {
 int fd;

 do { if (((void)(sd), 
# 16423 "../../../server-code/src/map/clif.c" 3 4
0
# 16423 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;

 WFIFOHEAD(fd, packet_db[0x7f6].len);
 WFIFOW(fd,0) = 0x7f6;
 WFIFOL(fd,2) = sd->bl.id;
 WFIFOL(fd,6) = exp;
 WFIFOW(fd,10) = type;
 WFIFOW(fd,12) = is_quest?1:0;
 WFIFOSET(fd,packet_db[0x7f6].len);
}
# 16444 "../../../server-code/src/map/clif.c"
void clif_showdigit(struct map_session_data* sd, unsigned char type, int value)
{
 do { if (((void)(sd), 
# 16446 "../../../server-code/src/map/clif.c" 3 4
0
# 16446 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 WFIFOHEAD(sd->fd, packet_db[0x1b1].len);
 WFIFOW(sd->fd,0) = 0x1b1;
 WFIFOB(sd->fd,2) = type;
 WFIFOL(sd->fd,3) = value;
 WFIFOSET(sd->fd, packet_db[0x1b1].len);
}

void clif_parse_LessEffect(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));
# 16467 "../../../server-code/src/map/clif.c"
void clif_parse_LessEffect(int fd, struct map_session_data* sd)
{
 int isLess = RFIFOL(fd,packet_db[RFIFOW(fd,0)].pos[0]);

 sd->state.lesseffect = ( isLess != 0 );
}

void clif_parse_ItemListWindowSelected(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));

void clif_parse_ItemListWindowSelected(int fd, struct map_session_data *sd)
{
 int n = ((int)RFIFOW(fd,2) - 12) / 4;
 int type = RFIFOL(fd,4);
 int flag = RFIFOL(fd,8);
 struct itemlist item_list = { 0 };
 int i;

 if( sd->state.trading || sd->npc_shopid )
  return;

 if (flag == 0 || n <= 0) {
  ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
  return;
 }

 if (n > 100)
  n = 100;

 if (sd->menuskill_id != SO_EL_ANALYSIS && sd->menuskill_id != GN_CHANGEMATERIAL) {
  ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
  return;
 }

 memset(&(item_list), 0, sizeof(item_list));
 do { int _empty_ = ( (item_list)._max_ )-( (item_list)._len_ ); if ((n) > _empty_) { while ((n) > _empty_) _empty_ += (1); do { if ((_empty_+( (item_list)._len_ )) > ( (item_list)._max_ )) { if (( (item_list)._max_ ) == 0) ( (item_list)._data_ ) = (iMalloc->malloc(((_empty_+( (item_list)._len_ ))*sizeof(( ( ( (item_list)._data_ )[0] ) ))),"../../../server-code/src/map/clif.c", 16501, __func__)); else ( (item_list)._data_ ) = (iMalloc->realloc((( (item_list)._data_ )),((_empty_+( (item_list)._len_ ))*sizeof(( ( ( (item_list)._data_ )[0] ) ))),"../../../server-code/src/map/clif.c", 16501, __func__)); memset(( (item_list)._data_ )+( (item_list)._len_ ), 0, (( (item_list)._max_ )-( (item_list)._len_ ))*sizeof(( ( ( (item_list)._data_ )[0] ) ))); ( (item_list)._max_ ) = (_empty_+( (item_list)._len_ )); } else if ((_empty_+( (item_list)._len_ )) == 0 && ( (item_list)._max_ ) > 0) { (iMalloc->free((( (item_list)._data_ )),"../../../server-code/src/map/clif.c", 16501, __func__)); ( (item_list)._data_ ) = 
# 16501 "../../../server-code/src/map/clif.c" 3 4
((void *)0)
# 16501 "../../../server-code/src/map/clif.c"
; ( (item_list)._max_ ) = 0; ( (item_list)._len_ ) = 0; } else if ((_empty_+( (item_list)._len_ )) < ( (item_list)._max_ )) { ( (item_list)._data_ ) = (iMalloc->realloc((( (item_list)._data_ )),((_empty_+( (item_list)._len_ ))*sizeof(( ( ( (item_list)._data_ )[0] ) ))),"../../../server-code/src/map/clif.c", 16501, __func__)); ( (item_list)._max_ ) = (_empty_+( (item_list)._len_ )); if ((_empty_+( (item_list)._len_ )) - ( (item_list)._len_ ) > 0) ( (item_list)._len_ ) = (_empty_+( (item_list)._len_ )); } } while(
# 16501 "../../../server-code/src/map/clif.c" 3 4
0
# 16501 "../../../server-code/src/map/clif.c"
); } } while(
# 16501 "../../../server-code/src/map/clif.c" 3 4
0
# 16501 "../../../server-code/src/map/clif.c"
);
 for (i = 0; i < n; i++) {
  struct itemlist_entry entry = { 0 };
  entry.id = (int)RFIFOW(fd, 12 + 4 * i) - 2;
  entry.amount = RFIFOW(fd, 12 + 4 * i + 2);
  do { ( ( (item_list)._data_ )[( (item_list)._len_ )] ) = (entry); ++( (item_list)._len_ ); }while(
# 16506 "../../../server-code/src/map/clif.c" 3 4
 0
# 16506 "../../../server-code/src/map/clif.c"
 );
 }

 switch( type ) {
  case 0:
   skill->changematerial(sd, &item_list);
   break;
  case 1:
  case 2:
   skill->elementalanalysis(sd, type, &item_list);
   break;
 }
 do { if (( (item_list)._max_ ) > 0) { (iMalloc->free((( (item_list)._data_ )),"../../../server-code/src/map/clif.c", 16518, __func__)); ( (item_list)._data_ ) = 
# 16518 "../../../server-code/src/map/clif.c" 3 4
((void *)0)
# 16518 "../../../server-code/src/map/clif.c"
; ( (item_list)._max_ ) = 0; ( (item_list)._len_ ) = 0; } } while(
# 16518 "../../../server-code/src/map/clif.c" 3 4
0
# 16518 "../../../server-code/src/map/clif.c"
);
 ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);

 return;
}




void clif_elemental_updatestatus(struct map_session_data *sd, int type) {
 struct elemental_data *ed;
 struct status_data *estatus;
 int fd;

 if( sd == 
# 16532 "../../../server-code/src/map/clif.c" 3 4
          ((void *)0) 
# 16532 "../../../server-code/src/map/clif.c"
               || (ed = sd->ed) == 
# 16532 "../../../server-code/src/map/clif.c" 3 4
                                   ((void *)0) 
# 16532 "../../../server-code/src/map/clif.c"
                                        )
  return;

 fd = sd->fd;
 estatus = &ed->battle_status;
 WFIFOHEAD(fd,8);
 WFIFOW(fd,0) = 0x81e;
 WFIFOW(fd,2) = type;
 switch( type ) {
  case SP_HP:
   WFIFOL(fd,4) = estatus->hp;
   break;
  case SP_MAXHP:
   WFIFOL(fd,4) = estatus->max_hp;
   break;
  case SP_SP:
   WFIFOL(fd,4) = estatus->sp;
   break;
  case SP_MAXSP:
   WFIFOL(fd,4) = estatus->max_sp;
   break;
 }
 WFIFOSET(fd,8);
}

void clif_elemental_info(struct map_session_data *sd) {
 int fd;
 struct elemental_data *ed;
 struct status_data *estatus;

 if( sd == 
# 16562 "../../../server-code/src/map/clif.c" 3 4
          ((void *)0) 
# 16562 "../../../server-code/src/map/clif.c"
               || (ed = sd->ed) == 
# 16562 "../../../server-code/src/map/clif.c" 3 4
                                   ((void *)0) 
# 16562 "../../../server-code/src/map/clif.c"
                                        )
  return;

 fd = sd->fd;
 estatus = &ed->battle_status;

 WFIFOHEAD(fd,22);
 WFIFOW(fd,0) = 0x81d;
 WFIFOL(fd, 2) = ed->bl.id;
 WFIFOL(fd, 6) = estatus->hp;
 WFIFOL(fd,10) = estatus->max_hp;
 WFIFOL(fd,14) = estatus->sp;
 WFIFOL(fd,18) = estatus->max_sp;
 WFIFOSET(fd,22);
}






void clif_buyingstore_open(struct map_session_data* sd)
{
 int fd;

 do { if (((void)(sd), 
# 16587 "../../../server-code/src/map/clif.c" 3 4
0
# 16587 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x810].len);
 WFIFOW(fd,0) = 0x810;
 WFIFOB(fd,2) = sd->buyingstore.slots;
 WFIFOSET(fd,packet_db[0x810].len);
}

void clif_parse_ReqOpenBuyingStore(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));





void clif_parse_ReqOpenBuyingStore(int fd, struct map_session_data* sd) {
 const unsigned int blocksize = 8;
 const uint8 *itemlist;
 char storename[(79 + 1)];
 unsigned char result;
 int zenylimit;
 unsigned int count, packet_len;
 struct s_packet_db* info = &packet_db[RFIFOW(fd,0)];

 packet_len = RFIFOW(fd,info->pos[0]);


 if( packet_len < 89 )
 {
  (showmsg->showError(("clif_parse_ReqOpenBuyingStore: Malformed packet (expected length=%u, length=%u, account_id=%d).\n"), 89U, packet_len, sd->bl.id));
  return;
 }

 zenylimit = RFIFOL(fd,info->pos[1]);
 result = RFIFOL(fd,info->pos[2]);
 (strlib->safestrncpy_((storename),(RFIFOP(fd,info->pos[3])),(sizeof(storename))));
 itemlist = RFIFOP(fd,info->pos[4]);


 packet_len-= info->pos[4];

 if( packet_len%blocksize )
 {
  (showmsg->showError(("clif_parse_ReqOpenBuyingStore: Unexpected item list size %u (account_id=%d, block size=%u)\n"), packet_len, sd->bl.id, blocksize));
  return;
 }
 count = packet_len/blocksize;

 buyingstore->create(sd, zenylimit, result, storename, itemlist, count);
}
# 16644 "../../../server-code/src/map/clif.c"
void clif_buyingstore_open_failed(struct map_session_data* sd, unsigned short result, unsigned int weight)
{
 int fd;

 do { if (((void)(sd), 
# 16648 "../../../server-code/src/map/clif.c" 3 4
0
# 16648 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x812].len);
 WFIFOW(fd,0) = 0x812;
 WFIFOW(fd,2) = result;
 WFIFOL(fd,4) = weight;
 WFIFOSET(fd,packet_db[0x812].len);
}



void clif_buyingstore_myitemlist(struct map_session_data* sd)
{
 int fd;
 unsigned int i;

 do { if (((void)(sd), 
# 16664 "../../../server-code/src/map/clif.c" 3 4
0
# 16664 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,12+sd->buyingstore.slots*9);
 WFIFOW(fd,0) = 0x813;
 WFIFOW(fd,2) = 12+sd->buyingstore.slots*9;
 WFIFOL(fd,4) = sd->bl.id;
 WFIFOL(fd,8) = sd->buyingstore.zenylimit;

 for( i = 0; i < sd->buyingstore.slots; i++ )
 {
  WFIFOL(fd,12+i*9) = sd->buyingstore.items[i].price;
  WFIFOW(fd,16+i*9) = sd->buyingstore.items[i].amount;
  WFIFOB(fd,18+i*9) = itemtype((itemdb->search(sd->buyingstore.items[i].nameid)->type));
  WFIFOW(fd,19+i*9) = sd->buyingstore.items[i].nameid;
 }

 WFIFOSET(fd,WFIFOW(fd,2));
}



void clif_buyingstore_entry(struct map_session_data* sd)
{
 uint8 buf[86];

 do { if (((void)(sd), 
# 16689 "../../../server-code/src/map/clif.c" 3 4
0
# 16689 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 WBUFW(buf,0) = 0x814;
 WBUFL(buf,2) = sd->bl.id;
 memcpy(WBUFP(buf,6), sd->message, (79 + 1));

 clif->send(buf, packet_db[0x814].len, &sd->bl, AREA_WOS);
}
void clif_buyingstore_entry_single(struct map_session_data* sd, struct map_session_data* pl_sd)
{
 int fd;

 do { if (((void)(sd), 
# 16700 "../../../server-code/src/map/clif.c" 3 4
0
# 16700 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x814].len);
 WFIFOW(fd,0) = 0x814;
 WFIFOL(fd,2) = pl_sd->bl.id;
 memcpy(WFIFOP(fd,6), pl_sd->message, (79 + 1));
 WFIFOSET(fd,packet_db[0x814].len);
}

void clif_parse_ReqCloseBuyingStore(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_ReqCloseBuyingStore(int fd, struct map_session_data* sd) {
 buyingstore->close(sd);
}



void clif_buyingstore_disappear_entry(struct map_session_data* sd)
{
 uint8 buf[6];

 do { if (((void)(sd), 
# 16722 "../../../server-code/src/map/clif.c" 3 4
0
# 16722 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 WBUFW(buf,0) = 0x816;
 WBUFL(buf,2) = sd->bl.id;

 clif->send(buf, packet_db[0x816].len, &sd->bl, AREA_WOS);
}
void clif_buyingstore_disappear_entry_single(struct map_session_data* sd, struct map_session_data* pl_sd)
{
 int fd;

 do { if (((void)(sd), 
# 16732 "../../../server-code/src/map/clif.c" 3 4
0
# 16732 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(pl_sd), 
# 16733 "../../../server-code/src/map/clif.c" 3 4
0
# 16733 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x816].len);
 WFIFOW(fd,0) = 0x816;
 WFIFOL(fd,2) = pl_sd->bl.id;
 WFIFOSET(fd,packet_db[0x816].len);
}



void clif_parse_ReqClickBuyingStore(int fd, struct map_session_data* sd)
{
 int account_id;

 account_id = RFIFOL(fd,packet_db[RFIFOW(fd,0)].pos[0]);

 buyingstore->open(sd, account_id);
}



void clif_buyingstore_itemlist(struct map_session_data* sd, struct map_session_data* pl_sd)
{
 int fd;
 unsigned int i;

 do { if (((void)(sd), 
# 16759 "../../../server-code/src/map/clif.c" 3 4
0
# 16759 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(pl_sd), 
# 16760 "../../../server-code/src/map/clif.c" 3 4
0
# 16760 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,16+pl_sd->buyingstore.slots*9);
 WFIFOW(fd,0) = 0x818;
 WFIFOW(fd,2) = 16+pl_sd->buyingstore.slots*9;
 WFIFOL(fd,4) = pl_sd->bl.id;
 WFIFOL(fd,8) = pl_sd->buyer_id;
 WFIFOL(fd,12) = pl_sd->buyingstore.zenylimit;

 for( i = 0; i < pl_sd->buyingstore.slots; i++ )
 {
  WFIFOL(fd,16+i*9) = pl_sd->buyingstore.items[i].price;
  WFIFOW(fd,20+i*9) = pl_sd->buyingstore.items[i].amount;
  WFIFOB(fd,22+i*9) = itemtype((itemdb->search(pl_sd->buyingstore.items[i].nameid)->type));
  WFIFOW(fd,23+i*9) = pl_sd->buyingstore.items[i].nameid;
 }

 WFIFOSET(fd,WFIFOW(fd,2));
}

void clif_parse_ReqTradeBuyingStore(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_ReqTradeBuyingStore(int fd, struct map_session_data* sd) {
 const unsigned int blocksize = 6;
 const uint8 *itemlist;
 int account_id;
 unsigned int count, packet_len, buyer_id;
 struct s_packet_db* info = &packet_db[RFIFOW(fd,0)];

 packet_len = RFIFOW(fd,info->pos[0]);

 if( packet_len < 12 )
 {
  (showmsg->showError(("clif_parse_ReqTradeBuyingStore: Malformed packet (expected length=%u, length=%u, account_id=%d).\n"), 12U, packet_len, sd->bl.id));
  return;
 }

 account_id = RFIFOL(fd,info->pos[1]);
 buyer_id = RFIFOL(fd,info->pos[2]);
 itemlist = RFIFOP(fd,info->pos[3]);


 packet_len-= info->pos[3];

 if( packet_len%blocksize )
 {
  (showmsg->showError(("clif_parse_ReqTradeBuyingStore: Unexpected item list size %u (account_id=%d, buyer_id=%d, block size=%u)\n"), packet_len, sd->bl.id, account_id, blocksize));
  return;
 }
 count = packet_len/blocksize;

 buyingstore->trade(sd, account_id, buyer_id, itemlist, count);
}







void clif_buyingstore_trade_failed_buyer(struct map_session_data* sd, short result)
{
 int fd;

 do { if (((void)(sd), 
# 16825 "../../../server-code/src/map/clif.c" 3 4
0
# 16825 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x81a].len);
 WFIFOW(fd,0) = 0x81a;
 WFIFOW(fd,2) = result;
 WFIFOSET(fd,packet_db[0x81a].len);
}



void clif_buyingstore_update_item(struct map_session_data* sd, unsigned short nameid, unsigned short amount)
{
 int fd;

 do { if (((void)(sd), 
# 16839 "../../../server-code/src/map/clif.c" 3 4
0
# 16839 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x81b].len);
 WFIFOW(fd,0) = 0x81b;
 WFIFOW(fd,2) = nameid;
 WFIFOW(fd,4) = amount;
 WFIFOL(fd,6) = sd->buyingstore.zenylimit;
 WFIFOSET(fd,packet_db[0x81b].len);
}







void clif_buyingstore_delete_item(struct map_session_data* sd, short index, unsigned short amount, int price)
{
 int fd;

 do { if (((void)(sd), 
# 16859 "../../../server-code/src/map/clif.c" 3 4
0
# 16859 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x81c].len);
 WFIFOW(fd,0) = 0x81c;
 WFIFOW(fd,2) = index+2;
 WFIFOW(fd,4) = amount;
 WFIFOL(fd,6) = price;
 WFIFOSET(fd,packet_db[0x81c].len);
}
# 16876 "../../../server-code/src/map/clif.c"
void clif_buyingstore_trade_failed_seller(struct map_session_data* sd, short result, unsigned short nameid)
{
 int fd;

 do { if (((void)(sd), 
# 16880 "../../../server-code/src/map/clif.c" 3 4
0
# 16880 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x824].len);
 WFIFOW(fd,0) = 0x824;
 WFIFOW(fd,2) = result;
 WFIFOW(fd,4) = nameid;
 WFIFOSET(fd,packet_db[0x824].len);
}

void clif_parse_SearchStoreInfo(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));
# 16902 "../../../server-code/src/map/clif.c"
void clif_parse_SearchStoreInfo(int fd, struct map_session_data* sd) {
 const unsigned int blocksize = 2;
 const uint8* itemlist;
 const uint8* cardlist;
 unsigned char type;
 unsigned int min_price, max_price, packet_len, count, item_count, card_count;
 struct s_packet_db* info = &packet_db[RFIFOW(fd,0)];

 packet_len = RFIFOW(fd,info->pos[0]);

 if( packet_len < 15 )
 {
  (showmsg->showError(("clif_parse_SearchStoreInfo: Malformed packet (expected length=%u, length=%u, account_id=%d).\n"), 15U, packet_len, sd->bl.id));
  return;
 }

 type = RFIFOB(fd,info->pos[1]);
 max_price = RFIFOL(fd,info->pos[2]);
 min_price = RFIFOL(fd,info->pos[3]);
 item_count = RFIFOB(fd,info->pos[4]);
 card_count = RFIFOB(fd,info->pos[5]);
 itemlist = RFIFOP(fd,info->pos[6]);
 cardlist = RFIFOP(fd,info->pos[6]+blocksize*item_count);


 packet_len-= info->pos[6];

 if( packet_len%blocksize )
 {
  (showmsg->showError(("clif_parse_SearchStoreInfo: Unexpected item list size %u (account_id=%d, block size=%u)\n"), packet_len, sd->bl.id, blocksize));
  return;
 }
 count = packet_len/blocksize;

 if( count < item_count+card_count )
 {
  (showmsg->showError(("clif_parse_SearchStoreInfo: Malformed packet (expected count=%u, count=%u, account_id=%d).\n"), item_count+card_count, count, sd->bl.id));
  return;
 }

 searchstore->query(sd, type, min_price, max_price, (const unsigned short*)itemlist, item_count, (const unsigned short*)cardlist, card_count);
}
# 16953 "../../../server-code/src/map/clif.c"
void clif_search_store_info_ack(struct map_session_data* sd)
{
 const unsigned int blocksize = (79 + 1)+26;
 int fd;
 unsigned int i, start, end;

 do { if (((void)(sd), 
# 16959 "../../../server-code/src/map/clif.c" 3 4
0
# 16959 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 start = sd->searchstore.pages*10;
 end = (((sd->searchstore.count) < (start+10)) ? (sd->searchstore.count) : (start+10));

 WFIFOHEAD(fd,7+(end-start)*blocksize);
 WFIFOW(fd,0) = 0x836;
 WFIFOW(fd,2) = 7+(end-start)*blocksize;
 WFIFOB(fd,4) = !sd->searchstore.pages;
 WFIFOB(fd,5) = searchstore->querynext(sd);
 WFIFOB(fd,6) = (unsigned char)(((sd->searchstore.uses) < (((uint8) 0xFF))) ? (sd->searchstore.uses) : (((uint8) 0xFF)));

 for( i = start; i < end; i++ ) {
  struct s_search_store_info_item* ssitem = &sd->searchstore.items[i];
  struct item it;

  WFIFOL(fd,i*blocksize+ 7) = ssitem->store_id;
  WFIFOL(fd,i*blocksize+11) = ssitem->account_id;
  memcpy(WFIFOP(fd,i*blocksize+15), ssitem->store_name, (79 + 1));
  WFIFOW(fd,i*blocksize+15+(79 + 1)) = ssitem->nameid;
  WFIFOB(fd,i*blocksize+17+(79 + 1)) = itemtype((itemdb->search(ssitem->nameid)->type));
  WFIFOL(fd,i*blocksize+18+(79 + 1)) = ssitem->price;
  WFIFOW(fd,i*blocksize+22+(79 + 1)) = ssitem->amount;
  WFIFOB(fd,i*blocksize+24+(79 + 1)) = ssitem->refine;


  memset(&it, 0, sizeof(it));
  memcpy(&it.card, &ssitem->card, sizeof(it.card));
  it.nameid = ssitem->nameid;
  it.amount = ssitem->amount;

  clif->addcards(WFIFOP(fd,i*blocksize+25+(79 + 1)), &it);
 }

 WFIFOSET(fd,WFIFOW(fd,2));
}
# 17004 "../../../server-code/src/map/clif.c"
void clif_search_store_info_failed(struct map_session_data* sd, unsigned char reason)
{
 int fd;

 do { if (((void)(sd), 
# 17008 "../../../server-code/src/map/clif.c" 3 4
0
# 17008 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x837].len);
 WFIFOW(fd,0) = 0x837;
 WFIFOB(fd,2) = reason;
 WFIFOSET(fd,packet_db[0x837].len);
}

void clif_parse_SearchStoreInfoNextPage(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_SearchStoreInfoNextPage(int fd, struct map_session_data* sd)
{
 searchstore->next(sd);
}






void clif_open_search_store_info(struct map_session_data* sd)
{
 int fd;

 do { if (((void)(sd), 
# 17033 "../../../server-code/src/map/clif.c" 3 4
0
# 17033 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x83a].len);
 WFIFOW(fd,0) = 0x83a;
 WFIFOW(fd,2) = sd->searchstore.effect;

 WFIFOB(fd,4) = (unsigned char)(((sd->searchstore.uses) < (((uint8) 0xFF))) ? (sd->searchstore.uses) : (((uint8) 0xFF)));

 WFIFOSET(fd,packet_db[0x83a].len);
}

void clif_parse_CloseSearchStoreInfo(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_CloseSearchStoreInfo(int fd, struct map_session_data* sd)
{
 searchstore->close(sd);
}

void clif_parse_SearchStoreInfoListItemClick(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));


void clif_parse_SearchStoreInfoListItemClick(int fd, struct map_session_data* sd)
{
 unsigned short nameid;
 int account_id, store_id;
 struct s_packet_db* info = &packet_db[RFIFOW(fd,0)];

 account_id = RFIFOL(fd,info->pos[0]);
 store_id = RFIFOL(fd,info->pos[1]);
 nameid = RFIFOW(fd,info->pos[2]);

 searchstore->click(sd, account_id, store_id, nameid);
}



void clif_search_store_info_click_ack(struct map_session_data* sd, short x, short y)
{
 int fd;

 do { if (((void)(sd), 
# 17074 "../../../server-code/src/map/clif.c" 3 4
0
# 17074 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x83d].len);
 WFIFOW(fd,0) = 0x83d;
 WFIFOW(fd,2) = x;
 WFIFOW(fd,4) = y;
 WFIFOSET(fd,packet_db[0x83d].len);
}


void clif_parse_debug(int fd,struct map_session_data *sd) {
 int cmd, packet_len;


 cmd = RFIFOW(fd,0);

 if( sd ) {
  packet_len = packet_db[cmd].len;

  if( packet_len == -1 ) {
   packet_len = RFIFOW(fd,2);
  }
  (showmsg->showDebug(("Packet debug of 0x%04X (length %d), %s session #%d, %d/%d (AID/CID)\n"), (unsigned int)cmd, packet_len, sd->state.active ? "authed" : "unauthed", fd, sd->status.account_id, sd->status.char_id));
 } else {
  packet_len = (int)RFIFOREST(fd);
  (showmsg->showDebug(("Packet debug of 0x%04X (length %d), session #%d\n"), (unsigned int)cmd, packet_len, fd));
 }

 ShowDump(RFIFOP(fd,0), packet_len);
}




int clif_elementalconverter_list(struct map_session_data *sd) {
 int i,c,view,fd;

 do { if (((void)(sd), 
# 17111 "../../../server-code/src/map/clif.c" 3 4
0
# 17111 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);


 fd=sd->fd;
 WFIFOHEAD(fd, 270 *2+4);
 WFIFOW(fd,0)=0x1ad;

 for(i=0,c=0;i<270;i++){
  if( skill->can_produce_mix(sd,skill->dbs->produce_db[i].nameid,23, 1) ){
   if((view = (itemdb->search(skill->dbs->produce_db[i].nameid)->view_id)) > 0)
    WFIFOW(fd,c*2+ 4)= view;
   else
    WFIFOW(fd,c*2+ 4)= skill->dbs->produce_db[i].nameid;
   c++;
  }
 }
 WFIFOW(fd,2) = c*2+4;
 WFIFOSET(fd, WFIFOW(fd,2));
 if (c > 0) {
  sd->menuskill_id = SA_CREATECON;
  sd->menuskill_val = c;
 }

 return 0;
}



void clif_millenniumshield(struct block_list *bl, short shields ) {

 unsigned char buf[10];

 do { if (((void)(bl), 
# 17143 "../../../server-code/src/map/clif.c" 3 4
0
# 17143 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 WBUFW(buf,0) = 0x440;
 WBUFL(buf,2) = bl->id;
 WBUFW(buf,6) = shields;
 WBUFW(buf,8) = 0;
 clif->send(buf,packet_db[0x440].len,bl,AREA);

}






int clif_spellbook_list(struct map_session_data *sd)
{
 int i, c;
 int fd;

 do { if (((void)(sd), 
# 17162 "../../../server-code/src/map/clif.c" 3 4
0
# 17162 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);

 fd = sd->fd;
 WFIFOHEAD(fd, 8 * 8 + 8);
 WFIFOW(fd,0) = 0x1ad;

 for( i = 0, c = 0; i < 100; i ++ )
 {
  if( ((sd->status.inventory[i].nameid) >= ITEMID_MAGIC_BOOK_FB && (sd->status.inventory[i].nameid) <= ITEMID_MAGIC_BOOK_DL) )
  {
   WFIFOW(fd,c * 2 + 4) = sd->status.inventory[i].nameid;
   c++;
  }
 }

 if( c > 0 )
 {
  WFIFOW(fd,2) = c * 2 + 4;
  WFIFOSET(fd, WFIFOW(fd,2));
  sd->menuskill_id = WL_READING_SB;
  sd->menuskill_val = c;
 }
 else{
  (status->change_end_((&sd->bl),(SC_STOP),((-1)),"../../../server-code/src/map/clif.c",17185));
  clif->skill_fail(sd, WL_READING_SB, USESKILL_FAIL_SPELLBOOK, 0);
 }

 return 1;
}






int clif_magicdecoy_list(struct map_session_data *sd, uint16 skill_lv, short x, short y) {
 int i, c;
 int fd;

 do { if (((void)(sd), 
# 17201 "../../../server-code/src/map/clif.c" 3 4
0
# 17201 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);

 fd = sd->fd;
 WFIFOHEAD(fd, 8 * 8 + 8);
 WFIFOW(fd,0) = 0x1ad;

 for( i = 0, c = 0; i < 100; i ++ ) {
  if( ((sd->status.inventory[i].nameid) >= ITEMID_SCARLET_POINT && (sd->status.inventory[i].nameid) <= ITEMID_LIME_GREEN_POINT) ) {
   WFIFOW(fd,c * 2 + 4) = sd->status.inventory[i].nameid;
   c ++;
  }
 }
 if( c > 0 ) {
  sd->menuskill_id = NC_MAGICDECOY;
  sd->menuskill_val = skill_lv;
  sd->sc.comet_x = x;
  sd->sc.comet_y = y;
  WFIFOW(fd,2) = c * 2 + 4;
  WFIFOSET(fd, WFIFOW(fd,2));
 } else {
  clif->skill_fail(sd,NC_MAGICDECOY,USESKILL_FAIL_LEVEL,0);
  return 0;
 }

 return 1;
}






int clif_poison_list(struct map_session_data *sd, uint16 skill_lv) {
 int i, c;
 int fd;

 do { if (((void)(sd), 
# 17237 "../../../server-code/src/map/clif.c" 3 4
0
# 17237 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);

 fd = sd->fd;
 WFIFOHEAD(fd, 8 * 8 + 8);
 WFIFOW(fd,0) = 0x1ad;

 for( i = 0, c = 0; i < 100; i ++ ) {
  if( ((sd->status.inventory[i].nameid) >= ITEMID_POISON_PARALYSIS && (sd->status.inventory[i].nameid) <= ITEMID_POISON_FATIGUE) ) {
   WFIFOW(fd,c * 2 + 4) = sd->status.inventory[i].nameid;
   c ++;
  }
 }
 if( c > 0 ) {
  sd->menuskill_id = GC_POISONINGWEAPON;
  sd->menuskill_val = skill_lv;
  WFIFOW(fd,2) = c * 2 + 4;
  WFIFOSET(fd, WFIFOW(fd,2));
 } else {
  clif->skill_fail(sd,GC_POISONINGWEAPON,USESKILL_FAIL_GUILLONTINE_POISON,0);
  return 0;
 }

 return 1;
}
int clif_autoshadowspell_list(struct map_session_data *sd) {
 int fd, i, c;
 do { if (((void)(sd), 
# 17263 "../../../server-code/src/map/clif.c" 3 4
0
# 17263 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);
 fd = sd->fd;
 if( !fd ) return 0;

 if( sd->menuskill_id == SC_AUTOSHADOWSPELL )
  return 0;

 WFIFOHEAD(fd, 2 * 6 + 4);
 WFIFOW(fd,0) = 0x442;
 for( i = 0, c = 0; i < 1478; i++ )
  if( sd->status.skill[i].flag == SKILL_FLAG_PLAGIARIZED && sd->status.skill[i].id > 0 &&
    sd->status.skill[i].id < GS_GLITTERING && skill->get_type(sd->status.skill[i].id) == BF_MAGIC )
  {
   WFIFOW(fd,8+c*2) = sd->status.skill[i].id;
   c++;
  }

 if( c > 0 ) {
  WFIFOW(fd,2) = 8 + c * 2;
  WFIFOL(fd,4) = c;
  WFIFOSET(fd,WFIFOW(fd,2));
  sd->menuskill_id = SC_AUTOSHADOWSPELL;
  sd->menuskill_val = c;
 } else {
  (status->change_end_((&sd->bl),(SC_STOP),((-1)),"../../../server-code/src/map/clif.c",17287));
  clif->skill_fail(sd,SC_AUTOSHADOWSPELL,USESKILL_FAIL_IMITATION_SKILL_NONE,0);
 }

 return 1;
}




int clif_skill_itemlistwindow( struct map_session_data *sd, uint16 skill_id, uint16 skill_lv )
{

 int fd;

 do { if (((void)(sd), 
# 17302 "../../../server-code/src/map/clif.c" 3 4
0
# 17302 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);

 sd->menuskill_id = skill_id;
 sd->menuskill_val = skill_lv;

 if( skill_id == GN_CHANGEMATERIAL )
  skill_lv = 0;

 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x7e3].len);
 WFIFOW(fd,0) = 0x7e3;
 WFIFOL(fd,2) = skill_lv;
 WFIFOL(fd,4) = 0;
 WFIFOSET(fd,packet_db[0x7e3].len);



 return 1;

}

void clif_parse_SkillSelectMenu(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));




void clif_parse_SkillSelectMenu(int fd, struct map_session_data *sd) {

 if( sd->menuskill_id != SC_AUTOSHADOWSPELL )
  return;

 if( ( (sd)->npc_id || (sd)->state.vending || (sd)->state.buyingstore || (sd)->state.trading ) ) {
  clif->skill_fail(sd,sd->ud.skill_id,0,0);
  ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
  return;
 }

 skill->select_menu(sd,RFIFOW(fd,6));

 ((sd)->menuskill_id = (sd)->menuskill_val = (sd)->menuskill_val2 = 0);
}




void clif_charm(struct map_session_data *sd)
{
 unsigned char buf[10];

 do { if (((void)(sd), 
# 17351 "../../../server-code/src/map/clif.c" 3 4
0
# 17351 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WBUFW(buf,0) = 0x08cf;
 WBUFL(buf,2) = sd->bl.id;
 WBUFW(buf,6) = sd->charm_type;
 WBUFW(buf,8) = sd->charm_count;
 clif->send(buf,packet_db[0x08cf].len,&sd->bl,AREA);
}

void clif_parse_MoveItem(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));







void clif_parse_MoveItem(int fd, struct map_session_data *sd) {

 int index;


 if(( (sd)->state.dead_sit == 1 )) {
  return;
 }

 index = RFIFOW(fd,2)-2;

 if (index < 0 || index >= 100)
  return;

 if ( sd->status.inventory[index].favorite && RFIFOB(fd, 4) == 1 )
  sd->status.inventory[index].favorite = 0;
 else if( RFIFOB(fd, 4) == 0 )
  sd->status.inventory[index].favorite = 1;
 else
  return;

 clif->favorite_item(sd, index);

}


void clif_cashshop_db(void) {
 struct config_t cashshop_conf;
 struct config_setting_t *cashshop = 
# 17396 "../../../server-code/src/map/clif.c" 3 4
                                    ((void *)0)
# 17396 "../../../server-code/src/map/clif.c"
                                        , *cats = 
# 17396 "../../../server-code/src/map/clif.c" 3 4
                                                  ((void *)0)
# 17396 "../../../server-code/src/map/clif.c"
                                                      ;
 const char *config_filename = "db/cashshop_db.conf";
 int i, item_count_t = 0;
 for( i = 0; i < CASHSHOP_TAB_MAX; i++ ) {
  ((clif->cs.data[i]) = (struct hCSData * *) (iMalloc->calloc(((1)),(sizeof(struct hCSData *)),"../../../server-code/src/map/clif.c", 17400, __func__)));
  clif->cs.item_count[i] = 0;
 }

 if (!libconfig->load_file(&cashshop_conf, config_filename))
  return;

 cashshop = libconfig->lookup(&cashshop_conf, "cash_shop");

 if( cashshop != 
# 17409 "../../../server-code/src/map/clif.c" 3 4
                ((void *)0) 
# 17409 "../../../server-code/src/map/clif.c"
                     && (cats = libconfig->setting_get_elem(cashshop, 0)) != 
# 17409 "../../../server-code/src/map/clif.c" 3 4
                                                                             ((void *)0) 
# 17409 "../../../server-code/src/map/clif.c"
                                                                                  ) {
  for(i = 0; i < CASHSHOP_TAB_MAX; i++) {
   struct config_setting_t *cat;
   char entry_name[10];

   sprintf(entry_name,"cat_%d",i);

   if( (cat = libconfig->setting_get_member(cats, entry_name)) != 
# 17416 "../../../server-code/src/map/clif.c" 3 4
                                                                 ((void *)0) 
# 17416 "../../../server-code/src/map/clif.c"
                                                                      ) {
    int k, item_count = libconfig->setting_length(cat);

    for(k = 0; k < item_count; k++) {
     struct config_setting_t *entry = libconfig->setting_get_elem(cat,k);
     const char *name = ((entry)->name);
     int price = libconfig->setting_get_int(entry);
     struct item_data * data = 
# 17423 "../../../server-code/src/map/clif.c" 3 4
                              ((void *)0)
# 17423 "../../../server-code/src/map/clif.c"
                                  ;

     if( price < 1 ) {
      (showmsg->showWarning(("cashshop_db: unsupported price '%d' for entry named '%s' in category '%s'\n"), price, name, entry_name));
      continue;
     }

     if( name[0] == 'I' && name[1] == 'D' && strlen(name) <= 7 ) {
      if( !( data = itemdb->exists(atoi(name+2))) ) {
       (showmsg->showWarning(("cashshop_db: unknown item id '%s' in category '%s'\n"), name+2, entry_name));
       continue;
      }
     } else {
      if( !( data = itemdb->search_name(name) ) ) {
       (showmsg->showWarning(("cashshop_db: unknown item name '%s' in category '%s'\n"), name, entry_name));
       continue;
      }
     }

     ((clif->cs.data[i]) = (struct hCSData * *) (iMalloc->reallocz(((clif->cs.data[i])),(sizeof(struct hCSData *) * (++clif->cs.item_count[i])),"../../../server-code/src/map/clif.c", 17442, __func__)));
     ((clif->cs.data[i][ clif->cs.item_count[i] - 1 ]) = (struct hCSData *) (iMalloc->calloc(((1)),(sizeof(struct hCSData)),"../../../server-code/src/map/clif.c", 17443, __func__)));

     clif->cs.data[i][ clif->cs.item_count[i] - 1 ]->id = data->nameid;
     clif->cs.data[i][ clif->cs.item_count[i] - 1 ]->price = price;
     item_count_t++;
    }
   }
  }

 }
 libconfig->destroy(&cashshop_conf);
 (showmsg->showStatus(("Done reading '""\033[1;37m""%d""\033[0m""' entries in '""\033[1;37m""%s""\033[0m""'.\n"), item_count_t, config_filename));
}


void clif_favorite_item(struct map_session_data* sd, unsigned short index) {
 int fd;

 do { if (((void)(sd), 
# 17461 "../../../server-code/src/map/clif.c" 3 4
0
# 17461 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0x908].len);
 WFIFOW(fd,0) = 0x908;
 WFIFOW(fd,2) = index+2;
 WFIFOB(fd,4) = (sd->status.inventory[index].favorite == 1) ? 0 : 1;
 WFIFOSET(fd,packet_db[0x908].len);
}

void clif_snap( struct block_list *bl, short x, short y ) {
 unsigned char buf[10];

 do { if (((void)(bl), 
# 17473 "../../../server-code/src/map/clif.c" 3 4
0
# 17473 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 WBUFW(buf,0) = 0x8d2;
 WBUFL(buf,2) = bl->id;
 WBUFW(buf,6) = x;
 WBUFW(buf,8) = y;

 clif->send(buf,packet_db[0x8d2].len,bl,AREA);
}

void clif_monster_hp_bar( struct mob_data* md, struct map_session_data *sd ) {
 struct packet_monster_hp p;

 do { if (((void)(md), 
# 17485 "../../../server-code/src/map/clif.c" 3 4
0
# 17485 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(sd), 
# 17486 "../../../server-code/src/map/clif.c" 3 4
0
# 17486 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 p.PacketType = monsterhpType;
 p.GID = md->bl.id;
 p.HP = md->status.hp;
 p.MaxHP = md->status.max_hp;

 clif->send(&p, sizeof(p), &sd->bl, SELF);
}


void __attribute__ ((unused)) clif_parse_dull(int fd,struct map_session_data *sd) {
 return;
}

void clif_parse_CashShopOpen(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));
void clif_parse_CashShopOpen(int fd, struct map_session_data *sd) {

 if (map->list[sd->bl.m].flag.nocashshop) {
  clif->messagecolor_self(fd, 0xff0000U, atcommand->msgfd((fd),(1489)));
  return;
 }

 WFIFOHEAD(fd, 10);
 WFIFOW(fd,0) = 0x845;
 WFIFOL(fd, 2) = sd->cashPoints;
 WFIFOL(fd, 6) = sd->kafraPoints;
 WFIFOSET(fd, 10);
}

void clif_parse_CashShopClose(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));
void clif_parse_CashShopClose(int fd, struct map_session_data *sd) {

}

void clif_parse_CashShopSchedule(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));
void clif_parse_CashShopSchedule(int fd, struct map_session_data *sd) {
 int i, j = 0;

 for( i = 0; i < CASHSHOP_TAB_MAX; i++ ) {
  if( clif->cs.item_count[i] == 0 )
   continue;

  WFIFOHEAD(fd, 8 + ( clif->cs.item_count[i] * 6 ) );
  WFIFOW(fd,0) = 0x8ca;
  WFIFOW(fd,2) = 8 + ( clif->cs.item_count[i] * 6 );
  WFIFOW(fd,4) = clif->cs.item_count[i];
  WFIFOW(fd,6) = i;

  for( j = 0; j < clif->cs.item_count[i]; j++ ) {
   WFIFOW(fd,8 + ( 6 * j )) = clif->cs.data[i][j]->id;
   WFIFOL(fd, 10 + ( 6 * j ) ) = clif->cs.data[i][j]->price;
  }

  WFIFOSET(fd, 8 + ( clif->cs.item_count[i] * 6 ));
 }
}

void clif_parse_CashShopBuy(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));
void clif_parse_CashShopBuy(int fd, struct map_session_data *sd) {
 unsigned short limit = RFIFOW(fd, 4), i, j;
 unsigned int kafra_pay = RFIFOL(fd, 6);

 if (map->list[sd->bl.m].flag.nocashshop) {
  clif->messagecolor_self(fd, 0xff0000U, atcommand->msgfd((fd),(1489)));
  return;
 }

 for(i = 0; i < limit; i++) {
  int qty = RFIFOL(fd, 14 + ( i * 10 ));
  int id = RFIFOL(fd, 10 + ( i * 10 ));
  short tab = RFIFOW(fd, 18 + ( i * 10 ));
  enum CASH_SHOP_BUY_RESULT result = CSBR_UNKNOWN;

  if( tab < 0 || tab >= CASHSHOP_TAB_MAX )
   continue;

  for( j = 0; j < clif->cs.item_count[tab]; j++ ) {
   if( clif->cs.data[tab][j]->id == id )
    break;
  }
  if( j < clif->cs.item_count[tab] ) {
   struct item_data *data;
   if( sd->kafraPoints < kafra_pay ) {
    result = CSBR_SHORTTAGE_CASH;
   } else if( (sd->cashPoints+kafra_pay) < (clif->cs.data[tab][j]->price * qty) ) {
    result = CSBR_SHORTTAGE_CASH;
   } else if ( !( data = itemdb->exists(clif->cs.data[tab][j]->id) ) ) {
    result = CSBR_UNKONWN_ITEM;
   } else {
    struct item item_tmp;
    int k, get_count;

    get_count = qty;

    if (!itemdb->isstackable2(data))
     get_count = 1;

    pc->paycash(sd, clif->cs.data[tab][j]->price * qty, kafra_pay);
    for (k = 0; k < qty; k += get_count) {
     if (!pet->create_egg(sd, data->nameid)) {
      memset(&item_tmp, 0, sizeof(item_tmp));
      item_tmp.nameid = data->nameid;
      item_tmp.identify = 1;

      switch (pc->additem(sd, &item_tmp, get_count, LOG_TYPE_NPC)) {
       case 0:
        result = CSBR_SUCCESS;
        break;
       case 1:
        result = CSBR_EACHITEM_OVERCOUNT;
        break;
       case 2:
        result = CSBR_INVENTORY_WEIGHT;
        break;
       case 4:
        result = CSBR_INVENTORY_ITEMCNT;
        break;
       case 5:
        result = CSBR_EACHITEM_OVERCOUNT;
        break;
       case 7:
        result = CSBR_RUNE_OVERCOUNT;
        break;
      }

      if( result != CSBR_SUCCESS )
       pc->getcash(sd, clif->cs.data[tab][j]->price * get_count,0);
     } else
      result = CSBR_SUCCESS;
    }
   }
  } else {
   result = CSBR_UNKONWN_ITEM;
  }

  WFIFOHEAD(fd, 16);
  WFIFOW(fd,0) = 0x849;
  WFIFOL(fd, 2) = id;
  WFIFOW(fd,6) = result;
  WFIFOL(fd, 8) = sd->cashPoints;
  WFIFOL(fd, 12) = sd->kafraPoints;
  WFIFOSET(fd, 16);

 }
}

void clif_parse_CashShopReqTab(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));

void clif_parse_CashShopReqTab(int fd, struct map_session_data *sd) {
 short tab = RFIFOW(fd, 2);
 int j;

 if( tab < 0 || tab >= CASHSHOP_TAB_MAX || clif->cs.item_count[tab] == 0 )
  return;

 WFIFOHEAD(fd, 10 + ( clif->cs.item_count[tab] * 6 ) );
 WFIFOW(fd,0) = 0x8c0;
 WFIFOW(fd,2) = 10 + ( clif->cs.item_count[tab] * 6 );
 WFIFOL(fd, 4) = tab;
 WFIFOW(fd,8) = clif->cs.item_count[tab];

 for( j = 0; j < clif->cs.item_count[tab]; j++ ) {
  WFIFOW(fd,10 + ( 6 * j )) = clif->cs.data[tab][j]->id;
  WFIFOL(fd, 12 + ( 6 * j ) ) = clif->cs.data[tab][j]->price;
 }

 WFIFOSET(fd, 10 + ( clif->cs.item_count[tab] * 6 ));
}

void clif_maptypeproperty2(struct block_list *bl,enum send_target t) {

 struct packet_maptypeproperty2 p;
 struct map_session_data *sd = 
# 17658 "../../../server-code/src/map/clif.c" 3 4
                              ((void *)0)
# 17658 "../../../server-code/src/map/clif.c"
                                  ;
 do { if (((void)(bl), 
# 17659 "../../../server-code/src/map/clif.c" 3 4
0
# 17659 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 sd = ( ((bl) == (struct block_list *)
# 17661 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0) 
# 17661 "../../../server-code/src/map/clif.c"
     || (bl)->type != (BL_PC)) ? (TBL_PC *)
# 17661 "../../../server-code/src/map/clif.c" 3 4
     ((void *)0) 
# 17661 "../../../server-code/src/map/clif.c"
     : (TBL_PC *)(bl) );

 p.PacketType = maptypeproperty2Type;
 p.type = 0x28;
 p.flag.party = map->list[bl->m].flag.pvp ? 1 : 0;
 p.flag.guild = (map->list[bl->m].flag.battleground || (map->list[bl->m].flag.gvg || ((map->agit_flag || map->agit2_flag) && map->list[bl->m].flag.gvg_castle))) ? 1 : 0;
 p.flag.siege = (map->list[bl->m].flag.battleground || (map->list[bl->m].flag.gvg || map->list[bl->m].flag.gvg_castle)) ? 1: 0;
 p.flag.mineffect = (map->list[bl->m].flag.gvg || ((map->agit_flag || map->agit2_flag) && map->list[bl->m].flag.gvg_castle)) ? 1 : ( (sd && sd->state.lesseffect) ? 1 : 0);
 p.flag.nolockon = 0;
 p.flag.countpk = map->list[bl->m].flag.pvp ? 1 : 0;
 p.flag.nopartyformation = map->list[bl->m].flag.partylock ? 1 : 0;
 p.flag.bg = map->list[bl->m].flag.battleground ? 1 : 0;
 p.flag.nocostume = (map->list[bl->m].flag.noviewid & (EQP_COSTUME_HEAD_TOP|EQP_COSTUME_HEAD_MID|EQP_COSTUME_HEAD_LOW|EQP_COSTUME_GARMENT)) ? 1 : 0;
 p.flag.usecart = 1;
 p.flag.summonstarmiracle = 0;
 p.flag.SpareBits = 0;

 clif->send(&p,sizeof(p),bl,t);

}

void clif_status_change2(struct block_list *bl, int tid, enum send_target target, int type, int val1, int val2, int val3) {
 struct packet_status_change2 p;

 p.PacketType = status_change2Type;
 p.index = type;
 p.AID = tid;
 p.state = 1;
 p.Left = 9999;
 p.val1 = val1;
 p.val2 = val2;
 p.val3 = val3;

 clif->send(&p,sizeof(p), bl, target);
}

void clif_partytickack(struct map_session_data* sd, 
# 17697 "../../../server-code/src/map/clif.c" 3 4
                                                   _Bool 
# 17697 "../../../server-code/src/map/clif.c"
                                                        flag) {
 do { if (((void)(sd), 
# 17698 "../../../server-code/src/map/clif.c" 3 4
0
# 17698 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WFIFOHEAD(sd->fd, packet_db[0x2c9].len);
 WFIFOW(sd->fd,0) = 0x2c9;
 WFIFOB(sd->fd, 2) = flag;
 WFIFOSET(sd->fd, packet_db[0x2c9].len);
}

void clif_ShowScript(struct block_list* bl, const char* message) {
 char buf[256];
 size_t len;
 do { if (((void)(bl), 
# 17709 "../../../server-code/src/map/clif.c" 3 4
0
# 17709 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if(!message)
  return;

 len = strlen(message)+1;

 if (len > sizeof(buf)-8) {
  (showmsg->showWarning(("clif_ShowScript: Truncating too long message '%s' (len=%""z" "u"").\n"), message, len));
  len = sizeof(buf)-8;
 }

 WBUFW(buf,0)=0x8b3;
 WBUFW(buf,2)=len+8;
 WBUFL(buf,4)=bl->id;
 (strlib->safestrncpy_((WBUFP(buf,8)),(message),(len)));
 clif->send((unsigned char *) buf,WBUFW(buf,2),bl,ALL_CLIENT);
}

void clif_status_change_end(struct block_list *bl, int tid, enum send_target target, int type) {
 struct packet_status_change_end p;

 do { if (((void)(bl), 
# 17731 "../../../server-code/src/map/clif.c" 3 4
0
# 17731 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if (bl->type == BL_PC && !((TBL_PC *)BL_UCAST_(bl))->state.active)
  return;

 p.PacketType = status_change_endType;
 p.index = type;
 p.AID = tid;
 p.state = 0;

 clif->send(&p,sizeof(p), bl, target);
}

void clif_bgqueue_ack(struct map_session_data *sd, enum BATTLEGROUNDS_QUEUE_ACK response, unsigned char arena_id) {
 switch (response) {
  case BGQA_FAIL_COOLDOWN:
  case BGQA_FAIL_DESERTER:
  case BGQA_FAIL_TEAM_COUNT:
   break;
  default: {
   struct packet_bgqueue_ack p;

   do { if (((void)(sd), 
# 17753 "../../../server-code/src/map/clif.c" 3 4
  0
# 17753 "../../../server-code/src/map/clif.c"
  )) return; } while(0);
   p.PacketType = bgqueue_ackType;
   p.type = response;
   (strlib->safestrncpy_((p.bg_name),(bg->arena[arena_id]->name),(sizeof(p.bg_name))));

   clif->send(&p,sizeof(p), &sd->bl, SELF);
  }
   break;
 }
}

void clif_bgqueue_notice_delete(struct map_session_data *sd, enum BATTLEGROUNDS_QUEUE_NOTICE_DELETED response, const char *name)
{
 struct packet_bgqueue_notice_delete p;

 do { if (((void)(sd), 
# 17768 "../../../server-code/src/map/clif.c" 3 4
0
# 17768 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 p.PacketType = bgqueue_notice_deleteType;
 p.type = response;
 (strlib->safestrncpy_((p.bg_name),(name),(sizeof(p.bg_name))));

 clif->send(&p,sizeof(p), &sd->bl, SELF);
}

void clif_parse_bgqueue_register(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));
void clif_parse_bgqueue_register(int fd, struct map_session_data *sd)
{
 const struct packet_bgqueue_register *p = RP2PTR(fd);
 struct bg_arena *arena = 
# 17780 "../../../server-code/src/map/clif.c" 3 4
                         ((void *)0)
# 17780 "../../../server-code/src/map/clif.c"
                             ;
 if( !bg->queue_on ) return;

 if( !(arena = bg->name2arena(p->bg_name)) ) {
  clif->bgqueue_ack(sd,BGQA_FAIL_BGNAME_INVALID,0);
  return;
 }

 switch( (enum bg_queue_types)p->type ) {
  case BGQT_INDIVIDUAL:
  case BGQT_PARTY:
  case BGQT_GUILD:
   break;
  default:
   clif->bgqueue_ack(sd,BGQA_FAIL_TYPE_INVALID, arena->id);
   return;
 }

 bg->queue_add(sd, arena, (enum bg_queue_types)p->type);
}

void clif_bgqueue_update_info(struct map_session_data *sd, unsigned char arena_id, int position) {
 struct packet_bgqueue_update_info p;

 do { if (((void)(sd), 
# 17804 "../../../server-code/src/map/clif.c" 3 4
0
# 17804 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (( (arena_id < bg->arenas) ? 
# 17805 "../../../server-code/src/map/clif.c" 3 4
0 
# 17805 "../../../server-code/src/map/clif.c"
: (nullpo->assert_report("../../../server-code/src/map/clif.c", 17805, __func__, "arena_id < bg->arenas", "failed assertion"), 
# 17805 "../../../server-code/src/map/clif.c" 3 4
1
# 17805 "../../../server-code/src/map/clif.c"
) )) return; } while(0);
 p.PacketType = bgqueue_updateinfoType;
 (strlib->safestrncpy_((p.bg_name),(bg->arena[arena_id]->name),(sizeof(p.bg_name))));
 p.position = position;

 sd->bg_queue.client_has_bg_data = 
# 17810 "../../../server-code/src/map/clif.c" 3 4
                                  1
# 17810 "../../../server-code/src/map/clif.c"
                                      ;

 clif->send(&p,sizeof(p), &sd->bl, SELF);
}

void clif_parse_bgqueue_checkstate(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));
void clif_parse_bgqueue_checkstate(int fd, struct map_session_data *sd)
{
 const struct packet_bgqueue_checkstate *p = RP2PTR(fd);

 do { if (((void)(sd), 
# 17820 "../../../server-code/src/map/clif.c" 3 4
0
# 17820 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 if (sd->bg_queue.arena && sd->bg_queue.type) {
  clif->bgqueue_update_info(sd,sd->bg_queue.arena->id,bg->id2pos(sd->bg_queue.arena->queue_id,sd->status.account_id));
 } else {
  clif->bgqueue_notice_delete(sd, BGQND_FAIL_NOT_QUEUING,p->bg_name);
 }
}

void clif_parse_bgqueue_revoke_req(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));
void clif_parse_bgqueue_revoke_req(int fd, struct map_session_data *sd)
{
 const struct packet_bgqueue_revoke_req *p = RP2PTR(fd);

 if( sd->bg_queue.arena )
  bg->queue_pc_cleanup(sd);
 else
  clif->bgqueue_notice_delete(sd, BGQND_FAIL_NOT_QUEUING,p->bg_name);
}

void clif_parse_bgqueue_battlebegin_ack(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));
void clif_parse_bgqueue_battlebegin_ack(int fd, struct map_session_data *sd)
{
 const struct packet_bgqueue_battlebegin_ack *p = RP2PTR(fd);
 struct bg_arena *arena;

 if( !bg->queue_on ) return;

 if( ( arena = bg->name2arena(p->bg_name) ) ) {
  bg->queue_ready_ack(arena,sd, ( p->result == 1 ) ? 
# 17848 "../../../server-code/src/map/clif.c" 3 4
                                                    1 
# 17848 "../../../server-code/src/map/clif.c"
                                                         : 
# 17848 "../../../server-code/src/map/clif.c" 3 4
                                                           0
# 17848 "../../../server-code/src/map/clif.c"
                                                                );
 } else {
  clif->bgqueue_ack(sd,BGQA_FAIL_BGNAME_INVALID, 0);
 }
}

void clif_bgqueue_joined(struct map_session_data *sd, int pos) {
 struct packet_bgqueue_notify_entry p;

 do { if (((void)(sd), 
# 17857 "../../../server-code/src/map/clif.c" 3 4
0
# 17857 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 p.PacketType = bgqueue_notify_entryType;
 (strlib->safestrncpy_((p.name),(sd->status.name),(sizeof(p.name))));
 p.position = pos;

 clif->send(&p,sizeof(p), &sd->bl, BG_QUEUE);
}

void clif_bgqueue_pcleft(struct map_session_data *sd) {

 return;
}


void clif_bgqueue_battlebegins(struct map_session_data *sd, unsigned char arena_id, enum send_target target) {
 struct packet_bgqueue_battlebegins p;

 do { if (((void)(sd), 
# 17874 "../../../server-code/src/map/clif.c" 3 4
0
# 17874 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (( (arena_id < bg->arenas) ? 
# 17875 "../../../server-code/src/map/clif.c" 3 4
0 
# 17875 "../../../server-code/src/map/clif.c"
: (nullpo->assert_report("../../../server-code/src/map/clif.c", 17875, __func__, "arena_id < bg->arenas", "failed assertion"), 
# 17875 "../../../server-code/src/map/clif.c" 3 4
1
# 17875 "../../../server-code/src/map/clif.c"
) )) return; } while(0);
 p.PacketType = bgqueue_battlebeginsType;
 (strlib->safestrncpy_((p.bg_name),(bg->arena[arena_id]->name),(sizeof(p.bg_name))));
 (strlib->safestrncpy_((p.game_name),(bg->arena[arena_id]->name),(sizeof(p.game_name))));

 clif->send(&p,sizeof(p), &sd->bl, target);
}

void clif_scriptclear(struct map_session_data *sd, int npcid) {
 struct packet_script_clear p;

 do { if (((void)(sd), 
# 17886 "../../../server-code/src/map/clif.c" 3 4
0
# 17886 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 p.PacketType = script_clearType;
 p.NpcID = npcid;

 clif->send(&p,sizeof(p), &sd->bl, SELF);
}


void clif_package_item_announce(struct map_session_data *sd, unsigned short nameid, unsigned short containerid) {
 struct packet_package_item_announce p;

 do { if (((void)(sd), 
# 17897 "../../../server-code/src/map/clif.c" 3 4
0
# 17897 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 p.PacketType = package_item_announceType;
 p.PacketLength = 11+(23 + 1);
 p.type = 0x0;
 p.ItemID = nameid;
 p.len = (23 + 1);
 (strlib->safestrncpy_((p.Name),(sd->status.name),(sizeof(p.Name))));
 p.unknown = 0x2;
 p.BoxItemID = containerid;

 clif->send(&p,sizeof(p), &sd->bl, ALL_CLIENT);
}


void clif_item_drop_announce(struct map_session_data *sd, unsigned short nameid, char *monsterName) {
 struct packet_item_drop_announce p;

 do { if (((void)(sd), 
# 17914 "../../../server-code/src/map/clif.c" 3 4
0
# 17914 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 p.PacketType = item_drop_announceType;
 p.PacketLength = sizeof(p);
 p.type = 0x1;
 p.ItemID = nameid;
 p.len = (23 + 1);
 (strlib->safestrncpy_((p.Name),(sd->status.name),(sizeof(p.Name))));
 p.monsterNameLen = (23 + 1);
 (strlib->safestrncpy_((p.monsterName),(monsterName),(sizeof(p.monsterName))));

 clif->send(&p,sizeof(p), &sd->bl, ALL_CLIENT);
}


void clif_skill_cooldown_list(int fd, struct skill_cd* cd) {

 const int offset = 10;



 int i, count = 0;

 do { if (((void)(cd), 
# 17936 "../../../server-code/src/map/clif.c" 3 4
0
# 17936 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 WFIFOHEAD(fd,4+(offset*cd->cursor));


 WFIFOW(fd,0) = 0x985;




 for( i = 0; i < cd->cursor; i++ ) {
  if( cd->entry[i]->duration < 1 ) continue;

  WFIFOW(fd,4 + (count*offset)) = cd->entry[i]->skill_id;

  WFIFOL(fd, 6 + (count*offset)) = cd->entry[i]->total;
  WFIFOL(fd, 10 + (count*offset)) = cd->entry[i]->duration;



  count++;
 }

 WFIFOW(fd,2) = 4+(offset*count);

 WFIFOSET(fd,4+(offset*count));
}





void clif_cart_additem_ack(struct map_session_data *sd, int flag) {
 struct packet_cart_additem_ack p;

 do { if (((void)(sd), 
# 17971 "../../../server-code/src/map/clif.c" 3 4
0
# 17971 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 p.PacketType = cart_additem_ackType;
 p.result = (char)flag;

 clif->send(&p,sizeof(p), &sd->bl, SELF);
}


void clif_parse_BankDeposit(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));
void clif_parse_BankDeposit(int fd, struct map_session_data *sd)
{
 const struct packet_banking_deposit_req *p = RP2PTR(fd);
 int money;

 if (!battle_config.feature_banking) {
  clif->messagecolor_self(fd, 0xff0000U, atcommand->msgfd((fd),(1483)));
  return;
 }

 money = (int)(((p->Money) >= (0x7fffffff)) ? (0x7fffffff) : ((p->Money) <= (0)) ? (0) : (p->Money));

 pc->bank_deposit(sd,money);
}

void clif_parse_BankWithdraw(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));
void clif_parse_BankWithdraw(int fd, struct map_session_data *sd)
{
 const struct packet_banking_withdraw_req *p = RP2PTR(fd);
 int money;

 if (!battle_config.feature_banking) {
  clif->messagecolor_self(fd, 0xff0000U, atcommand->msgfd((fd),(1483)));
  return;
 }

 money = (int)(((p->Money) >= (0x7fffffff)) ? (0x7fffffff) : ((p->Money) <= (0)) ? (0) : (p->Money));

 pc->bank_withdraw(sd,money);
}

void clif_parse_BankCheck(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));
void clif_parse_BankCheck(int fd, struct map_session_data* sd) {
 struct packet_banking_check p;

 if (!battle_config.feature_banking) {
  clif->messagecolor_self(fd, 0xff0000U, atcommand->msgfd((fd),(1483)));
  return;
 }

 p.PacketType = banking_checkType;
 p.Money = (int)sd->status.bank_vault;
 p.Reason = (short)0;

 clif->send(&p,sizeof(p), &sd->bl, SELF);
}

void clif_parse_BankOpen(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));
void clif_parse_BankOpen(int fd, struct map_session_data* sd) {
 return;
}

void clif_parse_BankClose(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));
void clif_parse_BankClose(int fd, struct map_session_data* sd) {
 return;
}

void clif_bank_deposit(struct map_session_data *sd, enum e_BANKING_DEPOSIT_ACK reason) {
 struct packet_banking_deposit_ack p;

 do { if (((void)(sd), 
# 18040 "../../../server-code/src/map/clif.c" 3 4
0
# 18040 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 p.PacketType = banking_deposit_ackType;
 p.Balance = sd->status.zeny;
 p.Money = (int64)sd->status.bank_vault;
 p.Reason = (short)reason;

 clif->send(&p,sizeof(p), &sd->bl, SELF);
}

void clif_bank_withdraw(struct map_session_data *sd,enum e_BANKING_WITHDRAW_ACK reason) {
 struct packet_banking_withdraw_ack p;

 do { if (((void)(sd), 
# 18052 "../../../server-code/src/map/clif.c" 3 4
0
# 18052 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 p.PacketType = banking_withdraw_ackType;
 p.Balance = sd->status.zeny;
 p.Money = (int64)sd->status.bank_vault;
 p.Reason = (short)reason;

 clif->send(&p,sizeof(p), &sd->bl, SELF);
}



void clif_show_modifiers (struct map_session_data *sd) {
 do { if (((void)(sd), 
# 18064 "../../../server-code/src/map/clif.c" 3 4
0
# 18064 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 if( sd->status.mod_exp != 100 || sd->status.mod_drop != 100 || sd->status.mod_death != 100 ) {
  char output[128];

  snprintf(output,128,"Base EXP : %d%% | Base Drop: %d%% | Base Death Penalty: %d%%",
    sd->status.mod_exp,sd->status.mod_drop,sd->status.mod_death);
  clif->broadcast2(&sd->bl,output, strlen(output) + 1, 0xffbc90, 0x190, 12, 0, 0, SELF);
 }

}

void clif_notify_bounditem(struct map_session_data *sd, unsigned short index) {
 struct packet_notify_bounditem p;

 do { if (((void)(sd), 
# 18079 "../../../server-code/src/map/clif.c" 3 4
0
# 18079 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 p.PacketType = notify_bounditemType;
 p.index = index+2;

 clif->send(&p,sizeof(p), &sd->bl, SELF);
}

void clif_parse_GMFullStrip(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));



void clif_parse_GMFullStrip(int fd, struct map_session_data *sd) {
 struct map_session_data *tsd = map->id2sd(RFIFOL(fd,2));
 int i;


 if( !tsd || ( (tsd)->group->level ) >= ( (sd)->group->level ) )
  return;

 for( i = 0; i < EQI_MAX; i++ ) {
  if( tsd->equip_index[ i ] >= 0 )
   pc->unequipitem(tsd, tsd->equip_index[i], PCUNEQUIPITEM_FORCE);
 }
}




int clif_delay_damage_sub(int tid, int64 tick, int id, intptr_t data) {
 struct cdelayed_damage *dd = (struct cdelayed_damage *)data;

 clif->send(&dd->p,sizeof(struct packet_damage),&dd->bl,AREA_WOS);

 ((clif->delayed_damage_ers)->free((clif->delayed_damage_ers),(dd)));

 return 0;
}
# 18131 "../../../server-code/src/map/clif.c"
int clif_delay_damage(int64 tick, struct block_list *src, struct block_list *dst, int sdelay, int ddelay, int64 in_damage, short div, unsigned char type) {
 struct cdelayed_damage *dd;
 struct status_change *sc;



 int damage;


 do { if (((void)(src), 
# 18140 "../../../server-code/src/map/clif.c" 3 4
0
# 18140 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);
 do { if (((void)(dst), 
# 18141 "../../../server-code/src/map/clif.c" 3 4
0
# 18141 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);

 sc = status->get_sc(dst);

 if(sc && sc->count && sc->data[SC_ILLUSION]) {
  if(in_damage) in_damage = in_damage*(sc->data[SC_ILLUSION]->val2) + rnd()%100;
 }




 damage = (int)(((in_damage) < (0x7fffffff)) ? (in_damage) : (0x7fffffff));


 type = clif_calc_delay(type,div,damage,ddelay);

 dd = ((struct cdelayed_damage *)(clif->delayed_damage_ers)->alloc(clif->delayed_damage_ers));

 dd->p.PacketType = damageType;
 dd->p.GID = src->id;
 dd->p.targetGID = dst->id;
 dd->p.startTime = (uint32)timer->gettick();
 dd->p.attackMT = sdelay;
 dd->p.attackedMT = ddelay;
 dd->p.count = div;
 dd->p.action = type;
 dd->p.leftDamage = 0;

 if( battle_config.hide_woe_damage && (map->list[src->m].flag.gvg || map->list[src->m].flag.gvg_castle) )
  dd->p.damage = damage?div:0;
 else
  dd->p.damage = damage;

 dd->bl.m = dst->m;
 dd->bl.x = dst->x;
 dd->bl.y = dst->y;
 dd->bl.type = BL_NUL;

 if( tick > timer->gettick() )
  timer->add(tick,clif->delay_damage_sub,0,(intptr_t)dd);
 else {
  clif->send(&dd->p,sizeof(struct packet_damage),&dd->bl,AREA_WOS);

  ((clif->delayed_damage_ers)->free((clif->delayed_damage_ers),(dd)));
 }

 return clif->calc_walkdelay(dst,ddelay,type,damage,div);
}

void clif_parse_NPCShopClosed(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));

void clif_parse_NPCShopClosed(int fd, struct map_session_data *sd) {

 sd->npc_shopid = 0;
}


void clif_npc_market_open(struct map_session_data *sd, struct npc_data *nd) {

 struct npc_item_list *shop;
 unsigned short shop_size, i, c;

 do { if (((void)(sd), 
# 18203 "../../../server-code/src/map/clif.c" 3 4
0
# 18203 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(nd), 
# 18204 "../../../server-code/src/map/clif.c" 3 4
0
# 18204 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 shop = nd->u.scr.shop->item;
 shop_size = nd->u.scr.shop->items;
 npcmarket_open.PacketType = npcmarketopenType;

 for(i = 0, c = 0; i < shop_size; i++) {
  struct item_data *id = 
# 18210 "../../../server-code/src/map/clif.c" 3 4
                        ((void *)0)
# 18210 "../../../server-code/src/map/clif.c"
                            ;
  if (shop[i].nameid && (id = itemdb->exists(shop[i].nameid)) != 
# 18211 "../../../server-code/src/map/clif.c" 3 4
                                                                ((void *)0)
# 18211 "../../../server-code/src/map/clif.c"
                                                                    ) {
   npcmarket_open.list[c].nameid = shop[i].nameid;
   npcmarket_open.list[c].price = shop[i].value;
   npcmarket_open.list[c].qty = shop[i].qty;
   npcmarket_open.list[c].type = itemtype(id->type);
   npcmarket_open.list[c].view = ( id->view_id > 0 ) ? id->view_id : id->nameid;
   c++;
  }
 }

 npcmarket_open.PacketLength = 4 + ( sizeof(npcmarket_open.list[0]) * c );

 clif->send(&npcmarket_open,npcmarket_open.PacketLength,&sd->bl,SELF);

}

void clif_parse_NPCMarketClosed(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));
void clif_parse_NPCMarketClosed(int fd, struct map_session_data *sd) {

 sd->npc_shopid = 0;
}

void clif_npc_market_purchase_ack(struct map_session_data *sd, const struct itemlist *item_list, unsigned char response)
{

 unsigned short c = 0;

 do { if (((void)(sd), 
# 18238 "../../../server-code/src/map/clif.c" 3 4
0
# 18238 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 do { if (((void)(item_list), 
# 18239 "../../../server-code/src/map/clif.c" 3 4
0
# 18239 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 npcmarket_result.PacketType = npcmarketresultackType;
 npcmarket_result.result = response == 0 ? 1 : 0;

 if (npcmarket_result.result) {
  struct npc_data *nd = map->id2nd(sd->npc_shopid);
  struct npc_item_list *shop = nd->u.scr.shop->item;
  unsigned short shop_size = nd->u.scr.shop->items;
  int i;

  for (i = 0; i < ( (*item_list)._len_ ); i++) {
   const struct itemlist_entry *entry = &( ( (*item_list)._data_ )[i] );
   int j;

   npcmarket_result.list[i].ITID = entry->id;
   npcmarket_result.list[i].qty = entry->amount;

   do { for ((j) = (0); (j) < (shop_size); ++(j)) if (entry->id == shop[j].nameid) break; } while(
# 18256 "../../../server-code/src/map/clif.c" 3 4
  0
# 18256 "../../../server-code/src/map/clif.c"
  );

   npcmarket_result.list[i].price = (j != shop_size) ? shop[j].value : 0;

   c++;
  }
 }

 npcmarket_result.PacketLength = 5 + ( sizeof(npcmarket_result.list[0]) * c );;

 clif->send(&npcmarket_result,npcmarket_result.PacketLength,&sd->bl,SELF);

}

void clif_parse_NPCMarketPurchase(int fd, struct map_session_data *sd) __attribute__((nonnull (2)));
void clif_parse_NPCMarketPurchase(int fd, struct map_session_data *sd)
{

 const struct packet_npc_market_purchase *p = RP2PTR(fd);
 int response = 0, i;
 int count = (p->PacketLength - 4) / sizeof p->list[0];
 struct itemlist item_list;

 do { if (( (count >= 0 && count <= 100) ? 
# 18279 "../../../server-code/src/map/clif.c" 3 4
0 
# 18279 "../../../server-code/src/map/clif.c"
: (nullpo->assert_report("../../../server-code/src/map/clif.c", 18279, __func__, "count >= 0 && count <= 100", "failed assertion"), 
# 18279 "../../../server-code/src/map/clif.c" 3 4
1
# 18279 "../../../server-code/src/map/clif.c"
) )) return; } while(0);

 memset(&(item_list), 0, sizeof(item_list));
 do { int _empty_ = ( (item_list)._max_ )-( (item_list)._len_ ); if ((count) > _empty_) { while ((count) > _empty_) _empty_ += (1); do { if ((_empty_+( (item_list)._len_ )) > ( (item_list)._max_ )) { if (( (item_list)._max_ ) == 0) ( (item_list)._data_ ) = (iMalloc->malloc(((_empty_+( (item_list)._len_ ))*sizeof(( ( ( (item_list)._data_ )[0] ) ))),"../../../server-code/src/map/clif.c", 18282, __func__)); else ( (item_list)._data_ ) = (iMalloc->realloc((( (item_list)._data_ )),((_empty_+( (item_list)._len_ ))*sizeof(( ( ( (item_list)._data_ )[0] ) ))),"../../../server-code/src/map/clif.c", 18282, __func__)); memset(( (item_list)._data_ )+( (item_list)._len_ ), 0, (( (item_list)._max_ )-( (item_list)._len_ ))*sizeof(( ( ( (item_list)._data_ )[0] ) ))); ( (item_list)._max_ ) = (_empty_+( (item_list)._len_ )); } else if ((_empty_+( (item_list)._len_ )) == 0 && ( (item_list)._max_ ) > 0) { (iMalloc->free((( (item_list)._data_ )),"../../../server-code/src/map/clif.c", 18282, __func__)); ( (item_list)._data_ ) = 
# 18282 "../../../server-code/src/map/clif.c" 3 4
((void *)0)
# 18282 "../../../server-code/src/map/clif.c"
; ( (item_list)._max_ ) = 0; ( (item_list)._len_ ) = 0; } else if ((_empty_+( (item_list)._len_ )) < ( (item_list)._max_ )) { ( (item_list)._data_ ) = (iMalloc->realloc((( (item_list)._data_ )),((_empty_+( (item_list)._len_ ))*sizeof(( ( ( (item_list)._data_ )[0] ) ))),"../../../server-code/src/map/clif.c", 18282, __func__)); ( (item_list)._max_ ) = (_empty_+( (item_list)._len_ )); if ((_empty_+( (item_list)._len_ )) - ( (item_list)._len_ ) > 0) ( (item_list)._len_ ) = (_empty_+( (item_list)._len_ )); } } while(
# 18282 "../../../server-code/src/map/clif.c" 3 4
0
# 18282 "../../../server-code/src/map/clif.c"
); } } while(
# 18282 "../../../server-code/src/map/clif.c" 3 4
0
# 18282 "../../../server-code/src/map/clif.c"
);

 for (i = 0; i < count; i++) {
  struct itemlist_entry entry = { 0 };

  entry.id = p->list[i].ITID;
  entry.amount = p->list[i].qty;

  do { ( ( (item_list)._data_ )[( (item_list)._len_ )] ) = (entry); ++( (item_list)._len_ ); }while(
# 18290 "../../../server-code/src/map/clif.c" 3 4
 0
# 18290 "../../../server-code/src/map/clif.c"
 );
 }

 response = npc->market_buylist(sd, &item_list);
 clif->npc_market_purchase_ack(sd, &item_list, response);

 do { if (( (item_list)._max_ ) > 0) { (iMalloc->free((( (item_list)._data_ )),"../../../server-code/src/map/clif.c", 18296, __func__)); ( (item_list)._data_ ) = 
# 18296 "../../../server-code/src/map/clif.c" 3 4
((void *)0)
# 18296 "../../../server-code/src/map/clif.c"
; ( (item_list)._max_ ) = 0; ( (item_list)._len_ ) = 0; } } while(
# 18296 "../../../server-code/src/map/clif.c" 3 4
0
# 18296 "../../../server-code/src/map/clif.c"
);

}

void clif_PartyLeaderChanged(struct map_session_data *sd, int prev_leader_aid, int new_leader_aid) {
 struct packet_party_leader_changed p;

 do { if (((void)(sd), 
# 18303 "../../../server-code/src/map/clif.c" 3 4
0
# 18303 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 p.PacketType = partyleaderchangedType;

 p.prev_leader_aid = prev_leader_aid;
 p.new_leader_aid = new_leader_aid;

 clif->send(&p,sizeof(p),&sd->bl,PARTY);
}

void clif_parse_RouletteOpen(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));

void clif_parse_RouletteOpen(int fd, struct map_session_data* sd) {
 struct packet_roulette_open_ack p;

 if( !battle_config.feature_roulette ) {
  clif->message(fd,"Roulette is disabled");
  return;
 }

 p.PacketType = 0xa1a;
 p.Result = 0;
 p.Serial = 0;
 p.Step = sd->roulette.stage - 1;
 p.Idx = (char)sd->roulette.prizeIdx;
 p.AdditionItemID = -1;
 p.BronzePoint = (pc->readregistry((sd),(script->add_str("TmpRouletteBronze"))));
 p.GoldPoint = (pc->readregistry((sd),(script->add_str("TmpRouletteGold"))));
 p.SilverPoint = (pc->readregistry((sd),(script->add_str("TmpRouletteSilver"))));

 clif->send(&p,sizeof(p), &sd->bl, SELF);
}

void clif_parse_RouletteInfo(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));
void clif_parse_RouletteInfo(int fd, struct map_session_data* sd) {
 struct packet_roulette_info_ack p;
 unsigned short i, j, count = 0;

 if( !battle_config.feature_roulette ) {
  clif->message(fd,"Roulette is disabled");
  return;
 }

 p.PacketType = rouletteinfoackType;
 p.PacketLength = 8 + (42 * 8);
 p.RouletteSerial = 1;

 for(i = 0; i < 7; i++) {
  for(j = 0; j < 9 -i; j++) {
   p.ItemInfo[count].Row = i;
   p.ItemInfo[count].Position = j;
   p.ItemInfo[count].ItemId = clif->rd.nameid[i][j];
   p.ItemInfo[count].Count = clif->rd.qty[i][j];
   count++;
  }
 }
 clif->send(&p,sizeof(p), &sd->bl, SELF);
 return;
}

void clif_parse_RouletteClose(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));
void clif_parse_RouletteClose(int fd, struct map_session_data* sd) {
 if( !battle_config.feature_roulette ) {
  clif->message(fd,"Roulette is disabled");
  return;
 }




 return;
}

void clif_parse_RouletteGenerate(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));
void clif_parse_RouletteGenerate(int fd, struct map_session_data* sd) {
 unsigned char result = GENERATE_ROULETTE_SUCCESS;
 short stage = sd->roulette.stage;

 if( !battle_config.feature_roulette ) {
  clif->message(fd,"Roulette is disabled");
  return;
 }

 if( sd->roulette.stage >= 7 )
  stage = sd->roulette.stage = 0;

 if( stage == 0 ) {
  if( (pc->readregistry((sd),(script->add_str("TmpRouletteBronze")))) <= 0 &&
      (pc->readregistry((sd),(script->add_str("TmpRouletteSilver")))) < 10 &&
      (pc->readregistry((sd),(script->add_str("TmpRouletteGold")))) < 10 )
   result = GENERATE_ROULETTE_NO_ENOUGH_POINT;
 }

 if( result == GENERATE_ROULETTE_SUCCESS ) {
  if( stage == 0 ) {
   if( (pc->readregistry((sd),(script->add_str("TmpRouletteBronze")))) > 0 ) {
    (pc->setregistry((sd),(script->add_str("TmpRouletteBronze")),((pc->readregistry((sd),(script->add_str("TmpRouletteBronze")))) - 1)));
   } else if( (pc->readregistry((sd),(script->add_str("TmpRouletteSilver")))) > 9 ) {
    (pc->setregistry((sd),(script->add_str("TmpRouletteSilver")),((pc->readregistry((sd),(script->add_str("TmpRouletteSilver")))) - 10)));
    stage = sd->roulette.stage = 2;
   } else if( (pc->readregistry((sd),(script->add_str("TmpRouletteGold")))) > 9 ) {
    (pc->setregistry((sd),(script->add_str("TmpRouletteGold")),((pc->readregistry((sd),(script->add_str("TmpRouletteGold")))) - 10)));
    stage = sd->roulette.stage = 4;
   }
  }
  sd->roulette.prizeStage = stage;
  sd->roulette.prizeIdx = rnd()%clif->rd.items[stage];
  if( sd->roulette.prizeIdx == 0 ) {
   struct item it;
   memset(&it, 0, sizeof(it));

   it.nameid = clif->rd.nameid[stage][0];
   it.identify = 1;

   pc->additem(sd, &it, clif->rd.qty[stage][0], LOG_TYPE_ROULETTE);

   sd->roulette.stage = 0;
   result = GENERATE_ROULETTE_LOSING;
  } else
   sd->roulette.claimPrize = 
# 18421 "../../../server-code/src/map/clif.c" 3 4
                            1
# 18421 "../../../server-code/src/map/clif.c"
                                ;
 }

 clif->roulette_generate_ack(sd,result,stage,sd->roulette.prizeIdx,0);
 if( result == GENERATE_ROULETTE_SUCCESS )
  sd->roulette.stage++;
}

void clif_parse_RouletteRecvItem(int fd, struct map_session_data* sd) __attribute__((nonnull (2)));



void clif_parse_RouletteRecvItem(int fd, struct map_session_data* sd) {
 struct packet_roulette_itemrecv_ack p;

 if( !battle_config.feature_roulette ) {
  clif->message(fd,"Roulette is disabled");
  return;
 }

 p.PacketType = roulettercvitemackType;
 p.AdditionItemID = 0;

 if( sd->roulette.claimPrize ) {
  struct item it;
  memset(&it, 0, sizeof(it));

  it.nameid = clif->rd.nameid[sd->roulette.prizeStage][sd->roulette.prizeIdx];
  it.identify = 1;

  switch (pc->additem(sd, &it, clif->rd.qty[sd->roulette.prizeStage][sd->roulette.prizeIdx], LOG_TYPE_ROULETTE)) {
   case 0:
    p.Result = RECV_ITEM_SUCCESS;
    sd->roulette.claimPrize = 
# 18454 "../../../server-code/src/map/clif.c" 3 4
                             0
# 18454 "../../../server-code/src/map/clif.c"
                                  ;
    sd->roulette.prizeStage = 0;
    sd->roulette.prizeIdx = 0;
    sd->roulette.stage = 0;
    break;
   case 1:
   case 4:
   case 5:
    p.Result = RECV_ITEM_OVERCOUNT;
    break;
   case 2:
    p.Result = RECV_ITEM_OVERWEIGHT;
    break;
   default:
   case 7:
    p.Result = RECV_ITEM_FAILED;
    break;
  }
 } else
  p.Result = RECV_ITEM_FAILED;

 clif->send(&p,sizeof(p), &sd->bl, SELF);
 return;
}


# 18479 "../../../server-code/src/map/clif.c" 3 4
_Bool 
# 18479 "../../../server-code/src/map/clif.c"
    clif_parse_roulette_db(void) {
 struct config_t roulette_conf;
 struct config_setting_t *roulette = 
# 18481 "../../../server-code/src/map/clif.c" 3 4
                                    ((void *)0)
# 18481 "../../../server-code/src/map/clif.c"
                                        , *levels = 
# 18481 "../../../server-code/src/map/clif.c" 3 4
                                                    ((void *)0)
# 18481 "../../../server-code/src/map/clif.c"
                                                        ;
 const char *config_filename = "db/roulette_db.conf";
 int i, j, item_count_t = 0;

 for( i = 0; i < 7; i++ ) {
  clif->rd.items[i] = 0;
 }

 if (!libconfig->load_file(&roulette_conf, config_filename))
  return 
# 18490 "../../../server-code/src/map/clif.c" 3 4
        0
# 18490 "../../../server-code/src/map/clif.c"
             ;
 roulette = libconfig->lookup(&roulette_conf, "roulette");

 if( roulette != 
# 18493 "../../../server-code/src/map/clif.c" 3 4
                ((void *)0) 
# 18493 "../../../server-code/src/map/clif.c"
                     && (levels = libconfig->setting_get_elem(roulette, 0)) != 
# 18493 "../../../server-code/src/map/clif.c" 3 4
                                                                               ((void *)0) 
# 18493 "../../../server-code/src/map/clif.c"
                                                                                    ) {
  for(i = 0; i < 7; i++) {
   struct config_setting_t *level;
   char entry_name[10];

   sprintf(entry_name,"level_%d",i+1);

   if( (level = libconfig->setting_get_member(levels, entry_name)) != 
# 18500 "../../../server-code/src/map/clif.c" 3 4
                                                                     ((void *)0) 
# 18500 "../../../server-code/src/map/clif.c"
                                                                          ) {
    int k, item_count = libconfig->setting_length(level);

    for(k = 0; k < item_count; k++) {
     struct config_setting_t *entry = libconfig->setting_get_elem(level,k);
     const char *name = ((entry)->name);
     int qty = libconfig->setting_get_int(entry);
     struct item_data * data = 
# 18507 "../../../server-code/src/map/clif.c" 3 4
                              ((void *)0)
# 18507 "../../../server-code/src/map/clif.c"
                                  ;

     if( qty < 1 ) {
      (showmsg->showWarning(("roulette_db: unsupported qty '%d' for entry named '%s' in category '%s'\n"), qty, name, entry_name));
      continue;
     }

     if( name[0] == 'I' && name[1] == 'D' && strlen(name) <= 7 ) {
      if( !( data = itemdb->exists(atoi(name+2))) ) {
       (showmsg->showWarning(("roulette_db: unknown item id '%s' in category '%s'\n"), name+2, entry_name));
       continue;
      }
     } else {
      if( !( data = itemdb->search_name(name) ) ) {
       (showmsg->showWarning(("roulette_db: unknown item name '%s' in category '%s'\n"), name, entry_name));
       continue;
      }
     }

     j = clif->rd.items[i];
     ((clif->rd.nameid[i]) = (int *) (iMalloc->reallocz(((clif->rd.nameid[i])),(sizeof(int) * (++clif->rd.items[i])),"../../../server-code/src/map/clif.c", 18527, __func__)));
     ((clif->rd.qty[i]) = (int *) (iMalloc->reallocz(((clif->rd.qty[i])),(sizeof(int) * (clif->rd.items[i])),"../../../server-code/src/map/clif.c", 18528, __func__)));

     clif->rd.nameid[i][j] = data->nameid;
     clif->rd.qty[i][j] = qty;

     item_count_t++;
    }
   }
  }
 }
 libconfig->destroy(&roulette_conf);

 for(i = 0; i < 7; i++) {
  int limit = 9 -i;
  if( clif->rd.items[i] == limit ) continue;

  if( clif->rd.items[i] > limit ) {
   (showmsg->showWarning(("roulette_db: level %d has %d items, only %d supported, capping...\n"),i+1,clif->rd.items[i],limit));
   clif->rd.items[i] = limit;
   continue;
  }

  (showmsg->showWarning(("roulette_db: level %d has %d items, %d are required. filling with apples\n"),i+1,clif->rd.items[i],limit));

  clif->rd.items[i] = limit;
  ((clif->rd.nameid[i]) = (int *) (iMalloc->reallocz(((clif->rd.nameid[i])),(sizeof(int) * (clif->rd.items[i])),"../../../server-code/src/map/clif.c", 18553, __func__)));
  ((clif->rd.qty[i]) = (int *) (iMalloc->reallocz(((clif->rd.qty[i])),(sizeof(int) * (clif->rd.items[i])),"../../../server-code/src/map/clif.c", 18554, __func__)));

  for(j = 0; j < 9 -i; j++) {
   if (clif->rd.qty[i][j])
    continue;
   clif->rd.nameid[i][j] = ITEMID_APPLE;
   clif->rd.qty[i][j] = 1;
  }
 }
 (showmsg->showStatus(("Done reading '""\033[1;37m""%d""\033[0m""' entries in '""\033[1;37m""%s""\033[0m""'.\n"), item_count_t, config_filename));

 return 
# 18565 "../../../server-code/src/map/clif.c" 3 4
       1
# 18565 "../../../server-code/src/map/clif.c"
           ;
}




void clif_roulette_generate_ack(struct map_session_data *sd, unsigned char result, short stage, short prizeIdx, short bonusItemID) {
 struct packet_roulette_generate_ack p;

 do { if (((void)(sd), 
# 18574 "../../../server-code/src/map/clif.c" 3 4
0
# 18574 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 p.PacketType = roulettgenerateackType;
 p.Result = result;
 p.Step = stage;
 p.Idx = prizeIdx;
 p.AdditionItemID = bonusItemID;
 p.RemainBronze = (pc->readregistry((sd),(script->add_str("TmpRouletteBronze"))));
 p.RemainGold = (pc->readregistry((sd),(script->add_str("TmpRouletteGold"))));
 p.RemainSilver = (pc->readregistry((sd),(script->add_str("TmpRouletteSilver"))));

 clif->send(&p,sizeof(p), &sd->bl, SELF);
}




void clif_openmergeitem(int fd, struct map_session_data *sd)
{
 int i = 0, n = 0, j = 0;
 struct merge_item merge_items[100];
 struct merge_item *merge_items_[100] = {0};

 do { if (((void)(sd), 
# 18596 "../../../server-code/src/map/clif.c" 3 4
0
# 18596 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 memset(&merge_items,'\0',sizeof(merge_items));

 for (i = 0; i < 100; i++) {
  struct item *item_data = &sd->status.inventory[i];

  if (item_data->nameid == 0 || !itemdb->isstackable(item_data->nameid) || item_data->bound != IBT_NONE)
   continue;

  merge_items[n].nameid = item_data->nameid;
  merge_items[n].position = i + 2;
  n++;
 }

 qsort(merge_items,n,sizeof(struct merge_item),clif->comparemergeitem);

 for (i = 0, j = 0; i < n; i++) {
  if (i > 0 && merge_items[i].nameid == merge_items[i-1].nameid)
  {
   merge_items_[j] = &merge_items[i];
   j++;
   continue;
  }

  if (i < n - 1 && merge_items[i].nameid == merge_items[i+1].nameid)
  {
   merge_items_[j] = &merge_items[i];
   j++;
   continue;
  }
 }

 WFIFOHEAD(fd,2*j+4);
 WFIFOW(fd,0) = 0x96d;
 WFIFOW(fd,2) = 2*j+4;
 for ( i = 0; i < j; i++ )
  WFIFOW(fd,i*2+4) = merge_items_[i]->position;
 WFIFOSET(fd,2*j+4);
}

int clif_comparemergeitem(const void *a, const void *b)
{
 const struct merge_item *a_ = a;
 const struct merge_item *b_ = b;

 do { if (((void)(a), 
# 18641 "../../../server-code/src/map/clif.c" 3 4
0
# 18641 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);
 do { if (((void)(b), 
# 18642 "../../../server-code/src/map/clif.c" 3 4
0
# 18642 "../../../server-code/src/map/clif.c"
)) return(0); } while(0);
 if (a_->nameid == b_->nameid)
  return 0;
 return a_->nameid > b_->nameid ? -1 : 1;
}

void clif_ackmergeitems(int fd, struct map_session_data *sd)
{
 int i = 0, n = 0, length = 0, count = 0;
 int16 nameid = 0, indexes[100] = {0}, amounts[100] = {0};
 struct item item_data;

 do { if (((void)(sd), 
# 18654 "../../../server-code/src/map/clif.c" 3 4
0
# 18654 "../../../server-code/src/map/clif.c"
)) return; } while(0);
 length = (RFIFOW(fd,2) - 4)/2;

 if (length >= 100 || length < 2) {
  WFIFOHEAD(fd,7);
  WFIFOW(fd,0) = 0x96f;
  WFIFOW(fd,2) = 0;
  WFIFOW(fd,4) = 0;
  WFIFOB(fd,6) = MERGEITEM_FAILD;
  WFIFOSET(fd,7);
  return;
 }

 for (i = 0, n = 0; i < length; i++) {
  int16 idx = RFIFOW(fd,i*2+4) - 2;
  struct item *it = 
# 18669 "../../../server-code/src/map/clif.c" 3 4
                   ((void *)0)
# 18669 "../../../server-code/src/map/clif.c"
                       ;

  if (idx < 0 || idx >= 100)
   continue;

  it = &sd->status.inventory[idx];

  if (it->nameid == 0 || !itemdb->isstackable(it->nameid) || it->bound != IBT_NONE)
   continue;

  if (nameid == 0)
   nameid = it->nameid;

  if (nameid != it->nameid)
   continue;

  count += it->amount;
  indexes[n] = idx;
  amounts[n] = it->amount;
  n++;
 }

 if (n < 2 || count == 0) {
  WFIFOHEAD(fd,7);
  WFIFOW(fd,0) = 0x96f;
  WFIFOW(fd,2) = 0;
  WFIFOW(fd,4) = 0;
  WFIFOB(fd,6) = MERGEITEM_FAILD;
  WFIFOSET(fd,7);
  return;
 }

 if (count > 30000) {
  WFIFOHEAD(fd,7);
  WFIFOW(fd,0) = 0x96f;
  WFIFOW(fd,2) = 0;
  WFIFOW(fd,4) = 0;
  WFIFOB(fd,6) = MERGEITEM_MAXCOUNTFAILD;
  WFIFOSET(fd,7);
  return;
 }

 for (i = 0; i < n; i++)
  pc->delitem(sd,indexes[i],amounts[i],0,DELITEM_NORMAL,LOG_TYPE_NPC);

 memset(&item_data,'\0',sizeof(item_data));

 item_data.nameid = nameid;
 item_data.identify = 1;
 item_data.unique_id = itemdb->unique_id(sd);
 pc->additem(sd,&item_data,count,LOG_TYPE_NPC);

 do { for ((i) = (0); (i) < (100); ++(i)) if (item_data.unique_id == sd->status.inventory[i].unique_id) break; } while(
# 18721 "../../../server-code/src/map/clif.c" 3 4
0
# 18721 "../../../server-code/src/map/clif.c"
);

 WFIFOHEAD(fd,7);
 WFIFOW(fd,0) = 0x96f;
 WFIFOW(fd,2) = i+2;
 WFIFOW(fd,4) = count;
 WFIFOB(fd,6) = MERGEITEM_SUCCESS;
 WFIFOSET(fd,7);
}

void clif_cancelmergeitem (int fd, struct map_session_data *sd)
{

 return;
}

void clif_dressroom_open(struct map_session_data *sd, int view)
{
 int fd;

 do { if (((void)(sd), 
# 18741 "../../../server-code/src/map/clif.c" 3 4
0
# 18741 "../../../server-code/src/map/clif.c"
)) return; } while(0);

 fd = sd->fd;
 WFIFOHEAD(fd,packet_db[0xa02].len);
 WFIFOW(fd,0)=0xa02;
 WFIFOW(fd,2)=view;
 WFIFOSET(fd,packet_db[0xa02].len);
}



void clif_selectcart(struct map_session_data *sd)
{
# 18770 "../../../server-code/src/map/clif.c"
}







const char *clif_get_bl_name(const struct block_list *bl)
{
 const char *name = status->get_name(bl);

 if (name == 
# 18782 "../../../server-code/src/map/clif.c" 3 4
            ((void *)0)
# 18782 "../../../server-code/src/map/clif.c"
                )
  return "Unknown";

 return name;
}


unsigned short clif_decrypt_cmd( int cmd, struct map_session_data *sd ) {
 if( sd ) {
  return (cmd ^ ((sd->cryptKey >> 16) & 0x7FFF));
 }
 return (cmd ^ (((( clif->cryptKey[0] * clif->cryptKey[1] ) + clif->cryptKey[2]) >> 16) & 0x7FFF));
}

unsigned short clif_parse_cmd_normal( int fd, struct map_session_data *sd ) {
 unsigned short cmd = RFIFOW(fd,0);

 return cmd;
}

unsigned short clif_parse_cmd_decrypt( int fd, struct map_session_data *sd ) {
 unsigned short cmd = RFIFOW(fd,0);

 cmd = clif->decrypt_cmd(cmd, sd);

 return cmd;
}

unsigned short clif_parse_cmd_optional( int fd, struct map_session_data *sd ) {
 unsigned short cmd = RFIFOW(fd,0);


 if( cmd > 0x0F00 || cmd < 0x0064 || packet_db[cmd].len == 0 ) {
  if( sd )
   sd->parse_cmd_func = clif_parse_cmd_decrypt;
  return clif_parse_cmd_decrypt(fd, sd);
 } else if( sd ) {
  sd->parse_cmd_func = clif_parse_cmd_normal;
 }

 return cmd;
}




int clif_parse(int fd) {
 int cmd, packet_len;
 struct map_session_data *sd;
 int pnum;




 for( pnum = 0; pnum < 3; ++pnum ) {
  unsigned short (*parse_cmd_func)(int fd, struct map_session_data *sd);


  sd = sockt->session[fd]->session_data;

  if (sockt->session[fd]->flag.eof) {
   if (sd) {
    if (sd->state.autotrade) {

     sockt->session[fd]->session_data = 
# 18846 "../../../server-code/src/map/clif.c" 3 4
                                       ((void *)0)
# 18846 "../../../server-code/src/map/clif.c"
                                           ;
     sd->fd = 0;
     (showmsg->showInfo(("Character '""\033[1;37m""%s""\033[0m""' logged off (using @autotrade).\n"), sd->status.name));
    } else
     if (sd->state.active) {

      (showmsg->showInfo(("Character '""\033[1;37m""%s""\033[0m""' logged off.\n"), sd->status.name));
      clif->quitsave(fd, sd);
     } else {

      (showmsg->showInfo(("Player AID:%d/CID:%d logged off.\n"), sd->status.account_id, sd->status.char_id));
      map->quit(sd);
     }
   } else {
    (showmsg->showInfo(("Closed connection from '""\033[1;37m""%s""\033[0m""'.\n"), sockt->ip2str(sockt->session[fd]->client_addr, 
# 18860 "../../../server-code/src/map/clif.c" 3 4
   ((void *)0)
# 18860 "../../../server-code/src/map/clif.c"
   )));
   }
   sockt->close(fd);
   return 0;
  }

  if (RFIFOREST(fd) < 2)
   return 0;

  if (sd)
   parse_cmd_func = sd->parse_cmd_func;
  else
   parse_cmd_func = clif->parse_cmd;

  cmd = parse_cmd_func(fd,sd);

  if (( (HPM->packets[hpClif_Parse])._len_ ) > 0) {
   int result = HPM->parse_packets(fd,cmd,hpClif_Parse);
   if (result == 1)
    continue;
   if (result == 2)
    return 0;
  }


  if (cmd > 0x0F00 || cmd < 0x0064 || packet_db[cmd].len == 0) {
   (showmsg->showWarning(("clif_parse: Received unsupported packet (packet 0x%04x (0x%04x), %""z" "u"" bytes received), disconnecting session #%d.\n"), (unsigned int)cmd, RFIFOW(fd,0), RFIFOREST(fd), fd))
                                                                  ;



   sockt->eof(fd);
   return 0;
  }


  if ( ( packet_len = packet_db[cmd].len ) == -1) {

   if (RFIFOREST(fd) < 4)
    return 0;

   packet_len = RFIFOW(fd,2);
   if (packet_len < 4 || packet_len > 32768) {
    (showmsg->showWarning(("clif_parse: Received packet 0x%04x specifies invalid packet_len (%d), disconnecting session #%d.\n"), (unsigned int)cmd, packet_len, fd));



    sockt->eof(fd);

    return 0;
   }
  }

  if ((int)RFIFOREST(fd) < packet_len)
   return 0;

  if( battle_config.packet_obfuscation == 2 || cmd != RFIFOW(fd, 0) || (sd && sd->parse_cmd_func == clif_parse_cmd_decrypt) ) {


   int16 *packet_id = ((void *)(sockt->session[fd]->rdata + sockt->session[fd]->rdata_pos + (0)));

   *packet_id = cmd;
   if( sd ) {
    sd->cryptKey = (( sd->cryptKey * clif->cryptKey[1] ) + clif->cryptKey[2]) & 0xFFFFFFFF;
   }
  }

  if( packet_db[cmd].func == clif->pDebug )
   packet_db[cmd].func(fd, sd);
  else if( packet_db[cmd].func != 
# 18929 "../../../server-code/src/map/clif.c" 3 4
                                 ((void *)0) 
# 18929 "../../../server-code/src/map/clif.c"
                                      ) {
   if( !sd && packet_db[cmd].func != clif->pWantToConnection )
    ;
   else
    if( sd && sd->bl.prev == 
# 18933 "../../../server-code/src/map/clif.c" 3 4
                            ((void *)0) 
# 18933 "../../../server-code/src/map/clif.c"
                                 && packet_db[cmd].func != clif->pLoadEndAck )
     ;
    else
     packet_db[cmd].func(fd, sd);
  }
# 18968 "../../../server-code/src/map/clif.c"
  RFIFOSKIP(fd, packet_len);

 };

 return 0;
}







const struct s_packet_db *clif_packet(int packet_id)
{
 if (packet_id < 0x0064 || packet_id > 0x0F00 || packet_db[packet_id].len == 0)
  return 
# 18984 "../../../server-code/src/map/clif.c" 3 4
        ((void *)0)
# 18984 "../../../server-code/src/map/clif.c"
            ;
 return &packet_db[packet_id];
}

static void __attribute__ ((unused)) packetdb_addpacket(short cmd, int len, ...) {
 va_list va;
 int i;
 int pos;
 pFunc func;

 if (cmd > 0x0F00) {
  (showmsg->showError(("Packet Error: packet 0x%x is greater than the maximum allowed (0x%x), skipping...\n"), (unsigned int)cmd, (unsigned int)0x0F00));
  return;
 }

 if (cmd < 0x0064) {
  (showmsg->showError(("Packet Error: packet 0x%x is lower than the minimum allowed (0x%x), skipping...\n"), (unsigned int)cmd, (unsigned int)0x0064));
  return;
 }

 packet_db[cmd].len = len;

 
# 19006 "../../../server-code/src/map/clif.c" 3 4
__builtin_va_start(
# 19006 "../../../server-code/src/map/clif.c"
va
# 19006 "../../../server-code/src/map/clif.c" 3 4
,
# 19006 "../../../server-code/src/map/clif.c"
len
# 19006 "../../../server-code/src/map/clif.c" 3 4
)
# 19006 "../../../server-code/src/map/clif.c"
                ;

 pos = 
# 19008 "../../../server-code/src/map/clif.c" 3 4
      __builtin_va_arg(
# 19008 "../../../server-code/src/map/clif.c"
      va
# 19008 "../../../server-code/src/map/clif.c" 3 4
      ,
# 19008 "../../../server-code/src/map/clif.c"
      int
# 19008 "../../../server-code/src/map/clif.c" 3 4
      )
# 19008 "../../../server-code/src/map/clif.c"
                     ;

 
# 19010 "../../../server-code/src/map/clif.c" 3 4
__builtin_va_end(
# 19010 "../../../server-code/src/map/clif.c"
va
# 19010 "../../../server-code/src/map/clif.c" 3 4
)
# 19010 "../../../server-code/src/map/clif.c"
          ;

 if( pos == 0xFFFF ) {
  return;
 }

 
# 19016 "../../../server-code/src/map/clif.c" 3 4
__builtin_va_start(
# 19016 "../../../server-code/src/map/clif.c"
va
# 19016 "../../../server-code/src/map/clif.c" 3 4
,
# 19016 "../../../server-code/src/map/clif.c"
len
# 19016 "../../../server-code/src/map/clif.c" 3 4
)
# 19016 "../../../server-code/src/map/clif.c"
                ;

 func = 
# 19018 "../../../server-code/src/map/clif.c" 3 4
       __builtin_va_arg(
# 19018 "../../../server-code/src/map/clif.c"
       va
# 19018 "../../../server-code/src/map/clif.c" 3 4
       ,
# 19018 "../../../server-code/src/map/clif.c"
       pFunc
# 19018 "../../../server-code/src/map/clif.c" 3 4
       )
# 19018 "../../../server-code/src/map/clif.c"
                       ;

 packet_db[cmd].func = func;

 for (i = 0; i < 20; i++) {
  pos = 
# 19023 "../../../server-code/src/map/clif.c" 3 4
       __builtin_va_arg(
# 19023 "../../../server-code/src/map/clif.c"
       va
# 19023 "../../../server-code/src/map/clif.c" 3 4
       ,
# 19023 "../../../server-code/src/map/clif.c"
       int
# 19023 "../../../server-code/src/map/clif.c" 3 4
       )
# 19023 "../../../server-code/src/map/clif.c"
                      ;

  if (pos == 0xFFFF)
   break;

  packet_db[cmd].pos[i] = pos;
 }
 
# 19030 "../../../server-code/src/map/clif.c" 3 4
__builtin_va_end(
# 19030 "../../../server-code/src/map/clif.c"
va
# 19030 "../../../server-code/src/map/clif.c" 3 4
)
# 19030 "../../../server-code/src/map/clif.c"
          ;
}
void packetdb_loaddb(void) {
 memset(packet_db,0,sizeof(packet_db));



# 1 "../../../server-code/src/map/packets.h" 1
# 42 "../../../server-code/src/map/packets.h"
packetdb_addpacket((0x0064), (55), 0xFFFF);
packetdb_addpacket((0x0065), (17), 0xFFFF);
packetdb_addpacket((0x0066), (6), 0xFFFF);
packetdb_addpacket((0x0067), (37), 0xFFFF);
packetdb_addpacket((0x0068), (46), 0xFFFF);
packetdb_addpacket((0x0069), (-1), 0xFFFF);
packetdb_addpacket((0x006a), (23), 0xFFFF);
packetdb_addpacket((0x006b), (-1), 0xFFFF);
packetdb_addpacket((0x006c), (3), 0xFFFF);
packetdb_addpacket((0x006d), (108), 0xFFFF);
packetdb_addpacket((0x006e), (3), 0xFFFF);
packetdb_addpacket((0x006f), (2), 0xFFFF);
packetdb_addpacket((0x0070), (6), 0xFFFF);
packetdb_addpacket((0x0071), (28), 0xFFFF);
packetdb_addpacket((0x0072), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
packetdb_addpacket((0x0073), (11), 0xFFFF);
packetdb_addpacket((0x0074), (3), 0xFFFF);
packetdb_addpacket((0x0075), (-1), 0xFFFF);
packetdb_addpacket((0x0076), (9), 0xFFFF);
packetdb_addpacket((0x0077), (5), 0xFFFF);
packetdb_addpacket((0x0078), (54), 0xFFFF);
packetdb_addpacket((0x0079), (53), 0xFFFF);
packetdb_addpacket((0x007a), (58), 0xFFFF);
packetdb_addpacket((0x007b), (60), 0xFFFF);
packetdb_addpacket((0x007c), (41), 0xFFFF);
packetdb_addpacket((0x007d), (2),clif->pLoadEndAck,0, 0xFFFF);
packetdb_addpacket((0x007e), (6),clif->pTickSend,2, 0xFFFF);
packetdb_addpacket((0x007f), (6), 0xFFFF);
packetdb_addpacket((0x0080), (7), 0xFFFF);
packetdb_addpacket((0x0081), (3), 0xFFFF);
packetdb_addpacket((0x0082), (2), 0xFFFF);
packetdb_addpacket((0x0083), (2), 0xFFFF);
packetdb_addpacket((0x0084), (2), 0xFFFF);
packetdb_addpacket((0x0085), (5),clif->pWalkToXY,2, 0xFFFF);
packetdb_addpacket((0x0086), (16), 0xFFFF);
packetdb_addpacket((0x0087), (12), 0xFFFF);
packetdb_addpacket((0x0088), (10), 0xFFFF);
packetdb_addpacket((0x0089), (7),clif->pActionRequest,2,6, 0xFFFF);
packetdb_addpacket((0x008a), (29), 0xFFFF);
packetdb_addpacket((0x008b), (2), 0xFFFF);
packetdb_addpacket((0x008c), (-1),clif->pGlobalMessage,2,4, 0xFFFF);
packetdb_addpacket((0x008d), (-1), 0xFFFF);
packetdb_addpacket((0x008e), (-1), 0xFFFF);

packetdb_addpacket((0x0090), (7),clif->pNpcClicked,2, 0xFFFF);
packetdb_addpacket((0x0091), (22), 0xFFFF);
packetdb_addpacket((0x0092), (28), 0xFFFF);
packetdb_addpacket((0x0093), (2), 0xFFFF);
packetdb_addpacket((0x0094), (6),clif->pGetCharNameRequest,2, 0xFFFF);
packetdb_addpacket((0x0095), (30), 0xFFFF);
packetdb_addpacket((0x0096), (-1),clif->pWisMessage,2,4,28, 0xFFFF);
packetdb_addpacket((0x0097), (-1), 0xFFFF);
packetdb_addpacket((0x0098), (3), 0xFFFF);
packetdb_addpacket((0x0099), (-1),clif->pBroadcast,2,4, 0xFFFF);
packetdb_addpacket((0x009a), (-1), 0xFFFF);
packetdb_addpacket((0x009b), (5),clif->pChangeDir,2,4, 0xFFFF);
packetdb_addpacket((0x009c), (9), 0xFFFF);
packetdb_addpacket((0x009d), (17), 0xFFFF);
packetdb_addpacket((0x009e), (17), 0xFFFF);
packetdb_addpacket((0x009f), (6),clif->pTakeItem,2, 0xFFFF);
packetdb_addpacket((0x00a0), (23), 0xFFFF);
packetdb_addpacket((0x00a1), (6), 0xFFFF);
packetdb_addpacket((0x00a2), (6),clif->pDropItem,2,4, 0xFFFF);
packetdb_addpacket((0x00a3), (-1), 0xFFFF);
packetdb_addpacket((0x00a4), (-1), 0xFFFF);
packetdb_addpacket((0x00a5), (-1), 0xFFFF);
packetdb_addpacket((0x00a6), (-1), 0xFFFF);
packetdb_addpacket((0x00a7), (8),clif->pUseItem,2,4, 0xFFFF);
packetdb_addpacket((0x00a8), (7), 0xFFFF);
packetdb_addpacket((0x00a9), (6),clif->pEquipItem,2,4, 0xFFFF);
packetdb_addpacket((0x00aa), (7), 0xFFFF);
packetdb_addpacket((0x00ab), (4),clif->pUnequipItem,2, 0xFFFF);
packetdb_addpacket((0x00ac), (7), 0xFFFF);

packetdb_addpacket((0x00ae), (-1), 0xFFFF);
packetdb_addpacket((0x00af), (6), 0xFFFF);
packetdb_addpacket((0x00b0), (8), 0xFFFF);
packetdb_addpacket((0x00b1), (8), 0xFFFF);
packetdb_addpacket((0x00b2), (3),clif->pRestart,2, 0xFFFF);
packetdb_addpacket((0x00b3), (3), 0xFFFF);
packetdb_addpacket((0x00b4), (-1), 0xFFFF);
packetdb_addpacket((0x00b5), (6), 0xFFFF);
packetdb_addpacket((0x00b6), (6), 0xFFFF);
packetdb_addpacket((0x00b7), (-1), 0xFFFF);
packetdb_addpacket((0x00b8), (7),clif->pNpcSelectMenu,2,6, 0xFFFF);
packetdb_addpacket((0x00b9), (6),clif->pNpcNextClicked,2, 0xFFFF);
packetdb_addpacket((0x00ba), (2), 0xFFFF);
packetdb_addpacket((0x00bb), (5),clif->pStatusUp,2,4, 0xFFFF);
packetdb_addpacket((0x00bc), (6), 0xFFFF);
packetdb_addpacket((0x00bd), (44), 0xFFFF);
packetdb_addpacket((0x00be), (5), 0xFFFF);
packetdb_addpacket((0x00bf), (3),clif->pEmotion,2, 0xFFFF);
packetdb_addpacket((0x00c0), (7), 0xFFFF);
packetdb_addpacket((0x00c1), (2),clif->pHowManyConnections,0, 0xFFFF);
packetdb_addpacket((0x00c2), (6), 0xFFFF);
packetdb_addpacket((0x00c3), (8), 0xFFFF);
packetdb_addpacket((0x00c4), (6), 0xFFFF);
packetdb_addpacket((0x00c5), (7),clif->pNpcBuySellSelected,2,6, 0xFFFF);
packetdb_addpacket((0x00c6), (-1), 0xFFFF);
packetdb_addpacket((0x00c7), (-1), 0xFFFF);
packetdb_addpacket((0x00c8), (-1),clif->pNpcBuyListSend,2,4, 0xFFFF);
packetdb_addpacket((0x00c9), (-1),clif->pNpcSellListSend,2,4, 0xFFFF);
packetdb_addpacket((0x00ca), (3), 0xFFFF);
packetdb_addpacket((0x00cb), (3), 0xFFFF);
packetdb_addpacket((0x00cc), (6),clif->pGMKick,2, 0xFFFF);
packetdb_addpacket((0x00cd), (3), 0xFFFF);
packetdb_addpacket((0x00ce), (2),clif->pGMKickAll,0, 0xFFFF);
packetdb_addpacket((0x00cf), (27),clif->pPMIgnore,2,26, 0xFFFF);
packetdb_addpacket((0x00d0), (3),clif->pPMIgnoreAll,2, 0xFFFF);
packetdb_addpacket((0x00d1), (4), 0xFFFF);
packetdb_addpacket((0x00d2), (4), 0xFFFF);
packetdb_addpacket((0x00d3), (2),clif->pPMIgnoreList,0, 0xFFFF);
packetdb_addpacket((0x00d4), (-1), 0xFFFF);
packetdb_addpacket((0x00d5), (-1),clif->pCreateChatRoom,2,4,6,7,15, 0xFFFF);
packetdb_addpacket((0x00d6), (3), 0xFFFF);
packetdb_addpacket((0x00d7), (-1), 0xFFFF);
packetdb_addpacket((0x00d8), (6), 0xFFFF);
packetdb_addpacket((0x00d9), (14),clif->pChatAddMember,2,6, 0xFFFF);
packetdb_addpacket((0x00da), (3), 0xFFFF);
packetdb_addpacket((0x00db), (-1), 0xFFFF);
packetdb_addpacket((0x00dc), (28), 0xFFFF);
packetdb_addpacket((0x00dd), (29), 0xFFFF);
packetdb_addpacket((0x00de), (-1),clif->pChatRoomStatusChange,2,4,6,7,15, 0xFFFF);
packetdb_addpacket((0x00df), (-1), 0xFFFF);
packetdb_addpacket((0x00e0), (30),clif->pChangeChatOwner,2,6, 0xFFFF);
packetdb_addpacket((0x00e1), (30), 0xFFFF);
packetdb_addpacket((0x00e2), (26),clif->pKickFromChat,2, 0xFFFF);
packetdb_addpacket((0x00e3), (2),clif->pChatLeave,0, 0xFFFF);
packetdb_addpacket((0x00e4), (6),clif->pTradeRequest,2, 0xFFFF);
packetdb_addpacket((0x00e5), (26), 0xFFFF);
packetdb_addpacket((0x00e6), (3),clif->pTradeAck,2, 0xFFFF);
packetdb_addpacket((0x00e7), (3), 0xFFFF);
packetdb_addpacket((0x00e8), (8),clif->pTradeAddItem,2,4, 0xFFFF);
packetdb_addpacket((0x00e9), (19), 0xFFFF);
packetdb_addpacket((0x00ea), (5), 0xFFFF);
packetdb_addpacket((0x00eb), (2),clif->pTradeOk,0, 0xFFFF);
packetdb_addpacket((0x00ec), (3), 0xFFFF);
packetdb_addpacket((0x00ed), (2),clif->pTradeCancel,0, 0xFFFF);
packetdb_addpacket((0x00ee), (2), 0xFFFF);
packetdb_addpacket((0x00ef), (2),clif->pTradeCommit,0, 0xFFFF);
packetdb_addpacket((0x00f0), (3), 0xFFFF);
packetdb_addpacket((0x00f1), (2), 0xFFFF);
packetdb_addpacket((0x00f2), (6), 0xFFFF);
packetdb_addpacket((0x00f3), (8),clif->pMoveToKafra,2,4, 0xFFFF);
packetdb_addpacket((0x00f4), (21), 0xFFFF);
packetdb_addpacket((0x00f5), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
packetdb_addpacket((0x00f6), (8), 0xFFFF);
packetdb_addpacket((0x00f7), (2),clif->pCloseKafra,0, 0xFFFF);
packetdb_addpacket((0x00f8), (2), 0xFFFF);
packetdb_addpacket((0x00f9), (26),clif->pCreateParty,2, 0xFFFF);
packetdb_addpacket((0x00fa), (3), 0xFFFF);
packetdb_addpacket((0x00fb), (-1), 0xFFFF);
packetdb_addpacket((0x00fc), (6),clif->pPartyInvite,2, 0xFFFF);
packetdb_addpacket((0x00fd), (27), 0xFFFF);
packetdb_addpacket((0x00fe), (30), 0xFFFF);
packetdb_addpacket((0x00ff), (10),clif->pReplyPartyInvite,2,6, 0xFFFF);
packetdb_addpacket((0x0100), (2),clif->pLeaveParty,0, 0xFFFF);
packetdb_addpacket((0x0101), (6), 0xFFFF);
packetdb_addpacket((0x0102), (6),clif->pPartyChangeOption,2, 0xFFFF);
packetdb_addpacket((0x0103), (30),clif->pRemovePartyMember,2,6, 0xFFFF);
packetdb_addpacket((0x0104), (79), 0xFFFF);
packetdb_addpacket((0x0105), (31), 0xFFFF);
packetdb_addpacket((0x0106), (10), 0xFFFF);
packetdb_addpacket((0x0107), (10), 0xFFFF);
packetdb_addpacket((0x0108), (-1),clif->pPartyMessage,2,4, 0xFFFF);
packetdb_addpacket((0x0109), (-1), 0xFFFF);
packetdb_addpacket((0x010a), (4), 0xFFFF);
packetdb_addpacket((0x010b), (6), 0xFFFF);
packetdb_addpacket((0x010c), (6), 0xFFFF);
packetdb_addpacket((0x010d), (2), 0xFFFF);
packetdb_addpacket((0x010e), (11), 0xFFFF);
packetdb_addpacket((0x010f), (-1), 0xFFFF);
packetdb_addpacket((0x0110), (10), 0xFFFF);
packetdb_addpacket((0x0111), (39), 0xFFFF);
packetdb_addpacket((0x0112), (4),clif->pSkillUp,2, 0xFFFF);
packetdb_addpacket((0x0113), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
packetdb_addpacket((0x0114), (31), 0xFFFF);
packetdb_addpacket((0x0115), (35), 0xFFFF);
packetdb_addpacket((0x0116), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
packetdb_addpacket((0x0117), (18), 0xFFFF);
packetdb_addpacket((0x0118), (2),clif->pStopAttack,0, 0xFFFF);
packetdb_addpacket((0x0119), (13), 0xFFFF);
packetdb_addpacket((0x011a), (15), 0xFFFF);
packetdb_addpacket((0x011b), (20),clif->pUseSkillMap,2,4, 0xFFFF);
packetdb_addpacket((0x011c), (68), 0xFFFF);
packetdb_addpacket((0x011d), (2),clif->pRequestMemo,0, 0xFFFF);
packetdb_addpacket((0x011e), (3), 0xFFFF);
packetdb_addpacket((0x011f), (16), 0xFFFF);
packetdb_addpacket((0x0120), (6), 0xFFFF);
packetdb_addpacket((0x0121), (14), 0xFFFF);
packetdb_addpacket((0x0122), (-1), 0xFFFF);
packetdb_addpacket((0x0123), (-1), 0xFFFF);
packetdb_addpacket((0x0124), (21), 0xFFFF);
packetdb_addpacket((0x0125), (8), 0xFFFF);
packetdb_addpacket((0x0126), (8),clif->pPutItemToCart,2,4, 0xFFFF);
packetdb_addpacket((0x0127), (8),clif->pGetItemFromCart,2,4, 0xFFFF);
packetdb_addpacket((0x0128), (8),clif->pMoveFromKafraToCart,2,4, 0xFFFF);
packetdb_addpacket((0x0129), (8),clif->pMoveToKafraFromCart,2,4, 0xFFFF);
packetdb_addpacket((0x012a), (2),clif->pRemoveOption,0, 0xFFFF);
packetdb_addpacket((0x012b), (2), 0xFFFF);
packetdb_addpacket((0x012c), (3), 0xFFFF);
packetdb_addpacket((0x012d), (4), 0xFFFF);
packetdb_addpacket((0x012e), (2),clif->pCloseVending,0, 0xFFFF);
packetdb_addpacket((0x012f), (-1), 0xFFFF);
packetdb_addpacket((0x0130), (6),clif->pVendingListReq,2, 0xFFFF);
packetdb_addpacket((0x0131), (86), 0xFFFF);
packetdb_addpacket((0x0132), (6), 0xFFFF);
packetdb_addpacket((0x0133), (-1), 0xFFFF);
packetdb_addpacket((0x0134), (-1),clif->pPurchaseReq,2,4,8, 0xFFFF);
packetdb_addpacket((0x0135), (7), 0xFFFF);
packetdb_addpacket((0x0136), (-1), 0xFFFF);
packetdb_addpacket((0x0137), (6), 0xFFFF);
packetdb_addpacket((0x0138), (3), 0xFFFF);
packetdb_addpacket((0x0139), (16), 0xFFFF);
packetdb_addpacket((0x013a), (4), 0xFFFF);
packetdb_addpacket((0x013b), (4), 0xFFFF);
packetdb_addpacket((0x013c), (4), 0xFFFF);
packetdb_addpacket((0x013d), (6), 0xFFFF);
packetdb_addpacket((0x013e), (24), 0xFFFF);
packetdb_addpacket((0x013f), (26),clif->pGM_Monster_Item,2, 0xFFFF);
packetdb_addpacket((0x0140), (22),clif->pMapMove,2,18,20, 0xFFFF);
packetdb_addpacket((0x0141), (14), 0xFFFF);
packetdb_addpacket((0x0142), (6), 0xFFFF);
packetdb_addpacket((0x0143), (10),clif->pNpcAmountInput,2,6, 0xFFFF);
packetdb_addpacket((0x0144), (23), 0xFFFF);
packetdb_addpacket((0x0145), (19), 0xFFFF);
packetdb_addpacket((0x0146), (6),clif->pNpcCloseClicked,2, 0xFFFF);
packetdb_addpacket((0x0147), (39), 0xFFFF);
packetdb_addpacket((0x0148), (8), 0xFFFF);
packetdb_addpacket((0x0149), (9),clif->pGMReqNoChat,2,6,7, 0xFFFF);
packetdb_addpacket((0x014a), (6), 0xFFFF);
packetdb_addpacket((0x014b), (27), 0xFFFF);
packetdb_addpacket((0x014c), (-1), 0xFFFF);
packetdb_addpacket((0x014d), (2),clif->pGuildCheckMaster,0, 0xFFFF);
packetdb_addpacket((0x014e), (6), 0xFFFF);
packetdb_addpacket((0x014f), (6),clif->pGuildRequestInfo,2, 0xFFFF);
packetdb_addpacket((0x0150), (110), 0xFFFF);
packetdb_addpacket((0x0151), (6),clif->pGuildRequestEmblem,2, 0xFFFF);
packetdb_addpacket((0x0152), (-1), 0xFFFF);
packetdb_addpacket((0x0153), (-1),clif->pGuildChangeEmblem,2,4, 0xFFFF);
packetdb_addpacket((0x0154), (-1), 0xFFFF);
packetdb_addpacket((0x0155), (-1),clif->pGuildChangeMemberPosition,2, 0xFFFF);
packetdb_addpacket((0x0156), (-1), 0xFFFF);
packetdb_addpacket((0x0157), (6), 0xFFFF);
packetdb_addpacket((0x0158), (-1), 0xFFFF);
packetdb_addpacket((0x0159), (54),clif->pGuildLeave,2,6,10,14, 0xFFFF);
packetdb_addpacket((0x015a), (66), 0xFFFF);
packetdb_addpacket((0x015b), (54),clif->pGuildExpulsion,2,6,10,14, 0xFFFF);
packetdb_addpacket((0x015c), (90), 0xFFFF);
packetdb_addpacket((0x015d), (42),clif->pGuildBreak,2, 0xFFFF);
packetdb_addpacket((0x015e), (6), 0xFFFF);
packetdb_addpacket((0x015f), (42), 0xFFFF);
packetdb_addpacket((0x0160), (-1), 0xFFFF);
packetdb_addpacket((0x0161), (-1),clif->pGuildChangePositionInfo,2, 0xFFFF);
packetdb_addpacket((0x0162), (-1), 0xFFFF);
packetdb_addpacket((0x0163), (-1), 0xFFFF);
packetdb_addpacket((0x0164), (-1), 0xFFFF);
packetdb_addpacket((0x0165), (30),clif->pCreateGuild,6, 0xFFFF);
packetdb_addpacket((0x0166), (-1), 0xFFFF);
packetdb_addpacket((0x0167), (3), 0xFFFF);
packetdb_addpacket((0x0168), (14),clif->pGuildInvite,2, 0xFFFF);
packetdb_addpacket((0x0169), (3), 0xFFFF);
packetdb_addpacket((0x016a), (30), 0xFFFF);
packetdb_addpacket((0x016b), (10),clif->pGuildReplyInvite,2,6, 0xFFFF);
packetdb_addpacket((0x016c), (43), 0xFFFF);
packetdb_addpacket((0x016d), (14), 0xFFFF);
packetdb_addpacket((0x016e), (186),clif->pGuildChangeNotice,2,6,66, 0xFFFF);
packetdb_addpacket((0x016f), (182), 0xFFFF);
packetdb_addpacket((0x0170), (14),clif->pGuildRequestAlliance,2, 0xFFFF);
packetdb_addpacket((0x0171), (30), 0xFFFF);
packetdb_addpacket((0x0172), (10),clif->pGuildReplyAlliance,2,6, 0xFFFF);
packetdb_addpacket((0x0173), (3), 0xFFFF);
packetdb_addpacket((0x0174), (-1), 0xFFFF);
packetdb_addpacket((0x0175), (6), 0xFFFF);
packetdb_addpacket((0x0176), (106), 0xFFFF);
packetdb_addpacket((0x0177), (-1), 0xFFFF);
packetdb_addpacket((0x0178), (4),clif->pItemIdentify,2, 0xFFFF);
packetdb_addpacket((0x0179), (5), 0xFFFF);
packetdb_addpacket((0x017a), (4),clif->pUseCard,2, 0xFFFF);
packetdb_addpacket((0x017b), (-1), 0xFFFF);
packetdb_addpacket((0x017c), (6),clif->pInsertCard,2,4, 0xFFFF);
packetdb_addpacket((0x017d), (7), 0xFFFF);
packetdb_addpacket((0x017e), (-1),clif->pGuildMessage,2,4, 0xFFFF);
packetdb_addpacket((0x017f), (-1), 0xFFFF);
packetdb_addpacket((0x0180), (6),clif->pGuildOpposition,2, 0xFFFF);
packetdb_addpacket((0x0181), (3), 0xFFFF);
packetdb_addpacket((0x0182), (106), 0xFFFF);
packetdb_addpacket((0x0183), (10),clif->pGuildDelAlliance,2,6, 0xFFFF);
packetdb_addpacket((0x0184), (10), 0xFFFF);
packetdb_addpacket((0x0185), (34), 0xFFFF);

packetdb_addpacket((0x0187), (6), 0xFFFF);
packetdb_addpacket((0x0188), (8), 0xFFFF);
packetdb_addpacket((0x0189), (4), 0xFFFF);
packetdb_addpacket((0x018a), (4),clif->pQuitGame,0, 0xFFFF);
packetdb_addpacket((0x018b), (4), 0xFFFF);
packetdb_addpacket((0x018c), (29), 0xFFFF);
packetdb_addpacket((0x018d), (-1), 0xFFFF);
packetdb_addpacket((0x018e), (10),clif->pProduceMix,2,4,6,8, 0xFFFF);
packetdb_addpacket((0x018f), (6), 0xFFFF);
packetdb_addpacket((0x0190), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
packetdb_addpacket((0x0191), (86), 0xFFFF);
packetdb_addpacket((0x0192), (24), 0xFFFF);
packetdb_addpacket((0x0193), (6),clif->pSolveCharName,2, 0xFFFF);
packetdb_addpacket((0x0194), (30), 0xFFFF);
packetdb_addpacket((0x0195), (102), 0xFFFF);
packetdb_addpacket((0x0196), (9), 0xFFFF);
packetdb_addpacket((0x0197), (4),clif->pResetChar,2, 0xFFFF);
packetdb_addpacket((0x0198), (8),clif->pGMChangeMapType,2,4,6, 0xFFFF);
packetdb_addpacket((0x0199), (4), 0xFFFF);
packetdb_addpacket((0x019a), (14), 0xFFFF);
packetdb_addpacket((0x019b), (10), 0xFFFF);
packetdb_addpacket((0x019c), (-1),clif->pLocalBroadcast,2,4, 0xFFFF);
packetdb_addpacket((0x019d), (6),clif->pGMHide,0, 0xFFFF);
packetdb_addpacket((0x019e), (2), 0xFFFF);
packetdb_addpacket((0x019f), (6),clif->pCatchPet,2, 0xFFFF);
packetdb_addpacket((0x01a0), (3), 0xFFFF);
packetdb_addpacket((0x01a1), (3),clif->pPetMenu,2, 0xFFFF);
packetdb_addpacket((0x01a2), (35), 0xFFFF);
packetdb_addpacket((0x01a3), (5), 0xFFFF);
packetdb_addpacket((0x01a4), (11), 0xFFFF);
packetdb_addpacket((0x01a5), (26),clif->pChangePetName,2, 0xFFFF);
packetdb_addpacket((0x01a6), (-1), 0xFFFF);
packetdb_addpacket((0x01a7), (4),clif->pSelectEgg,2, 0xFFFF);
packetdb_addpacket((0x01a8), (4), 0xFFFF);
packetdb_addpacket((0x01a9), (6),clif->pSendEmotion,2, 0xFFFF);
packetdb_addpacket((0x01aa), (10), 0xFFFF);
packetdb_addpacket((0x01ab), (12), 0xFFFF);
packetdb_addpacket((0x01ac), (6), 0xFFFF);
packetdb_addpacket((0x01ad), (-1), 0xFFFF);
packetdb_addpacket((0x01ae), (4),clif->pSelectArrow,2, 0xFFFF);
packetdb_addpacket((0x01af), (4),clif->pChangeCart,2, 0xFFFF);
packetdb_addpacket((0x01b0), (11), 0xFFFF);
packetdb_addpacket((0x01b1), (7), 0xFFFF);
packetdb_addpacket((0x01b2), (-1),clif->pOpenVending,2,4,84,85, 0xFFFF);
packetdb_addpacket((0x01b3), (67), 0xFFFF);
packetdb_addpacket((0x01b4), (12), 0xFFFF);
packetdb_addpacket((0x01b5), (18), 0xFFFF);
packetdb_addpacket((0x01b6), (114), 0xFFFF);
packetdb_addpacket((0x01b7), (6), 0xFFFF);
packetdb_addpacket((0x01b8), (3), 0xFFFF);
packetdb_addpacket((0x01b9), (6), 0xFFFF);
packetdb_addpacket((0x01ba), (26),clif->pGMShift,2, 0xFFFF);
packetdb_addpacket((0x01bb), (26),clif->pGMShift,2, 0xFFFF);
packetdb_addpacket((0x01bc), (26),clif->pGMRecall,2, 0xFFFF);
packetdb_addpacket((0x01bd), (26),clif->pGMRecall,2, 0xFFFF);
packetdb_addpacket((0x01be), (2), 0xFFFF);
packetdb_addpacket((0x01bf), (3), 0xFFFF);
packetdb_addpacket((0x01c0), (2), 0xFFFF);
packetdb_addpacket((0x01c1), (14), 0xFFFF);
packetdb_addpacket((0x01c2), (10), 0xFFFF);
packetdb_addpacket((0x01c3), (-1), 0xFFFF);
packetdb_addpacket((0x01c4), (22), 0xFFFF);
packetdb_addpacket((0x01c5), (22), 0xFFFF);
packetdb_addpacket((0x01c6), (4), 0xFFFF);
packetdb_addpacket((0x01c7), (2), 0xFFFF);
packetdb_addpacket((0x01c8), (13), 0xFFFF);
packetdb_addpacket((0x01c9), (97), 0xFFFF);

packetdb_addpacket((0x01cb), (9), 0xFFFF);
packetdb_addpacket((0x01cc), (9), 0xFFFF);
packetdb_addpacket((0x01cd), (30), 0xFFFF);
packetdb_addpacket((0x01ce), (6),clif->pAutoSpell,2, 0xFFFF);
packetdb_addpacket((0x01cf), (28), 0xFFFF);
packetdb_addpacket((0x01d0), (8), 0xFFFF);
packetdb_addpacket((0x01d1), (14), 0xFFFF);
packetdb_addpacket((0x01d2), (10), 0xFFFF);
packetdb_addpacket((0x01d3), (35), 0xFFFF);
packetdb_addpacket((0x01d4), (6), 0xFFFF);
packetdb_addpacket((0x01d5), (-1),clif->pNpcStringInput,2,4,8, 0xFFFF);
packetdb_addpacket((0x01d6), (4), 0xFFFF);
packetdb_addpacket((0x01d7), (11), 0xFFFF);
packetdb_addpacket((0x01d8), (54), 0xFFFF);
packetdb_addpacket((0x01d9), (53), 0xFFFF);
packetdb_addpacket((0x01da), (60), 0xFFFF);
packetdb_addpacket((0x01db), (2), 0xFFFF);
packetdb_addpacket((0x01dc), (-1), 0xFFFF);
packetdb_addpacket((0x01dd), (47), 0xFFFF);
packetdb_addpacket((0x01de), (33), 0xFFFF);
packetdb_addpacket((0x01df), (6),clif->pGMReqAccountName,2, 0xFFFF);
packetdb_addpacket((0x01e0), (30), 0xFFFF);
packetdb_addpacket((0x01e1), (8), 0xFFFF);
packetdb_addpacket((0x01e2), (34), 0xFFFF);
packetdb_addpacket((0x01e3), (14), 0xFFFF);
packetdb_addpacket((0x01e4), (2), 0xFFFF);
packetdb_addpacket((0x01e5), (6), 0xFFFF);
packetdb_addpacket((0x01e6), (26), 0xFFFF);
packetdb_addpacket((0x01e7), (2),clif->pNoviceDoriDori,0, 0xFFFF);
packetdb_addpacket((0x01e8), (28),clif->pCreateParty2,2, 0xFFFF);
packetdb_addpacket((0x01e9), (81), 0xFFFF);
packetdb_addpacket((0x01ea), (6), 0xFFFF);
packetdb_addpacket((0x01eb), (10), 0xFFFF);
packetdb_addpacket((0x01ec), (26), 0xFFFF);
packetdb_addpacket((0x01ed), (2),clif->pNoviceExplosionSpirits,0, 0xFFFF);
packetdb_addpacket((0x01ee), (-1), 0xFFFF);
packetdb_addpacket((0x01ef), (-1), 0xFFFF);
packetdb_addpacket((0x01f0), (-1), 0xFFFF);
packetdb_addpacket((0x01f1), (-1), 0xFFFF);
packetdb_addpacket((0x01f2), (20), 0xFFFF);
packetdb_addpacket((0x01f3), (10), 0xFFFF);
packetdb_addpacket((0x01f4), (32), 0xFFFF);
packetdb_addpacket((0x01f5), (9), 0xFFFF);
packetdb_addpacket((0x01f6), (34), 0xFFFF);
packetdb_addpacket((0x01f7), (14),clif->pAdopt_reply,0, 0xFFFF);
packetdb_addpacket((0x01f8), (2), 0xFFFF);
packetdb_addpacket((0x01f9), (6),clif->pAdopt_request,0, 0xFFFF);
packetdb_addpacket((0x01fa), (48), 0xFFFF);
packetdb_addpacket((0x01fb), (56), 0xFFFF);
packetdb_addpacket((0x01fc), (-1), 0xFFFF);
packetdb_addpacket((0x01fd), (4),clif->pRepairItem,2, 0xFFFF);
packetdb_addpacket((0x01fe), (5), 0xFFFF);
packetdb_addpacket((0x01ff), (10), 0xFFFF);
packetdb_addpacket((0x0200), (26), 0xFFFF);
packetdb_addpacket((0x0201), (-1), 0xFFFF);
packetdb_addpacket((0x0202), (26),clif->pFriendsListAdd,2, 0xFFFF);
packetdb_addpacket((0x0203), (10),clif->pFriendsListRemove,2,6, 0xFFFF);
packetdb_addpacket((0x0204), (18), 0xFFFF);
packetdb_addpacket((0x0205), (26), 0xFFFF);
packetdb_addpacket((0x0206), (11), 0xFFFF);
packetdb_addpacket((0x0207), (34), 0xFFFF);
packetdb_addpacket((0x0208), (11),clif->pFriendsListReply,2,6,10, 0xFFFF);
packetdb_addpacket((0x0209), (36), 0xFFFF);
packetdb_addpacket((0x020a), (10), 0xFFFF);


packetdb_addpacket((0x020d), (-1), 0xFFFF);
packetdb_addpacket((0x974), (2),clif->cancelmergeitem, 0xFFFF);
packetdb_addpacket((0x96e), (-1),clif->ackmergeitems, 0xFFFF);



 packetdb_addpacket((0x0072), (22),clif->pWantToConnection,5,9,13,17,21, 0xFFFF);
 packetdb_addpacket((0x0085), (8),clif->pWalkToXY,5, 0xFFFF);
 packetdb_addpacket((0x00a7), (13),clif->pUseItem,5,9, 0xFFFF);
 packetdb_addpacket((0x0113), (15),clif->pUseSkillToId,4,9,11, 0xFFFF);
 packetdb_addpacket((0x0116), (15),clif->pUseSkillToPos,4,9,11,13, 0xFFFF);
 packetdb_addpacket((0x0190), (95),clif->pUseSkillToPosMoreInfo,4,9,11,13,15, 0xFFFF);
 packetdb_addpacket((0x0208), (14),clif->pFriendsListReply,2,6,10, 0xFFFF);
 packetdb_addpacket((0x020e), (24), 0xFFFF);




 packetdb_addpacket((0x0072), (39),clif->pWantToConnection,12,22,30,34,38, 0xFFFF);
 packetdb_addpacket((0x0085), (9),clif->pWalkToXY,6, 0xFFFF);
 packetdb_addpacket((0x009b), (13),clif->pChangeDir,5,12, 0xFFFF);
 packetdb_addpacket((0x009f), (10),clif->pTakeItem,6, 0xFFFF);
 packetdb_addpacket((0x00a7), (17),clif->pUseItem,6,13, 0xFFFF);
 packetdb_addpacket((0x0113), (19),clif->pUseSkillToId,7,9,15, 0xFFFF);
 packetdb_addpacket((0x0116), (19),clif->pUseSkillToPos,7,9,15,17, 0xFFFF);
 packetdb_addpacket((0x0190), (99),clif->pUseSkillToPosMoreInfo,7,9,15,17,19, 0xFFFF);




 packetdb_addpacket((0x0072), (14),clif->pDropItem,5,12, 0xFFFF);
 packetdb_addpacket((0x007e), (33),clif->pWantToConnection,12,18,24,28,32, 0xFFFF);
 packetdb_addpacket((0x0085), (20),clif->pUseSkillToId,7,12,16, 0xFFFF);
 packetdb_addpacket((0x0089), (15),clif->pGetCharNameRequest,11, 0xFFFF);
 packetdb_addpacket((0x008c), (23),clif->pUseSkillToPos,3,6,17,21, 0xFFFF);
 packetdb_addpacket((0x0094), (10),clif->pTakeItem,6, 0xFFFF);
 packetdb_addpacket((0x009b), (6),clif->pWalkToXY,3, 0xFFFF);
 packetdb_addpacket((0x009f), (13),clif->pChangeDir,5,12, 0xFFFF);
 packetdb_addpacket((0x00a2), (103),clif->pUseSkillToPosMoreInfo,3,6,17,21,23, 0xFFFF);
 packetdb_addpacket((0x00a7), (12),clif->pSolveCharName,8, 0xFFFF);
 packetdb_addpacket((0x00f3), (-1),clif->pGlobalMessage,2,4, 0xFFFF);
 packetdb_addpacket((0x00f5), (17),clif->pUseItem,6,12, 0xFFFF);
 packetdb_addpacket((0x00f7), (10),clif->pTickSend,6, 0xFFFF);
 packetdb_addpacket((0x0113), (16),clif->pMoveToKafra,5,12, 0xFFFF);
 packetdb_addpacket((0x0116), (2),clif->pCloseKafra,0, 0xFFFF);
 packetdb_addpacket((0x0190), (26),clif->pMoveFromKafra,10,22, 0xFFFF);
 packetdb_addpacket((0x0193), (9),clif->pActionRequest,3,8, 0xFFFF);




 packetdb_addpacket((0x0072), (17),clif->pDropItem,8,15, 0xFFFF);
 packetdb_addpacket((0x007e), (37),clif->pWantToConnection,9,21,28,32,36, 0xFFFF);
 packetdb_addpacket((0x0085), (26),clif->pUseSkillToId,11,18,22, 0xFFFF);
 packetdb_addpacket((0x0089), (12),clif->pGetCharNameRequest,8, 0xFFFF);
 packetdb_addpacket((0x008c), (40),clif->pUseSkillToPos,5,15,29,38, 0xFFFF);
 packetdb_addpacket((0x0094), (13),clif->pTakeItem,9, 0xFFFF);
 packetdb_addpacket((0x009b), (15),clif->pWalkToXY,12, 0xFFFF);
 packetdb_addpacket((0x009f), (12),clif->pChangeDir,7,11, 0xFFFF);
 packetdb_addpacket((0x00a2), (120),clif->pUseSkillToPosMoreInfo,5,15,29,38,40, 0xFFFF);
 packetdb_addpacket((0x00a7), (11),clif->pSolveCharName,7, 0xFFFF);
 packetdb_addpacket((0x00f5), (24),clif->pUseItem,9,20, 0xFFFF);
 packetdb_addpacket((0x00f7), (13),clif->pTickSend,9, 0xFFFF);
 packetdb_addpacket((0x0113), (23),clif->pMoveToKafra,5,19, 0xFFFF);
 packetdb_addpacket((0x0190), (26),clif->pMoveFromKafra,11,22, 0xFFFF);
 packetdb_addpacket((0x0193), (18),clif->pActionRequest,7,17, 0xFFFF);




 packetdb_addpacket((0x0212), (26),clif->pGMRc,2, 0xFFFF);
 packetdb_addpacket((0x0213), (26),clif->pCheck,2, 0xFFFF);
 packetdb_addpacket((0x0214), (42), 0xFFFF);




 packetdb_addpacket((0x020f), (10),clif->pPVPInfo,2,6, 0xFFFF);
 packetdb_addpacket((0x0210), (22), 0xFFFF);




 packetdb_addpacket((0x0072), (20),clif->pUseItem,9,20, 0xFFFF);
 packetdb_addpacket((0x007e), (19),clif->pMoveToKafra,3,15, 0xFFFF);
 packetdb_addpacket((0x0085), (23),clif->pActionRequest,9,22, 0xFFFF);
 packetdb_addpacket((0x0089), (9),clif->pWalkToXY,6, 0xFFFF);
 packetdb_addpacket((0x008c), (105),clif->pUseSkillToPosMoreInfo,10,14,18,23,25, 0xFFFF);
 packetdb_addpacket((0x0094), (17),clif->pDropItem,6,15, 0xFFFF);
 packetdb_addpacket((0x009b), (14),clif->pGetCharNameRequest,10, 0xFFFF);
 packetdb_addpacket((0x009f), (-1),clif->pGlobalMessage,2,4, 0xFFFF);
 packetdb_addpacket((0x00a2), (14),clif->pSolveCharName,10, 0xFFFF);
 packetdb_addpacket((0x00a7), (25),clif->pUseSkillToPos,10,14,18,23, 0xFFFF);
 packetdb_addpacket((0x00f3), (10),clif->pChangeDir,4,9, 0xFFFF);
 packetdb_addpacket((0x00f5), (34),clif->pWantToConnection,7,15,25,29,33, 0xFFFF);
 packetdb_addpacket((0x00f7), (2),clif->pCloseKafra,0, 0xFFFF);
 packetdb_addpacket((0x0113), (11),clif->pTakeItem,7, 0xFFFF);
 packetdb_addpacket((0x0116), (11),clif->pTickSend,7, 0xFFFF);
 packetdb_addpacket((0x0190), (22),clif->pUseSkillToId,9,15,18, 0xFFFF);
 packetdb_addpacket((0x0193), (17),clif->pMoveFromKafra,3,13, 0xFFFF);




 packetdb_addpacket((0x0072), (18),clif->pUseItem,10,14, 0xFFFF);
 packetdb_addpacket((0x007e), (25),clif->pMoveToKafra,6,21, 0xFFFF);
 packetdb_addpacket((0x0085), (9),clif->pActionRequest,3,8, 0xFFFF);
 packetdb_addpacket((0x0089), (14),clif->pWalkToXY,11, 0xFFFF);
 packetdb_addpacket((0x008c), (109),clif->pUseSkillToPosMoreInfo,16,20,23,27,29, 0xFFFF);
 packetdb_addpacket((0x0094), (19),clif->pDropItem,12,17, 0xFFFF);
 packetdb_addpacket((0x009b), (10),clif->pGetCharNameRequest,6, 0xFFFF);
 packetdb_addpacket((0x00a2), (10),clif->pSolveCharName,6, 0xFFFF);
 packetdb_addpacket((0x00a7), (29),clif->pUseSkillToPos,6,20,23,27, 0xFFFF);
 packetdb_addpacket((0x00f3), (18),clif->pChangeDir,8,17, 0xFFFF);
 packetdb_addpacket((0x00f5), (32),clif->pWantToConnection,10,17,23,27,31, 0xFFFF);
 packetdb_addpacket((0x0113), (14),clif->pTakeItem,10, 0xFFFF);
 packetdb_addpacket((0x0116), (14),clif->pTickSend,10, 0xFFFF);
 packetdb_addpacket((0x0190), (14),clif->pUseSkillToId,4,7,10, 0xFFFF);
 packetdb_addpacket((0x0193), (12),clif->pMoveFromKafra,4,8, 0xFFFF);




 packetdb_addpacket((0x0072), (17),clif->pUseItem,6,13, 0xFFFF);
 packetdb_addpacket((0x007e), (16),clif->pMoveToKafra,5,12, 0xFFFF);
 packetdb_addpacket((0x0089), (6),clif->pWalkToXY,3, 0xFFFF);
 packetdb_addpacket((0x008c), (103),clif->pUseSkillToPosMoreInfo,2,6,17,21,23, 0xFFFF);
 packetdb_addpacket((0x0094), (14),clif->pDropItem,5,12, 0xFFFF);
 packetdb_addpacket((0x009b), (15),clif->pGetCharNameRequest,11, 0xFFFF);
 packetdb_addpacket((0x00a2), (12),clif->pSolveCharName,8, 0xFFFF);
 packetdb_addpacket((0x00a7), (23),clif->pUseSkillToPos,3,6,17,21, 0xFFFF);
 packetdb_addpacket((0x00f3), (13),clif->pChangeDir,5,12, 0xFFFF);
 packetdb_addpacket((0x00f5), (33),clif->pWantToConnection,12,18,24,28,32, 0xFFFF);
 packetdb_addpacket((0x0113), (10),clif->pTakeItem,6, 0xFFFF);
 packetdb_addpacket((0x0116), (10),clif->pTickSend,6, 0xFFFF);
 packetdb_addpacket((0x0190), (20),clif->pUseSkillToId,7,12,16, 0xFFFF);
 packetdb_addpacket((0x0193), (26),clif->pMoveFromKafra,10,22, 0xFFFF);




 packetdb_addpacket((0x0072), (13),clif->pUseItem,5,9, 0xFFFF);
 packetdb_addpacket((0x007e), (13),clif->pMoveToKafra,6,9, 0xFFFF);
 packetdb_addpacket((0x0085), (15),clif->pActionRequest,4,14, 0xFFFF);
 packetdb_addpacket((0x008c), (108),clif->pUseSkillToPosMoreInfo,6,9,23,26,28, 0xFFFF);
 packetdb_addpacket((0x0094), (12),clif->pDropItem,6,10, 0xFFFF);
 packetdb_addpacket((0x009b), (10),clif->pGetCharNameRequest,6, 0xFFFF);
 packetdb_addpacket((0x00a2), (16),clif->pSolveCharName,12, 0xFFFF);
 packetdb_addpacket((0x00a7), (28),clif->pUseSkillToPos,6,9,23,26, 0xFFFF);
 packetdb_addpacket((0x00f3), (15),clif->pChangeDir,6,14, 0xFFFF);
 packetdb_addpacket((0x00f5), (29),clif->pWantToConnection,5,14,20,24,28, 0xFFFF);
 packetdb_addpacket((0x0113), (9),clif->pTakeItem,5, 0xFFFF);
 packetdb_addpacket((0x0116), (9),clif->pTickSend,5, 0xFFFF);
 packetdb_addpacket((0x0190), (26),clif->pUseSkillToId,4,10,22, 0xFFFF);
 packetdb_addpacket((0x0193), (22),clif->pMoveFromKafra,12,18, 0xFFFF);




 packetdb_addpacket((0x0084), (-1), 0xFFFF);
 packetdb_addpacket((0x0215), (6), 0xFFFF);




 packetdb_addpacket((0x0084), (2), 0xFFFF);
 packetdb_addpacket((0x0216), (6), 0xFFFF);
 packetdb_addpacket((0x0217), (2),clif->pBlacksmith,0, 0xFFFF);
 packetdb_addpacket((0x0218), (2),clif->pAlchemist,0, 0xFFFF);
 packetdb_addpacket((0x0219), (282), 0xFFFF);
 packetdb_addpacket((0x021a), (282), 0xFFFF);
 packetdb_addpacket((0x021b), (10), 0xFFFF);
 packetdb_addpacket((0x021c), (10), 0xFFFF);




 packetdb_addpacket((0x021d), (6),clif->pLessEffect,2, 0xFFFF);




 packetdb_addpacket((0x0072), (22),clif->pUseSkillToId,8,12,18, 0xFFFF);
 packetdb_addpacket((0x007e), (30),clif->pUseSkillToPos,4,9,22,28, 0xFFFF);
 packetdb_addpacket((0x0085), (-1),clif->pGlobalMessage,2,4, 0xFFFF);
 packetdb_addpacket((0x0089), (7),clif->pTickSend,3, 0xFFFF);
 packetdb_addpacket((0x008c), (13),clif->pGetCharNameRequest,9, 0xFFFF);
 packetdb_addpacket((0x0094), (14),clif->pMoveToKafra,4,10, 0xFFFF);
 packetdb_addpacket((0x009b), (2),clif->pCloseKafra,0, 0xFFFF);
 packetdb_addpacket((0x009f), (18),clif->pActionRequest,6,17, 0xFFFF);
 packetdb_addpacket((0x00a2), (7),clif->pTakeItem,3, 0xFFFF);
 packetdb_addpacket((0x00a7), (7),clif->pWalkToXY,4, 0xFFFF);
 packetdb_addpacket((0x00f3), (8),clif->pChangeDir,3,7, 0xFFFF);
 packetdb_addpacket((0x00f5), (29),clif->pWantToConnection,3,10,20,24,28, 0xFFFF);
 packetdb_addpacket((0x00f7), (14),clif->pSolveCharName,10, 0xFFFF);
 packetdb_addpacket((0x0113), (110),clif->pUseSkillToPosMoreInfo,4,9,22,28,30, 0xFFFF);
 packetdb_addpacket((0x0116), (12),clif->pDropItem,4,10, 0xFFFF);
 packetdb_addpacket((0x0190), (15),clif->pUseItem,3,11, 0xFFFF);
 packetdb_addpacket((0x0193), (21),clif->pMoveFromKafra,4,17, 0xFFFF);
 packetdb_addpacket((0x0221), (-1), 0xFFFF);
 packetdb_addpacket((0x0222), (6),clif->pWeaponRefine,2, 0xFFFF);
 packetdb_addpacket((0x0223), (8), 0xFFFF);





 packetdb_addpacket((0x0066), (3), 0xFFFF);
 packetdb_addpacket((0x0070), (3), 0xFFFF);
 packetdb_addpacket((0x01ca), (3), 0xFFFF);
 packetdb_addpacket((0x021e), (6), 0xFFFF);
 packetdb_addpacket((0x021f), (66), 0xFFFF);
 packetdb_addpacket((0x0220), (10), 0xFFFF);




 packetdb_addpacket((0x0072), (26),clif->pUseSkillToId,8,16,22, 0xFFFF);
 packetdb_addpacket((0x007e), (114),clif->pUseSkillToPosMoreInfo,10,18,22,32,34, 0xFFFF);
 packetdb_addpacket((0x0085), (23),clif->pChangeDir,12,22, 0xFFFF);
 packetdb_addpacket((0x0089), (9),clif->pTickSend,5, 0xFFFF);
 packetdb_addpacket((0x008c), (8),clif->pGetCharNameRequest,4, 0xFFFF);
 packetdb_addpacket((0x0094), (20),clif->pMoveToKafra,10,16, 0xFFFF);
 packetdb_addpacket((0x009b), (32),clif->pWantToConnection,3,12,23,27,31, 0xFFFF);
 packetdb_addpacket((0x009f), (17),clif->pUseItem,5,13, 0xFFFF);
 packetdb_addpacket((0x00a2), (11),clif->pSolveCharName,7, 0xFFFF);
 packetdb_addpacket((0x00a7), (13),clif->pWalkToXY,10, 0xFFFF);
 packetdb_addpacket((0x00f3), (-1),clif->pGlobalMessage,2,4, 0xFFFF);
 packetdb_addpacket((0x00f5), (9),clif->pTakeItem,5, 0xFFFF);
 packetdb_addpacket((0x00f7), (21),clif->pMoveFromKafra,11,17, 0xFFFF);
 packetdb_addpacket((0x0113), (34),clif->pUseSkillToPos,10,18,22,32, 0xFFFF);
 packetdb_addpacket((0x0116), (20),clif->pDropItem,15,18, 0xFFFF);
 packetdb_addpacket((0x0190), (20),clif->pActionRequest,9,19, 0xFFFF);
 packetdb_addpacket((0x0193), (2),clif->pCloseKafra,0, 0xFFFF);




 packetdb_addpacket((0x0224), (10), 0xFFFF);
 packetdb_addpacket((0x0225), (2),clif->pTaekwon,0, 0xFFFF);
 packetdb_addpacket((0x0226), (282), 0xFFFF);




 packetdb_addpacket((0x0227), (18), 0xFFFF);
 packetdb_addpacket((0x0228), (18), 0xFFFF);




 packetdb_addpacket((0x0229), (15), 0xFFFF);
 packetdb_addpacket((0x022a), (58), 0xFFFF);
 packetdb_addpacket((0x022b), (57), 0xFFFF);
 packetdb_addpacket((0x022c), (64), 0xFFFF);




 packetdb_addpacket((0x022d), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x0232), (9),clif->pHomMoveTo,2,6, 0xFFFF);
 packetdb_addpacket((0x0233), (11),clif->pHomAttack,2,6,10, 0xFFFF);
 packetdb_addpacket((0x0234), (6),clif->pHomMoveToMaster,2, 0xFFFF);




 packetdb_addpacket((0x0072), (25),clif->pUseSkillToId,6,10,21, 0xFFFF);
 packetdb_addpacket((0x007e), (102),clif->pUseSkillToPosMoreInfo,5,9,12,20,22, 0xFFFF);
 packetdb_addpacket((0x0085), (11),clif->pChangeDir,7,10, 0xFFFF);
 packetdb_addpacket((0x0089), (8),clif->pTickSend,4, 0xFFFF);
 packetdb_addpacket((0x008c), (11),clif->pGetCharNameRequest,7, 0xFFFF);
 packetdb_addpacket((0x0094), (14),clif->pMoveToKafra,7,10, 0xFFFF);
 packetdb_addpacket((0x009b), (26),clif->pWantToConnection,4,9,17,21,25, 0xFFFF);
 packetdb_addpacket((0x009f), (14),clif->pUseItem,4,10, 0xFFFF);
 packetdb_addpacket((0x00a2), (15),clif->pSolveCharName,11, 0xFFFF);
 packetdb_addpacket((0x00a7), (8),clif->pWalkToXY,5, 0xFFFF);
 packetdb_addpacket((0x00f5), (8),clif->pTakeItem,4, 0xFFFF);
 packetdb_addpacket((0x00f7), (22),clif->pMoveFromKafra,14,18, 0xFFFF);
 packetdb_addpacket((0x0113), (22),clif->pUseSkillToPos,5,9,12,20, 0xFFFF);
 packetdb_addpacket((0x0116), (10),clif->pDropItem,5,8, 0xFFFF);
 packetdb_addpacket((0x0190), (19),clif->pActionRequest,5,18, 0xFFFF);




 packetdb_addpacket((0x022e), (69), 0xFFFF);
 packetdb_addpacket((0x0230), (12), 0xFFFF);




 packetdb_addpacket((0x022e), (71), 0xFFFF);
 packetdb_addpacket((0x0235), (-1), 0xFFFF);
 packetdb_addpacket((0x0236), (10), 0xFFFF);
 packetdb_addpacket((0x0237), (2),clif->pRankingPk,0, 0xFFFF);
 packetdb_addpacket((0x0238), (282), 0xFFFF);




 packetdb_addpacket((0x0216), (2), 0xFFFF);
 packetdb_addpacket((0x0239), (11), 0xFFFF);




 packetdb_addpacket((0x0216), (6), 0xFFFF);
 packetdb_addpacket((0x0217), (2),clif->pBlacksmith,0, 0xFFFF);
 packetdb_addpacket((0x022f), (5), 0xFFFF);
 packetdb_addpacket((0x0231), (26),clif->pChangeHomunculusName,0, 0xFFFF);
 packetdb_addpacket((0x023a), (4), 0xFFFF);
 packetdb_addpacket((0x023b), (36),clif->pStoragePassword,2,4,20, 0xFFFF);
 packetdb_addpacket((0x023c), (6), 0xFFFF);




 packetdb_addpacket((0x022e), (71), 0xFFFF);





 packetdb_addpacket((0x0072), (34),clif->pUseSkillToId,6,17,30, 0xFFFF);
 packetdb_addpacket((0x007e), (113),clif->pUseSkillToPosMoreInfo,12,15,18,31,33, 0xFFFF);
 packetdb_addpacket((0x0085), (17),clif->pChangeDir,8,16, 0xFFFF);
 packetdb_addpacket((0x0089), (13),clif->pTickSend,9, 0xFFFF);
 packetdb_addpacket((0x008c), (8),clif->pGetCharNameRequest,4, 0xFFFF);
 packetdb_addpacket((0x0094), (31),clif->pMoveToKafra,16,27, 0xFFFF);
 packetdb_addpacket((0x009b), (32),clif->pWantToConnection,9,15,23,27,31, 0xFFFF);
 packetdb_addpacket((0x009f), (19),clif->pUseItem,9,15, 0xFFFF);
 packetdb_addpacket((0x00a2), (9),clif->pSolveCharName,5, 0xFFFF);
 packetdb_addpacket((0x00a7), (11),clif->pWalkToXY,8, 0xFFFF);
 packetdb_addpacket((0x00f5), (13),clif->pTakeItem,9, 0xFFFF);
 packetdb_addpacket((0x00f7), (18),clif->pMoveFromKafra,11,14, 0xFFFF);
 packetdb_addpacket((0x0113), (33),clif->pUseSkillToPos,12,15,18,31, 0xFFFF);
 packetdb_addpacket((0x0116), (12),clif->pDropItem,3,10, 0xFFFF);
 packetdb_addpacket((0x0190), (24),clif->pActionRequest,11,23, 0xFFFF);
 packetdb_addpacket((0x0216), (-1), 0xFFFF);
 packetdb_addpacket((0x023d), (-1), 0xFFFF);
 packetdb_addpacket((0x023e), (4), 0xFFFF);




 packetdb_addpacket((0x0072), (19),clif->pUseSkillToId,5,11,15, 0xFFFF);
 packetdb_addpacket((0x007e), (110),clif->pUseSkillToPosMoreInfo,9,15,23,28,30, 0xFFFF);
 packetdb_addpacket((0x0085), (11),clif->pChangeDir,6,10, 0xFFFF);
 packetdb_addpacket((0x0089), (7),clif->pTickSend,3, 0xFFFF);
 packetdb_addpacket((0x008c), (11),clif->pGetCharNameRequest,7, 0xFFFF);
 packetdb_addpacket((0x0094), (21),clif->pMoveToKafra,12,17, 0xFFFF);
 packetdb_addpacket((0x009b), (31),clif->pWantToConnection,3,13,22,26,30, 0xFFFF);
 packetdb_addpacket((0x009f), (12),clif->pUseItem,3,8, 0xFFFF);
 packetdb_addpacket((0x00a2), (18),clif->pSolveCharName,14, 0xFFFF);
 packetdb_addpacket((0x00a7), (15),clif->pWalkToXY,12, 0xFFFF);
 packetdb_addpacket((0x00f5), (7),clif->pTakeItem,3, 0xFFFF);
 packetdb_addpacket((0x00f7), (13),clif->pMoveFromKafra,5,9, 0xFFFF);
 packetdb_addpacket((0x0113), (30),clif->pUseSkillToPos,9,15,23,28, 0xFFFF);
 packetdb_addpacket((0x0116), (12),clif->pDropItem,6,10, 0xFFFF);
 packetdb_addpacket((0x0190), (21),clif->pActionRequest,5,20, 0xFFFF);
 packetdb_addpacket((0x0216), (6), 0xFFFF);
 packetdb_addpacket((0x023f), (2),clif->pMail_refreshinbox,0, 0xFFFF);
 packetdb_addpacket((0x0240), (8), 0xFFFF);
 packetdb_addpacket((0x0241), (6),clif->pMail_read,2, 0xFFFF);
 packetdb_addpacket((0x0242), (-1), 0xFFFF);
 packetdb_addpacket((0x0243), (6),clif->pMail_delete,2, 0xFFFF);
 packetdb_addpacket((0x0244), (6),clif->pMail_getattach,2, 0xFFFF);
 packetdb_addpacket((0x0245), (7), 0xFFFF);
 packetdb_addpacket((0x0246), (4),clif->pMail_winopen,2, 0xFFFF);
 packetdb_addpacket((0x0247), (8),clif->pMail_setattach,2,4, 0xFFFF);
 packetdb_addpacket((0x0248), (68), 0xFFFF);
 packetdb_addpacket((0x0249), (3), 0xFFFF);
 packetdb_addpacket((0x024a), (70), 0xFFFF);
 packetdb_addpacket((0x024b), (4),clif->pAuction_cancelreg,0, 0xFFFF);
 packetdb_addpacket((0x024c), (8),clif->pAuction_setitem,0, 0xFFFF);
 packetdb_addpacket((0x024d), (14), 0xFFFF);
 packetdb_addpacket((0x024e), (6),clif->pAuction_cancel,0, 0xFFFF);
 packetdb_addpacket((0x024f), (10),clif->pAuction_bid,0, 0xFFFF);
 packetdb_addpacket((0x0250), (3), 0xFFFF);
 packetdb_addpacket((0x0251), (2), 0xFFFF);
 packetdb_addpacket((0x0252), (-1), 0xFFFF);




 packetdb_addpacket((0x0072), (34),clif->pUseSkillToId,6,17,30, 0xFFFF);
 packetdb_addpacket((0x007e), (113),clif->pUseSkillToPosMoreInfo,12,15,18,31,33, 0xFFFF);
 packetdb_addpacket((0x0085), (17),clif->pChangeDir,8,16, 0xFFFF);
 packetdb_addpacket((0x0089), (13),clif->pTickSend,9, 0xFFFF);
 packetdb_addpacket((0x008c), (8),clif->pGetCharNameRequest,4, 0xFFFF);
 packetdb_addpacket((0x0094), (31),clif->pMoveToKafra,16,27, 0xFFFF);
 packetdb_addpacket((0x009b), (32),clif->pWantToConnection,9,15,23,27,31, 0xFFFF);
 packetdb_addpacket((0x009f), (19),clif->pUseItem,9,15, 0xFFFF);
 packetdb_addpacket((0x00a2), (9),clif->pSolveCharName,5, 0xFFFF);
 packetdb_addpacket((0x00a7), (11),clif->pWalkToXY,8, 0xFFFF);
 packetdb_addpacket((0x00f5), (13),clif->pTakeItem,9, 0xFFFF);
 packetdb_addpacket((0x00f7), (18),clif->pMoveFromKafra,11,14, 0xFFFF);
 packetdb_addpacket((0x0113), (33),clif->pUseSkillToPos,12,15,18,31, 0xFFFF);
 packetdb_addpacket((0x0116), (12),clif->pDropItem,3,10, 0xFFFF);
 packetdb_addpacket((0x0190), (24),clif->pActionRequest,11,23, 0xFFFF);




 packetdb_addpacket((0x0245), (3), 0xFFFF);
 packetdb_addpacket((0x0251), (4), 0xFFFF);




 packetdb_addpacket((0x024d), (12),clif->pAuction_register,0, 0xFFFF);
 packetdb_addpacket((0x024e), (4), 0xFFFF);




 packetdb_addpacket((0x0253), (3), 0xFFFF);
 packetdb_addpacket((0x0254), (3),clif->pFeelSaveOk,0, 0xFFFF);




 packetdb_addpacket((0x0240), (-1), 0xFFFF);
 packetdb_addpacket((0x0248), (-1),clif->pMail_send,2,4,28,68, 0xFFFF);
 packetdb_addpacket((0x0255), (5), 0xFFFF);
 packetdb_addpacket((0x0256), (-1), 0xFFFF);
 packetdb_addpacket((0x0257), (8), 0xFFFF);




 packetdb_addpacket((0x0256), (5), 0xFFFF);
 packetdb_addpacket((0x0258), (2), 0xFFFF);
 packetdb_addpacket((0x0259), (3), 0xFFFF);




 packetdb_addpacket((0x020e), (32), 0xFFFF);
 packetdb_addpacket((0x025a), (-1), 0xFFFF);
 packetdb_addpacket((0x025b), (6),clif->pCooking,0, 0xFFFF);




 packetdb_addpacket((0x007a), (6), 0xFFFF);
 packetdb_addpacket((0x0251), (32), 0xFFFF);
 packetdb_addpacket((0x025c), (4),clif->pAuction_buysell,0, 0xFFFF);




 packetdb_addpacket((0x007a), (58), 0xFFFF);
 packetdb_addpacket((0x025d), (6),clif->pAuction_close,0, 0xFFFF);
 packetdb_addpacket((0x025e), (4), 0xFFFF);




 packetdb_addpacket((0x025f), (6), 0xFFFF);
 packetdb_addpacket((0x0260), (6), 0xFFFF);




 packetdb_addpacket((0x024e), (6),clif->pAuction_cancel,0, 0xFFFF);
 packetdb_addpacket((0x0251), (34),clif->pAuction_search,0, 0xFFFF);




 packetdb_addpacket((0x0261), (11), 0xFFFF);
 packetdb_addpacket((0x0262), (11), 0xFFFF);
 packetdb_addpacket((0x0263), (11), 0xFFFF);
 packetdb_addpacket((0x0264), (20), 0xFFFF);
 packetdb_addpacket((0x0265), (20), 0xFFFF);
 packetdb_addpacket((0x0266), (30), 0xFFFF);
 packetdb_addpacket((0x0267), (4), 0xFFFF);
 packetdb_addpacket((0x0268), (4), 0xFFFF);
 packetdb_addpacket((0x0269), (4), 0xFFFF);
 packetdb_addpacket((0x026a), (4), 0xFFFF);
 packetdb_addpacket((0x026b), (4), 0xFFFF);
 packetdb_addpacket((0x026c), (4), 0xFFFF);
 packetdb_addpacket((0x026d), (4), 0xFFFF);
 packetdb_addpacket((0x026f), (2), 0xFFFF);
 packetdb_addpacket((0x0270), (2), 0xFFFF);
 packetdb_addpacket((0x0271), (38), 0xFFFF);
 packetdb_addpacket((0x0272), (44), 0xFFFF);




 packetdb_addpacket((0x0271), (40), 0xFFFF);





 packetdb_addpacket((0x0273), (6), 0xFFFF);
 packetdb_addpacket((0x0274), (8), 0xFFFF);




 packetdb_addpacket((0x0273), (30),clif->pMail_return,2,6, 0xFFFF);




 packetdb_addpacket((0x0072), (26),clif->pUseSkillToId,11,18,22, 0xFFFF);
 packetdb_addpacket((0x007e), (120),clif->pUseSkillToPosMoreInfo,5,15,29,38,40, 0xFFFF);
 packetdb_addpacket((0x0085), (12),clif->pChangeDir,7,11, 0xFFFF);

 packetdb_addpacket((0x008c), (12),clif->pGetCharNameRequest,8, 0xFFFF);
 packetdb_addpacket((0x0094), (23),clif->pMoveToKafra,5,19, 0xFFFF);
 packetdb_addpacket((0x009b), (37),clif->pWantToConnection,9,21,28,32,36, 0xFFFF);
 packetdb_addpacket((0x009f), (24),clif->pUseItem,9,20, 0xFFFF);
 packetdb_addpacket((0x00a2), (11),clif->pSolveCharName,7, 0xFFFF);
 packetdb_addpacket((0x00a7), (15),clif->pWalkToXY,12, 0xFFFF);
 packetdb_addpacket((0x00f5), (13),clif->pTakeItem,9, 0xFFFF);
 packetdb_addpacket((0x00f7), (26),clif->pMoveFromKafra,11,22, 0xFFFF);
 packetdb_addpacket((0x0113), (40),clif->pUseSkillToPos,5,15,29,38, 0xFFFF);
 packetdb_addpacket((0x0116), (17),clif->pDropItem,8,15, 0xFFFF);
 packetdb_addpacket((0x0190), (18),clif->pActionRequest,7,17, 0xFFFF);




 packetdb_addpacket((0x006d), (110), 0xFFFF);




 packetdb_addpacket((0x023e), (8), 0xFFFF);
 packetdb_addpacket((0x0277), (84), 0xFFFF);
 packetdb_addpacket((0x0278), (2), 0xFFFF);
 packetdb_addpacket((0x0279), (2), 0xFFFF);
 packetdb_addpacket((0x027a), (-1), 0xFFFF);
 packetdb_addpacket((0x027b), (14), 0xFFFF);
 packetdb_addpacket((0x027c), (60), 0xFFFF);
 packetdb_addpacket((0x027d), (62), 0xFFFF);
 packetdb_addpacket((0x027e), (-1), 0xFFFF);
 packetdb_addpacket((0x027f), (8), 0xFFFF);
 packetdb_addpacket((0x0280), (12), 0xFFFF);
 packetdb_addpacket((0x0281), (4), 0xFFFF);
 packetdb_addpacket((0x0282), (284), 0xFFFF);
 packetdb_addpacket((0x0283), (6), 0xFFFF);
 packetdb_addpacket((0x0284), (14), 0xFFFF);
 packetdb_addpacket((0x0285), (6), 0xFFFF);
 packetdb_addpacket((0x0286), (4), 0xFFFF);
 packetdb_addpacket((0x0287), (-1), 0xFFFF);
 packetdb_addpacket((0x0288), (6), 0xFFFF);
 packetdb_addpacket((0x0289), (8), 0xFFFF);
 packetdb_addpacket((0x028a), (18), 0xFFFF);
 packetdb_addpacket((0x028b), (-1), 0xFFFF);
 packetdb_addpacket((0x028c), (46), 0xFFFF);
 packetdb_addpacket((0x028d), (34), 0xFFFF);
 packetdb_addpacket((0x028e), (4), 0xFFFF);
 packetdb_addpacket((0x028f), (6), 0xFFFF);
 packetdb_addpacket((0x0290), (4), 0xFFFF);
 packetdb_addpacket((0x0291), (4), 0xFFFF);
 packetdb_addpacket((0x0292), (2),clif->pAutoRevive,0, 0xFFFF);
 packetdb_addpacket((0x0293), (70), 0xFFFF);
 packetdb_addpacket((0x0294), (10), 0xFFFF);
 packetdb_addpacket((0x0295), (-1), 0xFFFF);
 packetdb_addpacket((0x0296), (-1), 0xFFFF);
 packetdb_addpacket((0x0297), (-1), 0xFFFF);
 packetdb_addpacket((0x0298), (8), 0xFFFF);
 packetdb_addpacket((0x0299), (6), 0xFFFF);
 packetdb_addpacket((0x029a), (27), 0xFFFF);
 packetdb_addpacket((0x029c), (66), 0xFFFF);
 packetdb_addpacket((0x029d), (-1), 0xFFFF);
 packetdb_addpacket((0x029e), (11), 0xFFFF);
 packetdb_addpacket((0x029f), (3),clif->pmercenary_action,0, 0xFFFF);
 packetdb_addpacket((0x02a0), (-1), 0xFFFF);
 packetdb_addpacket((0x02a1), (-1), 0xFFFF);
 packetdb_addpacket((0x02a2), (8), 0xFFFF);




 packetdb_addpacket((0x0072), (30),clif->pUseSkillToId,10,14,26, 0xFFFF);
 packetdb_addpacket((0x007e), (120),clif->pUseSkillToPosMoreInfo,10,19,23,38,40, 0xFFFF);
 packetdb_addpacket((0x0085), (14),clif->pChangeDir,10,13, 0xFFFF);
 packetdb_addpacket((0x0089), (11),clif->pTickSend,7, 0xFFFF);
 packetdb_addpacket((0x008c), (17),clif->pGetCharNameRequest,13, 0xFFFF);
 packetdb_addpacket((0x0094), (17),clif->pMoveToKafra,4,13, 0xFFFF);
 packetdb_addpacket((0x009b), (35),clif->pWantToConnection,7,21,26,30,34, 0xFFFF);
 packetdb_addpacket((0x009f), (21),clif->pUseItem,7,17, 0xFFFF);
 packetdb_addpacket((0x00a2), (10),clif->pSolveCharName,6, 0xFFFF);
 packetdb_addpacket((0x00a7), (8),clif->pWalkToXY,5, 0xFFFF);
 packetdb_addpacket((0x00f5), (11),clif->pTakeItem,7, 0xFFFF);
 packetdb_addpacket((0x00f7), (15),clif->pMoveFromKafra,3,11, 0xFFFF);
 packetdb_addpacket((0x0113), (40),clif->pUseSkillToPos,10,19,23,38, 0xFFFF);
 packetdb_addpacket((0x0116), (19),clif->pDropItem,11,17, 0xFFFF);
 packetdb_addpacket((0x0190), (10),clif->pActionRequest,4,9, 0xFFFF);




 packetdb_addpacket((0x02a3), (18), 0xFFFF);
 packetdb_addpacket((0x02a4), (2), 0xFFFF);




 packetdb_addpacket((0x029b), (72), 0xFFFF);
 packetdb_addpacket((0x02a3), (-1), 0xFFFF);
 packetdb_addpacket((0x02a4), (-1), 0xFFFF);
 packetdb_addpacket((0x02a5), (8), 0xFFFF);





 packetdb_addpacket((0x02aa), (4), 0xFFFF);
 packetdb_addpacket((0x02ab), (36), 0xFFFF);
 packetdb_addpacket((0x02ac), (6), 0xFFFF);




 packetdb_addpacket((0x0072), (25),clif->pUseSkillToId,6,10,21, 0xFFFF);
 packetdb_addpacket((0x007e), (102),clif->pUseSkillToPosMoreInfo,5,9,12,20,22, 0xFFFF);
 packetdb_addpacket((0x0085), (11),clif->pChangeDir,7,10, 0xFFFF);
 packetdb_addpacket((0x0089), (8),clif->pTickSend,4, 0xFFFF);
 packetdb_addpacket((0x008c), (11),clif->pGetCharNameRequest,7, 0xFFFF);
 packetdb_addpacket((0x0094), (14),clif->pMoveToKafra,7,10, 0xFFFF);
 packetdb_addpacket((0x009b), (26),clif->pWantToConnection,4,9,17,21,25, 0xFFFF);
 packetdb_addpacket((0x009f), (14),clif->pUseItem,4,10, 0xFFFF);
 packetdb_addpacket((0x00a2), (15),clif->pSolveCharName,11, 0xFFFF);

 packetdb_addpacket((0x00f5), (8),clif->pTakeItem,4, 0xFFFF);
 packetdb_addpacket((0x00f7), (22),clif->pMoveFromKafra,14,18, 0xFFFF);
 packetdb_addpacket((0x0113), (22),clif->pUseSkillToPos,5,9,12,20, 0xFFFF);
 packetdb_addpacket((0x0116), (10),clif->pDropItem,5,8, 0xFFFF);
 packetdb_addpacket((0x0190), (19),clif->pActionRequest,5,18, 0xFFFF);




 packetdb_addpacket((0x01fd), (15),clif->pRepairItem,2, 0xFFFF);




 packetdb_addpacket((0x0288), (10),clif->pcashshop_buy,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0289), (12), 0xFFFF);
 packetdb_addpacket((0x02a6), (22), 0xFFFF);
 packetdb_addpacket((0x02a7), (22), 0xFFFF);
 packetdb_addpacket((0x02a8), (162), 0xFFFF);
 packetdb_addpacket((0x02a9), (58), 0xFFFF);
 packetdb_addpacket((0x02ad), (8), 0xFFFF);
 packetdb_addpacket((0x02b0), (85), 0xFFFF);
 packetdb_addpacket((0x02b1), (-1), 0xFFFF);
 packetdb_addpacket((0x02b2), (-1), 0xFFFF);
 packetdb_addpacket((0x02b3), (107), 0xFFFF);
 packetdb_addpacket((0x02b4), (6), 0xFFFF);
 packetdb_addpacket((0x02b5), (-1), 0xFFFF);
 packetdb_addpacket((0x02b6), (7),clif->pquestStateAck,2,6, 0xFFFF);
 packetdb_addpacket((0x02b7), (7), 0xFFFF);
 packetdb_addpacket((0x02b8), (22), 0xFFFF);
 packetdb_addpacket((0x02b9), (191), 0xFFFF);
 packetdb_addpacket((0x02ba), (11),clif->pHotkey,2,4,5,9, 0xFFFF);
 packetdb_addpacket((0x02bb), (8), 0xFFFF);
 packetdb_addpacket((0x02bc), (6), 0xFFFF);
 packetdb_addpacket((0x02bf), (10), 0xFFFF);
 packetdb_addpacket((0x02c0), (2), 0xFFFF);
 packetdb_addpacket((0x02c1), (-1), 0xFFFF);
 packetdb_addpacket((0x02c2), (-1), 0xFFFF);
 packetdb_addpacket((0x02c4), (26),clif->pPartyInvite2,2, 0xFFFF);
 packetdb_addpacket((0x02c5), (30), 0xFFFF);
 packetdb_addpacket((0x02c6), (30), 0xFFFF);
 packetdb_addpacket((0x02c7), (7),clif->pReplyPartyInvite2,2,6, 0xFFFF);
 packetdb_addpacket((0x02c8), (3),clif->pPartyTick,2, 0xFFFF);
 packetdb_addpacket((0x02c9), (3), 0xFFFF);
 packetdb_addpacket((0x02ca), (3), 0xFFFF);
 packetdb_addpacket((0x02cb), (20), 0xFFFF);
 packetdb_addpacket((0x02cc), (4), 0xFFFF);
 packetdb_addpacket((0x02cd), (26), 0xFFFF);
 packetdb_addpacket((0x02ce), (10), 0xFFFF);
 packetdb_addpacket((0x02cf), (6), 0xFFFF);
 packetdb_addpacket((0x02d0), (-1), 0xFFFF);
 packetdb_addpacket((0x02d1), (-1), 0xFFFF);
 packetdb_addpacket((0x02d2), (-1), 0xFFFF);
 packetdb_addpacket((0x02d3), (4), 0xFFFF);
 packetdb_addpacket((0x02d4), (29), 0xFFFF);
 packetdb_addpacket((0x02d5), (2), 0xFFFF);
 packetdb_addpacket((0x02d6), (6),clif->pViewPlayerEquip,2, 0xFFFF);
 packetdb_addpacket((0x02d7), (-1), 0xFFFF);
 packetdb_addpacket((0x02d8), (10),clif->pEquipTick,6, 0xFFFF);
 packetdb_addpacket((0x02d9), (10), 0xFFFF);
 packetdb_addpacket((0x02da), (3), 0xFFFF);
 packetdb_addpacket((0x02db), (-1),clif->pBattleChat,2,4, 0xFFFF);
 packetdb_addpacket((0x02dc), (-1), 0xFFFF);
 packetdb_addpacket((0x02dd), (32), 0xFFFF);
 packetdb_addpacket((0x02de), (6), 0xFFFF);
 packetdb_addpacket((0x02df), (36), 0xFFFF);
 packetdb_addpacket((0x02e0), (34), 0xFFFF);




 packetdb_addpacket((0x02cb), (65), 0xFFFF);
 packetdb_addpacket((0x02cd), (71), 0xFFFF);




 packetdb_addpacket((0x0078), (55), 0xFFFF);
 packetdb_addpacket((0x007c), (42), 0xFFFF);
 packetdb_addpacket((0x022c), (65), 0xFFFF);
 packetdb_addpacket((0x029b), (80), 0xFFFF);




 packetdb_addpacket((0x02e1), (33), 0xFFFF);





 packetdb_addpacket((0x02e2), (14), 0xFFFF);
 packetdb_addpacket((0x02e3), (25), 0xFFFF);
 packetdb_addpacket((0x02e4), (8), 0xFFFF);
 packetdb_addpacket((0x02e5), (8), 0xFFFF);
 packetdb_addpacket((0x02e6), (6), 0xFFFF);




 packetdb_addpacket((0x02e7), (-1), 0xFFFF);




 packetdb_addpacket((0x01df), (6),clif->pGMReqAccountName,2, 0xFFFF);
 packetdb_addpacket((0x02e8), (-1), 0xFFFF);
 packetdb_addpacket((0x02e9), (-1), 0xFFFF);
 packetdb_addpacket((0x02ea), (-1), 0xFFFF);
 packetdb_addpacket((0x02eb), (13), 0xFFFF);
 packetdb_addpacket((0x02ec), (67), 0xFFFF);
 packetdb_addpacket((0x02ed), (59), 0xFFFF);
 packetdb_addpacket((0x02ee), (60), 0xFFFF);
 packetdb_addpacket((0x02ef), (8), 0xFFFF);




 packetdb_addpacket((0x02bf), (-1), 0xFFFF);
 packetdb_addpacket((0x02c0), (-1), 0xFFFF);
 packetdb_addpacket((0x02f0), (10), 0xFFFF);
 packetdb_addpacket((0x02f1), (2),clif->pProgressbar,0, 0xFFFF);
 packetdb_addpacket((0x02f2), (2), 0xFFFF);




 packetdb_addpacket((0x02f3), (-1), 0xFFFF);
 packetdb_addpacket((0x02f4), (-1), 0xFFFF);
 packetdb_addpacket((0x02f5), (-1), 0xFFFF);
 packetdb_addpacket((0x02f6), (-1), 0xFFFF);
 packetdb_addpacket((0x02f7), (-1), 0xFFFF);
 packetdb_addpacket((0x02f8), (-1), 0xFFFF);
 packetdb_addpacket((0x02f9), (-1), 0xFFFF);
 packetdb_addpacket((0x02fa), (-1), 0xFFFF);
 packetdb_addpacket((0x02fb), (-1), 0xFFFF);
 packetdb_addpacket((0x02fc), (-1), 0xFFFF);
 packetdb_addpacket((0x02fd), (-1), 0xFFFF);
 packetdb_addpacket((0x02fe), (-1), 0xFFFF);
 packetdb_addpacket((0x02ff), (-1), 0xFFFF);
 packetdb_addpacket((0x0300), (-1), 0xFFFF);




 packetdb_addpacket((0x0301), (-1), 0xFFFF);
 packetdb_addpacket((0x0302), (-1), 0xFFFF);
 packetdb_addpacket((0x0303), (-1), 0xFFFF);
 packetdb_addpacket((0x0304), (-1), 0xFFFF);
 packetdb_addpacket((0x0305), (-1), 0xFFFF);
 packetdb_addpacket((0x0306), (-1), 0xFFFF);
 packetdb_addpacket((0x0307), (-1), 0xFFFF);
 packetdb_addpacket((0x0308), (-1), 0xFFFF);
 packetdb_addpacket((0x0309), (-1), 0xFFFF);
 packetdb_addpacket((0x030a), (-1), 0xFFFF);
 packetdb_addpacket((0x030b), (-1), 0xFFFF);
 packetdb_addpacket((0x030c), (-1), 0xFFFF);
 packetdb_addpacket((0x030d), (-1), 0xFFFF);
 packetdb_addpacket((0x030e), (-1), 0xFFFF);
 packetdb_addpacket((0x030f), (-1), 0xFFFF);
 packetdb_addpacket((0x0310), (-1), 0xFFFF);
 packetdb_addpacket((0x0311), (-1), 0xFFFF);
 packetdb_addpacket((0x0312), (-1), 0xFFFF);
 packetdb_addpacket((0x0313), (-1), 0xFFFF);
 packetdb_addpacket((0x0314), (-1), 0xFFFF);
 packetdb_addpacket((0x0315), (-1), 0xFFFF);
 packetdb_addpacket((0x0316), (-1), 0xFFFF);
 packetdb_addpacket((0x0317), (-1), 0xFFFF);
 packetdb_addpacket((0x0318), (-1), 0xFFFF);
 packetdb_addpacket((0x0319), (-1), 0xFFFF);
 packetdb_addpacket((0x031a), (-1), 0xFFFF);
 packetdb_addpacket((0x031b), (-1), 0xFFFF);
 packetdb_addpacket((0x031c), (-1), 0xFFFF);
 packetdb_addpacket((0x031d), (-1), 0xFFFF);
 packetdb_addpacket((0x031e), (-1), 0xFFFF);
 packetdb_addpacket((0x031f), (-1), 0xFFFF);
 packetdb_addpacket((0x0320), (-1), 0xFFFF);
 packetdb_addpacket((0x0321), (-1), 0xFFFF);
 packetdb_addpacket((0x0322), (-1), 0xFFFF);
 packetdb_addpacket((0x0323), (-1), 0xFFFF);
 packetdb_addpacket((0x0324), (-1), 0xFFFF);
 packetdb_addpacket((0x0325), (-1), 0xFFFF);
 packetdb_addpacket((0x0326), (-1), 0xFFFF);
 packetdb_addpacket((0x0327), (-1), 0xFFFF);
 packetdb_addpacket((0x0328), (-1), 0xFFFF);
 packetdb_addpacket((0x0329), (-1), 0xFFFF);
 packetdb_addpacket((0x032a), (-1), 0xFFFF);
 packetdb_addpacket((0x032b), (-1), 0xFFFF);
 packetdb_addpacket((0x032c), (-1), 0xFFFF);
 packetdb_addpacket((0x032d), (-1), 0xFFFF);
 packetdb_addpacket((0x032e), (-1), 0xFFFF);
 packetdb_addpacket((0x032f), (-1), 0xFFFF);
 packetdb_addpacket((0x0330), (-1), 0xFFFF);
 packetdb_addpacket((0x0331), (-1), 0xFFFF);
 packetdb_addpacket((0x0332), (-1), 0xFFFF);
 packetdb_addpacket((0x0333), (-1), 0xFFFF);
 packetdb_addpacket((0x0334), (-1), 0xFFFF);
 packetdb_addpacket((0x0335), (-1), 0xFFFF);
 packetdb_addpacket((0x0336), (-1), 0xFFFF);
 packetdb_addpacket((0x0337), (-1), 0xFFFF);
 packetdb_addpacket((0x0338), (-1), 0xFFFF);
 packetdb_addpacket((0x0339), (-1), 0xFFFF);
 packetdb_addpacket((0x033a), (-1), 0xFFFF);
 packetdb_addpacket((0x033b), (-1), 0xFFFF);
 packetdb_addpacket((0x033c), (-1), 0xFFFF);
 packetdb_addpacket((0x033d), (-1), 0xFFFF);
 packetdb_addpacket((0x033e), (-1), 0xFFFF);
 packetdb_addpacket((0x033f), (-1), 0xFFFF);
 packetdb_addpacket((0x0340), (-1), 0xFFFF);
 packetdb_addpacket((0x0341), (-1), 0xFFFF);
 packetdb_addpacket((0x0342), (-1), 0xFFFF);
 packetdb_addpacket((0x0343), (-1), 0xFFFF);
 packetdb_addpacket((0x0344), (-1), 0xFFFF);
 packetdb_addpacket((0x0345), (-1), 0xFFFF);
 packetdb_addpacket((0x0346), (-1), 0xFFFF);
 packetdb_addpacket((0x0347), (-1), 0xFFFF);
 packetdb_addpacket((0x0348), (-1), 0xFFFF);
 packetdb_addpacket((0x0349), (-1), 0xFFFF);
 packetdb_addpacket((0x034a), (-1), 0xFFFF);
 packetdb_addpacket((0x034b), (-1), 0xFFFF);
 packetdb_addpacket((0x034c), (-1), 0xFFFF);
 packetdb_addpacket((0x034d), (-1), 0xFFFF);
 packetdb_addpacket((0x034e), (-1), 0xFFFF);
 packetdb_addpacket((0x034f), (-1), 0xFFFF);
 packetdb_addpacket((0x0350), (-1), 0xFFFF);
 packetdb_addpacket((0x0351), (-1), 0xFFFF);
 packetdb_addpacket((0x0352), (-1), 0xFFFF);
 packetdb_addpacket((0x0353), (-1), 0xFFFF);
 packetdb_addpacket((0x0354), (-1), 0xFFFF);
 packetdb_addpacket((0x0355), (-1), 0xFFFF);
 packetdb_addpacket((0x0356), (-1), 0xFFFF);
 packetdb_addpacket((0x0357), (-1), 0xFFFF);
 packetdb_addpacket((0x0358), (-1), 0xFFFF);
 packetdb_addpacket((0x0359), (-1), 0xFFFF);
 packetdb_addpacket((0x035a), (-1), 0xFFFF);




 packetdb_addpacket((0x035b), (-1), 0xFFFF);
 packetdb_addpacket((0x035c), (2), 0xFFFF);
 packetdb_addpacket((0x035d), (-1), 0xFFFF);
 packetdb_addpacket((0x035e), (2), 0xFFFF);
 packetdb_addpacket((0x035f), (-1), 0xFFFF);
 packetdb_addpacket((0x0389), (-1), 0xFFFF);




 packetdb_addpacket((0x040c), (-1), 0xFFFF);
 packetdb_addpacket((0x040d), (-1), 0xFFFF);
 packetdb_addpacket((0x040e), (-1), 0xFFFF);
 packetdb_addpacket((0x040f), (-1), 0xFFFF);
 packetdb_addpacket((0x0410), (-1), 0xFFFF);
 packetdb_addpacket((0x0411), (-1), 0xFFFF);
 packetdb_addpacket((0x0412), (-1), 0xFFFF);
 packetdb_addpacket((0x0413), (-1), 0xFFFF);
 packetdb_addpacket((0x0414), (-1), 0xFFFF);
 packetdb_addpacket((0x0415), (-1), 0xFFFF);
 packetdb_addpacket((0x0416), (-1), 0xFFFF);
 packetdb_addpacket((0x0417), (-1), 0xFFFF);
 packetdb_addpacket((0x0418), (-1), 0xFFFF);
 packetdb_addpacket((0x0419), (-1), 0xFFFF);
 packetdb_addpacket((0x041a), (-1), 0xFFFF);
 packetdb_addpacket((0x041b), (-1), 0xFFFF);
 packetdb_addpacket((0x041c), (-1), 0xFFFF);
 packetdb_addpacket((0x041d), (-1), 0xFFFF);
 packetdb_addpacket((0x041e), (-1), 0xFFFF);
 packetdb_addpacket((0x041f), (-1), 0xFFFF);
 packetdb_addpacket((0x0420), (-1), 0xFFFF);
 packetdb_addpacket((0x0421), (-1), 0xFFFF);
 packetdb_addpacket((0x0422), (-1), 0xFFFF);
 packetdb_addpacket((0x0423), (-1), 0xFFFF);
 packetdb_addpacket((0x0424), (-1), 0xFFFF);
 packetdb_addpacket((0x0425), (-1), 0xFFFF);
 packetdb_addpacket((0x0426), (-1), 0xFFFF);
 packetdb_addpacket((0x0427), (-1), 0xFFFF);
 packetdb_addpacket((0x0428), (-1), 0xFFFF);
 packetdb_addpacket((0x0429), (-1), 0xFFFF);
 packetdb_addpacket((0x042a), (-1), 0xFFFF);
 packetdb_addpacket((0x042b), (-1), 0xFFFF);
 packetdb_addpacket((0x042c), (-1), 0xFFFF);
 packetdb_addpacket((0x042d), (-1), 0xFFFF);
 packetdb_addpacket((0x042e), (-1), 0xFFFF);
 packetdb_addpacket((0x042f), (-1), 0xFFFF);
 packetdb_addpacket((0x0430), (-1), 0xFFFF);
 packetdb_addpacket((0x0431), (-1), 0xFFFF);
 packetdb_addpacket((0x0432), (-1), 0xFFFF);
 packetdb_addpacket((0x0433), (-1), 0xFFFF);
 packetdb_addpacket((0x0434), (-1), 0xFFFF);
 packetdb_addpacket((0x0435), (-1), 0xFFFF);




 packetdb_addpacket((0x0436), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0437), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x0438), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0439), (8),clif->pUseItem,2,4, 0xFFFF);




 packetdb_addpacket((0x043d), (8), 0xFFFF);
 packetdb_addpacket((0x043e), (-1), 0xFFFF);
 packetdb_addpacket((0x043f), (8), 0xFFFF);




 packetdb_addpacket((0x01a2), (37), 0xFFFF);
 packetdb_addpacket((0x0440), (10), 0xFFFF);
 packetdb_addpacket((0x0441), (4), 0xFFFF);




 packetdb_addpacket((0x0442), (-1), 0xFFFF);
 packetdb_addpacket((0x0443), (8),clif->pSkillSelectMenu,2,6, 0xFFFF);




 packetdb_addpacket((0x043f), (25), 0xFFFF);
 packetdb_addpacket((0x0444), (-1), 0xFFFF);
 packetdb_addpacket((0x0445), (10), 0xFFFF);




 packetdb_addpacket((0x0446), (14), 0xFFFF);




 packetdb_addpacket((0x0448), (-1), 0xFFFF);




 packetdb_addpacket((0x0449), (4), 0xFFFF);




 packetdb_addpacket((0x02a6), (-1), 0xFFFF);
 packetdb_addpacket((0x02a7), (-1), 0xFFFF);
 packetdb_addpacket((0x044a), (6), 0xFFFF);




 packetdb_addpacket((0x0072), (22),clif->pUseSkillToId,9,15,18, 0xFFFF);
 packetdb_addpacket((0x007c), (44), 0xFFFF);
 packetdb_addpacket((0x007e), (105),clif->pUseSkillToPosMoreInfo,10,14,18,23,25, 0xFFFF);
 packetdb_addpacket((0x0085), (10),clif->pChangeDir,4,9, 0xFFFF);
 packetdb_addpacket((0x0089), (11),clif->pTickSend,7, 0xFFFF);
 packetdb_addpacket((0x008c), (14),clif->pGetCharNameRequest,10, 0xFFFF);
 packetdb_addpacket((0x0094), (19),clif->pMoveToKafra,3,15, 0xFFFF);
 packetdb_addpacket((0x009b), (34),clif->pWantToConnection,7,15,25,29,33, 0xFFFF);
 packetdb_addpacket((0x009f), (20),clif->pUseItem,7,20, 0xFFFF);
 packetdb_addpacket((0x00a2), (14),clif->pSolveCharName,10, 0xFFFF);
 packetdb_addpacket((0x00a7), (9),clif->pWalkToXY,6, 0xFFFF);
 packetdb_addpacket((0x00f5), (11),clif->pTakeItem,7, 0xFFFF);
 packetdb_addpacket((0x00f7), (17),clif->pMoveFromKafra,3,13, 0xFFFF);
 packetdb_addpacket((0x0113), (25),clif->pUseSkillToPos,10,14,18,23, 0xFFFF);
 packetdb_addpacket((0x0116), (17),clif->pDropItem,6,15, 0xFFFF);
 packetdb_addpacket((0x0190), (23),clif->pActionRequest,9,22, 0xFFFF);
 packetdb_addpacket((0x02e2), (20), 0xFFFF);
 packetdb_addpacket((0x02e3), (22), 0xFFFF);
 packetdb_addpacket((0x02e4), (11), 0xFFFF);
 packetdb_addpacket((0x02e5), (9), 0xFFFF);




 packetdb_addpacket((0x0436), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0437), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x0438), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0439), (8),clif->pUseItem,2,4, 0xFFFF);





 packetdb_addpacket((0x043d), (8), 0xFFFF);

 packetdb_addpacket((0x043f), (8), 0xFFFF);




 packetdb_addpacket((0x01a2), (37), 0xFFFF);
# 1501 "../../../server-code/src/map/packets.h"
 packetdb_addpacket((0x006d), (114), 0xFFFF);





 packetdb_addpacket((0x043f), (25), 0xFFFF);
# 1546 "../../../server-code/src/map/packets.h"
 packetdb_addpacket((0x07d7), (8),clif->pPartyChangeOption,2,6,7, 0xFFFF);
 packetdb_addpacket((0x07d8), (8), 0xFFFF);
 packetdb_addpacket((0x07d9), (254), 0xFFFF);
 packetdb_addpacket((0x07da), (6),clif->pPartyChangeLeader,2, 0xFFFF);
# 1559 "../../../server-code/src/map/packets.h"
 packetdb_addpacket((0x07d9), (268), 0xFFFF);
# 1579 "../../../server-code/src/map/packets.h"
 packetdb_addpacket((0x07e1), (15), 0xFFFF);




 packetdb_addpacket((0x07e2), (8), 0xFFFF);




 packetdb_addpacket((0x07e3), (6), 0xFFFF);
 packetdb_addpacket((0x07e4), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x07e6), (8), 0xFFFF);





 packetdb_addpacket((0x07e7), (5), 0xFFFF);




 packetdb_addpacket((0x07e5), (8), 0xFFFF);
 packetdb_addpacket((0x07e6), (8), 0xFFFF);
 packetdb_addpacket((0x07e7), (32), 0xFFFF);
 packetdb_addpacket((0x07e8), (-1), 0xFFFF);
 packetdb_addpacket((0x07e9), (5), 0xFFFF);
# 1635 "../../../server-code/src/map/packets.h"
 packetdb_addpacket((0x07f5), (6),clif->pGMFullStrip,2, 0xFFFF);
 packetdb_addpacket((0x07f6), (14), 0xFFFF);




 packetdb_addpacket((0x07f7), (-1), 0xFFFF);
 packetdb_addpacket((0x07f8), (-1), 0xFFFF);
 packetdb_addpacket((0x07f9), (-1), 0xFFFF);




 packetdb_addpacket((0x07fa), (8), 0xFFFF);





 packetdb_addpacket((0x07fb), (25), 0xFFFF);






 packetdb_addpacket((0x07fe), (26), 0xFFFF);





 packetdb_addpacket((0x0800), (-1), 0xFFFF);





 packetdb_addpacket((0x0802), (18),clif->pPartyBookingRegisterReq,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0803), (4), 0xFFFF);
 packetdb_addpacket((0x0804), (8), 0xFFFF);
 packetdb_addpacket((0x0805), (-1), 0xFFFF);
 packetdb_addpacket((0x0806), (4),clif->pPartyBookingDeleteReq,2, 0xFFFF);

 packetdb_addpacket((0x0808), (4), 0xFFFF);
# 1688 "../../../server-code/src/map/packets.h"
 packetdb_addpacket((0x0804), (14),clif->pPartyBookingSearchReq,2,4,6,8,12, 0xFFFF);
 packetdb_addpacket((0x0806), (2),clif->pPartyBookingDeleteReq,0, 0xFFFF);
 packetdb_addpacket((0x0807), (4), 0xFFFF);
 packetdb_addpacket((0x0808), (14),clif->pPartyBookingUpdateReq,2, 0xFFFF);
 packetdb_addpacket((0x0809), (50), 0xFFFF);
 packetdb_addpacket((0x080A), (18), 0xFFFF);
 packetdb_addpacket((0x080B), (6), 0xFFFF);




 packetdb_addpacket((0x0801), (-1),clif->pPurchaseReq2,2,4,8,12, 0xFFFF);






 packetdb_addpacket((0x080E), (14), 0xFFFF);
# 1716 "../../../server-code/src/map/packets.h"
 packetdb_addpacket((0x080F), (20), 0xFFFF);




 packetdb_addpacket((0x0810), (3), 0xFFFF);
 packetdb_addpacket((0x0811), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);
# 1734 "../../../server-code/src/map/packets.h"
 packetdb_addpacket((0x0813), (-1), 0xFFFF);


 packetdb_addpacket((0x0816), (6), 0xFFFF);
 packetdb_addpacket((0x0818), (-1), 0xFFFF);




 packetdb_addpacket((0x081d), (22), 0xFFFF);
 packetdb_addpacket((0x081e), (8), 0xFFFF);
# 1760 "../../../server-code/src/map/packets.h"
 packetdb_addpacket((0x0820), (11), 0xFFFF);
# 1773 "../../../server-code/src/map/packets.h"
 packetdb_addpacket((0x0812), (8), 0xFFFF);
 packetdb_addpacket((0x0814), (86), 0xFFFF);
 packetdb_addpacket((0x0815), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0817), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x0819), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x081a), (4), 0xFFFF);
 packetdb_addpacket((0x081b), (10), 0xFFFF);
 packetdb_addpacket((0x081c), (10), 0xFFFF);
 packetdb_addpacket((0x0824), (6), 0xFFFF);






 packetdb_addpacket((0x0835), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x0836), (-1), 0xFFFF);
 packetdb_addpacket((0x0837), (3), 0xFFFF);





 packetdb_addpacket((0x0838), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x083A), (4), 0xFFFF);
 packetdb_addpacket((0x083B), (2),clif->pCloseSearchStoreInfo,0, 0xFFFF);
 packetdb_addpacket((0x083C), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x083D), (6), 0xFFFF);
# 1815 "../../../server-code/src/map/packets.h"
 packetdb_addpacket((0x00AA), (9), 0xFFFF);







 packetdb_addpacket((0x083A), (5), 0xFFFF);
# 1845 "../../../server-code/src/map/packets.h"
 packetdb_addpacket((0x0839), (66), 0xFFFF);
 packetdb_addpacket((0x0842), (6),clif->pGMRecall2,2, 0xFFFF);
 packetdb_addpacket((0x0843), (6),clif->pGMRemove2,2, 0xFFFF);




 packetdb_addpacket((0x0288), (-1),clif->pcashshop_buy,4,8, 0xFFFF);
 packetdb_addpacket((0x0436), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x035f), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x0360), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x0361), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x0362), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x0363), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x0364), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0365), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0366), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x0367), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x0368), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0369), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x0856), (-1), 0xFFFF);
 packetdb_addpacket((0x0857), (-1), 0xFFFF);
 packetdb_addpacket((0x0858), (-1), 0xFFFF);
 packetdb_addpacket((0x0859), (-1), 0xFFFF);




 packetdb_addpacket((0x0844), (2),clif->pCashShopOpen,2, 0xFFFF);
 packetdb_addpacket((0x084a), (2),clif->pCashShopClose,2, 0xFFFF);
 packetdb_addpacket((0x0846), (4),clif->pCashShopReqTab,2, 0xFFFF);
 packetdb_addpacket((0x08c9), (2),clif->pCashShopSchedule,0, 0xFFFF);
 packetdb_addpacket((0x0848), (-1),clif->pCashShopBuy,2, 0xFFFF);




 packetdb_addpacket((0x0364), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x0817), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x0366), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x0815), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x0885), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x0893), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0897), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0369), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x08ad), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x088a), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0838), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x0439), (8),clif->pUseItem,2,4, 0xFFFF);
 packetdb_addpacket((0x08d2), (10), 0xFFFF);
 packetdb_addpacket((0x08d7), (28),clif->pBGQueueRegister,2, 0xFFFF);
 packetdb_addpacket((0x090a), (26),clif->pBGQueueCheckState,2, 0xFFFF);
 packetdb_addpacket((0x08da), (26),clif->pBGQueueRevokeReq,2, 0xFFFF);
 packetdb_addpacket((0x08e0), (51),clif->pBGQueueBattleBeginAck,2, 0xFFFF);




 packetdb_addpacket((0x0436), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x0898), (5),clif->pHomMenu,4, 0xFFFF);
 packetdb_addpacket((0x0281), (36),clif->pStoragePassword,0, 0xFFFF);
 packetdb_addpacket((0x088d), (26),clif->pPartyInvite2,2, 0xFFFF);
 packetdb_addpacket((0x083c), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x08aa), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x02c4), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0811), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x890), (8), 0xFFFF);
 packetdb_addpacket((0x08a5), (18),clif->pPartyBookingRegisterReq,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0835), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);
 packetdb_addpacket((0x089b), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x08a1), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x089e), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x08ab), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x088b), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x08a2), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);

  packetdb_addpacket((0x0835), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
  packetdb_addpacket((0x0892), (5),clif->pWalkToXY,2, 0xFFFF);
  packetdb_addpacket((0x0899), (6),clif->pTickSend,2, 0xFFFF);





 packetdb_addpacket((0x086A), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0437), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x0887), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x0890), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x0865), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x02C4), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x093B), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0963), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0438), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x0366), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x096A), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0368), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x0369), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x0863), (5),clif->pHomMenu,4, 0xFFFF);
 packetdb_addpacket((0x0861), (36),clif->pStoragePassword,0, 0xFFFF);
 packetdb_addpacket((0x0929), (26),clif->pPartyInvite2,2, 0xFFFF);
 packetdb_addpacket((0x0885), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x0889), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0870), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x0365), (18),clif->pPartyBookingRegisterReq,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0815), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);
 packetdb_addpacket((0x0817), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0360), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x0811), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x0884), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x0835), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x0838), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x0439), (8),clif->pUseItem,2,4, 0xFFFF);




 packetdb_addpacket((0x01FD), (15),clif->pRepairItem,2, 0xFFFF);
 packetdb_addpacket((0x089C), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x0885), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x0961), (36),clif->pStoragePassword,0, 0xFFFF);
 packetdb_addpacket((0x0288), (-1),clif->pcashshop_buy,4,8, 0xFFFF);
 packetdb_addpacket((0x091C), (26),clif->pPartyInvite2,2, 0xFFFF);
 packetdb_addpacket((0x094B), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0369), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x083C), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0439), (8),clif->pUseItem,2,4, 0xFFFF);
 packetdb_addpacket((0x0945), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x0815), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);
 packetdb_addpacket((0x0817), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0360), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x0811), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x0819), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x0835), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x0838), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x0437), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x0886), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x0871), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x0938), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x0891), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x086C), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x08A6), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0438), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x0366), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x0889), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0884), (6),clif->pSolveCharName,2, 0xFFFF);

 packetdb_addpacket((0x091D), (18),clif->pPartyBookingRegisterReq,2,4,6, 0xFFFF);



 packetdb_addpacket((0x08E6), (4), 0xFFFF);
 packetdb_addpacket((0x08E7), (10),clif->pPartyRecruitSearchReq,2, 0xFFFF);
 packetdb_addpacket((0x08E8), (-1), 0xFFFF);
 packetdb_addpacket((0x08E9), (2),clif->pPartyRecruitDeleteReq,2, 0xFFFF);
 packetdb_addpacket((0x08EA), (4), 0xFFFF);
 packetdb_addpacket((0x08EB), (39),clif->pPartyRecruitUpdateReq,2, 0xFFFF);
 packetdb_addpacket((0x08EC), (73), 0xFFFF);
 packetdb_addpacket((0x08ED), (43), 0xFFFF);
 packetdb_addpacket((0x08EE), (6), 0xFFFF);





 packetdb_addpacket((0x08F2), (36), 0xFFFF);
 packetdb_addpacket((0x08F3), (-1), 0xFFFF);
 packetdb_addpacket((0x08F4), (6), 0xFFFF);
 packetdb_addpacket((0x08F5), (-1),clif->pDull,2,4, 0xFFFF);
 packetdb_addpacket((0x08F6), (22), 0xFFFF);
 packetdb_addpacket((0x08F7), (3), 0xFFFF);
 packetdb_addpacket((0x08F8), (7), 0xFFFF);
 packetdb_addpacket((0x08F9), (6), 0xFFFF);



 packetdb_addpacket((0x08FA), (6), 0xFFFF);
 packetdb_addpacket((0x08FB), (6),clif->pDull,2, 0xFFFF);
 packetdb_addpacket((0x0907), (5),clif->pMoveItem,2,4, 0xFFFF);
 packetdb_addpacket((0x0908), (5), 0xFFFF);
 packetdb_addpacket((0x08CF), (10), 0xFFFF);
 packetdb_addpacket((0x0977), (14), 0xFFFF);




 packetdb_addpacket((0x023B), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x0361), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x08A8), (36),clif->pStoragePassword,0, 0xFFFF);
 packetdb_addpacket((0x0802), (26),clif->pPartyInvite2,2, 0xFFFF);
 packetdb_addpacket((0x022D), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0281), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x035F), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x0202), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x07E4), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x0362), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x07EC), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0364), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x096A), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0368), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x08E5), (41),clif->pPartyRecruitRegisterReq,2,4, 0xFFFF);
 packetdb_addpacket((0x08d2), (10), 0xFFFF);
 packetdb_addpacket((0x0916), (26),clif->pGuildInvite2,2, 0xFFFF);




 packetdb_addpacket((0x0861), (18),clif->pPartyRecruitRegisterReq,2,4,6, 0xFFFF);





 packetdb_addpacket((0x0983), (29), 0xFFFF);






 packetdb_addpacket((0x0363), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0364), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x085a), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x0861), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0862), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0863), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x0886), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x0889), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x089e), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x089f), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x08a0), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x094a), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0953), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x0960), (5),clif->pChangeDir,2,4, 0xFFFF);




 packetdb_addpacket((0x0886), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);




 packetdb_addpacket((0x0879), (18),clif->pPartyBookingRegisterReq,2,4,6, 0xFFFF);
 packetdb_addpacket((0x023B), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x0361), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x0819), (36),clif->pStoragePassword,0, 0xFFFF);
 packetdb_addpacket((0x0802), (26),clif->pPartyInvite2,2, 0xFFFF);
 packetdb_addpacket((0x022D), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0369), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x083C), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0439), (8),clif->pUseItem,2,4, 0xFFFF);
 packetdb_addpacket((0x0281), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x0815), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);
 packetdb_addpacket((0x0817), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0360), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x0940), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x0811), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x0835), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x0838), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x0437), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x035F), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x0202), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x07E4), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x0362), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x07EC), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0364), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0438), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x0366), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x096A), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0368), (6),clif->pSolveCharName,2, 0xFFFF);





 packetdb_addpacket((0x088E), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x089B), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0881), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x0363), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x0897), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x0933), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x0438), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x08AC), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0874), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0959), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x085A), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x0898), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x094C), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x0365), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x092E), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x094E), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x0922), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x035F), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x0886), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0938), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);



 packetdb_addpacket((0x085D), (18),clif->pPartyBookingRegisterReq,2,4, 0xFFFF);


 packetdb_addpacket((0x0868), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x0888), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x086D), (26),clif->pPartyInvite2,2, 0xFFFF);

 packetdb_addpacket((0x086F), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x093F), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x0947), (36),clif->pStoragePassword,0, 0xFFFF);



 packetdb_addpacket((0x0998), (8),clif->pEquipItem,2,4, 0xFFFF);
 packetdb_addpacket((0x0447), (2), 0xFFFF);
 packetdb_addpacket((0x099f), (24), 0xFFFF);






 packetdb_addpacket((0x0369), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x083C), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0437), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x035F), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x0362), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x08A1), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x0944), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x0887), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x08AC), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0438), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x0366), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x096A), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0368), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x0838), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x0835), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x0819), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x0811), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x0360), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x0817), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0815), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);



 packetdb_addpacket((0x092D), (18),clif->pPartyBookingRegisterReq,2,4, 0xFFFF);


 packetdb_addpacket((0x0963), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x0943), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0947), (26),clif->pPartyInvite2,2, 0xFFFF);

 packetdb_addpacket((0x0962), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x0931), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x093E), (36),clif->pStoragePassword,0, 0xFFFF);






 packetdb_addpacket((0x08A2), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x095C), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0360), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x07EC), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x0925), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x095E), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x089C), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x08A3), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x087E), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0811), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x0964), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x08A6), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0369), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x093E), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x08AA), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x095B), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x0952), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x0368), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x086E), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0874), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);



 packetdb_addpacket((0x089B), (18),clif->pPartyBookingRegisterReq,2,4, 0xFFFF);


 packetdb_addpacket((0x086A), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x08A9), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0950), (26),clif->pPartyInvite2,2, 0xFFFF);

 packetdb_addpacket((0x0362), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x0926), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x088E), (36),clif->pStoragePassword,0, 0xFFFF);





 packetdb_addpacket((0x0890), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x0438), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0876), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x0897), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x0951), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x0895), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x08A7), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x0938), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0957), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0917), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x085E), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x0863), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0937), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x085A), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x0941), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x0918), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x0936), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x0892), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x0964), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0869), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);



 packetdb_addpacket((0x0874), (18),clif->pPartyBookingRegisterReq,2,4, 0xFFFF);


 packetdb_addpacket((0x0958), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x0919), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x08A8), (26),clif->pPartyInvite2,2, 0xFFFF);

 packetdb_addpacket((0x0877), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x023B), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x0956), (36),clif->pStoragePassword,0, 0xFFFF);




 packetdb_addpacket((0x0369), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x083C), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0437), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x035F), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x0202), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x07E4), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x0362), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x07EC), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0364), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0438), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x0366), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x096A), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0368), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x0838), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x0835), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x0819), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x0811), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x0360), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x0817), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0815), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);



 packetdb_addpacket((0x0365), (18),clif->pPartyBookingRegisterReq,2,4, 0xFFFF);


 packetdb_addpacket((0x0281), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x022D), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0802), (26),clif->pPartyInvite2,2, 0xFFFF);

 packetdb_addpacket((0x023B), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x0361), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x0883), (36),clif->pStoragePassword,0, 0xFFFF);
 packetdb_addpacket((0x097C), (4),clif->pRanklist, 0xFFFF);




 packetdb_addpacket((0x087E), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x0919), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0940), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x093A), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x0964), (36),clif->pStoragePassword,0, 0xFFFF);




 packetdb_addpacket((0x0889), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x0951), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x088E), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x0930), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x08A6), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x0962), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x0917), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x0885), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0936), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x096A), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x094F), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x0944), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0945), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x0890), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x0363), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x0281), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x0891), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x0862), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x085A), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0932), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);



 packetdb_addpacket((0x08A7), (18),clif->pPartyBookingRegisterReq,2,4, 0xFFFF);


 packetdb_addpacket((0x0942), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x095B), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0887), (26),clif->pPartyInvite2,2, 0xFFFF);

 packetdb_addpacket((0x0953), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x02C4), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x0864), (36),clif->pStoragePassword,0, 0xFFFF);




 packetdb_addpacket((0x0369), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x083C), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0437), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x035F), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x094D), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x088B), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x0952), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x0921), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0817), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0438), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x0366), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x096A), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0368), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x0838), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x0835), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x0819), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x0811), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x0360), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x0365), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0815), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);



 packetdb_addpacket((0x0894), (18),clif->pPartyBookingRegisterReq,2,4, 0xFFFF);


 packetdb_addpacket((0x08A5), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x088C), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0895), (26),clif->pPartyInvite2,2, 0xFFFF);

 packetdb_addpacket((0x08AB), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x0960), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x0930), (36),clif->pStoragePassword,0, 0xFFFF);




 packetdb_addpacket((0x0930), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x07E4), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x0362), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x07EC), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0364), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0202), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x0817), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0815), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);



 packetdb_addpacket((0x0365), (18),clif->pPartyBookingRegisterReq,2,4, 0xFFFF);


 packetdb_addpacket((0x0281), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x022D), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0802), (26),clif->pPartyInvite2,2, 0xFFFF);

 packetdb_addpacket((0x0360), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x094A), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x0873), (36),clif->pStoragePassword,0, 0xFFFF);




 packetdb_addpacket((0x09A6), (12), 0xFFFF);
 packetdb_addpacket((0x09A7), (10),clif->pBankDeposit,2,4,6, 0xFFFF);
 packetdb_addpacket((0x09A8), (16), 0xFFFF);
 packetdb_addpacket((0x09A9), (10),clif->pBankWithdraw,2,4,6, 0xFFFF);
 packetdb_addpacket((0x09AA), (16), 0xFFFF);
 packetdb_addpacket((0x09AB), (6),clif->pBankCheck,2,4, 0xFFFF);

 packetdb_addpacket((0x09B6), (6),clif->pBankOpen,2,4, 0xFFFF);
 packetdb_addpacket((0x09B7), (4), 0xFFFF);
 packetdb_addpacket((0x09B8), (6),clif->pBankClose,2,4, 0xFFFF);
 packetdb_addpacket((0x09B9), (4), 0xFFFF);




 packetdb_addpacket((0x0369), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x083C), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0437), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x035F), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x0202), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x07E4), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x0362), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x07EC), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0364), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0438), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x0366), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x096A), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0368), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x0838), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x0835), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x0819), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x0811), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x0360), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x0817), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0815), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);



 packetdb_addpacket((0x0365), (18),clif->pPartyBookingRegisterReq,2,4, 0xFFFF);


 packetdb_addpacket((0x0281), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x022D), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0802), (26),clif->pPartyInvite2,2, 0xFFFF);

 packetdb_addpacket((0x023B), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x0361), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x0887), (36),clif->pStoragePassword,0, 0xFFFF);




 packetdb_addpacket((0x0874), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x0947), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x093A), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x088A), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x088C), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x0926), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x095F), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x0202), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0873), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0887), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x0962), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x0937), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0923), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x0868), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x0941), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x0889), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x0835), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x0895), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x094E), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0936), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);



 packetdb_addpacket((0x0959), (18),clif->pPartyBookingRegisterReq,2,4, 0xFFFF);


 packetdb_addpacket((0x08A4), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x0368), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0927), (26),clif->pPartyInvite2,2, 0xFFFF);

 packetdb_addpacket((0x0281), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x0958), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x0885), (36),clif->pStoragePassword,0, 0xFFFF);




 packetdb_addpacket((0x0369), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x083C), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0437), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x035F), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x0947), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x07E4), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x0362), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x07EC), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0364), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0438), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x0366), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x096A), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0368), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x0838), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x0835), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x0819), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x022D), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x0360), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x0817), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0815), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);
 packetdb_addpacket((0x0365), (18),clif->pPartyBookingRegisterReq,2,4, 0xFFFF);

 packetdb_addpacket((0x0281), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x092F), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0802), (26),clif->pPartyInvite2,2, 0xFFFF);

 packetdb_addpacket((0x08AB), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x0811), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x085C), (36),clif->pStoragePassword,0, 0xFFFF);

 packetdb_addpacket((0x09d4), (2),clif->pNPCShopClosed, 0xFFFF);
 packetdb_addpacket((0x09ce), (102),clif->pGM_Monster_Item,2, 0xFFFF);

 packetdb_addpacket((0x09d8), (2),clif->pNPCMarketClosed, 0xFFFF);
 packetdb_addpacket((0x09d6), (-1),clif->pNPCMarketPurchase, 0xFFFF);




 packetdb_addpacket((0x0369), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x083C), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0437), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x035F), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x0202), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x07E4), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x0362), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x07EC), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0364), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0438), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x0366), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x096A), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0368), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x0838), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x0835), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x0819), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x0811), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x0360), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x0817), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0815), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);
 packetdb_addpacket((0x0365), (18),clif->pPartyBookingRegisterReq,2,4, 0xFFFF);

 packetdb_addpacket((0x0281), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x022d), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0802), (26),clif->pPartyInvite2,2, 0xFFFF);

 packetdb_addpacket((0x023B), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x0361), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x08A4), (36),clif->pStoragePassword,0, 0xFFFF);
 packetdb_addpacket((0x09df), (7), 0xFFFF);




 packetdb_addpacket((0x0871), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x02C4), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x035F), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x0438), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x094A), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x092A), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x0860), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x0968), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0895), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x091E), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x096A), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x0926), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0898), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x087B), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x0369), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x093D), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x087F), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x0969), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x094C), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0365), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);
 packetdb_addpacket((0x091F), (18),clif->pPartyBookingRegisterReq,2,4, 0xFFFF);

 packetdb_addpacket((0x022D), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x089C), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x08A9), (26),clif->pPartyInvite2,2, 0xFFFF);

 packetdb_addpacket((0x0943), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x0949), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x091D), (36),clif->pStoragePassword,0, 0xFFFF);






 packetdb_addpacket((0x0369), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x083C), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0437), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x035F), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x08A7), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x0940), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x0361), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x088E), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0367), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0438), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x0366), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x0802), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0368), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x0360), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x0817), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x0815), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x096A), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x088A), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x0965), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0815), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);
 packetdb_addpacket((0x096A), (18),clif->pPartyBookingRegisterReq,2,4, 0xFFFF);

 packetdb_addpacket((0x0965), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x0966), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x095D), (26),clif->pPartyInvite2,2, 0xFFFF);

 packetdb_addpacket((0x089B), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x092D), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x0865), (36),clif->pStoragePassword,0, 0xFFFF);




 packetdb_addpacket((0x0369), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x083C), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0437), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x035F), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x0202), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x07E4), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x0362), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x07EC), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0364), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0438), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x0366), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x096A), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0368), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x0838), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x0835), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x0819), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x0811), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x0360), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x0817), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0815), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);
 packetdb_addpacket((0x0365), (18),clif->pPartyBookingRegisterReq,2,4, 0xFFFF);

 packetdb_addpacket((0x0281), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x022D), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0802), (26),clif->pPartyInvite2,2, 0xFFFF);

 packetdb_addpacket((0x023B), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x0361), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x0938), (36),clif->pStoragePassword,0, 0xFFFF);
 packetdb_addpacket((0x09DF), (7), 0xFFFF);




 packetdb_addpacket((0x0369), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x083C), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0437), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x035F), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x0815), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x0202), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x0362), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x07EC), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0364), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0436), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x0366), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x096A), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0368), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x0838), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x0835), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x0819), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x0811), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x0360), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x0817), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0361), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);
 packetdb_addpacket((0x0365), (18),clif->pPartyBookingRegisterReq,2,4, 0xFFFF);

 packetdb_addpacket((0x0281), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x0438), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0802), (26),clif->pPartyInvite2,2, 0xFFFF);

 packetdb_addpacket((0x07E4), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x0934), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x095e), (36),clif->pStoragePassword,0, 0xFFFF);
 packetdb_addpacket((0x09DF), (7), 0xFFFF);




 packetdb_addpacket((0x0946), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x0868), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x093F), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x0950), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x0360), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x0958), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x0882), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x095C), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x085B), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0364), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x092D), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x088A), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x07EC), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x0965), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x085D), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x0933), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x091F), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x023B), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x0867), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0944), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);
 packetdb_addpacket((0x08AC), (18),clif->pPartyBookingRegisterReq,2,4, 0xFFFF);

 packetdb_addpacket((0x0883), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x0920), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0890), (26),clif->pPartyInvite2,2, 0xFFFF);

 packetdb_addpacket((0x089A), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x0896), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x0926), (36),clif->pStoragePassword,0, 0xFFFF);
 packetdb_addpacket((0x09DF), (7), 0xFFFF);




 packetdb_addpacket((0x0369), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x083C), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0437), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x035F), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x0202), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x07E4), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x0362), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x07EC), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0364), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0438), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x0366), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x096A), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0368), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x0838), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x0835), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x0819), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x0811), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x0360), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x0817), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0815), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);
 packetdb_addpacket((0x0365), (18),clif->pPartyBookingRegisterReq,2,4, 0xFFFF);

 packetdb_addpacket((0x0281), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x022D), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0802), (26),clif->pPartyInvite2,2, 0xFFFF);

 packetdb_addpacket((0x023B), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x0361), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x095C), (36),clif->pStoragePassword,0, 0xFFFF);
 packetdb_addpacket((0x09DF), (7), 0xFFFF);




 packetdb_addpacket((0x0369), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x083C), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0437), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x035F), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x0967), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x07E4), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x0362), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x07EC), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x022D), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x0438), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x0366), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x096A), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0368), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x0838), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x0835), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x0819), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x0811), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x0360), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x0817), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0815), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);
 packetdb_addpacket((0x0365), (18),clif->pPartyBookingRegisterReq,2,4, 0xFFFF);

 packetdb_addpacket((0x0281), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x086E), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0802), (26),clif->pPartyInvite2,2, 0xFFFF);

 packetdb_addpacket((0x094B), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x0364), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x0936), (36),clif->pStoragePassword,0, 0xFFFF);
 packetdb_addpacket((0x09DF), (7), 0xFFFF);
 packetdb_addpacket((0x0a00), (269), 0xFFFF);




 packetdb_addpacket((0x0A19), (2),clif->pRouletteOpen,0, 0xFFFF);
 packetdb_addpacket((0x0A1A), (23), 0xFFFF);
 packetdb_addpacket((0x0A1B), (2),clif->pRouletteInfo,0, 0xFFFF);
 packetdb_addpacket((0x0A1C), (-1), 0xFFFF);
 packetdb_addpacket((0x0A1D), (2),clif->pRouletteClose,0, 0xFFFF);
 packetdb_addpacket((0x0A1E), (3), 0xFFFF);
 packetdb_addpacket((0x0A1F), (2),clif->pRouletteGenerate,0, 0xFFFF);
 packetdb_addpacket((0x0A20), (21), 0xFFFF);
 packetdb_addpacket((0x0A21), (3),clif->pRouletteRecvItem,2, 0xFFFF);
 packetdb_addpacket((0x0A22), (5), 0xFFFF);




 packetdb_addpacket((0x0369), (7),clif->pActionRequest,2,6, 0xFFFF);
 packetdb_addpacket((0x083C), (10),clif->pUseSkillToId,2,4,6, 0xFFFF);
 packetdb_addpacket((0x0437), (5),clif->pWalkToXY,2, 0xFFFF);
 packetdb_addpacket((0x035F), (6),clif->pTickSend,2, 0xFFFF);
 packetdb_addpacket((0x08AD), (5),clif->pChangeDir,2,4, 0xFFFF);
 packetdb_addpacket((0x094E), (6),clif->pTakeItem,2, 0xFFFF);
 packetdb_addpacket((0x087D), (6),clif->pDropItem,2,4, 0xFFFF);
 packetdb_addpacket((0x0878), (8),clif->pMoveToKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x08AA), (8),clif->pMoveFromKafra,2,4, 0xFFFF);
 packetdb_addpacket((0x023B), (10),clif->pUseSkillToPos,2,4,6,8, 0xFFFF);
 packetdb_addpacket((0x0366), (90),clif->pUseSkillToPosMoreInfo,2,4,6,8,10, 0xFFFF);
 packetdb_addpacket((0x096A), (6),clif->pGetCharNameRequest,2, 0xFFFF);
 packetdb_addpacket((0x0368), (6),clif->pSolveCharName,2, 0xFFFF);
 packetdb_addpacket((0x0835), (12),clif->pSearchStoreInfoListItemClick,2,6,10, 0xFFFF);
 packetdb_addpacket((0x0940), (2),clif->pSearchStoreInfoNextPage,0, 0xFFFF);
 packetdb_addpacket((0x0819), (-1),clif->pSearchStoreInfo,2,4,5,9,13,14,15, 0xFFFF);
 packetdb_addpacket((0x0811), (-1),clif->pReqTradeBuyingStore,2,4,8,12, 0xFFFF);
 packetdb_addpacket((0x0360), (6),clif->pReqClickBuyingStore,2, 0xFFFF);
 packetdb_addpacket((0x0817), (2),clif->pReqCloseBuyingStore,0, 0xFFFF);
 packetdb_addpacket((0x0815), (-1),clif->pReqOpenBuyingStore,2,4,8,9,89, 0xFFFF);
 packetdb_addpacket((0x0955), (18),clif->pPartyBookingRegisterReq,2,4, 0xFFFF);

 packetdb_addpacket((0x0281), (-1),clif->pItemListWindowSelected,2,4,8, 0xFFFF);
 packetdb_addpacket((0x093B), (19),clif->pWantToConnection,2,6,10,14,18, 0xFFFF);
 packetdb_addpacket((0x0896), (26),clif->pPartyInvite2,2, 0xFFFF);

 packetdb_addpacket((0x091A), (26),clif->pFriendsListAdd,2, 0xFFFF);
 packetdb_addpacket((0x0899), (5),clif->pHomMenu,2,4, 0xFFFF);
 packetdb_addpacket((0x0438), (36),clif->pStoragePassword,0, 0xFFFF);
 packetdb_addpacket((0x0A01), (3),clif->pHotkeyRowShift,2, 0xFFFF);
# 2926 "../../../server-code/src/map/packets.h"
 do { clif->cryptKey[0] = (0x053D5CED); clif->cryptKey[1] = (0x3DED6DED); clif->cryptKey[2] = (0x6DED6DED); } while(0);



 do { clif->cryptKey[0] = (0x35C91401); clif->cryptKey[1] = (0x262A5556); clif->cryptKey[2] = (0x28FA03AA); } while(0);



 do { clif->cryptKey[0] = (0x3AD67ED0); clif->cryptKey[1] = (0x44703C69); clif->cryptKey[2] = (0x6F876809); } while(0);



 do { clif->cryptKey[0] = (0x3AD67ED0); clif->cryptKey[1] = (0x44703C69); clif->cryptKey[2] = (0x6F876809); } while(0);



 do { clif->cryptKey[0] = (0x291E6762); clif->cryptKey[1] = (0x77CD391A); clif->cryptKey[2] = (0x60AC2F16); } while(0);



 do { clif->cryptKey[0] = (0x7F3C2D29); clif->cryptKey[1] = (0x59B01DE6); clif->cryptKey[2] = (0x1DBB44CA); } while(0);



 do { clif->cryptKey[0] = (0x357D55DC); clif->cryptKey[1] = (0x5A8D759F); clif->cryptKey[2] = (0x245C30F5); } while(0);



 do { clif->cryptKey[0] = (0x50AE1A63); clif->cryptKey[1] = (0x3CE579B5); clif->cryptKey[2] = (0x29C10406); } while(0);



 do { clif->cryptKey[0] = (0x5324329D); clif->cryptKey[1] = (0x5D545D52); clif->cryptKey[2] = (0x06137269); } while(0);



 do { clif->cryptKey[0] = (0x0B642BDA); clif->cryptKey[1] = (0x6ECB1D1C); clif->cryptKey[2] = (0x61C7454B); } while(0);



 do { clif->cryptKey[0] = (0x3B550F07); clif->cryptKey[1] = (0x1F666C7C); clif->cryptKey[2] = (0x60304EF5); } while(0);



 do { clif->cryptKey[0] = (0x2A610886); clif->cryptKey[1] = (0x3E09165E); clif->cryptKey[2] = (0x57C11888); } while(0);



 do { clif->cryptKey[0] = (0x5151306B); clif->cryptKey[1] = (0x7AE32886); clif->cryptKey[2] = (0x53060628); } while(0);



 do { clif->cryptKey[0] = (0x05D53871); clif->cryptKey[1] = (0x7D0027B4); clif->cryptKey[2] = (0x29975333); } while(0);



 do { clif->cryptKey[0] = (0x0FF87E93); clif->cryptKey[1] = (0x6CFF7860); clif->cryptKey[2] = (0x3A3D1DEC); } while(0);



 do { clif->cryptKey[0] = (0x262034A1); clif->cryptKey[1] = (0x674542A5); clif->cryptKey[2] = (0x73A50BA5); } while(0);



 do { clif->cryptKey[0] = (0x2B412AFC); clif->cryptKey[1] = (0x4FF94487); clif->cryptKey[2] = (0x6705339D); } while(0);



 do { clif->cryptKey[0] = (0x504345D0); clif->cryptKey[1] = (0x3D427B1B); clif->cryptKey[2] = (0x794C2DCC); } while(0);



 do { clif->cryptKey[0] = (0x2CFC0A71); clif->cryptKey[1] = (0x2BA91D8D); clif->cryptKey[2] = (0x087E39E0); } while(0);



 do { clif->cryptKey[0] = (0x1D373F5D); clif->cryptKey[1] = (0x5ACD604D); clif->cryptKey[2] = (0x1C4D7C4D); } while(0);



 do { clif->cryptKey[0] = (0x7A255EFA); clif->cryptKey[1] = (0x30977276); clif->cryptKey[2] = (0x2D4A0448); } while(0);



 do { clif->cryptKey[0] = (0x520B4C64); clif->cryptKey[1] = (0x2800407D); clif->cryptKey[2] = (0x47651458); } while(0);



 do { clif->cryptKey[0] = (0x382A6DEF); clif->cryptKey[1] = (0x5CBE7202); clif->cryptKey[2] = (0x61F46637); } while(0);



 do { clif->cryptKey[0] = (0x689C1729); clif->cryptKey[1] = (0x11812639); clif->cryptKey[2] = (0x60F82967); } while(0);



 do { clif->cryptKey[0] = (0x21F9683F); clif->cryptKey[1] = (0x710C5CA5); clif->cryptKey[2] = (0x1FD910E9); } while(0);



 do { clif->cryptKey[0] = (0x75B8553B); clif->cryptKey[1] = (0x37F20B12); clif->cryptKey[2] = (0x385C2B40); } while(0);



 do { clif->cryptKey[0] = (0x0036310C); clif->cryptKey[1] = (0x2DCD0BED); clif->cryptKey[2] = (0x1EE62A78); } while(0);



 do { clif->cryptKey[0] = (0x01581359); clif->cryptKey[1] = (0x452D6FFA); clif->cryptKey[2] = (0x6AFB6E2E); } while(0);



 do { clif->cryptKey[0] = (0x01540E48); clif->cryptKey[1] = (0x13041224); clif->cryptKey[2] = (0x31247924); } while(0);



 do { clif->cryptKey[0] = (0x411D1DBB); clif->cryptKey[1] = (0x4CBA4848); clif->cryptKey[2] = (0x1A432FC4); } while(0);



 do { clif->cryptKey[0] = (0x16CF3301); clif->cryptKey[1] = (0x1F472B9B); clif->cryptKey[2] = (0x0B4A3CD2); } while(0);



 do { clif->cryptKey[0] = (0x4A715EF9); clif->cryptKey[1] = (0x79103E4F); clif->cryptKey[2] = (0x405C1238); } while(0);



 do { clif->cryptKey[0] = (0x70EB4CCB); clif->cryptKey[1] = (0x0487713C); clif->cryptKey[2] = (0x398D4B08); } while(0);



 do { clif->cryptKey[0] = (0x68CA3080); clif->cryptKey[1] = (0x31B74BDD); clif->cryptKey[2] = (0x505208F1); } while(0);



 do { clif->cryptKey[0] = (0x32E45D64); clif->cryptKey[1] = (0x35643564); clif->cryptKey[2] = (0x35643564); } while(0);



 do { clif->cryptKey[0] = (0x261F261F); clif->cryptKey[1] = (0x261F261F); clif->cryptKey[2] = (0x261F261F); } while(0);



 do { clif->cryptKey[0] = (0x25733B31); clif->cryptKey[1] = (0x53486CFD); clif->cryptKey[2] = (0x398649BD); } while(0);



 do { clif->cryptKey[0] = (0x76052205); clif->cryptKey[1] = (0x22052205); clif->cryptKey[2] = (0x22052205); } while(0);



 do { clif->cryptKey[0] = (0x3F094C49); clif->cryptKey[1] = (0x55F86C1E); clif->cryptKey[2] = (0x58AA359A); } while(0);



 do { clif->cryptKey[0] = (0x75794A38); clif->cryptKey[1] = (0x58A96BC1); clif->cryptKey[2] = (0x296E6FB8); } while(0);



 do { clif->cryptKey[0] = (0x6948050B); clif->cryptKey[1] = (0x06511D9D); clif->cryptKey[2] = (0x725D4DF1); } while(0);



 do { clif->cryptKey[0] = (0x023A6C87); clif->cryptKey[1] = (0x14BF1F1E); clif->cryptKey[2] = (0x5CC70CC9); } while(0);



 do { clif->cryptKey[0] = (0x646E08D9); clif->cryptKey[1] = (0x5F153AB5); clif->cryptKey[2] = (0x61B509B5); } while(0);



 do { clif->cryptKey[0] = (0x6D166F66); clif->cryptKey[1] = (0x3C000FCF); clif->cryptKey[2] = (0x295B0FCB); } while(0);



 do { clif->cryptKey[0] = (0x434115DE); clif->cryptKey[1] = (0x34A10FE9); clif->cryptKey[2] = (0x6791428E); } while(0);



 do { clif->cryptKey[0] = (0x38F453EF); clif->cryptKey[1] = (0x6A040FD8); clif->cryptKey[2] = (0X65BD6668); } while(0);



 do { clif->cryptKey[0] = (0x4FF90E23); clif->cryptKey[1] = (0x0F1432F2); clif->cryptKey[2] = (0x4CFA1EDA); } while(0);



 do { clif->cryptKey[0] = (0x7E241DE0); clif->cryptKey[1] = (0x5E805580); clif->cryptKey[2] = (0x3D807D80); } while(0);



 do { clif->cryptKey[0] = (0x23A23148); clif->cryptKey[1] = (0x0C41420E); clif->cryptKey[2] = (0x53785AD7); } while(0);



 do { clif->cryptKey[0] = (0x6A596301); clif->cryptKey[1] = (0x76866D0E); clif->cryptKey[2] = (0x32294A45); } while(0);



 do { clif->cryptKey[0] = (0x631C511C); clif->cryptKey[1] = (0x111C111C); clif->cryptKey[2] = (0x111C111C); } while(0);



 do { clif->cryptKey[0] = (0x611B7097); clif->cryptKey[1] = (0x01F957A1); clif->cryptKey[2] = (0x768A0FCB); } while(0);





 do { clif->cryptKey[0] = (0x63224335); clif->cryptKey[1] = (0x0F3A1F27); clif->cryptKey[2] = (0x6D217B24); } while(0);



 do { clif->cryptKey[0] = (0x63DC7BDC); clif->cryptKey[1] = (0x7BDC7BDC); clif->cryptKey[2] = (0x7BDC7BDC); } while(0);



 do { clif->cryptKey[0] = (0x116763F2); clif->cryptKey[1] = (0x41117DAC); clif->cryptKey[2] = (0x7FD13C45); } while(0);



 do { clif->cryptKey[0] = (0x15D3271C); clif->cryptKey[1] = (0x004D725B); clif->cryptKey[2] = (0x111A3A37); } while(0);



 do { clif->cryptKey[0] = (0x04810281); clif->cryptKey[1] = (0x42814281); clif->cryptKey[2] = (0x42814281); } while(0);



 do { clif->cryptKey[0] = (0x2DFF467C); clif->cryptKey[1] = (0x444B37EE); clif->cryptKey[2] = (0x2C1B634F); } while(0);



 do { clif->cryptKey[0] = (0x290551EA); clif->cryptKey[1] = (0x2B952C75); clif->cryptKey[2] = (0x2D67669B); } while(0);
# 19038 "../../../server-code/src/map/clif.c" 2


}
void clif_bc_ready(void) {
 if( battle_config.display_status_timers )
  clif->status_change = clif_status_change;
 else
  clif->status_change = clif_status_change_notick;

 switch( battle_config.packet_obfuscation ) {
  case 0:
   clif->parse_cmd = clif_parse_cmd_normal;
   break;
  default:
  case 1:
   clif->parse_cmd = clif_parse_cmd_optional;
   break;
  case 2:
   clif->parse_cmd = clif_parse_cmd_decrypt;
   break;
 }
}



int do_init_clif(
# 19063 "../../../server-code/src/map/clif.c" 3 4
                _Bool 
# 19063 "../../../server-code/src/map/clif.c"
                     minimal)
{
 if (minimal)
  return 0;

 packetdb_loaddb();

 sockt->set_defaultparse(clif->parse);
 if (sockt->make_listen_bind(clif->bind_ip,clif->map_port) == -1) {
  (showmsg->showFatalError(("Failed to bind to port '""\033[1;37m""%d""\033[0m""'\n"),clif->map_port));
  exit(
# 19073 "../../../server-code/src/map/clif.c" 3 4
      1
# 19073 "../../../server-code/src/map/clif.c"
                  );
 }

 timer->add_func_list(clif->clearunit_delayed_sub, "clif_clearunit_delayed_sub");
 timer->add_func_list(clif->delayquit, "clif_delayquit");

 clif->delay_clearunit_ers = ers_new(sizeof(struct block_list),"clif.c::delay_clearunit_ers",ERS_OPT_CLEAR);
 clif->delayed_damage_ers = ers_new(sizeof(struct cdelayed_damage),"clif.c::delayed_damage_ers",ERS_OPT_CLEAR);

 return 0;
}

void do_final_clif(void)
{
 unsigned char i;

 ((clif->delay_clearunit_ers)->destroy(clif->delay_clearunit_ers));
 ((clif->delayed_damage_ers)->destroy(clif->delayed_damage_ers));

 for(i = 0; i < CASHSHOP_TAB_MAX; i++) {
  int k;
  for( k = 0; k < clif->cs.item_count[i]; k++ ) {
   (iMalloc->free((clif->cs.data[i][k]),"../../../server-code/src/map/clif.c", 19095, __func__));
  }
  (iMalloc->free((clif->cs.data[i]),"../../../server-code/src/map/clif.c", 19097, __func__));
 }

 for(i = 0; i < 7; i++) {
  if( clif->rd.nameid[i] )
   (iMalloc->free((clif->rd.nameid[i]),"../../../server-code/src/map/clif.c", 19102, __func__));
  if( clif->rd.qty[i] )
   (iMalloc->free((clif->rd.qty[i]),"../../../server-code/src/map/clif.c", 19104, __func__));
 }

}
void clif_defaults(void) {
 clif = &clif_s;

 clif->bind_ip = INADDR_ANY;
 clif->map_port = 5121;
 clif->ally_only = 
# 19113 "../../../server-code/src/map/clif.c" 3 4
                  0
# 19113 "../../../server-code/src/map/clif.c"
                       ;
 clif->delayed_damage_ers = 
# 19114 "../../../server-code/src/map/clif.c" 3 4
                           ((void *)0)
# 19114 "../../../server-code/src/map/clif.c"
                               ;

 clif->init = do_init_clif;
 clif->final = do_final_clif;
 clif->setip = clif_setip;
 clif->setbindip = clif_setbindip;
 clif->setport = clif_setport;
 clif->refresh_ip = clif_refresh_ip;
 clif->send = clif_send;
 clif->send_sub = clif_send_sub;
 clif->send_actual = clif_send_actual;
 clif->parse = clif_parse;
 clif->parse_cmd = clif_parse_cmd_optional;
 clif->decrypt_cmd = clif_decrypt_cmd;
 clif->packet = clif_packet;

 clif->authok = clif_authok;
 clif->authrefuse = clif_authrefuse;
 clif->authfail_fd = clif_authfail_fd;
 clif->charselectok = clif_charselectok;

 clif->dropflooritem = clif_dropflooritem;
 clif->clearflooritem = clif_clearflooritem;
 clif->additem = clif_additem;
 clif->dropitem = clif_dropitem;
 clif->delitem = clif_delitem;
 clif->takeitem = clif_takeitem;
 clif->item_equip = clif_item_equip;
 clif->item_normal = clif_item_normal;
 clif->arrowequip = clif_arrowequip;
 clif->arrow_fail = clif_arrow_fail;
 clif->use_card = clif_use_card;
 clif->cart_additem = clif_cart_additem;
 clif->cart_delitem = clif_cart_delitem;
 clif->equipitemack = clif_equipitemack;
 clif->unequipitemack = clif_unequipitemack;
 clif->useitemack = clif_useitemack;
 clif->addcards = clif_addcards;
 clif->addcards2 = clif_addcards2;
 clif->item_sub = clif_item_sub;
 clif->getareachar_item = clif_getareachar_item;
 clif->cart_additem_ack = clif_cart_additem_ack;
 clif->cashshop_load = clif_cashshop_db;
 clif->package_announce = clif_package_item_announce;
 clif->item_drop_announce = clif_item_drop_announce;

 clif->clearunit_single = clif_clearunit_single;
 clif->clearunit_area = clif_clearunit_area;
 clif->clearunit_delayed = clif_clearunit_delayed;
 clif->walkok = clif_walkok;
 clif->move = clif_move;
 clif->move2 = clif_move2;
 clif->blown = clif_blown;
 clif->slide = clif_slide;
 clif->fixpos = clif_fixpos;
 clif->changelook = clif_changelook;
 clif->changetraplook = clif_changetraplook;
 clif->refreshlook = clif_refreshlook;
 clif->sendlook = clif_sendlook;
 clif->class_change = clif_class_change;
 clif->skill_delunit = clif_skill_delunit;
 clif->skillunit_update = clif_skillunit_update;
 clif->clearunit_delayed_sub = clif_clearunit_delayed_sub;
 clif->set_unit_idle = clif_set_unit_idle;
 clif->spawn_unit = clif_spawn_unit;
 clif->spawn_unit2 = clif_spawn_unit2;
 clif->set_unit_idle2 = clif_set_unit_idle2;
 clif->set_unit_walking = clif_set_unit_walking;
 clif->calc_walkdelay = clif_calc_walkdelay;
 clif->getareachar_skillunit = clif_getareachar_skillunit;
 clif->getareachar_unit = clif_getareachar_unit;
 clif->clearchar_skillunit = clif_clearchar_skillunit;
 clif->getareachar = clif_getareachar;
 clif->graffiti_entry = clif_graffiti_entry;

 clif->spawn = clif_spawn;

 clif->changemap = clif_changemap;
 clif->changemapcell = clif_changemapcell;
 clif->map_property = clif_map_property;
 clif->pvpset = clif_pvpset;
 clif->map_property_mapall = clif_map_property_mapall;
 clif->bossmapinfo = clif_bossmapinfo;
 clif->map_type = clif_map_type;
 clif->maptypeproperty2 = clif_maptypeproperty2;

 clif->changemapserver = clif_changemapserver;

 clif->npcbuysell = clif_npcbuysell;
 clif->buylist = clif_buylist;
 clif->selllist = clif_selllist;
 clif->cashshop_show = clif_cashshop_show;
 clif->npc_buy_result = clif_npc_buy_result;
 clif->npc_sell_result = clif_npc_sell_result;
 clif->cashshop_ack = clif_cashshop_ack;

 clif->scriptmes = clif_scriptmes;
 clif->scriptnext = clif_scriptnext;
 clif->scriptclose = clif_scriptclose;
 clif->scriptmenu = clif_scriptmenu;
 clif->scriptinput = clif_scriptinput;
 clif->scriptinputstr = clif_scriptinputstr;
 clif->cutin = clif_cutin;
 clif->sendfakenpc = clif_sendfakenpc;
 clif->scriptclear = clif_scriptclear;

 clif->viewpoint = clif_viewpoint;
 clif->damage = clif_damage;
 clif->sitting = clif_sitting;
 clif->standing = clif_standing;
 clif->arrow_create_list = clif_arrow_create_list;
 clif->refresh_storagewindow = clif_refresh_storagewindow;
 clif->refresh = clif_refresh;
 clif->fame_blacksmith = clif_fame_blacksmith;
 clif->fame_alchemist = clif_fame_alchemist;
 clif->fame_taekwon = clif_fame_taekwon;
 clif->ranklist = clif_ranklist;
 clif->pRanklist = clif_parse_ranklist;
 clif->update_rankingpoint = clif_update_rankingpoint;
 clif->hotkeys = clif_hotkeys_send;
 clif->insight = clif_insight;
 clif->outsight = clif_outsight;
 clif->skillcastcancel = clif_skillcastcancel;
 clif->skill_fail = clif_skill_fail;
 clif->skill_cooldown = clif_skill_cooldown;
 clif->skill_memomessage = clif_skill_memomessage;
 clif->skill_mapinfomessage = clif_skill_mapinfomessage;
 clif->skill_produce_mix_list = clif_skill_produce_mix_list;
 clif->cooking_list = clif_cooking_list;
 clif->autospell = clif_autospell;
 clif->combo_delay = clif_combo_delay;
 clif->status_change = clif_status_change;
 clif->insert_card = clif_insert_card;
 clif->inventorylist = clif_inventorylist;
 clif->equiplist = clif_equiplist;
 clif->cartlist = clif_cartlist;
 clif->favorite_item = clif_favorite_item;
 clif->clearcart = clif_clearcart;
 clif->item_identify_list = clif_item_identify_list;
 clif->item_identified = clif_item_identified;
 clif->item_repair_list = clif_item_repair_list;
 clif->item_repaireffect = clif_item_repaireffect;
 clif->item_damaged = clif_item_damaged;
 clif->item_refine_list = clif_item_refine_list;
 clif->item_skill = clif_item_skill;
 clif->mvp_item = clif_mvp_item;
 clif->mvp_exp = clif_mvp_exp;
 clif->mvp_noitem = clif_mvp_noitem;
 clif->changed_dir = clif_changed_dir;
 clif->charnameack = clif_charnameack;
 clif->monster_hp_bar = clif_monster_hp_bar;
 clif->hpmeter = clif_hpmeter;
 clif->hpmeter_single = clif_hpmeter_single;
 clif->hpmeter_sub = clif_hpmeter_sub;
 clif->upgrademessage = clif_upgrademessage;
 clif->get_weapon_view = clif_get_weapon_view;
 clif->gospel_info = clif_gospel_info;
 clif->feel_req = clif_feel_req;
 clif->starskill = clif_starskill;
 clif->feel_info = clif_feel_info;
 clif->hate_info = clif_hate_info;
 clif->mission_info = clif_mission_info;
 clif->feel_hate_reset = clif_feel_hate_reset;
 clif->partytickack = clif_partytickack;
 clif->equiptickack = clif_equiptickack;
 clif->viewequip_ack = clif_viewequip_ack;
 clif->equpcheckbox = clif_equpcheckbox;
 clif->displayexp = clif_displayexp;
 clif->font = clif_font;
 clif->progressbar = clif_progressbar;
 clif->progressbar_abort = clif_progressbar_abort;
 clif->showdigit = clif_showdigit;
 clif->elementalconverter_list = clif_elementalconverter_list;
 clif->spellbook_list = clif_spellbook_list;
 clif->magicdecoy_list = clif_magicdecoy_list;
 clif->poison_list = clif_poison_list;
 clif->autoshadowspell_list = clif_autoshadowspell_list;
 clif->skill_itemlistwindow = clif_skill_itemlistwindow;
 clif->sc_load = clif_status_change2;
 clif->sc_end = clif_status_change_end;
 clif->initialstatus = clif_initialstatus;
 clif->cooldown_list = clif_skill_cooldown_list;

 clif->updatestatus = clif_updatestatus;
 clif->changestatus = clif_changestatus;
 clif->statusupack = clif_statusupack;
 clif->movetoattack = clif_movetoattack;
 clif->solved_charname = clif_solved_charname;
 clif->charnameupdate = clif_charnameupdate;
 clif->delayquit = clif_delayquit;
 clif->getareachar_pc = clif_getareachar_pc;
 clif->disconnect_ack = clif_disconnect_ack;
 clif->PVPInfo = clif_PVPInfo;
 clif->blacksmith = clif_blacksmith;
 clif->alchemist = clif_alchemist;
 clif->taekwon = clif_taekwon;
 clif->ranking_pk = clif_ranking_pk;
 clif->quitsave = clif_quitsave;

 clif->misceffect = clif_misceffect;
 clif->changeoption = clif_changeoption;
 clif->changeoption2 = clif_changeoption2;
 clif->emotion = clif_emotion;
 clif->talkiebox = clif_talkiebox;
 clif->wedding_effect = clif_wedding_effect;
 clif->divorced = clif_divorced;
 clif->callpartner = clif_callpartner;
 clif->skill_damage = clif_skill_damage;
 clif->skill_nodamage = clif_skill_nodamage;
 clif->skill_poseffect = clif_skill_poseffect;
 clif->skill_estimation = clif_skill_estimation;
 clif->skill_warppoint = clif_skill_warppoint;
 clif->skillcasting = clif_skillcasting;
 clif->produce_effect = clif_produceeffect;
 clif->devotion = clif_devotion;
 clif->spiritball = clif_spiritball;
 clif->spiritball_single = clif_spiritball_single;
 clif->bladestop = clif_bladestop;
 clif->mvp_effect = clif_mvp_effect;
 clif->heal = clif_heal;
 clif->resurrection = clif_resurrection;
 clif->refine = clif_refine;
 clif->weather = clif_weather;
 clif->specialeffect = clif_specialeffect;
 clif->specialeffect_single = clif_specialeffect_single;
 clif->specialeffect_value = clif_specialeffect_value;
 clif->millenniumshield = clif_millenniumshield;
 clif->spiritcharm = clif_charm;
 clif->charm_single = clif_charm_single;
 clif->snap = clif_snap;
 clif->weather_check = clif_weather_check;

 clif->playBGM = clif_playBGM;
 clif->soundeffect = clif_soundeffect;
 clif->soundeffectall = clif_soundeffectall;

 clif->GlobalMessage = clif_GlobalMessage;
 clif->createchat = clif_createchat;
 clif->dispchat = clif_dispchat;
 clif->joinchatfail = clif_joinchatfail;
 clif->joinchatok = clif_joinchatok;
 clif->addchat = clif_addchat;
 clif->changechatowner = clif_changechatowner;
 clif->clearchat = clif_clearchat;
 clif->leavechat = clif_leavechat;
 clif->changechatstatus = clif_changechatstatus;
 clif->wis_message = clif_wis_message;
 clif->wis_end = clif_wis_end;
 clif->disp_message = clif_disp_message;
 clif->broadcast = clif_broadcast;
 clif->broadcast2 = clif_broadcast2;
 clif->messagecolor_self = clif_messagecolor_self;
 clif->messagecolor = clif_messagecolor;
 clif->disp_overhead = clif_disp_overhead;
 clif->msgtable_skill = clif_msgtable_skill;
 clif->msgtable = clif_msgtable;
 clif->msgtable_num = clif_msgtable_num;
 clif->message = clif_displaymessage;
 clif->messageln = clif_displaymessage2;
 clif->messages = clif_displaymessage_sprintf;
 clif->process_message = clif_process_message;
 clif->wisexin = clif_wisexin;
 clif->wisall = clif_wisall;
 clif->PMIgnoreList = clif_PMIgnoreList;
 clif->ShowScript = clif_ShowScript;

 clif->traderequest = clif_traderequest;
 clif->tradestart = clif_tradestart;
 clif->tradeadditem = clif_tradeadditem;
 clif->tradeitemok = clif_tradeitemok;
 clif->tradedeal_lock = clif_tradedeal_lock;
 clif->tradecancelled = clif_tradecancelled;
 clif->tradecompleted = clif_tradecompleted;
 clif->tradeundo = clif_tradeundo;

 clif->openvendingreq = clif_openvendingreq;
 clif->showvendingboard = clif_showvendingboard;
 clif->closevendingboard = clif_closevendingboard;
 clif->vendinglist = clif_vendinglist;
 clif->buyvending = clif_buyvending;
 clif->openvending = clif_openvending;
 clif->vendingreport = clif_vendingreport;

 clif->storagelist = clif_storagelist;
 clif->updatestorageamount = clif_updatestorageamount;
 clif->storageitemadded = clif_storageitemadded;
 clif->storageitemremoved = clif_storageitemremoved;
 clif->storageclose = clif_storageclose;

 clif->skillinfoblock = clif_skillinfoblock;
 clif->skillup = clif_skillup;
 clif->skillinfo = clif_skillinfo;
 clif->addskill = clif_addskill;
 clif->deleteskill = clif_deleteskill;

 clif->party_created = clif_party_created;
 clif->party_member_info = clif_party_member_info;
 clif->party_info = clif_party_info;
 clif->party_invite = clif_party_invite;
 clif->party_inviteack = clif_party_inviteack;
 clif->party_option = clif_party_option;
 clif->party_withdraw = clif_party_withdraw;
 clif->party_message = clif_party_message;
 clif->party_xy = clif_party_xy;
 clif->party_xy_single = clif_party_xy_single;
 clif->party_hp = clif_party_hp;
 clif->party_xy_remove = clif_party_xy_remove;
 clif->party_show_picker = clif_party_show_picker;
 clif->partyinvitationstate = clif_partyinvitationstate;
 clif->PartyLeaderChanged = clif_PartyLeaderChanged;

 clif->guild_created = clif_guild_created;
 clif->guild_belonginfo = clif_guild_belonginfo;
 clif->guild_masterormember = clif_guild_masterormember;
 clif->guild_basicinfo = clif_guild_basicinfo;
 clif->guild_allianceinfo = clif_guild_allianceinfo;
 clif->guild_memberlist = clif_guild_memberlist;
 clif->guild_skillinfo = clif_guild_skillinfo;
 clif->guild_send_onlineinfo = clif_guild_send_onlineinfo;
 clif->guild_memberlogin_notice = clif_guild_memberlogin_notice;
 clif->guild_invite = clif_guild_invite;
 clif->guild_inviteack = clif_guild_inviteack;
 clif->guild_leave = clif_guild_leave;
 clif->guild_expulsion = clif_guild_expulsion;
 clif->guild_positionchanged = clif_guild_positionchanged;
 clif->guild_memberpositionchanged = clif_guild_memberpositionchanged;
 clif->guild_emblem = clif_guild_emblem;
 clif->guild_emblem_area = clif_guild_emblem_area;
 clif->guild_notice = clif_guild_notice;
 clif->guild_message = clif_guild_message;
 clif->guild_reqalliance = clif_guild_reqalliance;
 clif->guild_allianceack = clif_guild_allianceack;
 clif->guild_delalliance = clif_guild_delalliance;
 clif->guild_oppositionack = clif_guild_oppositionack;
 clif->guild_broken = clif_guild_broken;
 clif->guild_xy = clif_guild_xy;
 clif->guild_xy_single = clif_guild_xy_single;
 clif->guild_xy_remove = clif_guild_xy_remove;
 clif->guild_positionnamelist = clif_guild_positionnamelist;
 clif->guild_positioninfolist = clif_guild_positioninfolist;
 clif->guild_expulsionlist = clif_guild_expulsionlist;
 clif->validate_emblem = clif_validate_emblem;

 clif->bg_hp = clif_bg_hp;
 clif->bg_xy = clif_bg_xy;
 clif->bg_xy_remove = clif_bg_xy_remove;
 clif->bg_message = clif_bg_message;
 clif->bg_updatescore = clif_bg_updatescore;
 clif->bg_updatescore_single = clif_bg_updatescore_single;
 clif->sendbgemblem_area = clif_sendbgemblem_area;
 clif->sendbgemblem_single = clif_sendbgemblem_single;

 clif->instance = clif_instance;
 clif->instance_join = clif_instance_join;
 clif->instance_leave = clif_instance_leave;

 clif->catch_process = clif_catch_process;
 clif->pet_roulette = clif_pet_roulette;
 clif->sendegg = clif_sendegg;
 clif->send_petstatus = clif_send_petstatus;
 clif->send_petdata = clif_send_petdata;
 clif->pet_emotion = clif_pet_emotion;
 clif->pet_food = clif_pet_food;

 clif->friendslist_toggle_sub = clif_friendslist_toggle_sub;
 clif->friendslist_send = clif_friendslist_send;
 clif->friendslist_reqack = clif_friendslist_reqack;
 clif->friendslist_toggle = clif_friendslist_toggle;
 clif->friendlist_req = clif_friendlist_req;

 clif->GM_kickack = clif_GM_kickack;
 clif->GM_kick = clif_GM_kick;
 clif->manner_message = clif_manner_message;
 clif->GM_silence = clif_GM_silence;
 clif->account_name = clif_account_name;
 clif->check = clif_check;

 clif->hominfo = clif_hominfo;
 clif->homskillinfoblock = clif_homskillinfoblock;
 clif->homskillup = clif_homskillup;
 clif->hom_food = clif_hom_food;
 clif->send_homdata = clif_send_homdata;

 clif->quest_send_list = clif_quest_send_list;
 clif->quest_send_mission = clif_quest_send_mission;
 clif->quest_add = clif_quest_add;
 clif->quest_delete = clif_quest_delete;
 clif->quest_update_status = clif_quest_update_status;
 clif->quest_update_objective = clif_quest_update_objective;
 clif->quest_show_event = clif_quest_show_event;

 clif->mail_window = clif_Mail_window;
 clif->mail_read = clif_Mail_read;
 clif->mail_delete = clif_Mail_delete;
 clif->mail_return = clif_Mail_return;
 clif->mail_send = clif_Mail_send;
 clif->mail_new = clif_Mail_new;
 clif->mail_refreshinbox = clif_Mail_refreshinbox;
 clif->mail_getattachment = clif_Mail_getattachment;
 clif->mail_setattachment = clif_Mail_setattachment;

 clif->auction_openwindow = clif_Auction_openwindow;
 clif->auction_results = clif_Auction_results;
 clif->auction_message = clif_Auction_message;
 clif->auction_close = clif_Auction_close;
 clif->auction_setitem = clif_Auction_setitem;

 clif->mercenary_info = clif_mercenary_info;
 clif->mercenary_skillblock = clif_mercenary_skillblock;
 clif->mercenary_message = clif_mercenary_message;
 clif->mercenary_updatestatus = clif_mercenary_updatestatus;

 clif->rental_time = clif_rental_time;
 clif->rental_expired = clif_rental_expired;

 clif->PartyBookingRegisterAck = clif_PartyBookingRegisterAck;
 clif->PartyBookingDeleteAck = clif_PartyBookingDeleteAck;
 clif->PartyBookingSearchAck = clif_PartyBookingSearchAck;
 clif->PartyBookingUpdateNotify = clif_PartyBookingUpdateNotify;
 clif->PartyBookingDeleteNotify = clif_PartyBookingDeleteNotify;
 clif->PartyBookingInsertNotify = clif_PartyBookingInsertNotify;
 clif->PartyRecruitRegisterAck = clif_PartyRecruitRegisterAck;
 clif->PartyRecruitDeleteAck = clif_PartyRecruitDeleteAck;
 clif->PartyRecruitSearchAck = clif_PartyRecruitSearchAck;
 clif->PartyRecruitUpdateNotify = clif_PartyRecruitUpdateNotify;
 clif->PartyRecruitDeleteNotify = clif_PartyRecruitDeleteNotify;
 clif->PartyRecruitInsertNotify = clif_PartyRecruitInsertNotify;

 clif->PartyBookingVolunteerInfo = clif_PartyBookingVolunteerInfo;
 clif->PartyBookingRefuseVolunteer = clif_PartyBookingRefuseVolunteer;
 clif->PartyBookingCancelVolunteer = clif_PartyBookingCancelVolunteer;
 clif->PartyBookingAddFilteringList = clif_PartyBookingAddFilteringList;
 clif->PartyBookingSubFilteringList = clif_PartyBookingSubFilteringList;

 clif->buyingstore_open = clif_buyingstore_open;
 clif->buyingstore_open_failed = clif_buyingstore_open_failed;
 clif->buyingstore_myitemlist = clif_buyingstore_myitemlist;
 clif->buyingstore_entry = clif_buyingstore_entry;
 clif->buyingstore_entry_single = clif_buyingstore_entry_single;
 clif->buyingstore_disappear_entry = clif_buyingstore_disappear_entry;
 clif->buyingstore_disappear_entry_single = clif_buyingstore_disappear_entry_single;
 clif->buyingstore_itemlist = clif_buyingstore_itemlist;
 clif->buyingstore_trade_failed_buyer = clif_buyingstore_trade_failed_buyer;
 clif->buyingstore_update_item = clif_buyingstore_update_item;
 clif->buyingstore_delete_item = clif_buyingstore_delete_item;
 clif->buyingstore_trade_failed_seller = clif_buyingstore_trade_failed_seller;

 clif->search_store_info_ack = clif_search_store_info_ack;
 clif->search_store_info_failed = clif_search_store_info_failed;
 clif->open_search_store_info = clif_open_search_store_info;
 clif->search_store_info_click_ack = clif_search_store_info_click_ack;

 clif->elemental_info = clif_elemental_info;
 clif->elemental_updatestatus = clif_elemental_updatestatus;

 clif->bgqueue_ack = clif_bgqueue_ack;
 clif->bgqueue_notice_delete = clif_bgqueue_notice_delete;
 clif->bgqueue_update_info = clif_bgqueue_update_info;
 clif->bgqueue_joined = clif_bgqueue_joined;
 clif->bgqueue_pcleft = clif_bgqueue_pcleft;
 clif->bgqueue_battlebegins = clif_bgqueue_battlebegins;

 clif->adopt_reply = clif_Adopt_reply;
 clif->adopt_request = clif_Adopt_request;
 clif->readbook = clif_readbook;
 clif->notify_time = clif_notify_time;
 clif->user_count = clif_user_count;
 clif->noask_sub = clif_noask_sub;
 clif->bc_ready = clif_bc_ready;

 clif->channel_msg = clif_channel_msg;
 clif->channel_msg2 = clif_channel_msg2;

 clif->undisguise_timer = clif_undisguise_timer;

 clif->bank_deposit = clif_bank_deposit;
 clif->bank_withdraw = clif_bank_withdraw;

 clif->show_modifiers = clif_show_modifiers;

 clif->notify_bounditem = clif_notify_bounditem;

 clif->delay_damage = clif_delay_damage;
 clif->delay_damage_sub = clif_delay_damage_sub;

 clif->npc_market_open = clif_npc_market_open;
 clif->npc_market_purchase_ack = clif_npc_market_purchase_ack;

 clif->parse_roulette_db = clif_parse_roulette_db;
 clif->roulette_generate_ack = clif_roulette_generate_ack;

 clif->openmergeitem = clif_openmergeitem;
 clif->cancelmergeitem = clif_cancelmergeitem;
 clif->comparemergeitem = clif_comparemergeitem;
 clif->ackmergeitems = clif_ackmergeitems;

 clif->selectcart = clif_selectcart;




 clif->pWantToConnection = clif_parse_WantToConnection;
 clif->pLoadEndAck = clif_parse_LoadEndAck;
 clif->pTickSend = clif_parse_TickSend;
 clif->pHotkey = clif_parse_Hotkey;
 clif->pProgressbar = clif_parse_progressbar;
 clif->pWalkToXY = clif_parse_WalkToXY;
 clif->pQuitGame = clif_parse_QuitGame;
 clif->pGetCharNameRequest = clif_parse_GetCharNameRequest;
 clif->pGlobalMessage = clif_parse_GlobalMessage;
 clif->pMapMove = clif_parse_MapMove;
 clif->pChangeDir = clif_parse_ChangeDir;
 clif->pEmotion = clif_parse_Emotion;
 clif->pHowManyConnections = clif_parse_HowManyConnections;
 clif->pActionRequest = clif_parse_ActionRequest;
 clif->pActionRequest_sub = clif_parse_ActionRequest_sub;
 clif->pRestart = clif_parse_Restart;
 clif->pWisMessage = clif_parse_WisMessage;
 clif->pBroadcast = clif_parse_Broadcast;
 clif->pTakeItem = clif_parse_TakeItem;
 clif->pDropItem = clif_parse_DropItem;
 clif->pUseItem = clif_parse_UseItem;
 clif->pEquipItem = clif_parse_EquipItem;
 clif->pUnequipItem = clif_parse_UnequipItem;
 clif->pNpcClicked = clif_parse_NpcClicked;
 clif->pNpcBuySellSelected = clif_parse_NpcBuySellSelected;
 clif->pNpcBuyListSend = clif_parse_NpcBuyListSend;
 clif->pNpcSellListSend = clif_parse_NpcSellListSend;
 clif->pCreateChatRoom = clif_parse_CreateChatRoom;
 clif->pChatAddMember = clif_parse_ChatAddMember;
 clif->pChatRoomStatusChange = clif_parse_ChatRoomStatusChange;
 clif->pChangeChatOwner = clif_parse_ChangeChatOwner;
 clif->pKickFromChat = clif_parse_KickFromChat;
 clif->pChatLeave = clif_parse_ChatLeave;
 clif->pTradeRequest = clif_parse_TradeRequest;
 clif->pTradeAck = clif_parse_TradeAck;
 clif->pTradeAddItem = clif_parse_TradeAddItem;
 clif->pTradeOk = clif_parse_TradeOk;
 clif->pTradeCancel = clif_parse_TradeCancel;
 clif->pTradeCommit = clif_parse_TradeCommit;
 clif->pStopAttack = clif_parse_StopAttack;
 clif->pPutItemToCart = clif_parse_PutItemToCart;
 clif->pGetItemFromCart = clif_parse_GetItemFromCart;
 clif->pRemoveOption = clif_parse_RemoveOption;
 clif->pChangeCart = clif_parse_ChangeCart;
 clif->pSelectCart = clif_parse_SelectCart;
 clif->pStatusUp = clif_parse_StatusUp;
 clif->pSkillUp = clif_parse_SkillUp;
 clif->pUseSkillToId = clif_parse_UseSkillToId;
 clif->pUseSkillToId_homun = clif_parse_UseSkillToId_homun;
 clif->pUseSkillToId_mercenary = clif_parse_UseSkillToId_mercenary;
 clif->pUseSkillToPos = clif_parse_UseSkillToPos;
 clif->pUseSkillToPosSub = clif_parse_UseSkillToPosSub;
 clif->pUseSkillToPos_homun = clif_parse_UseSkillToPos_homun;
 clif->pUseSkillToPos_mercenary = clif_parse_UseSkillToPos_mercenary;
 clif->pUseSkillToPosMoreInfo = clif_parse_UseSkillToPosMoreInfo;
 clif->pUseSkillMap = clif_parse_UseSkillMap;
 clif->pRequestMemo = clif_parse_RequestMemo;
 clif->pProduceMix = clif_parse_ProduceMix;
 clif->pCooking = clif_parse_Cooking;
 clif->pRepairItem = clif_parse_RepairItem;
 clif->pWeaponRefine = clif_parse_WeaponRefine;
 clif->pNpcSelectMenu = clif_parse_NpcSelectMenu;
 clif->pNpcNextClicked = clif_parse_NpcNextClicked;
 clif->pNpcAmountInput = clif_parse_NpcAmountInput;
 clif->pNpcStringInput = clif_parse_NpcStringInput;
 clif->pNpcCloseClicked = clif_parse_NpcCloseClicked;
 clif->pItemIdentify = clif_parse_ItemIdentify;
 clif->pSelectArrow = clif_parse_SelectArrow;
 clif->pAutoSpell = clif_parse_AutoSpell;
 clif->pUseCard = clif_parse_UseCard;
 clif->pInsertCard = clif_parse_InsertCard;
 clif->pSolveCharName = clif_parse_SolveCharName;
 clif->pResetChar = clif_parse_ResetChar;
 clif->pLocalBroadcast = clif_parse_LocalBroadcast;
 clif->pMoveToKafra = clif_parse_MoveToKafra;
 clif->pMoveFromKafra = clif_parse_MoveFromKafra;
 clif->pMoveToKafraFromCart = clif_parse_MoveToKafraFromCart;
 clif->pMoveFromKafraToCart = clif_parse_MoveFromKafraToCart;
 clif->pCloseKafra = clif_parse_CloseKafra;
 clif->pStoragePassword = clif_parse_StoragePassword;
 clif->pCreateParty = clif_parse_CreateParty;
 clif->pCreateParty2 = clif_parse_CreateParty2;
 clif->pPartyInvite = clif_parse_PartyInvite;
 clif->pPartyInvite2 = clif_parse_PartyInvite2;
 clif->pReplyPartyInvite = clif_parse_ReplyPartyInvite;
 clif->pReplyPartyInvite2 = clif_parse_ReplyPartyInvite2;
 clif->pLeaveParty = clif_parse_LeaveParty;
 clif->pRemovePartyMember = clif_parse_RemovePartyMember;
 clif->pPartyChangeOption = clif_parse_PartyChangeOption;
 clif->pPartyMessage = clif_parse_PartyMessage;
 clif->pPartyChangeLeader = clif_parse_PartyChangeLeader;
 clif->pPartyBookingRegisterReq = clif_parse_PartyBookingRegisterReq;
 clif->pPartyBookingSearchReq = clif_parse_PartyBookingSearchReq;
 clif->pPartyBookingDeleteReq = clif_parse_PartyBookingDeleteReq;
 clif->pPartyBookingUpdateReq = clif_parse_PartyBookingUpdateReq;
 clif->pPartyRecruitRegisterReq = clif_parse_PartyRecruitRegisterReq;
 clif->pPartyRecruitSearchReq = clif_parse_PartyRecruitSearchReq;
 clif->pPartyRecruitDeleteReq = clif_parse_PartyRecruitDeleteReq;
 clif->pPartyRecruitUpdateReq = clif_parse_PartyRecruitUpdateReq;
 clif->pCloseVending = clif_parse_CloseVending;
 clif->pVendingListReq = clif_parse_VendingListReq;
 clif->pPurchaseReq = clif_parse_PurchaseReq;
 clif->pPurchaseReq2 = clif_parse_PurchaseReq2;
 clif->pOpenVending = clif_parse_OpenVending;
 clif->pCreateGuild = clif_parse_CreateGuild;
 clif->pGuildCheckMaster = clif_parse_GuildCheckMaster;
 clif->pGuildRequestInfo = clif_parse_GuildRequestInfo;
 clif->pGuildChangePositionInfo = clif_parse_GuildChangePositionInfo;
 clif->pGuildChangeMemberPosition = clif_parse_GuildChangeMemberPosition;
 clif->pGuildRequestEmblem = clif_parse_GuildRequestEmblem;
 clif->pGuildChangeEmblem = clif_parse_GuildChangeEmblem;
 clif->pGuildChangeNotice = clif_parse_GuildChangeNotice;
 clif->pGuildInvite = clif_parse_GuildInvite;
 clif->pGuildReplyInvite = clif_parse_GuildReplyInvite;
 clif->pGuildLeave = clif_parse_GuildLeave;
 clif->pGuildExpulsion = clif_parse_GuildExpulsion;
 clif->pGuildMessage = clif_parse_GuildMessage;
 clif->pGuildRequestAlliance = clif_parse_GuildRequestAlliance;
 clif->pGuildReplyAlliance = clif_parse_GuildReplyAlliance;
 clif->pGuildDelAlliance = clif_parse_GuildDelAlliance;
 clif->pGuildOpposition = clif_parse_GuildOpposition;
 clif->pGuildBreak = clif_parse_GuildBreak;
 clif->pPetMenu = clif_parse_PetMenu;
 clif->pCatchPet = clif_parse_CatchPet;
 clif->pSelectEgg = clif_parse_SelectEgg;
 clif->pSendEmotion = clif_parse_SendEmotion;
 clif->pChangePetName = clif_parse_ChangePetName;
 clif->pGMKick = clif_parse_GMKick;
 clif->pGMKickAll = clif_parse_GMKickAll;
 clif->pGMShift = clif_parse_GMShift;
 clif->pGMRemove2 = clif_parse_GMRemove2;
 clif->pGMRecall = clif_parse_GMRecall;
 clif->pGMRecall2 = clif_parse_GMRecall2;
 clif->pGM_Monster_Item = clif_parse_GM_Monster_Item;
 clif->pGMHide = clif_parse_GMHide;
 clif->pGMReqNoChat = clif_parse_GMReqNoChat;
 clif->pGMRc = clif_parse_GMRc;
 clif->pGMReqAccountName = clif_parse_GMReqAccountName;
 clif->pGMChangeMapType = clif_parse_GMChangeMapType;
 clif->pGMFullStrip = clif_parse_GMFullStrip;
 clif->pPMIgnore = clif_parse_PMIgnore;
 clif->pPMIgnoreAll = clif_parse_PMIgnoreAll;
 clif->pPMIgnoreList = clif_parse_PMIgnoreList;
 clif->pNoviceDoriDori = clif_parse_NoviceDoriDori;
 clif->pNoviceExplosionSpirits = clif_parse_NoviceExplosionSpirits;
 clif->pFriendsListAdd = clif_parse_FriendsListAdd;
 clif->pFriendsListReply = clif_parse_FriendsListReply;
 clif->pFriendsListRemove = clif_parse_FriendsListRemove;
 clif->pPVPInfo = clif_parse_PVPInfo;
 clif->pBlacksmith = clif_parse_Blacksmith;
 clif->pAlchemist = clif_parse_Alchemist;
 clif->pTaekwon = clif_parse_Taekwon;
 clif->pRankingPk = clif_parse_RankingPk;
 clif->pFeelSaveOk = clif_parse_FeelSaveOk;
 clif->pChangeHomunculusName = clif_parse_ChangeHomunculusName;
 clif->pHomMoveToMaster = clif_parse_HomMoveToMaster;
 clif->pHomMoveTo = clif_parse_HomMoveTo;
 clif->pHomAttack = clif_parse_HomAttack;
 clif->pHomMenu = clif_parse_HomMenu;
 clif->pAutoRevive = clif_parse_AutoRevive;
 clif->pCheck = clif_parse_Check;
 clif->pMail_refreshinbox = clif_parse_Mail_refreshinbox;
 clif->pMail_read = clif_parse_Mail_read;
 clif->pMail_getattach = clif_parse_Mail_getattach;
 clif->pMail_delete = clif_parse_Mail_delete;
 clif->pMail_return = clif_parse_Mail_return;
 clif->pMail_setattach = clif_parse_Mail_setattach;
 clif->pMail_winopen = clif_parse_Mail_winopen;
 clif->pMail_send = clif_parse_Mail_send;
 clif->pAuction_cancelreg = clif_parse_Auction_cancelreg;
 clif->pAuction_setitem = clif_parse_Auction_setitem;
 clif->pAuction_register = clif_parse_Auction_register;
 clif->pAuction_cancel = clif_parse_Auction_cancel;
 clif->pAuction_close = clif_parse_Auction_close;
 clif->pAuction_bid = clif_parse_Auction_bid;
 clif->pAuction_search = clif_parse_Auction_search;
 clif->pAuction_buysell = clif_parse_Auction_buysell;
 clif->pcashshop_buy = clif_parse_cashshop_buy;
 clif->pAdopt_request = clif_parse_Adopt_request;
 clif->pAdopt_reply = clif_parse_Adopt_reply;
 clif->pViewPlayerEquip = clif_parse_ViewPlayerEquip;
 clif->pEquipTick = clif_parse_EquipTick;
 clif->pquestStateAck = clif_parse_questStateAck;
 clif->pmercenary_action = clif_parse_mercenary_action;
 clif->pBattleChat = clif_parse_BattleChat;
 clif->pLessEffect = clif_parse_LessEffect;
 clif->pItemListWindowSelected = clif_parse_ItemListWindowSelected;
 clif->pReqOpenBuyingStore = clif_parse_ReqOpenBuyingStore;
 clif->pReqCloseBuyingStore = clif_parse_ReqCloseBuyingStore;
 clif->pReqClickBuyingStore = clif_parse_ReqClickBuyingStore;
 clif->pReqTradeBuyingStore = clif_parse_ReqTradeBuyingStore;
 clif->pSearchStoreInfo = clif_parse_SearchStoreInfo;
 clif->pSearchStoreInfoNextPage = clif_parse_SearchStoreInfoNextPage;
 clif->pCloseSearchStoreInfo = clif_parse_CloseSearchStoreInfo;
 clif->pSearchStoreInfoListItemClick = clif_parse_SearchStoreInfoListItemClick;
 clif->pDebug = clif_parse_debug;
 clif->pSkillSelectMenu = clif_parse_SkillSelectMenu;
 clif->pMoveItem = clif_parse_MoveItem;

 clif->pDull = clif_parse_dull;

 clif->pBGQueueRegister = clif_parse_bgqueue_register;
 clif->pBGQueueCheckState = clif_parse_bgqueue_checkstate;
 clif->pBGQueueRevokeReq = clif_parse_bgqueue_revoke_req;
 clif->pBGQueueBattleBeginAck = clif_parse_bgqueue_battlebegin_ack;

 clif->pCashShopOpen = clif_parse_CashShopOpen;
 clif->pCashShopClose = clif_parse_CashShopClose;
 clif->pCashShopReqTab = clif_parse_CashShopReqTab;
 clif->pCashShopSchedule = clif_parse_CashShopSchedule;
 clif->pCashShopBuy = clif_parse_CashShopBuy;

 clif->pPartyTick = clif_parse_PartyTick;
 clif->pGuildInvite2 = clif_parse_GuildInvite2;

 clif->pPartyBookingAddFilter = clif_parse_PartyBookingAddFilteringList;
 clif->pPartyBookingSubFilter = clif_parse_PartyBookingSubFilteringList;
 clif->pPartyBookingReqVolunteer = clif_parse_PartyBookingReqVolunteer;
 clif->pPartyBookingRefuseVolunteer = clif_parse_PartyBookingRefuseVolunteer;
 clif->pPartyBookingCancelVolunteer = clif_parse_PartyBookingCancelVolunteer;

 clif->pBankDeposit = clif_parse_BankDeposit;
 clif->pBankWithdraw = clif_parse_BankWithdraw;
 clif->pBankCheck = clif_parse_BankCheck;
 clif->pBankOpen = clif_parse_BankOpen;
 clif->pBankClose = clif_parse_BankClose;

 clif->pRouletteOpen = clif_parse_RouletteOpen;
 clif->pRouletteInfo = clif_parse_RouletteInfo;
 clif->pRouletteClose = clif_parse_RouletteClose;
 clif->pRouletteGenerate = clif_parse_RouletteGenerate;
 clif->pRouletteRecvItem = clif_parse_RouletteRecvItem;

 clif->pNPCShopClosed = clif_parse_NPCShopClosed;

 clif->pNPCMarketClosed = clif_parse_NPCMarketClosed;
 clif->pNPCMarketPurchase = clif_parse_NPCMarketPurchase;

 clif->add_random_options = clif_add_random_options;
 clif->pHotkeyRowShift = clif_parse_HotkeyRowShift;
 clif->dressroom_open = clif_dressroom_open;
 clif->pOneClick_ItemIdentify = clif_parse_OneClick_ItemIdentify;
 clif->get_bl_name = clif_get_bl_name;
}
